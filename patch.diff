diff --git a/.github/workflows/pr-kubernetes-tests.yaml b/.github/workflows/pr-kubernetes-tests.yaml
index 9167ebd74..550ef8276 100644
--- a/.github/workflows/pr-kubernetes-tests.yaml
+++ b/.github/workflows/pr-kubernetes-tests.yaml
@@ -27,45 +27,43 @@ jobs:
         # If tests are exceeding the 30-minute limit, please see:
         # /test/kubernetes/e2e/load_balancing_tests.md
         #
-        # Above each test below, we document the latest date/time for the GitHub action step `Run /./.github/actions/kubernetes-e2e-tests` to run
-        # NOTE: We use the GitHub action step time (as opposed to the `go test` time or the GitHub action job time), because it is easier to capture and fairly consistent
+        # Above each test below, we document the latest date/time for the GitHub action step to run
+        # NOTE: We use the GitHub action step time (as opposed to the `go test` time), because it is easier to capture
         test:
-        # July 8, 2025: ~10 minutes
+        # May 19, 2025: ~19 minutes
         - cluster-name: 'cluster-one'
           go-test-args: '-v -timeout=25m'
-          go-test-run-regex: '^TestKgateway$$/^BasicRouting$$|^TestKgateway$$/^PathMatching$$|^TestKgateway$$/^HTTPRouteServices$$|^TestKgateway$$/^TLSRouteServices$$|^TestKgateway$$/^GRPCRouteServices$$|^TestListenerSet$$'
+          go-test-run-regex: '^TestKgateway$$/^BasicRouting$$|^TestKgateway$$/^HTTPRouteServices$$|^TestKgateway$$/^TLSRouteServices$$|^TestKgateway$$/^GRPCRouteServices$$|^TestListenerSet$$'
           localstack: 'false'
-        # July 8, 2025: ~13 minutes
+        # May 19, 2025: ~25 minutes
         - cluster-name: 'cluster-two'
           go-test-args: '-v -timeout=25m'
-          go-test-run-regex: '^TestKgatewayWaypoint$$'
+          go-test-run-regex: '^TestKgateway$$/^Backends$$|^TestKgateway$$/^Transforms$$|^TestKgateway$$/^BackendTLSPolicies$$|^TestKgatewayWaypoint$$'
           localstack: 'false'
-        # July 8, 2025: ~11 minutes
+        # June 23, 2025: ~20 minutes
         - cluster-name: 'cluster-three'
           go-test-args: '-v -timeout=25m'
-          go-test-run-regex: '^TestKgateway$$/^DynamicForwardProxy$$|^TestKgateway$$/^Deployer$$|^TestKgateway$$/^RouteDelegation$$|^TestKgateway$$/^Lambda$$|^TestKgateway$$/^AccessLog$$|^TestKgateway$$/^LocalRateLimit$$|^TestKgateway$$/^Cors$$|^TestKgateway$$/^BackendConfigPolicy$$|^TestKgateway$$/^Metrics$$|^TestKgateway$$/^HttpListenerPolicy$$|^TestKgateway$$/^Tracing$$|^TestKgateway$$/^DirectResponse$$'
+          go-test-run-regex: '^TestKgateway$$/^DynamicForwardProxy$$|^TestKgateway$$/^Deployer$$|^TestKgateway$$/^RouteDelegation$$|^TestKgateway$$/^Lambda$$|^TestKgateway$$/^AccessLog$$|^TestKgateway$$/^LocalRateLimit$$|^TestKgateway$$/^Cors$$|^TestKgateway$$/^BackendConfigPolicy$$|^TestKgateway$$/^Metrics$$|^TestKgateway$$/^HttpListenerPolicy$$'
           localstack: 'true'
-        # July 8, 2025: ~9 minutes
+        # May 19, 2025: ~20 minutes
         - cluster-name: 'cluster-four'
           go-test-args: '-v -timeout=25m'
-          go-test-run-regex: '^TestKgateway$$/^ExtProc$$|^TestKgateway$$/^ExtAuth$$|^TestKgateway$$/^TCPRouteServices$$|^TestKgateway$$/^PolicySelector$$|^TestKgateway$$/^Backends$$|^TestKgateway$$/^Transforms$$|^TestKgateway$$/^BackendTLSPolicies$$|^TestKgateway$$/^CSRF$$|^TestInferenceExtension$$'
+          go-test-run-regex: '^TestKgateway$$/^ExtProc$$|^TestKgateway$$/^ExtAuth$$|^TestKgateway$$/^TCPRouteServices$$|^TestKgateway$$/^PolicySelector$$|^TestInferenceExtension$$|^TestKgateway$$/^CSRF$$'
           localstack: 'false'
-        # July 8, 2025: ~7 minutes
+        # May 19, 2025: ~20 minutes
         - cluster-name: 'cluster-ai'
           go-test-args: '-v -timeout=25m'
           go-test-run-regex: '^TestAIExtension'
           localstack: 'false'
-        # July 8, 2025: ~4 minutes
         - cluster-name: 'cluster-multi-install'
           go-test-args: '-v -timeout=5m'
           go-test-run-regex: '^TestMultipleInstalls'
           localstack: 'false'
-        # July 8, 2025: ~4 minutes
+        # May 19, 2025: ~10 minutes
         - cluster-name: 'agent-gateway-cluster'
           go-test-args: '-v -timeout=25m'
           go-test-run-regex: '^TestAgentGatewayIntegration'
           agentgateway: 'true'
-        # July 8, 2025: ~3 minutes
         - cluster-name: 'api-validation'
           go-test-args: '-v -timeout=10m'
           go-test-run-regex: '^TestAPIValidation'
diff --git a/.github/workflows/release.yaml b/.github/workflows/release.yaml
index 4522b85d9..6fd11a588 100644
--- a/.github/workflows/release.yaml
+++ b/.github/workflows/release.yaml
@@ -24,7 +24,7 @@ on:
       - main
 
 env:
-  # this uses the `github.repository_owner` to support releases from forks (useful for testing).
+  # this is uses the `github.repository_owner` to support releases from forks (useful for testing).
   IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
   VANITY_REGISTRY: cr.kgateway.dev/kgateway-dev
   MAIN_VERSION: v2.1.0-main
@@ -65,6 +65,9 @@ jobs:
           elif [[ ${{ github.event_name }} == 'workflow_dispatch' ]]; then
             VERSION="v0.0.0-manual-${GIT_SHA}"
             echo "goreleaser_args=--clean --skip=validate" >> $GITHUB_OUTPUT
+          elif [[ $GITHUB_REF == refs/tags/* ]]; then
+            VERSION="${GITHUB_REF#refs/tags/}"
+            echo "goreleaser_args=--clean" >> $GITHUB_OUTPUT
           elif [[ $GITHUB_REF == refs/heads/main ]]; then
             VERSION="${MAIN_VERSION}"
             echo "goreleaser_args=--clean --skip=validate" >> $GITHUB_OUTPUT
diff --git a/.golangci.yaml b/.golangci.yaml
index 593f5d4e4..c1eda8242 100644
--- a/.golangci.yaml
+++ b/.golangci.yaml
@@ -46,12 +46,6 @@ linters:
               recommendations:
                 - errors.Join
               reason: Use errors.Join (Go 1.20+) instead.
-          - github.com/pkg/errors:
-              recommendations:
-                - fmt.Errorf
-                - errors.New
-                - errors.Join
-              reason: Use the std-lib errors package and fmt.Errorf with \\%w instead.
     importas:
       alias:
         - pkg: k8s.io/api/apps/v1
diff --git a/.goreleaser.yaml b/.goreleaser.yaml
index e2c250f81..b03103b2e 100644
--- a/.goreleaser.yaml
+++ b/.goreleaser.yaml
@@ -177,7 +177,6 @@ release:
   prerelease: "auto"
   mode: "replace"
   replace_existing_artifacts: true
-  target_commitish: "{{ .FullCommit }}"
   header: |
     {{ if eq .Env.VERSION "v2.1.0-main" }}
     ðŸš€ Rolling main build of kgateway!
diff --git a/Makefile b/Makefile
index 4fda09893..e5fdd0553 100644
--- a/Makefile
+++ b/Makefile
@@ -299,7 +299,7 @@ generate-all: generated-code
 # Generates all required code, cleaning and formatting as well; this target is executed in CI
 .PHONY: generated-code
 generated-code: clean-gen go-generate-all mod-tidy
-generated-code: generate-licenses
+generated-code: update-licenses
 generated-code: fmt
 
 .PHONY: go-generate-all
@@ -313,12 +313,6 @@ go-generate-apis: ## Run all go generate directives in the repo, including codeg
 go-generate-mocks: ## Runs all generate directives for mockgen in the repo
 	GO111MODULE=on go generate -run="mockgen" ./...
 
-.PHONY: generate-licenses
-generate-licenses: ## Generate the licenses for the project
-	GO111MODULE=on go run hack/utils/oss_compliance/oss_compliance.go osagen -c "GNU General Public License v2.0,GNU General Public License v3.0,GNU Lesser General Public License v2.1,GNU Lesser General Public License v3.0,GNU Affero General Public License v3.0"
-	GO111MODULE=on go run hack/utils/oss_compliance/oss_compliance.go osagen -s "Mozilla Public License 2.0,GNU General Public License v2.0,GNU General Public License v3.0,GNU Lesser General Public License v2.1,GNU Lesser General Public License v3.0,GNU Affero General Public License v3.0"> hack/utils/oss_compliance/osa_provided.md
-	GO111MODULE=on go run hack/utils/oss_compliance/oss_compliance.go osagen -i "Mozilla Public License 2.0"> hack/utils/oss_compliance/osa_included.md
-
 #----------------------------------------------------------------------------------
 # AI Extensions ExtProc Server
 #----------------------------------------------------------------------------------
@@ -469,6 +463,34 @@ GORELEASER_CURRENT_TAG ?= $(VERSION)
 release: ## Create a release using goreleaser
 	GORELEASER_CURRENT_TAG=$(GORELEASER_CURRENT_TAG) $(GORELEASER) release $(GORELEASER_ARGS) --timeout $(GORELEASER_TIMEOUT)
 
+#----------------------------------------------------------------------------------
+# Docker
+#----------------------------------------------------------------------------------
+
+.PHONY: docker
+docker: kgateway-docker ## Build docker images
+docker: envoy-wrapper-docker
+docker: sds-docker
+docker: kgateway-ai-extension-docker
+
+.PHONY: docker-push
+docker-push: docker-push-kgateway
+docker-push: docker-push-envoy-wrapper
+docker-push: docker-push-sds
+docker-push: docker-push-kgateway-ai-extension
+
+.PHONY: docker-retag
+docker-retag: docker-retag-kgateway
+docker-retag: docker-retag-envoy-wrapper
+docker-retag: docker-retag-sds
+docker-retag: docker-retag-kgateway-ai-extension
+
+docker-retag-%:
+	docker tag $(ORIGINAL_IMAGE_REGISTRY)/$*:$(VERSION) $(IMAGE_REGISTRY)/$*:$(VERSION)
+
+docker-push-%:
+	docker push $(IMAGE_REGISTRY)/$*:$(VERSION)
+
 #----------------------------------------------------------------------------------
 # Development
 #----------------------------------------------------------------------------------
@@ -494,11 +516,8 @@ metallb: ## Install the MetalLB load balancer
 .PHONY: deploy-kgateway
 deploy-kgateway: package-kgateway-charts deploy-kgateway-crd-chart deploy-kgateway-chart ## Deploy the kgateway chart and CRDs
 
-.PHONY: setup
-setup: kind-create kind-build-and-load gw-api-crds metallb package-kgateway-charts ## Set up basic infrastructure (kind cluster, images, CRDs, MetalLB)
-
 .PHONY: run
-run: setup deploy-kgateway  ## Set up complete development environment
+run: kind-create kind-build-and-load gw-api-crds metallb deploy-kgateway  ## Set up complete development environment
 
 #----------------------------------------------------------------------------------
 # Build assets for kubernetes e2e tests
@@ -535,6 +554,15 @@ kind-set-image-%:
 # Envoy image may be specified via ENVOY_IMAGE on the command line or at the top of this file
 kind-reload-%: kind-build-and-load-% kind-set-image-% ; ## Use to build specified image, load it into kind, and restart its deployment
 
+# This is an alias to remedy the fact that the deployment is called gateway-proxy
+# but our make targets refer to envoy-wrapper
+kind-reload-envoy-wrapper: kind-build-and-load-envoy-wrapper
+kind-reload-envoy-wrapper:
+	kubectl rollout pause deployment gateway-proxy -n $(INSTALL_NAMESPACE) || true
+	kubectl set image deployment/gateway-proxy gateway-proxy=$(IMAGE_REGISTRY)/envoy-wrapper:$(VERSION) -n $(INSTALL_NAMESPACE)
+	kubectl patch deployment gateway-proxy -n $(INSTALL_NAMESPACE) -p '{"spec": {"template":{"metadata":{"annotations":{"kgateway-kind-last-update":"$(shell date)"}}}} }'
+	kubectl rollout resume deployment gateway-proxy -n $(INSTALL_NAMESPACE)
+
 .PHONY: kind-build-and-load ## Use to build all images and load them into kind
 kind-build-and-load: kind-build-and-load-kgateway
 kind-build-and-load: kind-build-and-load-envoy-wrapper
@@ -547,6 +575,27 @@ kind-load: kind-load-envoy-wrapper
 kind-load: kind-load-sds
 kind-load: kind-load-kgateway-ai-extension
 
+define kind_reload_msg
+The kind-reload-% targets exist in order to assist developers with the work cycle of
+build->test->change->build->test. To that end, rebuilding/reloading every image, then
+restarting every deployment is seldom necessary. Consider using kind-reload-% to do so
+for a specific component, or kind-build-and-load to push new images for every component.
+endef
+export kind_reload_msg
+.PHONY: kind-reload
+kind-reload:
+	@echo "$$kind_reload_msg"
+
+# Useful utility for listing images loaded into the kind cluster
+.PHONY: kind-list-images
+kind-list-images: ## List solo-io images in the kind cluster named {CLUSTER_NAME}
+	docker exec -ti $(CLUSTER_NAME)-control-plane crictl images | grep "solo-io"
+
+# Useful utility for pruning images that were previously loaded into the kind cluster
+.PHONY: kind-prune-images
+kind-prune-images: ## Remove images in the kind cluster named {CLUSTER_NAME}
+	docker exec -ti $(CLUSTER_NAME)-control-plane crictl rmi --prune
+
 #----------------------------------------------------------------------------------
 # A2A Test Server (for agentgateway a2a integration in e2e tests)
 #----------------------------------------------------------------------------------
@@ -594,6 +643,16 @@ conformance-%: $(TEST_ASSET_DIR)/conformance/conformance_test.go
 	go test -mod=mod -ldflags='$(LDFLAGS)' -tags conformance -test.v $(TEST_ASSET_DIR)/conformance/... -args $(CONFORMANCE_ARGS) \
 	-run-test=$*
 
+#----------------------------------------------------------------------------------
+# Third Party License Management
+#----------------------------------------------------------------------------------
+
+.PHONY: update-licenses
+update-licenses: ## Update the licenses for the project
+	GO111MODULE=on go run hack/utils/oss_compliance/oss_compliance.go osagen -c "GNU General Public License v2.0,GNU General Public License v3.0,GNU Lesser General Public License v2.1,GNU Lesser General Public License v3.0,GNU Affero General Public License v3.0"
+	GO111MODULE=on go run hack/utils/oss_compliance/oss_compliance.go osagen -s "Mozilla Public License 2.0,GNU General Public License v2.0,GNU General Public License v3.0,GNU Lesser General Public License v2.1,GNU Lesser General Public License v3.0,GNU Affero General Public License v3.0"> hack/utils/oss_compliance/osa_provided.md
+	GO111MODULE=on go run hack/utils/oss_compliance/oss_compliance.go osagen -i "Mozilla Public License 2.0"> hack/utils/oss_compliance/osa_included.md
+
 #----------------------------------------------------------------------------------
 # Printing makefile variables utility
 #----------------------------------------------------------------------------------
diff --git a/api/applyconfiguration/api/v1alpha1/accesslog.go b/api/applyconfiguration/api/v1alpha1/accesslog.go
index ea9fcff8d..05d480226 100644
--- a/api/applyconfiguration/api/v1alpha1/accesslog.go
+++ b/api/applyconfiguration/api/v1alpha1/accesslog.go
@@ -5,10 +5,9 @@ package v1alpha1
 // AccessLogApplyConfiguration represents a declarative configuration of the AccessLog type for use
 // with apply.
 type AccessLogApplyConfiguration struct {
-	FileSink      *FileSinkApplyConfiguration                      `json:"fileSink,omitempty"`
-	GrpcService   *AccessLogGrpcServiceApplyConfiguration          `json:"grpcService,omitempty"`
-	OpenTelemetry *OpenTelemetryAccessLogServiceApplyConfiguration `json:"openTelemetry,omitempty"`
-	Filter        *AccessLogFilterApplyConfiguration               `json:"filter,omitempty"`
+	FileSink    *FileSinkApplyConfiguration        `json:"fileSink,omitempty"`
+	GrpcService *GrpcServiceApplyConfiguration     `json:"grpcService,omitempty"`
+	Filter      *AccessLogFilterApplyConfiguration `json:"filter,omitempty"`
 }
 
 // AccessLogApplyConfiguration constructs a declarative configuration of the AccessLog type for use with
@@ -28,19 +27,11 @@ func (b *AccessLogApplyConfiguration) WithFileSink(value *FileSinkApplyConfigura
 // WithGrpcService sets the GrpcService field in the declarative configuration to the given value
 // and returns the receiver, so that objects can be built by chaining "With" function invocations.
 // If called multiple times, the GrpcService field is set to the value of the last call.
-func (b *AccessLogApplyConfiguration) WithGrpcService(value *AccessLogGrpcServiceApplyConfiguration) *AccessLogApplyConfiguration {
+func (b *AccessLogApplyConfiguration) WithGrpcService(value *GrpcServiceApplyConfiguration) *AccessLogApplyConfiguration {
 	b.GrpcService = value
 	return b
 }
 
-// WithOpenTelemetry sets the OpenTelemetry field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the OpenTelemetry field is set to the value of the last call.
-func (b *AccessLogApplyConfiguration) WithOpenTelemetry(value *OpenTelemetryAccessLogServiceApplyConfiguration) *AccessLogApplyConfiguration {
-	b.OpenTelemetry = value
-	return b
-}
-
 // WithFilter sets the Filter field in the declarative configuration to the given value
 // and returns the receiver, so that objects can be built by chaining "With" function invocations.
 // If called multiple times, the Filter field is set to the value of the last call.
diff --git a/api/applyconfiguration/api/v1alpha1/accessloggrpcservice.go b/api/applyconfiguration/api/v1alpha1/accessloggrpcservice.go
deleted file mode 100644
index b431e388c..000000000
--- a/api/applyconfiguration/api/v1alpha1/accessloggrpcservice.go
+++ /dev/null
@@ -1,122 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	v1 "sigs.k8s.io/gateway-api/apis/v1"
-)
-
-// AccessLogGrpcServiceApplyConfiguration represents a declarative configuration of the AccessLogGrpcService type for use
-// with apply.
-type AccessLogGrpcServiceApplyConfiguration struct {
-	CommonAccessLogGrpcServiceApplyConfiguration `json:",inline"`
-	AdditionalRequestHeadersToLog                []string `json:"additionalRequestHeadersToLog,omitempty"`
-	AdditionalResponseHeadersToLog               []string `json:"additionalResponseHeadersToLog,omitempty"`
-	AdditionalResponseTrailersToLog              []string `json:"additionalResponseTrailersToLog,omitempty"`
-}
-
-// AccessLogGrpcServiceApplyConfiguration constructs a declarative configuration of the AccessLogGrpcService type for use with
-// apply.
-func AccessLogGrpcService() *AccessLogGrpcServiceApplyConfiguration {
-	return &AccessLogGrpcServiceApplyConfiguration{}
-}
-
-// WithBackendRef sets the BackendRef field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the BackendRef field is set to the value of the last call.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithBackendRef(value v1.BackendRef) *AccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.BackendRef = &value
-	return b
-}
-
-// WithAuthority sets the Authority field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Authority field is set to the value of the last call.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithAuthority(value string) *AccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.Authority = &value
-	return b
-}
-
-// WithMaxReceiveMessageLength sets the MaxReceiveMessageLength field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the MaxReceiveMessageLength field is set to the value of the last call.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithMaxReceiveMessageLength(value uint32) *AccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.MaxReceiveMessageLength = &value
-	return b
-}
-
-// WithSkipEnvoyHeaders sets the SkipEnvoyHeaders field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the SkipEnvoyHeaders field is set to the value of the last call.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithSkipEnvoyHeaders(value bool) *AccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.SkipEnvoyHeaders = &value
-	return b
-}
-
-// WithTimeout sets the Timeout field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Timeout field is set to the value of the last call.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithTimeout(value metav1.Duration) *AccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.Timeout = &value
-	return b
-}
-
-// WithInitialMetadata adds the given value to the InitialMetadata field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the InitialMetadata field.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithInitialMetadata(values ...*HeaderValueApplyConfiguration) *AccessLogGrpcServiceApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithInitialMetadata")
-		}
-		b.CommonGrpcServiceApplyConfiguration.InitialMetadata = append(b.CommonGrpcServiceApplyConfiguration.InitialMetadata, *values[i])
-	}
-	return b
-}
-
-// WithRetryPolicy sets the RetryPolicy field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the RetryPolicy field is set to the value of the last call.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithRetryPolicy(value *RetryPolicyApplyConfiguration) *AccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.RetryPolicy = value
-	return b
-}
-
-// WithLogName sets the LogName field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the LogName field is set to the value of the last call.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithLogName(value string) *AccessLogGrpcServiceApplyConfiguration {
-	b.CommonAccessLogGrpcServiceApplyConfiguration.LogName = &value
-	return b
-}
-
-// WithAdditionalRequestHeadersToLog adds the given value to the AdditionalRequestHeadersToLog field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the AdditionalRequestHeadersToLog field.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithAdditionalRequestHeadersToLog(values ...string) *AccessLogGrpcServiceApplyConfiguration {
-	for i := range values {
-		b.AdditionalRequestHeadersToLog = append(b.AdditionalRequestHeadersToLog, values[i])
-	}
-	return b
-}
-
-// WithAdditionalResponseHeadersToLog adds the given value to the AdditionalResponseHeadersToLog field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the AdditionalResponseHeadersToLog field.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithAdditionalResponseHeadersToLog(values ...string) *AccessLogGrpcServiceApplyConfiguration {
-	for i := range values {
-		b.AdditionalResponseHeadersToLog = append(b.AdditionalResponseHeadersToLog, values[i])
-	}
-	return b
-}
-
-// WithAdditionalResponseTrailersToLog adds the given value to the AdditionalResponseTrailersToLog field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the AdditionalResponseTrailersToLog field.
-func (b *AccessLogGrpcServiceApplyConfiguration) WithAdditionalResponseTrailersToLog(values ...string) *AccessLogGrpcServiceApplyConfiguration {
-	for i := range values {
-		b.AdditionalResponseTrailersToLog = append(b.AdditionalResponseTrailersToLog, values[i])
-	}
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/aiextension.go b/api/applyconfiguration/api/v1alpha1/aiextension.go
index 67c6eac25..da3c093ef 100644
--- a/api/applyconfiguration/api/v1alpha1/aiextension.go
+++ b/api/applyconfiguration/api/v1alpha1/aiextension.go
@@ -16,7 +16,6 @@ type AiExtensionApplyConfiguration struct {
 	Env             []v1.EnvVar                         `json:"env,omitempty"`
 	Ports           []v1.ContainerPort                  `json:"ports,omitempty"`
 	Stats           *AiExtensionStatsApplyConfiguration `json:"stats,omitempty"`
-	Tracing         *AiExtensionTraceApplyConfiguration `json:"tracing,omitempty"`
 }
 
 // AiExtensionApplyConfiguration constructs a declarative configuration of the AiExtension type for use with
@@ -84,11 +83,3 @@ func (b *AiExtensionApplyConfiguration) WithStats(value *AiExtensionStatsApplyCo
 	b.Stats = value
 	return b
 }
-
-// WithTracing sets the Tracing field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Tracing field is set to the value of the last call.
-func (b *AiExtensionApplyConfiguration) WithTracing(value *AiExtensionTraceApplyConfiguration) *AiExtensionApplyConfiguration {
-	b.Tracing = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/aiextensiontrace.go b/api/applyconfiguration/api/v1alpha1/aiextensiontrace.go
deleted file mode 100644
index c190e63a8..000000000
--- a/api/applyconfiguration/api/v1alpha1/aiextensiontrace.go
+++ /dev/null
@@ -1,65 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	v1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-)
-
-// AiExtensionTraceApplyConfiguration represents a declarative configuration of the AiExtensionTrace type for use
-// with apply.
-type AiExtensionTraceApplyConfiguration struct {
-	EndPoint          *v1.AbsoluteURI                        `json:"endpoint,omitempty"`
-	Sampler           *OTelTracesSamplerApplyConfiguration   `json:"sampler,omitempty"`
-	Timeout           *v1.Duration                           `json:"timeout,omitempty"`
-	Protocol          *apiv1alpha1.OTLPTracesProtocolType    `json:"protocol,omitempty"`
-	TransportSecurity *apiv1alpha1.OTLPTransportSecurityMode `json:"transportSecurity,omitempty"`
-}
-
-// AiExtensionTraceApplyConfiguration constructs a declarative configuration of the AiExtensionTrace type for use with
-// apply.
-func AiExtensionTrace() *AiExtensionTraceApplyConfiguration {
-	return &AiExtensionTraceApplyConfiguration{}
-}
-
-// WithEndPoint sets the EndPoint field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the EndPoint field is set to the value of the last call.
-func (b *AiExtensionTraceApplyConfiguration) WithEndPoint(value v1.AbsoluteURI) *AiExtensionTraceApplyConfiguration {
-	b.EndPoint = &value
-	return b
-}
-
-// WithSampler sets the Sampler field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Sampler field is set to the value of the last call.
-func (b *AiExtensionTraceApplyConfiguration) WithSampler(value *OTelTracesSamplerApplyConfiguration) *AiExtensionTraceApplyConfiguration {
-	b.Sampler = value
-	return b
-}
-
-// WithTimeout sets the Timeout field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Timeout field is set to the value of the last call.
-func (b *AiExtensionTraceApplyConfiguration) WithTimeout(value v1.Duration) *AiExtensionTraceApplyConfiguration {
-	b.Timeout = &value
-	return b
-}
-
-// WithProtocol sets the Protocol field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Protocol field is set to the value of the last call.
-func (b *AiExtensionTraceApplyConfiguration) WithProtocol(value apiv1alpha1.OTLPTracesProtocolType) *AiExtensionTraceApplyConfiguration {
-	b.Protocol = &value
-	return b
-}
-
-// WithTransportSecurity sets the TransportSecurity field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the TransportSecurity field is set to the value of the last call.
-func (b *AiExtensionTraceApplyConfiguration) WithTransportSecurity(value apiv1alpha1.OTLPTransportSecurityMode) *AiExtensionTraceApplyConfiguration {
-	b.TransportSecurity = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/anyvalue.go b/api/applyconfiguration/api/v1alpha1/anyvalue.go
deleted file mode 100644
index b6fe42431..000000000
--- a/api/applyconfiguration/api/v1alpha1/anyvalue.go
+++ /dev/null
@@ -1,46 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// AnyValueApplyConfiguration represents a declarative configuration of the AnyValue type for use
-// with apply.
-type AnyValueApplyConfiguration struct {
-	StringValue *string                            `json:"stringValue,omitempty"`
-	ArrayValue  []AnyValueApplyConfiguration       `json:"arrayValue,omitempty"`
-	KvListValue *KeyAnyValueListApplyConfiguration `json:"kvListValue,omitempty"`
-}
-
-// AnyValueApplyConfiguration constructs a declarative configuration of the AnyValue type for use with
-// apply.
-func AnyValue() *AnyValueApplyConfiguration {
-	return &AnyValueApplyConfiguration{}
-}
-
-// WithStringValue sets the StringValue field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the StringValue field is set to the value of the last call.
-func (b *AnyValueApplyConfiguration) WithStringValue(value string) *AnyValueApplyConfiguration {
-	b.StringValue = &value
-	return b
-}
-
-// WithArrayValue adds the given value to the ArrayValue field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the ArrayValue field.
-func (b *AnyValueApplyConfiguration) WithArrayValue(values ...*AnyValueApplyConfiguration) *AnyValueApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithArrayValue")
-		}
-		b.ArrayValue = append(b.ArrayValue, *values[i])
-	}
-	return b
-}
-
-// WithKvListValue sets the KvListValue field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the KvListValue field is set to the value of the last call.
-func (b *AnyValueApplyConfiguration) WithKvListValue(value *KeyAnyValueListApplyConfiguration) *AnyValueApplyConfiguration {
-	b.KvListValue = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/backoffstrategy.go b/api/applyconfiguration/api/v1alpha1/backoffstrategy.go
deleted file mode 100644
index 416c30175..000000000
--- a/api/applyconfiguration/api/v1alpha1/backoffstrategy.go
+++ /dev/null
@@ -1,36 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-)
-
-// BackoffStrategyApplyConfiguration represents a declarative configuration of the BackoffStrategy type for use
-// with apply.
-type BackoffStrategyApplyConfiguration struct {
-	BaseInterval *v1.Duration `json:"baseInterval,omitempty"`
-	MaxInterval  *v1.Duration `json:"maxInterval,omitempty"`
-}
-
-// BackoffStrategyApplyConfiguration constructs a declarative configuration of the BackoffStrategy type for use with
-// apply.
-func BackoffStrategy() *BackoffStrategyApplyConfiguration {
-	return &BackoffStrategyApplyConfiguration{}
-}
-
-// WithBaseInterval sets the BaseInterval field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the BaseInterval field is set to the value of the last call.
-func (b *BackoffStrategyApplyConfiguration) WithBaseInterval(value v1.Duration) *BackoffStrategyApplyConfiguration {
-	b.BaseInterval = &value
-	return b
-}
-
-// WithMaxInterval sets the MaxInterval field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the MaxInterval field is set to the value of the last call.
-func (b *BackoffStrategyApplyConfiguration) WithMaxInterval(value v1.Duration) *BackoffStrategyApplyConfiguration {
-	b.MaxInterval = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/buffer.go b/api/applyconfiguration/api/v1alpha1/buffer.go
deleted file mode 100644
index 9ca1fb9d8..000000000
--- a/api/applyconfiguration/api/v1alpha1/buffer.go
+++ /dev/null
@@ -1,27 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	resource "k8s.io/apimachinery/pkg/api/resource"
-)
-
-// BufferApplyConfiguration represents a declarative configuration of the Buffer type for use
-// with apply.
-type BufferApplyConfiguration struct {
-	MaxRequestSize *resource.Quantity `json:"maxRequestSize,omitempty"`
-}
-
-// BufferApplyConfiguration constructs a declarative configuration of the Buffer type for use with
-// apply.
-func Buffer() *BufferApplyConfiguration {
-	return &BufferApplyConfiguration{}
-}
-
-// WithMaxRequestSize sets the MaxRequestSize field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the MaxRequestSize field is set to the value of the last call.
-func (b *BufferApplyConfiguration) WithMaxRequestSize(value resource.Quantity) *BufferApplyConfiguration {
-	b.MaxRequestSize = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/commonaccessloggrpcservice.go b/api/applyconfiguration/api/v1alpha1/commonaccessloggrpcservice.go
deleted file mode 100644
index 22c36f78d..000000000
--- a/api/applyconfiguration/api/v1alpha1/commonaccessloggrpcservice.go
+++ /dev/null
@@ -1,90 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	v1 "sigs.k8s.io/gateway-api/apis/v1"
-)
-
-// CommonAccessLogGrpcServiceApplyConfiguration represents a declarative configuration of the CommonAccessLogGrpcService type for use
-// with apply.
-type CommonAccessLogGrpcServiceApplyConfiguration struct {
-	CommonGrpcServiceApplyConfiguration `json:",inline"`
-	LogName                             *string `json:"logName,omitempty"`
-}
-
-// CommonAccessLogGrpcServiceApplyConfiguration constructs a declarative configuration of the CommonAccessLogGrpcService type for use with
-// apply.
-func CommonAccessLogGrpcService() *CommonAccessLogGrpcServiceApplyConfiguration {
-	return &CommonAccessLogGrpcServiceApplyConfiguration{}
-}
-
-// WithBackendRef sets the BackendRef field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the BackendRef field is set to the value of the last call.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithBackendRef(value v1.BackendRef) *CommonAccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.BackendRef = &value
-	return b
-}
-
-// WithAuthority sets the Authority field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Authority field is set to the value of the last call.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithAuthority(value string) *CommonAccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.Authority = &value
-	return b
-}
-
-// WithMaxReceiveMessageLength sets the MaxReceiveMessageLength field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the MaxReceiveMessageLength field is set to the value of the last call.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithMaxReceiveMessageLength(value uint32) *CommonAccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.MaxReceiveMessageLength = &value
-	return b
-}
-
-// WithSkipEnvoyHeaders sets the SkipEnvoyHeaders field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the SkipEnvoyHeaders field is set to the value of the last call.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithSkipEnvoyHeaders(value bool) *CommonAccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.SkipEnvoyHeaders = &value
-	return b
-}
-
-// WithTimeout sets the Timeout field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Timeout field is set to the value of the last call.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithTimeout(value metav1.Duration) *CommonAccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.Timeout = &value
-	return b
-}
-
-// WithInitialMetadata adds the given value to the InitialMetadata field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the InitialMetadata field.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithInitialMetadata(values ...*HeaderValueApplyConfiguration) *CommonAccessLogGrpcServiceApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithInitialMetadata")
-		}
-		b.CommonGrpcServiceApplyConfiguration.InitialMetadata = append(b.CommonGrpcServiceApplyConfiguration.InitialMetadata, *values[i])
-	}
-	return b
-}
-
-// WithRetryPolicy sets the RetryPolicy field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the RetryPolicy field is set to the value of the last call.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithRetryPolicy(value *RetryPolicyApplyConfiguration) *CommonAccessLogGrpcServiceApplyConfiguration {
-	b.CommonGrpcServiceApplyConfiguration.RetryPolicy = value
-	return b
-}
-
-// WithLogName sets the LogName field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the LogName field is set to the value of the last call.
-func (b *CommonAccessLogGrpcServiceApplyConfiguration) WithLogName(value string) *CommonAccessLogGrpcServiceApplyConfiguration {
-	b.LogName = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/commongrpcservice.go b/api/applyconfiguration/api/v1alpha1/commongrpcservice.go
deleted file mode 100644
index 873077324..000000000
--- a/api/applyconfiguration/api/v1alpha1/commongrpcservice.go
+++ /dev/null
@@ -1,87 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	v1 "sigs.k8s.io/gateway-api/apis/v1"
-)
-
-// CommonGrpcServiceApplyConfiguration represents a declarative configuration of the CommonGrpcService type for use
-// with apply.
-type CommonGrpcServiceApplyConfiguration struct {
-	BackendRef              *v1.BackendRef                  `json:"backendRef,omitempty"`
-	Authority               *string                         `json:"authority,omitempty"`
-	MaxReceiveMessageLength *uint32                         `json:"maxReceiveMessageLength,omitempty"`
-	SkipEnvoyHeaders        *bool                           `json:"skipEnvoyHeaders,omitempty"`
-	Timeout                 *metav1.Duration                `json:"timeout,omitempty"`
-	InitialMetadata         []HeaderValueApplyConfiguration `json:"initialMetadata,omitempty"`
-	RetryPolicy             *RetryPolicyApplyConfiguration  `json:"retryPolicy,omitempty"`
-}
-
-// CommonGrpcServiceApplyConfiguration constructs a declarative configuration of the CommonGrpcService type for use with
-// apply.
-func CommonGrpcService() *CommonGrpcServiceApplyConfiguration {
-	return &CommonGrpcServiceApplyConfiguration{}
-}
-
-// WithBackendRef sets the BackendRef field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the BackendRef field is set to the value of the last call.
-func (b *CommonGrpcServiceApplyConfiguration) WithBackendRef(value v1.BackendRef) *CommonGrpcServiceApplyConfiguration {
-	b.BackendRef = &value
-	return b
-}
-
-// WithAuthority sets the Authority field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Authority field is set to the value of the last call.
-func (b *CommonGrpcServiceApplyConfiguration) WithAuthority(value string) *CommonGrpcServiceApplyConfiguration {
-	b.Authority = &value
-	return b
-}
-
-// WithMaxReceiveMessageLength sets the MaxReceiveMessageLength field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the MaxReceiveMessageLength field is set to the value of the last call.
-func (b *CommonGrpcServiceApplyConfiguration) WithMaxReceiveMessageLength(value uint32) *CommonGrpcServiceApplyConfiguration {
-	b.MaxReceiveMessageLength = &value
-	return b
-}
-
-// WithSkipEnvoyHeaders sets the SkipEnvoyHeaders field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the SkipEnvoyHeaders field is set to the value of the last call.
-func (b *CommonGrpcServiceApplyConfiguration) WithSkipEnvoyHeaders(value bool) *CommonGrpcServiceApplyConfiguration {
-	b.SkipEnvoyHeaders = &value
-	return b
-}
-
-// WithTimeout sets the Timeout field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Timeout field is set to the value of the last call.
-func (b *CommonGrpcServiceApplyConfiguration) WithTimeout(value metav1.Duration) *CommonGrpcServiceApplyConfiguration {
-	b.Timeout = &value
-	return b
-}
-
-// WithInitialMetadata adds the given value to the InitialMetadata field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the InitialMetadata field.
-func (b *CommonGrpcServiceApplyConfiguration) WithInitialMetadata(values ...*HeaderValueApplyConfiguration) *CommonGrpcServiceApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithInitialMetadata")
-		}
-		b.InitialMetadata = append(b.InitialMetadata, *values[i])
-	}
-	return b
-}
-
-// WithRetryPolicy sets the RetryPolicy field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the RetryPolicy field is set to the value of the last call.
-func (b *CommonGrpcServiceApplyConfiguration) WithRetryPolicy(value *RetryPolicyApplyConfiguration) *CommonGrpcServiceApplyConfiguration {
-	b.RetryPolicy = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/customattribute.go b/api/applyconfiguration/api/v1alpha1/customattribute.go
deleted file mode 100644
index 91e5a7eb8..000000000
--- a/api/applyconfiguration/api/v1alpha1/customattribute.go
+++ /dev/null
@@ -1,59 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// CustomAttributeApplyConfiguration represents a declarative configuration of the CustomAttribute type for use
-// with apply.
-type CustomAttributeApplyConfiguration struct {
-	Name          *string                                       `json:"name,omitempty"`
-	Literal       *CustomAttributeLiteralApplyConfiguration     `json:"literal,omitempty"`
-	Environment   *CustomAttributeEnvironmentApplyConfiguration `json:"environment,omitempty"`
-	RequestHeader *CustomAttributeHeaderApplyConfiguration      `json:"requestHeader,omitempty"`
-	Metadata      *CustomAttributeMetadataApplyConfiguration    `json:"metadata,omitempty"`
-}
-
-// CustomAttributeApplyConfiguration constructs a declarative configuration of the CustomAttribute type for use with
-// apply.
-func CustomAttribute() *CustomAttributeApplyConfiguration {
-	return &CustomAttributeApplyConfiguration{}
-}
-
-// WithName sets the Name field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Name field is set to the value of the last call.
-func (b *CustomAttributeApplyConfiguration) WithName(value string) *CustomAttributeApplyConfiguration {
-	b.Name = &value
-	return b
-}
-
-// WithLiteral sets the Literal field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Literal field is set to the value of the last call.
-func (b *CustomAttributeApplyConfiguration) WithLiteral(value *CustomAttributeLiteralApplyConfiguration) *CustomAttributeApplyConfiguration {
-	b.Literal = value
-	return b
-}
-
-// WithEnvironment sets the Environment field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Environment field is set to the value of the last call.
-func (b *CustomAttributeApplyConfiguration) WithEnvironment(value *CustomAttributeEnvironmentApplyConfiguration) *CustomAttributeApplyConfiguration {
-	b.Environment = value
-	return b
-}
-
-// WithRequestHeader sets the RequestHeader field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the RequestHeader field is set to the value of the last call.
-func (b *CustomAttributeApplyConfiguration) WithRequestHeader(value *CustomAttributeHeaderApplyConfiguration) *CustomAttributeApplyConfiguration {
-	b.RequestHeader = value
-	return b
-}
-
-// WithMetadata sets the Metadata field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Metadata field is set to the value of the last call.
-func (b *CustomAttributeApplyConfiguration) WithMetadata(value *CustomAttributeMetadataApplyConfiguration) *CustomAttributeApplyConfiguration {
-	b.Metadata = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/customattributeenvironment.go b/api/applyconfiguration/api/v1alpha1/customattributeenvironment.go
deleted file mode 100644
index 85dd5efc4..000000000
--- a/api/applyconfiguration/api/v1alpha1/customattributeenvironment.go
+++ /dev/null
@@ -1,32 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// CustomAttributeEnvironmentApplyConfiguration represents a declarative configuration of the CustomAttributeEnvironment type for use
-// with apply.
-type CustomAttributeEnvironmentApplyConfiguration struct {
-	Name         *string `json:"name,omitempty"`
-	DefaultValue *string `json:"defaultValue,omitempty"`
-}
-
-// CustomAttributeEnvironmentApplyConfiguration constructs a declarative configuration of the CustomAttributeEnvironment type for use with
-// apply.
-func CustomAttributeEnvironment() *CustomAttributeEnvironmentApplyConfiguration {
-	return &CustomAttributeEnvironmentApplyConfiguration{}
-}
-
-// WithName sets the Name field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Name field is set to the value of the last call.
-func (b *CustomAttributeEnvironmentApplyConfiguration) WithName(value string) *CustomAttributeEnvironmentApplyConfiguration {
-	b.Name = &value
-	return b
-}
-
-// WithDefaultValue sets the DefaultValue field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the DefaultValue field is set to the value of the last call.
-func (b *CustomAttributeEnvironmentApplyConfiguration) WithDefaultValue(value string) *CustomAttributeEnvironmentApplyConfiguration {
-	b.DefaultValue = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/customattributeheader.go b/api/applyconfiguration/api/v1alpha1/customattributeheader.go
deleted file mode 100644
index 8c77639cc..000000000
--- a/api/applyconfiguration/api/v1alpha1/customattributeheader.go
+++ /dev/null
@@ -1,32 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// CustomAttributeHeaderApplyConfiguration represents a declarative configuration of the CustomAttributeHeader type for use
-// with apply.
-type CustomAttributeHeaderApplyConfiguration struct {
-	Name         *string `json:"name,omitempty"`
-	DefaultValue *string `json:"defaultValue,omitempty"`
-}
-
-// CustomAttributeHeaderApplyConfiguration constructs a declarative configuration of the CustomAttributeHeader type for use with
-// apply.
-func CustomAttributeHeader() *CustomAttributeHeaderApplyConfiguration {
-	return &CustomAttributeHeaderApplyConfiguration{}
-}
-
-// WithName sets the Name field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Name field is set to the value of the last call.
-func (b *CustomAttributeHeaderApplyConfiguration) WithName(value string) *CustomAttributeHeaderApplyConfiguration {
-	b.Name = &value
-	return b
-}
-
-// WithDefaultValue sets the DefaultValue field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the DefaultValue field is set to the value of the last call.
-func (b *CustomAttributeHeaderApplyConfiguration) WithDefaultValue(value string) *CustomAttributeHeaderApplyConfiguration {
-	b.DefaultValue = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/customattributeliteral.go b/api/applyconfiguration/api/v1alpha1/customattributeliteral.go
deleted file mode 100644
index a9e283747..000000000
--- a/api/applyconfiguration/api/v1alpha1/customattributeliteral.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// CustomAttributeLiteralApplyConfiguration represents a declarative configuration of the CustomAttributeLiteral type for use
-// with apply.
-type CustomAttributeLiteralApplyConfiguration struct {
-	Value *string `json:"value,omitempty"`
-}
-
-// CustomAttributeLiteralApplyConfiguration constructs a declarative configuration of the CustomAttributeLiteral type for use with
-// apply.
-func CustomAttributeLiteral() *CustomAttributeLiteralApplyConfiguration {
-	return &CustomAttributeLiteralApplyConfiguration{}
-}
-
-// WithValue sets the Value field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Value field is set to the value of the last call.
-func (b *CustomAttributeLiteralApplyConfiguration) WithValue(value string) *CustomAttributeLiteralApplyConfiguration {
-	b.Value = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/customattributemetadata.go b/api/applyconfiguration/api/v1alpha1/customattributemetadata.go
deleted file mode 100644
index 71f6190d8..000000000
--- a/api/applyconfiguration/api/v1alpha1/customattributemetadata.go
+++ /dev/null
@@ -1,45 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-)
-
-// CustomAttributeMetadataApplyConfiguration represents a declarative configuration of the CustomAttributeMetadata type for use
-// with apply.
-type CustomAttributeMetadataApplyConfiguration struct {
-	Kind         *apiv1alpha1.MetadataKind      `json:"kind,omitempty"`
-	MetadataKey  *MetadataKeyApplyConfiguration `json:"metadataKey,omitempty"`
-	DefaultValue *string                        `json:"defaultValue,omitempty"`
-}
-
-// CustomAttributeMetadataApplyConfiguration constructs a declarative configuration of the CustomAttributeMetadata type for use with
-// apply.
-func CustomAttributeMetadata() *CustomAttributeMetadataApplyConfiguration {
-	return &CustomAttributeMetadataApplyConfiguration{}
-}
-
-// WithKind sets the Kind field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Kind field is set to the value of the last call.
-func (b *CustomAttributeMetadataApplyConfiguration) WithKind(value apiv1alpha1.MetadataKind) *CustomAttributeMetadataApplyConfiguration {
-	b.Kind = &value
-	return b
-}
-
-// WithMetadataKey sets the MetadataKey field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the MetadataKey field is set to the value of the last call.
-func (b *CustomAttributeMetadataApplyConfiguration) WithMetadataKey(value *MetadataKeyApplyConfiguration) *CustomAttributeMetadataApplyConfiguration {
-	b.MetadataKey = value
-	return b
-}
-
-// WithDefaultValue sets the DefaultValue field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the DefaultValue field is set to the value of the last call.
-func (b *CustomAttributeMetadataApplyConfiguration) WithDefaultValue(value string) *CustomAttributeMetadataApplyConfiguration {
-	b.DefaultValue = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/grpcservice.go b/api/applyconfiguration/api/v1alpha1/grpcservice.go
new file mode 100644
index 000000000..a617eac1d
--- /dev/null
+++ b/api/applyconfiguration/api/v1alpha1/grpcservice.go
@@ -0,0 +1,69 @@
+// Code generated by applyconfiguration-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	v1 "sigs.k8s.io/gateway-api/apis/v1"
+)
+
+// GrpcServiceApplyConfiguration represents a declarative configuration of the GrpcService type for use
+// with apply.
+type GrpcServiceApplyConfiguration struct {
+	LogName                         *string        `json:"logName,omitempty"`
+	BackendRef                      *v1.BackendRef `json:"backendRef,omitempty"`
+	AdditionalRequestHeadersToLog   []string       `json:"additionalRequestHeadersToLog,omitempty"`
+	AdditionalResponseHeadersToLog  []string       `json:"additionalResponseHeadersToLog,omitempty"`
+	AdditionalResponseTrailersToLog []string       `json:"additionalResponseTrailersToLog,omitempty"`
+}
+
+// GrpcServiceApplyConfiguration constructs a declarative configuration of the GrpcService type for use with
+// apply.
+func GrpcService() *GrpcServiceApplyConfiguration {
+	return &GrpcServiceApplyConfiguration{}
+}
+
+// WithLogName sets the LogName field in the declarative configuration to the given value
+// and returns the receiver, so that objects can be built by chaining "With" function invocations.
+// If called multiple times, the LogName field is set to the value of the last call.
+func (b *GrpcServiceApplyConfiguration) WithLogName(value string) *GrpcServiceApplyConfiguration {
+	b.LogName = &value
+	return b
+}
+
+// WithBackendRef sets the BackendRef field in the declarative configuration to the given value
+// and returns the receiver, so that objects can be built by chaining "With" function invocations.
+// If called multiple times, the BackendRef field is set to the value of the last call.
+func (b *GrpcServiceApplyConfiguration) WithBackendRef(value v1.BackendRef) *GrpcServiceApplyConfiguration {
+	b.BackendRef = &value
+	return b
+}
+
+// WithAdditionalRequestHeadersToLog adds the given value to the AdditionalRequestHeadersToLog field in the declarative configuration
+// and returns the receiver, so that objects can be build by chaining "With" function invocations.
+// If called multiple times, values provided by each call will be appended to the AdditionalRequestHeadersToLog field.
+func (b *GrpcServiceApplyConfiguration) WithAdditionalRequestHeadersToLog(values ...string) *GrpcServiceApplyConfiguration {
+	for i := range values {
+		b.AdditionalRequestHeadersToLog = append(b.AdditionalRequestHeadersToLog, values[i])
+	}
+	return b
+}
+
+// WithAdditionalResponseHeadersToLog adds the given value to the AdditionalResponseHeadersToLog field in the declarative configuration
+// and returns the receiver, so that objects can be build by chaining "With" function invocations.
+// If called multiple times, values provided by each call will be appended to the AdditionalResponseHeadersToLog field.
+func (b *GrpcServiceApplyConfiguration) WithAdditionalResponseHeadersToLog(values ...string) *GrpcServiceApplyConfiguration {
+	for i := range values {
+		b.AdditionalResponseHeadersToLog = append(b.AdditionalResponseHeadersToLog, values[i])
+	}
+	return b
+}
+
+// WithAdditionalResponseTrailersToLog adds the given value to the AdditionalResponseTrailersToLog field in the declarative configuration
+// and returns the receiver, so that objects can be build by chaining "With" function invocations.
+// If called multiple times, values provided by each call will be appended to the AdditionalResponseTrailersToLog field.
+func (b *GrpcServiceApplyConfiguration) WithAdditionalResponseTrailersToLog(values ...string) *GrpcServiceApplyConfiguration {
+	for i := range values {
+		b.AdditionalResponseTrailersToLog = append(b.AdditionalResponseTrailersToLog, values[i])
+	}
+	return b
+}
diff --git a/api/applyconfiguration/api/v1alpha1/headervalue.go b/api/applyconfiguration/api/v1alpha1/headervalue.go
deleted file mode 100644
index ea147bfca..000000000
--- a/api/applyconfiguration/api/v1alpha1/headervalue.go
+++ /dev/null
@@ -1,32 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// HeaderValueApplyConfiguration represents a declarative configuration of the HeaderValue type for use
-// with apply.
-type HeaderValueApplyConfiguration struct {
-	Key   *string `json:"key,omitempty"`
-	Value *string `json:"value,omitempty"`
-}
-
-// HeaderValueApplyConfiguration constructs a declarative configuration of the HeaderValue type for use with
-// apply.
-func HeaderValue() *HeaderValueApplyConfiguration {
-	return &HeaderValueApplyConfiguration{}
-}
-
-// WithKey sets the Key field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Key field is set to the value of the last call.
-func (b *HeaderValueApplyConfiguration) WithKey(value string) *HeaderValueApplyConfiguration {
-	b.Key = &value
-	return b
-}
-
-// WithValue sets the Value field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Value field is set to the value of the last call.
-func (b *HeaderValueApplyConfiguration) WithValue(value string) *HeaderValueApplyConfiguration {
-	b.Value = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/httplistenerpolicyspec.go b/api/applyconfiguration/api/v1alpha1/httplistenerpolicyspec.go
index be1779e29..0bf0b27e5 100644
--- a/api/applyconfiguration/api/v1alpha1/httplistenerpolicyspec.go
+++ b/api/applyconfiguration/api/v1alpha1/httplistenerpolicyspec.go
@@ -14,7 +14,6 @@ type HTTPListenerPolicySpecApplyConfiguration struct {
 	TargetRefs                 []LocalPolicyTargetReferenceApplyConfiguration `json:"targetRefs,omitempty"`
 	TargetSelectors            []LocalPolicyTargetSelectorApplyConfiguration  `json:"targetSelectors,omitempty"`
 	AccessLog                  []AccessLogApplyConfiguration                  `json:"accessLog,omitempty"`
-	Tracing                    *TracingApplyConfiguration                     `json:"tracing,omitempty"`
 	UpgradeConfig              *UpgradeConfigApplyConfiguration               `json:"upgradeConfig,omitempty"`
 	UseRemoteAddress           *bool                                          `json:"useRemoteAddress,omitempty"`
 	XffNumTrustedHops          *uint32                                        `json:"xffNumTrustedHops,omitempty"`
@@ -67,14 +66,6 @@ func (b *HTTPListenerPolicySpecApplyConfiguration) WithAccessLog(values ...*Acce
 	return b
 }
 
-// WithTracing sets the Tracing field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Tracing field is set to the value of the last call.
-func (b *HTTPListenerPolicySpecApplyConfiguration) WithTracing(value *TracingApplyConfiguration) *HTTPListenerPolicySpecApplyConfiguration {
-	b.Tracing = value
-	return b
-}
-
 // WithUpgradeConfig sets the UpgradeConfig field in the declarative configuration to the given value
 // and returns the receiver, so that objects can be built by chaining "With" function invocations.
 // If called multiple times, the UpgradeConfig field is set to the value of the last call.
diff --git a/api/applyconfiguration/api/v1alpha1/keyanyvalue.go b/api/applyconfiguration/api/v1alpha1/keyanyvalue.go
deleted file mode 100644
index 065256e0e..000000000
--- a/api/applyconfiguration/api/v1alpha1/keyanyvalue.go
+++ /dev/null
@@ -1,32 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// KeyAnyValueApplyConfiguration represents a declarative configuration of the KeyAnyValue type for use
-// with apply.
-type KeyAnyValueApplyConfiguration struct {
-	Key   *string                     `json:"key,omitempty"`
-	Value *AnyValueApplyConfiguration `json:"value,omitempty"`
-}
-
-// KeyAnyValueApplyConfiguration constructs a declarative configuration of the KeyAnyValue type for use with
-// apply.
-func KeyAnyValue() *KeyAnyValueApplyConfiguration {
-	return &KeyAnyValueApplyConfiguration{}
-}
-
-// WithKey sets the Key field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Key field is set to the value of the last call.
-func (b *KeyAnyValueApplyConfiguration) WithKey(value string) *KeyAnyValueApplyConfiguration {
-	b.Key = &value
-	return b
-}
-
-// WithValue sets the Value field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Value field is set to the value of the last call.
-func (b *KeyAnyValueApplyConfiguration) WithValue(value *AnyValueApplyConfiguration) *KeyAnyValueApplyConfiguration {
-	b.Value = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/keyanyvaluelist.go b/api/applyconfiguration/api/v1alpha1/keyanyvaluelist.go
deleted file mode 100644
index b412c0177..000000000
--- a/api/applyconfiguration/api/v1alpha1/keyanyvaluelist.go
+++ /dev/null
@@ -1,28 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// KeyAnyValueListApplyConfiguration represents a declarative configuration of the KeyAnyValueList type for use
-// with apply.
-type KeyAnyValueListApplyConfiguration struct {
-	Values []KeyAnyValueApplyConfiguration `json:"values,omitempty"`
-}
-
-// KeyAnyValueListApplyConfiguration constructs a declarative configuration of the KeyAnyValueList type for use with
-// apply.
-func KeyAnyValueList() *KeyAnyValueListApplyConfiguration {
-	return &KeyAnyValueListApplyConfiguration{}
-}
-
-// WithValues adds the given value to the Values field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the Values field.
-func (b *KeyAnyValueListApplyConfiguration) WithValues(values ...*KeyAnyValueApplyConfiguration) *KeyAnyValueListApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithValues")
-		}
-		b.Values = append(b.Values, *values[i])
-	}
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/metadatakey.go b/api/applyconfiguration/api/v1alpha1/metadatakey.go
deleted file mode 100644
index d2b33c204..000000000
--- a/api/applyconfiguration/api/v1alpha1/metadatakey.go
+++ /dev/null
@@ -1,37 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// MetadataKeyApplyConfiguration represents a declarative configuration of the MetadataKey type for use
-// with apply.
-type MetadataKeyApplyConfiguration struct {
-	Key  *string                                 `json:"key,omitempty"`
-	Path []MetadataPathSegmentApplyConfiguration `json:"path,omitempty"`
-}
-
-// MetadataKeyApplyConfiguration constructs a declarative configuration of the MetadataKey type for use with
-// apply.
-func MetadataKey() *MetadataKeyApplyConfiguration {
-	return &MetadataKeyApplyConfiguration{}
-}
-
-// WithKey sets the Key field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Key field is set to the value of the last call.
-func (b *MetadataKeyApplyConfiguration) WithKey(value string) *MetadataKeyApplyConfiguration {
-	b.Key = &value
-	return b
-}
-
-// WithPath adds the given value to the Path field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the Path field.
-func (b *MetadataKeyApplyConfiguration) WithPath(values ...*MetadataPathSegmentApplyConfiguration) *MetadataKeyApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithPath")
-		}
-		b.Path = append(b.Path, *values[i])
-	}
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/metadatapathsegment.go b/api/applyconfiguration/api/v1alpha1/metadatapathsegment.go
deleted file mode 100644
index 3002b5844..000000000
--- a/api/applyconfiguration/api/v1alpha1/metadatapathsegment.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// MetadataPathSegmentApplyConfiguration represents a declarative configuration of the MetadataPathSegment type for use
-// with apply.
-type MetadataPathSegmentApplyConfiguration struct {
-	Key *string `json:"key,omitempty"`
-}
-
-// MetadataPathSegmentApplyConfiguration constructs a declarative configuration of the MetadataPathSegment type for use with
-// apply.
-func MetadataPathSegment() *MetadataPathSegmentApplyConfiguration {
-	return &MetadataPathSegmentApplyConfiguration{}
-}
-
-// WithKey sets the Key field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Key field is set to the value of the last call.
-func (b *MetadataPathSegmentApplyConfiguration) WithKey(value string) *MetadataPathSegmentApplyConfiguration {
-	b.Key = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/opentelemetryaccesslogservice.go b/api/applyconfiguration/api/v1alpha1/opentelemetryaccesslogservice.go
deleted file mode 100644
index 148679b28..000000000
--- a/api/applyconfiguration/api/v1alpha1/opentelemetryaccesslogservice.go
+++ /dev/null
@@ -1,50 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// OpenTelemetryAccessLogServiceApplyConfiguration represents a declarative configuration of the OpenTelemetryAccessLogService type for use
-// with apply.
-type OpenTelemetryAccessLogServiceApplyConfiguration struct {
-	GrpcService          *CommonAccessLogGrpcServiceApplyConfiguration `json:"grpcService,omitempty"`
-	Body                 *string                                       `json:"body,omitempty"`
-	DisableBuiltinLabels *bool                                         `json:"disableBuiltinLabels,omitempty"`
-	Attributes           *KeyAnyValueListApplyConfiguration            `json:"attributes,omitempty"`
-}
-
-// OpenTelemetryAccessLogServiceApplyConfiguration constructs a declarative configuration of the OpenTelemetryAccessLogService type for use with
-// apply.
-func OpenTelemetryAccessLogService() *OpenTelemetryAccessLogServiceApplyConfiguration {
-	return &OpenTelemetryAccessLogServiceApplyConfiguration{}
-}
-
-// WithGrpcService sets the GrpcService field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the GrpcService field is set to the value of the last call.
-func (b *OpenTelemetryAccessLogServiceApplyConfiguration) WithGrpcService(value *CommonAccessLogGrpcServiceApplyConfiguration) *OpenTelemetryAccessLogServiceApplyConfiguration {
-	b.GrpcService = value
-	return b
-}
-
-// WithBody sets the Body field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Body field is set to the value of the last call.
-func (b *OpenTelemetryAccessLogServiceApplyConfiguration) WithBody(value string) *OpenTelemetryAccessLogServiceApplyConfiguration {
-	b.Body = &value
-	return b
-}
-
-// WithDisableBuiltinLabels sets the DisableBuiltinLabels field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the DisableBuiltinLabels field is set to the value of the last call.
-func (b *OpenTelemetryAccessLogServiceApplyConfiguration) WithDisableBuiltinLabels(value bool) *OpenTelemetryAccessLogServiceApplyConfiguration {
-	b.DisableBuiltinLabels = &value
-	return b
-}
-
-// WithAttributes sets the Attributes field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Attributes field is set to the value of the last call.
-func (b *OpenTelemetryAccessLogServiceApplyConfiguration) WithAttributes(value *KeyAnyValueListApplyConfiguration) *OpenTelemetryAccessLogServiceApplyConfiguration {
-	b.Attributes = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/opentelemetrytracingconfig.go b/api/applyconfiguration/api/v1alpha1/opentelemetrytracingconfig.go
deleted file mode 100644
index adc4b866c..000000000
--- a/api/applyconfiguration/api/v1alpha1/opentelemetrytracingconfig.go
+++ /dev/null
@@ -1,55 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// OpenTelemetryTracingConfigApplyConfiguration represents a declarative configuration of the OpenTelemetryTracingConfig type for use
-// with apply.
-type OpenTelemetryTracingConfigApplyConfiguration struct {
-	GrpcService       *CommonGrpcServiceApplyConfiguration `json:"grpcService,omitempty"`
-	ServiceName       *string                              `json:"serviceName,omitempty"`
-	ResourceDetectors []ResourceDetectorApplyConfiguration `json:"resourceDetectors,omitempty"`
-	Sampler           *SamplerApplyConfiguration           `json:"sampler,omitempty"`
-}
-
-// OpenTelemetryTracingConfigApplyConfiguration constructs a declarative configuration of the OpenTelemetryTracingConfig type for use with
-// apply.
-func OpenTelemetryTracingConfig() *OpenTelemetryTracingConfigApplyConfiguration {
-	return &OpenTelemetryTracingConfigApplyConfiguration{}
-}
-
-// WithGrpcService sets the GrpcService field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the GrpcService field is set to the value of the last call.
-func (b *OpenTelemetryTracingConfigApplyConfiguration) WithGrpcService(value *CommonGrpcServiceApplyConfiguration) *OpenTelemetryTracingConfigApplyConfiguration {
-	b.GrpcService = value
-	return b
-}
-
-// WithServiceName sets the ServiceName field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the ServiceName field is set to the value of the last call.
-func (b *OpenTelemetryTracingConfigApplyConfiguration) WithServiceName(value string) *OpenTelemetryTracingConfigApplyConfiguration {
-	b.ServiceName = &value
-	return b
-}
-
-// WithResourceDetectors adds the given value to the ResourceDetectors field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the ResourceDetectors field.
-func (b *OpenTelemetryTracingConfigApplyConfiguration) WithResourceDetectors(values ...*ResourceDetectorApplyConfiguration) *OpenTelemetryTracingConfigApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithResourceDetectors")
-		}
-		b.ResourceDetectors = append(b.ResourceDetectors, *values[i])
-	}
-	return b
-}
-
-// WithSampler sets the Sampler field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Sampler field is set to the value of the last call.
-func (b *OpenTelemetryTracingConfigApplyConfiguration) WithSampler(value *SamplerApplyConfiguration) *OpenTelemetryTracingConfigApplyConfiguration {
-	b.Sampler = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/oteltracessampler.go b/api/applyconfiguration/api/v1alpha1/oteltracessampler.go
deleted file mode 100644
index d79de207b..000000000
--- a/api/applyconfiguration/api/v1alpha1/oteltracessampler.go
+++ /dev/null
@@ -1,36 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-)
-
-// OTelTracesSamplerApplyConfiguration represents a declarative configuration of the OTelTracesSampler type for use
-// with apply.
-type OTelTracesSamplerApplyConfiguration struct {
-	SamplerType *apiv1alpha1.OTelTracesSamplerType `json:"type,omitempty"`
-	SamplerArg  *string                            `json:"arg,omitempty"`
-}
-
-// OTelTracesSamplerApplyConfiguration constructs a declarative configuration of the OTelTracesSampler type for use with
-// apply.
-func OTelTracesSampler() *OTelTracesSamplerApplyConfiguration {
-	return &OTelTracesSamplerApplyConfiguration{}
-}
-
-// WithSamplerType sets the SamplerType field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the SamplerType field is set to the value of the last call.
-func (b *OTelTracesSamplerApplyConfiguration) WithSamplerType(value apiv1alpha1.OTelTracesSamplerType) *OTelTracesSamplerApplyConfiguration {
-	b.SamplerType = &value
-	return b
-}
-
-// WithSamplerArg sets the SamplerArg field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the SamplerArg field is set to the value of the last call.
-func (b *OTelTracesSamplerApplyConfiguration) WithSamplerArg(value string) *OTelTracesSamplerApplyConfiguration {
-	b.SamplerArg = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/resourcedetector.go b/api/applyconfiguration/api/v1alpha1/resourcedetector.go
deleted file mode 100644
index b731a1c67..000000000
--- a/api/applyconfiguration/api/v1alpha1/resourcedetector.go
+++ /dev/null
@@ -1,27 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-)
-
-// ResourceDetectorApplyConfiguration represents a declarative configuration of the ResourceDetector type for use
-// with apply.
-type ResourceDetectorApplyConfiguration struct {
-	EnvironmentResourceDetector *apiv1alpha1.EnvironmentResourceDetectorConfig `json:"environmentResourceDetector,omitempty"`
-}
-
-// ResourceDetectorApplyConfiguration constructs a declarative configuration of the ResourceDetector type for use with
-// apply.
-func ResourceDetector() *ResourceDetectorApplyConfiguration {
-	return &ResourceDetectorApplyConfiguration{}
-}
-
-// WithEnvironmentResourceDetector sets the EnvironmentResourceDetector field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the EnvironmentResourceDetector field is set to the value of the last call.
-func (b *ResourceDetectorApplyConfiguration) WithEnvironmentResourceDetector(value apiv1alpha1.EnvironmentResourceDetectorConfig) *ResourceDetectorApplyConfiguration {
-	b.EnvironmentResourceDetector = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/retrypolicy.go b/api/applyconfiguration/api/v1alpha1/retrypolicy.go
deleted file mode 100644
index ff1482e23..000000000
--- a/api/applyconfiguration/api/v1alpha1/retrypolicy.go
+++ /dev/null
@@ -1,32 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// RetryPolicyApplyConfiguration represents a declarative configuration of the RetryPolicy type for use
-// with apply.
-type RetryPolicyApplyConfiguration struct {
-	RetryBackOff *BackoffStrategyApplyConfiguration `json:"retryBackOff,omitempty"`
-	NumRetries   *uint32                            `json:"numRetries,omitempty"`
-}
-
-// RetryPolicyApplyConfiguration constructs a declarative configuration of the RetryPolicy type for use with
-// apply.
-func RetryPolicy() *RetryPolicyApplyConfiguration {
-	return &RetryPolicyApplyConfiguration{}
-}
-
-// WithRetryBackOff sets the RetryBackOff field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the RetryBackOff field is set to the value of the last call.
-func (b *RetryPolicyApplyConfiguration) WithRetryBackOff(value *BackoffStrategyApplyConfiguration) *RetryPolicyApplyConfiguration {
-	b.RetryBackOff = value
-	return b
-}
-
-// WithNumRetries sets the NumRetries field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the NumRetries field is set to the value of the last call.
-func (b *RetryPolicyApplyConfiguration) WithNumRetries(value uint32) *RetryPolicyApplyConfiguration {
-	b.NumRetries = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/sampler.go b/api/applyconfiguration/api/v1alpha1/sampler.go
deleted file mode 100644
index 7aacbd2bd..000000000
--- a/api/applyconfiguration/api/v1alpha1/sampler.go
+++ /dev/null
@@ -1,27 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-)
-
-// SamplerApplyConfiguration represents a declarative configuration of the Sampler type for use
-// with apply.
-type SamplerApplyConfiguration struct {
-	AlwaysOn *apiv1alpha1.AlwaysOnConfig `json:"alwaysOnConfig,omitempty"`
-}
-
-// SamplerApplyConfiguration constructs a declarative configuration of the Sampler type for use with
-// apply.
-func Sampler() *SamplerApplyConfiguration {
-	return &SamplerApplyConfiguration{}
-}
-
-// WithAlwaysOn sets the AlwaysOn field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the AlwaysOn field is set to the value of the last call.
-func (b *SamplerApplyConfiguration) WithAlwaysOn(value apiv1alpha1.AlwaysOnConfig) *SamplerApplyConfiguration {
-	b.AlwaysOn = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/tracing.go b/api/applyconfiguration/api/v1alpha1/tracing.go
deleted file mode 100644
index 3e2930cbc..000000000
--- a/api/applyconfiguration/api/v1alpha1/tracing.go
+++ /dev/null
@@ -1,91 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// TracingApplyConfiguration represents a declarative configuration of the Tracing type for use
-// with apply.
-type TracingApplyConfiguration struct {
-	Provider          *TracingProviderApplyConfiguration  `json:"provider,omitempty"`
-	ClientSampling    *uint32                             `json:"clientSampling,omitempty"`
-	RandomSampling    *uint32                             `json:"randomSampling,omitempty"`
-	OverallSampling   *uint32                             `json:"overallSampling,omitempty"`
-	Verbose           *bool                               `json:"verbose,omitempty"`
-	MaxPathTagLength  *uint32                             `json:"maxPathTagLength,omitempty"`
-	Attributes        []CustomAttributeApplyConfiguration `json:"attributes,omitempty"`
-	SpawnUpstreamSpan *bool                               `json:"spawnUpstreamSpan,omitempty"`
-}
-
-// TracingApplyConfiguration constructs a declarative configuration of the Tracing type for use with
-// apply.
-func Tracing() *TracingApplyConfiguration {
-	return &TracingApplyConfiguration{}
-}
-
-// WithProvider sets the Provider field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Provider field is set to the value of the last call.
-func (b *TracingApplyConfiguration) WithProvider(value *TracingProviderApplyConfiguration) *TracingApplyConfiguration {
-	b.Provider = value
-	return b
-}
-
-// WithClientSampling sets the ClientSampling field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the ClientSampling field is set to the value of the last call.
-func (b *TracingApplyConfiguration) WithClientSampling(value uint32) *TracingApplyConfiguration {
-	b.ClientSampling = &value
-	return b
-}
-
-// WithRandomSampling sets the RandomSampling field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the RandomSampling field is set to the value of the last call.
-func (b *TracingApplyConfiguration) WithRandomSampling(value uint32) *TracingApplyConfiguration {
-	b.RandomSampling = &value
-	return b
-}
-
-// WithOverallSampling sets the OverallSampling field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the OverallSampling field is set to the value of the last call.
-func (b *TracingApplyConfiguration) WithOverallSampling(value uint32) *TracingApplyConfiguration {
-	b.OverallSampling = &value
-	return b
-}
-
-// WithVerbose sets the Verbose field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Verbose field is set to the value of the last call.
-func (b *TracingApplyConfiguration) WithVerbose(value bool) *TracingApplyConfiguration {
-	b.Verbose = &value
-	return b
-}
-
-// WithMaxPathTagLength sets the MaxPathTagLength field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the MaxPathTagLength field is set to the value of the last call.
-func (b *TracingApplyConfiguration) WithMaxPathTagLength(value uint32) *TracingApplyConfiguration {
-	b.MaxPathTagLength = &value
-	return b
-}
-
-// WithAttributes adds the given value to the Attributes field in the declarative configuration
-// and returns the receiver, so that objects can be build by chaining "With" function invocations.
-// If called multiple times, values provided by each call will be appended to the Attributes field.
-func (b *TracingApplyConfiguration) WithAttributes(values ...*CustomAttributeApplyConfiguration) *TracingApplyConfiguration {
-	for i := range values {
-		if values[i] == nil {
-			panic("nil value passed to WithAttributes")
-		}
-		b.Attributes = append(b.Attributes, *values[i])
-	}
-	return b
-}
-
-// WithSpawnUpstreamSpan sets the SpawnUpstreamSpan field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the SpawnUpstreamSpan field is set to the value of the last call.
-func (b *TracingApplyConfiguration) WithSpawnUpstreamSpan(value bool) *TracingApplyConfiguration {
-	b.SpawnUpstreamSpan = &value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/tracingprovider.go b/api/applyconfiguration/api/v1alpha1/tracingprovider.go
deleted file mode 100644
index f44260cda..000000000
--- a/api/applyconfiguration/api/v1alpha1/tracingprovider.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Code generated by applyconfiguration-gen. DO NOT EDIT.
-
-package v1alpha1
-
-// TracingProviderApplyConfiguration represents a declarative configuration of the TracingProvider type for use
-// with apply.
-type TracingProviderApplyConfiguration struct {
-	OpenTelemetry *OpenTelemetryTracingConfigApplyConfiguration `json:"openTelemetry,omitempty"`
-}
-
-// TracingProviderApplyConfiguration constructs a declarative configuration of the TracingProvider type for use with
-// apply.
-func TracingProvider() *TracingProviderApplyConfiguration {
-	return &TracingProviderApplyConfiguration{}
-}
-
-// WithOpenTelemetry sets the OpenTelemetry field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the OpenTelemetry field is set to the value of the last call.
-func (b *TracingProviderApplyConfiguration) WithOpenTelemetry(value *OpenTelemetryTracingConfigApplyConfiguration) *TracingProviderApplyConfiguration {
-	b.OpenTelemetry = value
-	return b
-}
diff --git a/api/applyconfiguration/api/v1alpha1/trafficpolicyspec.go b/api/applyconfiguration/api/v1alpha1/trafficpolicyspec.go
index 0510c49a8..919560684 100644
--- a/api/applyconfiguration/api/v1alpha1/trafficpolicyspec.go
+++ b/api/applyconfiguration/api/v1alpha1/trafficpolicyspec.go
@@ -14,7 +14,6 @@ type TrafficPolicySpecApplyConfiguration struct {
 	RateLimit       *RateLimitApplyConfiguration                                  `json:"rateLimit,omitempty"`
 	Cors            *CorsPolicyApplyConfiguration                                 `json:"cors,omitempty"`
 	Csrf            *CSRFPolicyApplyConfiguration                                 `json:"csrf,omitempty"`
-	Buffer          *BufferApplyConfiguration                                     `json:"buffer,omitempty"`
 }
 
 // TrafficPolicySpecApplyConfiguration constructs a declarative configuration of the TrafficPolicySpec type for use with
@@ -104,11 +103,3 @@ func (b *TrafficPolicySpecApplyConfiguration) WithCsrf(value *CSRFPolicyApplyCon
 	b.Csrf = value
 	return b
 }
-
-// WithBuffer sets the Buffer field in the declarative configuration to the given value
-// and returns the receiver, so that objects can be built by chaining "With" function invocations.
-// If called multiple times, the Buffer field is set to the value of the last call.
-func (b *TrafficPolicySpecApplyConfiguration) WithBuffer(value *BufferApplyConfiguration) *TrafficPolicySpecApplyConfiguration {
-	b.Buffer = value
-	return b
-}
diff --git a/api/applyconfiguration/internal/internal.go b/api/applyconfiguration/internal/internal.go
index cf4d37a10..d0fff61fa 100644
--- a/api/applyconfiguration/internal/internal.go
+++ b/api/applyconfiguration/internal/internal.go
@@ -85,10 +85,7 @@ var schemaYAML = typed.YAMLObject(`types:
         namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AccessLogFilter
     - name: grpcService
       type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AccessLogGrpcService
-    - name: openTelemetry
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.OpenTelemetryAccessLogService
+        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.GrpcService
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AccessLogFilter
   map:
     fields:
@@ -128,55 +125,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: traceableFilter
       type:
         scalar: boolean
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AccessLogGrpcService
-  map:
-    fields:
-    - name: additionalRequestHeadersToLog
-      type:
-        list:
-          elementType:
-            scalar: string
-          elementRelationship: atomic
-    - name: additionalResponseHeadersToLog
-      type:
-        list:
-          elementType:
-            scalar: string
-          elementRelationship: atomic
-    - name: additionalResponseTrailersToLog
-      type:
-        list:
-          elementType:
-            scalar: string
-          elementRelationship: atomic
-    - name: authority
-      type:
-        scalar: string
-    - name: backendRef
-      type:
-        namedType: io.k8s.sigs.gateway-api.apis.v1.BackendRef
-    - name: initialMetadata
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.HeaderValue
-          elementRelationship: atomic
-    - name: logName
-      type:
-        scalar: string
-      default: ""
-    - name: maxReceiveMessageLength
-      type:
-        scalar: numeric
-    - name: retryPolicy
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.RetryPolicy
-    - name: skipEnvoyHeaders
-      type:
-        scalar: boolean
-    - name: timeout
-      type:
-        namedType: io.k8s.apimachinery.pkg.apis.meta.v1.Duration
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AgentGateway
   map:
     fields:
@@ -231,9 +179,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: stats
       type:
         namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AiExtensionStats
-    - name: tracing
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AiExtensionTrace
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AiExtensionStats
   map:
     fields:
@@ -243,37 +188,6 @@ var schemaYAML = typed.YAMLObject(`types:
           elementType:
             namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomLabel
           elementRelationship: atomic
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AiExtensionTrace
-  map:
-    fields:
-    - name: endpoint
-      type:
-        scalar: string
-      default: ""
-    - name: protocol
-      type:
-        scalar: string
-    - name: sampler
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.OTelTracesSampler
-    - name: timeout
-      type:
-        scalar: string
-    - name: transportSecurity
-      type:
-        scalar: string
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AlwaysOnConfig
-  map:
-    elementType:
-      scalar: untyped
-      list:
-        elementType:
-          namedType: __untyped_atomic_
-        elementRelationship: atomic
-      map:
-        elementType:
-          namedType: __untyped_deduced_
-        elementRelationship: separable
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AnthropicConfig
   map:
     fields:
@@ -287,21 +201,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: model
       type:
         scalar: string
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AnyValue
-  map:
-    fields:
-    - name: arrayValue
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AnyValue
-          elementRelationship: atomic
-    - name: kvListValue
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.KeyAnyValueList
-    - name: stringValue
-      type:
-        scalar: string
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AuthHeaderOverride
   map:
     fields:
@@ -506,15 +405,6 @@ var schemaYAML = typed.YAMLObject(`types:
           elementRelationship: associative
           keys:
           - type
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.BackoffStrategy
-  map:
-    fields:
-    - name: baseInterval
-      type:
-        namedType: io.k8s.apimachinery.pkg.apis.meta.v1.Duration
-    - name: maxInterval
-      type:
-        namedType: io.k8s.apimachinery.pkg.apis.meta.v1.Duration
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.BodyTransformation
   map:
     fields:
@@ -525,12 +415,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: value
       type:
         scalar: string
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Buffer
-  map:
-    fields:
-    - name: maxRequestSize
-      type:
-        namedType: io.k8s.apimachinery.pkg.api.resource.Quantity
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.BufferSettings
   map:
     fields:
@@ -566,64 +450,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: percentageShadowed
       type:
         scalar: numeric
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CommonAccessLogGrpcService
-  map:
-    fields:
-    - name: authority
-      type:
-        scalar: string
-    - name: backendRef
-      type:
-        namedType: io.k8s.sigs.gateway-api.apis.v1.BackendRef
-    - name: initialMetadata
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.HeaderValue
-          elementRelationship: atomic
-    - name: logName
-      type:
-        scalar: string
-      default: ""
-    - name: maxReceiveMessageLength
-      type:
-        scalar: numeric
-    - name: retryPolicy
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.RetryPolicy
-    - name: skipEnvoyHeaders
-      type:
-        scalar: boolean
-    - name: timeout
-      type:
-        namedType: io.k8s.apimachinery.pkg.apis.meta.v1.Duration
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CommonGrpcService
-  map:
-    fields:
-    - name: authority
-      type:
-        scalar: string
-    - name: backendRef
-      type:
-        namedType: io.k8s.sigs.gateway-api.apis.v1.BackendRef
-    - name: initialMetadata
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.HeaderValue
-          elementRelationship: atomic
-    - name: maxReceiveMessageLength
-      type:
-        scalar: numeric
-    - name: retryPolicy
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.RetryPolicy
-    - name: skipEnvoyHeaders
-      type:
-        scalar: boolean
-    - name: timeout
-      type:
-        namedType: io.k8s.apimachinery.pkg.apis.meta.v1.Duration
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CommonHttpProtocolOptions
   map:
     fields:
@@ -672,66 +498,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: maxAge
       type:
         scalar: numeric
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttribute
-  map:
-    fields:
-    - name: environment
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeEnvironment
-    - name: literal
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeLiteral
-    - name: metadata
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeMetadata
-    - name: name
-      type:
-        scalar: string
-      default: ""
-    - name: requestHeader
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeHeader
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeEnvironment
-  map:
-    fields:
-    - name: defaultValue
-      type:
-        scalar: string
-    - name: name
-      type:
-        scalar: string
-      default: ""
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeHeader
-  map:
-    fields:
-    - name: defaultValue
-      type:
-        scalar: string
-    - name: name
-      type:
-        scalar: string
-      default: ""
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeLiteral
-  map:
-    fields:
-    - name: value
-      type:
-        scalar: string
-      default: ""
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttributeMetadata
-  map:
-    fields:
-    - name: defaultValue
-      type:
-        scalar: string
-    - name: kind
-      type:
-        scalar: string
-      default: ""
-    - name: metadataKey
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.MetadataKey
-      default: {}
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomLabel
   map:
     fields:
@@ -816,18 +582,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: enableTls
       type:
         scalar: boolean
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.EnvironmentResourceDetectorConfig
-  map:
-    elementType:
-      scalar: untyped
-      list:
-        elementType:
-          namedType: __untyped_atomic_
-        elementRelationship: atomic
-      map:
-        elementType:
-          namedType: __untyped_deduced_
-        elementRelationship: separable
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.EnvoyBootstrap
   map:
     fields:
@@ -1075,6 +829,34 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: sleepTimeSeconds
       type:
         scalar: numeric
+- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.GrpcService
+  map:
+    fields:
+    - name: additionalRequestHeadersToLog
+      type:
+        list:
+          elementType:
+            scalar: string
+          elementRelationship: atomic
+    - name: additionalResponseHeadersToLog
+      type:
+        list:
+          elementType:
+            scalar: string
+          elementRelationship: atomic
+    - name: additionalResponseTrailersToLog
+      type:
+        list:
+          elementType:
+            scalar: string
+          elementRelationship: atomic
+    - name: backendRef
+      type:
+        namedType: io.k8s.sigs.gateway-api.apis.v1.BackendRef
+    - name: logName
+      type:
+        scalar: string
+      default: ""
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.GrpcStatusFilter
   map:
     fields:
@@ -1135,9 +917,6 @@ var schemaYAML = typed.YAMLObject(`types:
           elementType:
             namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.LocalPolicyTargetSelector
           elementRelationship: atomic
-    - name: tracing
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Tracing
     - name: upgradeConfig
       type:
         namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.UpgradeConfig
@@ -1163,16 +942,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: value
       type:
         scalar: string
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.HeaderValue
-  map:
-    fields:
-    - name: key
-      type:
-        scalar: string
-      default: ""
-    - name: value
-      type:
-        scalar: string
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.HealthCheck
   map:
     fields:
@@ -1311,26 +1080,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: istioProxyContainer
       type:
         namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.IstioContainer
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.KeyAnyValue
-  map:
-    fields:
-    - name: key
-      type:
-        scalar: string
-      default: ""
-    - name: value
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AnyValue
-      default: {}
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.KeyAnyValueList
-  map:
-    fields:
-    - name: values
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.KeyAnyValue
-          elementRelationship: atomic
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.KubernetesProxyConfig
   map:
     fields:
@@ -1532,26 +1281,6 @@ var schemaYAML = typed.YAMLObject(`types:
       type:
         scalar: string
       default: ""
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.MetadataKey
-  map:
-    fields:
-    - name: key
-      type:
-        scalar: string
-      default: ""
-    - name: path
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.MetadataPathSegment
-          elementRelationship: atomic
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.MetadataPathSegment
-  map:
-    fields:
-    - name: key
-      type:
-        scalar: string
-      default: ""
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Moderation
   map:
     fields:
@@ -1567,15 +1296,6 @@ var schemaYAML = typed.YAMLObject(`types:
           elementType:
             namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Priority
           elementRelationship: atomic
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.OTelTracesSampler
-  map:
-    fields:
-    - name: arg
-      type:
-        scalar: string
-    - name: type
-      type:
-        scalar: string
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.OpenAIConfig
   map:
     fields:
@@ -1586,42 +1306,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: model
       type:
         scalar: string
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.OpenTelemetryAccessLogService
-  map:
-    fields:
-    - name: attributes
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.KeyAnyValueList
-    - name: body
-      type:
-        scalar: string
-    - name: disableBuiltinLabels
-      type:
-        scalar: boolean
-    - name: grpcService
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CommonAccessLogGrpcService
-      default: {}
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.OpenTelemetryTracingConfig
-  map:
-    fields:
-    - name: grpcService
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CommonGrpcService
-      default: {}
-    - name: resourceDetectors
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.ResourceDetector
-          elementRelationship: atomic
-    - name: sampler
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Sampler
-    - name: serviceName
-      type:
-        scalar: string
-      default: ""
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Parameters
   map:
     fields:
@@ -1864,12 +1548,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: pattern
       type:
         scalar: string
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.ResourceDetector
-  map:
-    fields:
-    - name: environmentResourceDetector
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.EnvironmentResourceDetectorConfig
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.ResponseFlagFilter
   map:
     fields:
@@ -1879,21 +1557,6 @@ var schemaYAML = typed.YAMLObject(`types:
           elementType:
             scalar: string
           elementRelationship: atomic
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.RetryPolicy
-  map:
-    fields:
-    - name: numRetries
-      type:
-        scalar: numeric
-    - name: retryBackOff
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.BackoffStrategy
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Sampler
-  map:
-    fields:
-    - name: alwaysOnConfig
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AlwaysOnConfig
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.SdsBootstrap
   map:
     fields:
@@ -2137,43 +1800,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: tokensPerFill
       type:
         scalar: numeric
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Tracing
-  map:
-    fields:
-    - name: attributes
-      type:
-        list:
-          elementType:
-            namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CustomAttribute
-          elementRelationship: atomic
-    - name: clientSampling
-      type:
-        scalar: numeric
-    - name: maxPathTagLength
-      type:
-        scalar: numeric
-    - name: overallSampling
-      type:
-        scalar: numeric
-    - name: provider
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.TracingProvider
-      default: {}
-    - name: randomSampling
-      type:
-        scalar: numeric
-    - name: spawnUpstreamSpan
-      type:
-        scalar: boolean
-    - name: verbose
-      type:
-        scalar: boolean
-- name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.TracingProvider
-  map:
-    fields:
-    - name: openTelemetry
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.OpenTelemetryTracingConfig
 - name: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.TrafficPolicy
   map:
     fields:
@@ -2201,9 +1827,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: ai
       type:
         namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.AIPolicy
-    - name: buffer
-      type:
-        namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.Buffer
     - name: cors
       type:
         namedType: com.github.kgateway-dev.kgateway.v2.api.v1alpha1.CorsPolicy
diff --git a/api/applyconfiguration/utils.go b/api/applyconfiguration/utils.go
index 84b0c33ee..407b61e5d 100644
--- a/api/applyconfiguration/utils.go
+++ b/api/applyconfiguration/utils.go
@@ -21,8 +21,6 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.AccessLogApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AccessLogFilter"):
 		return &apiv1alpha1.AccessLogFilterApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("AccessLogGrpcService"):
-		return &apiv1alpha1.AccessLogGrpcServiceApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AgentGateway"):
 		return &apiv1alpha1.AgentGatewayApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AIBackend"):
@@ -31,8 +29,6 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.AiExtensionApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AiExtensionStats"):
 		return &apiv1alpha1.AiExtensionStatsApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("AiExtensionTrace"):
-		return &apiv1alpha1.AiExtensionTraceApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AIPolicy"):
 		return &apiv1alpha1.AIPolicyApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AIPromptEnrichment"):
@@ -41,8 +37,6 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.AIPromptGuardApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AnthropicConfig"):
 		return &apiv1alpha1.AnthropicConfigApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("AnyValue"):
-		return &apiv1alpha1.AnyValueApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AuthHeaderOverride"):
 		return &apiv1alpha1.AuthHeaderOverrideApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("AwsAuth"):
@@ -63,36 +57,18 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.BackendSpecApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("BackendStatus"):
 		return &apiv1alpha1.BackendStatusApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("BackoffStrategy"):
-		return &apiv1alpha1.BackoffStrategyApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("BodyTransformation"):
 		return &apiv1alpha1.BodyTransformationApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("Buffer"):
-		return &apiv1alpha1.BufferApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("BufferSettings"):
 		return &apiv1alpha1.BufferSettingsApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("CELFilter"):
 		return &apiv1alpha1.CELFilterApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("CommonAccessLogGrpcService"):
-		return &apiv1alpha1.CommonAccessLogGrpcServiceApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("CommonGrpcService"):
-		return &apiv1alpha1.CommonGrpcServiceApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("CommonHttpProtocolOptions"):
 		return &apiv1alpha1.CommonHttpProtocolOptionsApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("CorsPolicy"):
 		return &apiv1alpha1.CorsPolicyApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("CSRFPolicy"):
 		return &apiv1alpha1.CSRFPolicyApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("CustomAttribute"):
-		return &apiv1alpha1.CustomAttributeApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("CustomAttributeEnvironment"):
-		return &apiv1alpha1.CustomAttributeEnvironmentApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("CustomAttributeHeader"):
-		return &apiv1alpha1.CustomAttributeHeaderApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("CustomAttributeLiteral"):
-		return &apiv1alpha1.CustomAttributeLiteralApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("CustomAttributeMetadata"):
-		return &apiv1alpha1.CustomAttributeMetadataApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("CustomLabel"):
 		return &apiv1alpha1.CustomLabelApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("CustomResponse"):
@@ -139,14 +115,14 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.GeminiConfigApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("GracefulShutdownSpec"):
 		return &apiv1alpha1.GracefulShutdownSpecApplyConfiguration{}
+	case v1alpha1.SchemeGroupVersion.WithKind("GrpcService"):
+		return &apiv1alpha1.GrpcServiceApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("GrpcStatusFilter"):
 		return &apiv1alpha1.GrpcStatusFilterApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("HeaderFilter"):
 		return &apiv1alpha1.HeaderFilterApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("HeaderTransformation"):
 		return &apiv1alpha1.HeaderTransformationApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("HeaderValue"):
-		return &apiv1alpha1.HeaderValueApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("HealthCheck"):
 		return &apiv1alpha1.HealthCheckApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("HealthCheckGrpc"):
@@ -169,10 +145,6 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.IstioContainerApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("IstioIntegration"):
 		return &apiv1alpha1.IstioIntegrationApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("KeyAnyValue"):
-		return &apiv1alpha1.KeyAnyValueApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("KeyAnyValueList"):
-		return &apiv1alpha1.KeyAnyValueListApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("KubernetesProxyConfig"):
 		return &apiv1alpha1.KubernetesProxyConfigApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("LLMProvider"):
@@ -195,22 +167,12 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.LocalRateLimitPolicyApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("Message"):
 		return &apiv1alpha1.MessageApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("MetadataKey"):
-		return &apiv1alpha1.MetadataKeyApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("MetadataPathSegment"):
-		return &apiv1alpha1.MetadataPathSegmentApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("Moderation"):
 		return &apiv1alpha1.ModerationApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("MultiPoolConfig"):
 		return &apiv1alpha1.MultiPoolConfigApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("OpenAIConfig"):
 		return &apiv1alpha1.OpenAIConfigApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("OpenTelemetryAccessLogService"):
-		return &apiv1alpha1.OpenTelemetryAccessLogServiceApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("OpenTelemetryTracingConfig"):
-		return &apiv1alpha1.OpenTelemetryTracingConfigApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("OTelTracesSampler"):
-		return &apiv1alpha1.OTelTracesSamplerApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("Parameters"):
 		return &apiv1alpha1.ParametersApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("PathOverride"):
@@ -245,14 +207,8 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.RegexApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("RegexMatch"):
 		return &apiv1alpha1.RegexMatchApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("ResourceDetector"):
-		return &apiv1alpha1.ResourceDetectorApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("ResponseFlagFilter"):
 		return &apiv1alpha1.ResponseFlagFilterApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("RetryPolicy"):
-		return &apiv1alpha1.RetryPolicyApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("Sampler"):
-		return &apiv1alpha1.SamplerApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("SdsBootstrap"):
 		return &apiv1alpha1.SdsBootstrapApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("SdsContainer"):
@@ -283,10 +239,6 @@ func ForKind(kind schema.GroupVersionKind) interface{} {
 		return &apiv1alpha1.TLSFilesApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("TokenBucket"):
 		return &apiv1alpha1.TokenBucketApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("Tracing"):
-		return &apiv1alpha1.TracingApplyConfiguration{}
-	case v1alpha1.SchemeGroupVersion.WithKind("TracingProvider"):
-		return &apiv1alpha1.TracingProviderApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("TrafficPolicy"):
 		return &apiv1alpha1.TrafficPolicyApplyConfiguration{}
 	case v1alpha1.SchemeGroupVersion.WithKind("TrafficPolicySpec"):
diff --git a/api/v1alpha1/backend_config_policy_types.go b/api/v1alpha1/backend_config_policy_types.go
index 66991c5b9..ca5ac0784 100644
--- a/api/v1alpha1/backend_config_policy_types.go
+++ b/api/v1alpha1/backend_config_policy_types.go
@@ -30,19 +30,16 @@ type BackendConfigPolicyList struct {
 }
 
 // BackendConfigPolicySpec defines the desired state of BackendConfigPolicy.
-//
 // +kubebuilder:validation:AtMostOneOf=http1ProtocolOptions;http2ProtocolOptions
 type BackendConfigPolicySpec struct {
 	// TargetRefs specifies the target references to attach the policy to.
 	// +optional
 	// +kubebuilder:validation:MinItems=1
 	// +kubebuilder:validation:MaxItems=16
-	// +kubebuilder:validation:XValidation:rule="self.all(r, (r.group == '' && r.kind == 'Service') || (r.group == 'gateway.kgateway.dev' && r.kind == 'Backend'))",message="TargetRefs must reference either a Kubernetes Service or a Backend API"
 	TargetRefs []LocalPolicyTargetReference `json:"targetRefs,omitempty"`
 
 	// TargetSelectors specifies the target selectors to select resources to attach the policy to.
 	// +optional
-	// +kubebuilder:validation:XValidation:rule="self.all(r, (r.group == '' && r.kind == 'Service') || (r.group == 'gateway.kgateway.dev' && r.kind == 'Backend'))",message="TargetSelectors must reference either a Kubernetes Service or a Backend API"
 	TargetSelectors []LocalPolicyTargetSelector `json:"targetSelectors,omitempty"`
 
 	// The timeout for new network connections to hosts in the cluster.
@@ -155,14 +152,12 @@ type Http2ProtocolOptions struct {
 	// Defaults to 268435456 (256 * 1024 * 1024).
 	// Values can be specified with units like "64Ki".
 	// +optional
-	// +kubebuilder:validation:XValidation:message="InitialStreamWindowSize must be between 65535 and 2147483647 bytes (inclusive)",rule="quantity(self).isGreaterThan(quantity('65534')) && quantity(self).isLessThan(quantity('2147483648'))"
 	InitialStreamWindowSize *resource.Quantity `json:"initialStreamWindowSize,omitempty"`
 
 	// InitialConnectionWindowSize is similar to InitialStreamWindowSize, but for the connection level.
 	// Same range and default value as InitialStreamWindowSize.
 	// Values can be specified with units like "64Ki".
 	// +optional
-	// +kubebuilder:validation:XValidation:message="InitialConnectionWindowSize must be between 65535 and 2147483647 bytes (inclusive)",rule="quantity(self).isGreaterThan(quantity('65534')) && quantity(self).isLessThan(quantity('2147483648'))"
 	InitialConnectionWindowSize *resource.Quantity `json:"initialConnectionWindowSize,omitempty"`
 
 	// The maximum number of concurrent streams that the connection can have.
diff --git a/api/v1alpha1/gateway_parameters_types.go b/api/v1alpha1/gateway_parameters_types.go
index c738650f0..c4a9fca43 100644
--- a/api/v1alpha1/gateway_parameters_types.go
+++ b/api/v1alpha1/gateway_parameters_types.go
@@ -3,7 +3,6 @@ package v1alpha1
 import (
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 )
 
 // +kubebuilder:rbac:groups=gateway.kgateway.dev,resources=gatewayparameters,verbs=get;list;watch
@@ -650,11 +649,6 @@ type AiExtension struct {
 	//       metadataKey: "principal:iss"
 	// ```
 	Stats *AiExtensionStats `json:"stats,omitempty"`
-
-	// Additional OTel tracing config for AI Extension.
-	//
-	// +optional
-	Tracing *AiExtensionTrace `json:"tracing,omitempty"`
 }
 
 func (in *AiExtension) GetEnabled() *bool {
@@ -706,13 +700,6 @@ func (in *AiExtension) GetStats() *AiExtensionStats {
 	return in.Stats
 }
 
-func (in *AiExtension) GetTracing() *AiExtensionTrace {
-	if in == nil {
-		return nil
-	}
-	return in.Tracing
-}
-
 type AiExtensionStats struct {
 	// Set of custom labels to be added to the request metrics.
 	// These will be added on each request which goes through the AI Extension.
@@ -784,213 +771,6 @@ func (in *CustomLabel) GetKeyDelimiter() *string {
 	return in.KeyDelimiter
 }
 
-// AiExtensionTrace defines the tracing configuration for the AI extension
-type AiExtensionTrace struct {
-	// EndPoint specifies the URL of the OTLP Exporter for traces.
-	// Example: "http://my-otel-collector.svc.cluster.local:4317"
-	// https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_endpoint
-	//
-	// +required
-	EndPoint gwv1.AbsoluteURI `json:"endpoint"`
-
-	// Sampler defines the sampling strategy for OpenTelemetry traces.
-	// Sampling helps in reducing the volume of trace data by selectively
-	// recording only a subset of traces.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler
-	//
-	// +optional
-	Sampler *OTelTracesSampler `json:"sampler,omitempty"`
-
-	// OTLPTimeout specifies timeout configurations for OTLP (OpenTelemetry Protocol) exports.
-	// It allows setting general and trace-specific timeouts for sending data.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_timeout
-	//
-	// +optional
-	Timeout *gwv1.Duration `json:"timeout,omitempty"`
-
-	// OTLPProtocol specifies the protocol to be used for OTLP exports.
-	// This determines how tracing data is serialized and transported (e.g., gRPC, HTTP/Protobuf).
-	// https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_protocol
-	//
-	// +optional
-	// +kubebuilder:validation:Enum=grpc;http/protobuf;http/json
-	Protocol *OTLPTracesProtocolType `json:"protocol,omitempty"`
-
-	// TransportSecurity controls the TLS (Transport Layer Security) settings when connecting
-	// to the tracing server. It determines whether certificate verification should be skipped.
-	//
-	// +optional
-	// +kubebuilder:validation:Enum=secure;insecure
-	TransportSecurity *OTLPTransportSecurityMode `json:"transportSecurity,omitempty"`
-}
-
-func (in *AiExtensionTrace) GetTimeout() *gwv1.Duration {
-	if in == nil {
-		return nil
-	}
-	return in.Timeout
-}
-
-// OTelTracesSamplerType defines the available OpenTelemetry trace sampler types.
-// These samplers determine which traces are recorded and exported.
-type OTelTracesSamplerType string
-
-const (
-	// OTelTracesSamplerAlwaysOn enables always-on sampling.
-	// All traces will be recorded and exported. Useful for development or low-traffic systems.
-	OTelTracesSamplerAlwaysOn OTelTracesSamplerType = "alwaysOn"
-
-	// OTelTracesSamplerAlwaysOff enables always-off sampling.
-	// No traces will be recorded or exported. Effectively disables tracing.
-	OTelTracesSamplerAlwaysOff OTelTracesSamplerType = "alwaysOff"
-
-	// OTelTracesSamplerTraceidratio enables trace ID ratio based sampling.
-	// Traces are sampled based on a configured probability derived from their trace ID.
-	OTelTracesSamplerTraceidratio OTelTracesSamplerType = "traceidratio"
-
-	// OTelTracesSamplerParentbasedAlwaysOn enables parent-based always-on sampling.
-	// If a parent span exists and is sampled, the child span is also sampled.
-	OTelTracesSamplerParentbasedAlwaysOn OTelTracesSamplerType = "parentbasedAlwaysOn"
-
-	// OTelTracesSamplerParentbasedAlwaysOff enables parent-based always-off sampling.
-	// If a parent span exists and is not sampled, the child span is also not sampled.
-	OTelTracesSamplerParentbasedAlwaysOff OTelTracesSamplerType = "parentbasedAlwaysOff"
-
-	// OTelTracesSamplerParentbasedTraceidratio enables parent-based trace ID ratio sampling.
-	// If a parent span exists and is sampled, the child span is also sampled.
-	OTelTracesSamplerParentbasedTraceidratio OTelTracesSamplerType = "parentbasedTraceidratio"
-)
-
-func (otelSamplerType OTelTracesSamplerType) String() string {
-	switch otelSamplerType {
-	case OTelTracesSamplerAlwaysOn:
-		return "alwaysOn"
-	case OTelTracesSamplerAlwaysOff:
-		return "alwaysOff"
-	case OTelTracesSamplerTraceidratio:
-		return "traceidratio"
-	case OTelTracesSamplerParentbasedAlwaysOn:
-		return "parentbasedAlwaysOn"
-	case OTelTracesSamplerParentbasedAlwaysOff:
-		return "parentbasedAlwaysOff"
-	case OTelTracesSamplerParentbasedTraceidratio:
-		return "parentbasedTraceidratio"
-	default:
-		return ""
-	}
-}
-
-// OTelTracesSampler defines the configuration for an OpenTelemetry trace sampler.
-// It combines the sampler type with any required arguments for that type.
-type OTelTracesSampler struct {
-	// SamplerType specifies the type of sampler to use (default value: "parentbased_always_on").
-	// Refer to OTelTracesSamplerType for available options.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler
-	//
-	//+optional
-	// +kubebuilder:validation:Enum=alwaysOn;alwaysOff;traceidratio;parentbasedAlwaysOn;parentbasedAlwaysOff;parentbasedTraceidratio
-	SamplerType *OTelTracesSamplerType `json:"type,omitempty"`
-	// SamplerArg provides an argument for the chosen sampler type.
-	// For "traceidratio" or "parentbased_traceidratio" samplers: Sampling probability, a number in the [0..1] range,
-	// e.g. 0.25. Default is 1.0 if unset.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler_arg
-	//
-	//+optional
-	// +kubebuilder:validation:Pattern=`^0(\.\d+)?|1(\.0+)?$`
-	SamplerArg *string `json:"arg,omitempty"`
-}
-
-func (in *AiExtensionTrace) GetSampler() *OTelTracesSampler {
-	if in == nil {
-		return nil
-	}
-	return in.Sampler
-}
-
-func (in *AiExtensionTrace) GetSamplerType() *string {
-	if in == nil || in.Sampler == nil || in.Sampler.SamplerType == nil {
-		return nil
-	}
-	value := in.Sampler.SamplerType.String()
-	return &value
-}
-
-func (in *AiExtensionTrace) GetSamplerArg() *string {
-	if in == nil || in.Sampler == nil {
-		return nil
-	}
-	return in.GetSampler().SamplerArg
-}
-
-// OTLPTracesProtocolType defines the supported protocols for OTLP exporter.
-type OTLPTracesProtocolType string
-
-const (
-	// OTLPTracesProtocolTypeGrpc specifies OTLP over gRPC protocol.
-	// This is typically the most efficient protocol for OpenTelemetry data transfer.
-	OTLPTracesProtocolTypeGrpc OTLPTracesProtocolType = "grpc"
-	// OTLPTracesProtocolTypeProtobuf specifies OTLP over HTTP with Protobuf serialization.
-	// Data is sent via HTTP POST requests with Protobuf message bodies.
-	OTLPTracesProtocolTypeProtobuf OTLPTracesProtocolType = "http/protobuf"
-	// OTLPTracesProtocolTypeJson specifies OTLP over HTTP with JSON serialization.
-	// Data is sent via HTTP POST requests with JSON message bodies.
-	OTLPTracesProtocolTypeJson OTLPTracesProtocolType = "http/json"
-)
-
-func (in *AiExtensionTrace) GetOTLPProtocolType() *string {
-	if in == nil || in.Protocol == nil {
-		return nil
-	}
-	value := in.Protocol.String()
-	return &value
-}
-
-func (otelProtocolType OTLPTracesProtocolType) String() string {
-	switch otelProtocolType {
-	case OTLPTracesProtocolTypeGrpc:
-		return "grpc"
-	case OTLPTracesProtocolTypeProtobuf:
-		return "http/protobuf"
-	case OTLPTracesProtocolTypeJson:
-		return "http/json"
-	default:
-		return ""
-	}
-}
-
-// OTLPTransportSecurityMode defines the transport security options for OTLP connections.
-type OTLPTransportSecurityMode string
-
-const (
-	// OTLPTransportSecuritySecure enables TLS (client transport security) for OTLP connections.
-	// This means the client will verify the server's certificate.
-	OTLPTransportSecuritySecure OTLPTransportSecurityMode = "secure"
-
-	// OTLPTransportSecurityInsecure disables TLS for OTLP connections,
-	// meaning certificate verification is skipped. This is generally not recommended
-	// for production environments due to security risks.
-	OTLPTransportSecurityInsecure OTLPTransportSecurityMode = "insecure"
-)
-
-func (otelTransportSecurityMode OTLPTransportSecurityMode) String() string {
-	switch otelTransportSecurityMode {
-	case OTLPTransportSecuritySecure:
-		return "secure"
-	case OTLPTransportSecurityInsecure:
-		return "insecure"
-	default:
-		return ""
-	}
-}
-
-func (in *AiExtensionTrace) GetTransportSecurityMode() *string {
-	if in == nil || in.TransportSecurity == nil {
-		return nil
-	}
-	value := in.TransportSecurity.String()
-	return &value
-}
-
 // AgentGateway configures the AgentGateway integration. If AgentGateway is enabled, Envoy
 type AgentGateway struct {
 	// Whether to enable the extension.
diff --git a/api/v1alpha1/http_listener_policy_types.go b/api/v1alpha1/http_listener_policy_types.go
index 4fecca46f..899d704c0 100644
--- a/api/v1alpha1/http_listener_policy_types.go
+++ b/api/v1alpha1/http_listener_policy_types.go
@@ -34,19 +34,16 @@ type HTTPListenerPolicyList struct {
 	Items           []HTTPListenerPolicy `json:"items"`
 }
 
-// HTTPListenerPolicySpec defines the desired state of a HTTP listener policy.
 type HTTPListenerPolicySpec struct {
 	// TargetRefs specifies the target resources by reference to attach the policy to.
 	// +optional
 	//
 	// +kubebuilder:validation:MinItems=1
 	// +kubebuilder:validation:MaxItems=16
-	// +kubebuilder:validation:XValidation:rule="self.all(r, r.kind == 'Gateway' && (!has(r.group) || r.group == 'gateway.networking.k8s.io'))",message="targetRefs may only reference Gateway resources"
 	TargetRefs []LocalPolicyTargetReference `json:"targetRefs,omitempty"`
 
 	// TargetSelectors specifies the target selectors to select resources to attach the policy to.
 	// +optional
-	// +kubebuilder:validation:XValidation:rule="self.all(r, r.kind == 'Gateway' && (!has(r.group) || r.group == 'gateway.networking.k8s.io'))",message="targetSelectors may only reference Gateway resources"
 	TargetSelectors []LocalPolicyTargetSelector `json:"targetSelectors,omitempty"`
 
 	// AccessLoggingConfig contains various settings for Envoy's access logging service.
@@ -56,11 +53,6 @@ type HTTPListenerPolicySpec struct {
 	// +kubebuilder:validation:MaxItems=16
 	AccessLog []AccessLog `json:"accessLog,omitempty"`
 
-	// Tracing contains various settings for Envoy's OpenTelemetry tracer.
-	// See here for more information: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/opentelemetry.proto.html
-	// +optional
-	Tracing *Tracing `json:"tracing,omitempty"`
-
 	// UpgradeConfig contains configuration for HTTP upgrades like WebSocket.
 	// See here for more information: https://www.envoyproxy.io/docs/envoy/v1.34.1/intro/arch_overview/http/upgrades.html
 	UpgradeConfig *UpgradeConfig `json:"upgradeConfig,omitempty"`
@@ -96,10 +88,7 @@ type AccessLog struct {
 	FileSink *FileSink `json:"fileSink,omitempty"`
 
 	// Send access logs to gRPC service
-	GrpcService *AccessLogGrpcService `json:"grpcService,omitempty"`
-
-	// Send access logs to an OTel collector
-	OpenTelemetry *OpenTelemetryAccessLogService `json:"openTelemetry,omitempty"`
+	GrpcService *GrpcService `json:"grpcService,omitempty"`
 
 	// Filter access logs configuration
 	Filter *AccessLogFilter `json:"filter,omitempty"`
@@ -119,10 +108,15 @@ type FileSink struct {
 	JsonFormat *runtime.RawExtension `json:"jsonFormat,omitempty"`
 }
 
-// AccessLogGrpcService represents the gRPC service configuration for access logs.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/grpc/v3/als.proto#envoy-v3-api-msg-extensions-access-loggers-grpc-v3-httpgrpcaccesslogconfig
-type AccessLogGrpcService struct {
-	CommonAccessLogGrpcService `json:",inline"`
+// GrpcService represents the gRPC service configuration for access logs.
+type GrpcService struct {
+	// name of log stream
+	// +required
+	LogName string `json:"logName"`
+
+	// The backend gRPC service. Can be any type of supported backend (Kubernetes Service, kgateway Backend, etc..)
+	// +required
+	BackendRef *gwv1.BackendRef `json:"backendRef"`
 
 	// Additional request headers to log in the access log
 	AdditionalRequestHeadersToLog []string `json:"additionalRequestHeadersToLog,omitempty"`
@@ -134,142 +128,6 @@ type AccessLogGrpcService struct {
 	AdditionalResponseTrailersToLog []string `json:"additionalResponseTrailersToLog,omitempty"`
 }
 
-// Common configuration for gRPC access logs.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/grpc/v3/als.proto#envoy-v3-api-msg-extensions-access-loggers-grpc-v3-commongrpcaccesslogconfig
-type CommonAccessLogGrpcService struct {
-	CommonGrpcService `json:",inline"`
-
-	// name of log stream
-	// +kubebuilder:validation:Required
-	LogName string `json:"logName"`
-}
-
-// Common gRPC service configuration created by setting `envoy_grpcâ€œ as the gRPC client
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/grpc_service.proto#envoy-v3-api-msg-config-core-v3-grpcservice
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/grpc_service.proto#envoy-v3-api-msg-config-core-v3-grpcservice-envoygrpc
-type CommonGrpcService struct {
-	// The backend gRPC service. Can be any type of supported backend (Kubernetes Service, kgateway Backend, etc..)
-	// +kubebuilder:validation:Required
-	BackendRef *gwv1.BackendRef `json:"backendRef"`
-
-	// The :authority header in the grpc request. If this field is not set, the authority header value will be cluster_name.
-	// Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster.
-	// +kubebuilder:validation:Optional
-	Authority *string `json:"authority,omitempty"`
-
-	// Maximum gRPC message size that is allowed to be received. If a message over this limit is received, the gRPC stream is terminated with the RESOURCE_EXHAUSTED error.
-	// Defaults to 0, which means unlimited.
-	// +kubebuilder:validation:Optional
-	MaxReceiveMessageLength *uint32 `json:"maxReceiveMessageLength,omitempty"`
-
-	// This provides gRPC client level control over envoy generated headers. If false, the header will be sent but it can be overridden by per stream option. If true, the header will be removed and can not be overridden by per stream option. Default to false.
-	// +kubebuilder:validation:Optional
-	SkipEnvoyHeaders *bool `json:"skipEnvoyHeaders,omitempty"`
-
-	// The timeout for the gRPC request. This is the timeout for a specific request
-	// +kubebuilder:validation:Optional
-	Timeout *metav1.Duration `json:"timeout,omitempty"`
-
-	// Additional metadata to include in streams initiated to the GrpcService.
-	// This can be used for scenarios in which additional ad hoc authorization headers (e.g. x-foo-bar: baz-key) are to be injected
-	// +kubebuilder:validation:Optional
-	InitialMetadata []HeaderValue `json:"initialMetadata,omitempty"`
-
-	// Indicates the retry policy for re-establishing the gRPC stream.
-	// If max interval is not provided, it will be set to ten times the provided base interval
-	// +kubebuilder:validation:Optional
-	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`
-}
-
-// Header name/value pair.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-headervalue
-type HeaderValue struct {
-	// Header name.
-	// +kubebuilder:validation:Required
-	Key string `json:"key"`
-
-	// Header value.
-	// +kubebuilder:validation:Optional
-	Value string `json:"value,omitempty"`
-}
-
-// Specifies the retry policy of remote data source when fetching fails.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-retrypolicy
-type RetryPolicy struct {
-	// Specifies parameters that control retry backoff strategy.
-	// the default base interval is 1000 milliseconds and the default maximum interval is 10 times the base interval.
-	// +kubebuilder:validation:Optional
-	RetryBackOff *BackoffStrategy `json:"retryBackOff,omitempty"`
-
-	// Specifies the allowed number of retries. Defaults to 1.
-	// +kubebuilder:validation:Optional
-	NumRetries *uint32 `json:"numRetries,omitempty"`
-}
-
-// Configuration defining a jittered exponential back off strategy.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/backoff.proto#envoy-v3-api-msg-config-core-v3-backoffstrategy
-type BackoffStrategy struct {
-	// The base interval to be used for the next back off computation. It should be greater than zero and less than or equal to max_interval.
-	// +kubebuilder:validation:Required
-	BaseInterval metav1.Duration `json:"baseInterval"`
-
-	// Specifies the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set. The default is 10 times the base_interval.
-	// +kubebuilder:validation:Optional
-	MaxInterval *metav1.Duration `json:"maxInterval,omitempty"`
-}
-
-// OpenTelemetryAccessLogService represents the OTel configuration for access logs.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/open_telemetry/v3/logs_service.proto
-type OpenTelemetryAccessLogService struct {
-	// Send access logs to gRPC service
-	// +kubebuilder:validation:Required
-	GrpcService CommonAccessLogGrpcService `json:"grpcService"`
-
-	// OpenTelemetry LogResource fields, following Envoy access logging formatting.
-	// +kubebuilder:validation:Optional
-	Body *string `json:"body,omitempty"`
-
-	// If specified, Envoy will not generate built-in resource labels like log_name, zone_name, cluster_name, node_name.
-	// +kubebuilder:validation:Optional
-	DisableBuiltinLabels *bool `json:"disableBuiltinLabels,omitempty"`
-
-	// Additional attributes that describe the specific event occurrence.
-	// +kubebuilder:validation:Optional
-	Attributes *KeyAnyValueList `json:"attributes,omitempty"`
-}
-
-// A list of key-value pair that is used to store Span attributes, Link attributes, etc.
-type KeyAnyValueList struct {
-	// A collection of key/value pairs of key-value pairs.
-	// +kubebuilder:validation:items:Type=object
-	Values []KeyAnyValue `json:"values,omitempty"`
-}
-
-// KeyValue is a key-value pair that is used to store Span attributes, Link attributes, etc.
-type KeyAnyValue struct {
-	// Attribute keys must be unique
-	// +kubebuilder:validation:Required
-	Key string `json:"key"`
-	// Value may contain a primitive value such as a string or integer or it may contain an arbitrary nested object containing arrays, key-value lists and primitives.
-	// +kubebuilder:validation:Required
-	Value AnyValue `json:"value"`
-}
-
-// AnyValue is used to represent any type of attribute value. AnyValue may contain a primitive value such as a string or integer or it may contain an arbitrary nested object containing arrays, key-value lists and primitives.
-// This is limited to string and nested values as OTel only supports them
-// +kubebuilder:validation:MaxProperties=1
-// +kubebuilder:validation:MinProperties=1
-type AnyValue struct {
-	StringValue *string `json:"stringValue,omitempty"`
-	// TODO: Add support for ArrayValue && KvListValue
-	// +kubebuilder:validation:items:Type=object
-	// +kubebuilder:validation:items:XPreserveUnknownFields
-	ArrayValue []AnyValue `json:"arrayValue,omitempty"`
-	// +kubebuilder:validation:Type=object
-	// +kubebuilder:validation:XPreserveUnknownFields
-	KvListValue *KeyAnyValueList `json:"kvListValue,omitempty"`
-}
-
 // AccessLogFilter represents the top-level filter structure.
 // Based on: https://www.envoyproxy.io/docs/envoy/v1.33.0/api-v3/config/accesslog/v3/accesslog.proto#config-accesslog-v3-accesslogfilter
 // +kubebuilder:validation:MaxProperties=1
@@ -384,209 +242,6 @@ type GrpcStatusFilter struct {
 	Exclude  bool         `json:"exclude,omitempty"`
 }
 
-// Tracing represents the top-level Envoy's tracer.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-tracing
-type Tracing struct {
-	// Provider defines the upstream to which envoy sends traces
-	// +kubebuilder:validation:Required
-	Provider TracingProvider `json:"provider"`
-
-	// Target percentage of requests managed by this HTTP connection manager that will be force traced if the x-client-trace-id header is set. Defaults to 100%
-	// +kubebuilder:validation:Optional
-	// +kubebuilder:validation:Minimum=0
-	// +kubebuilder:validation:Maximum=100
-	ClientSampling *uint32 `json:"clientSampling,omitempty"`
-
-	// Target percentage of requests managed by this HTTP connection manager that will be randomly selected for trace generation, if not requested by the client or not forced. Defaults to 100%
-	// +kubebuilder:validation:Optional
-	// +kubebuilder:validation:Minimum=0
-	// +kubebuilder:validation:Maximum=100
-	RandomSampling *uint32 `json:"randomSampling,omitempty"`
-
-	// Target percentage of requests managed by this HTTP connection manager that will be traced after all other sampling checks have been applied (client-directed, force tracing, random sampling). Defaults to 100%
-	// +kubebuilder:validation:Optional
-	// +kubebuilder:validation:Minimum=0
-	// +kubebuilder:validation:Maximum=100
-	OverallSampling *uint32 `json:"overallSampling,omitempty"`
-
-	// Whether to annotate spans with additional data. If true, spans will include logs for stream events. Defaults to false
-	// +kubebuilder:validation:Optional
-	Verbose *bool `json:"verbose,omitempty"`
-
-	// Maximum length of the request path to extract and include in the HttpUrl tag. Used to truncate lengthy request paths to meet the needs of a tracing backend. Default: 256
-	// +kubebuilder:validation:Optional
-	MaxPathTagLength *uint32 `json:"maxPathTagLength,omitempty"`
-
-	// A list of attributes with a unique name to create attributes for the active span.
-	// +kubebuilder:validation:Optional
-	Attributes []CustomAttribute `json:"attributes,omitempty"`
-
-	// Create separate tracing span for each upstream request if true. Defaults to false
-	// Link to envoy docs for more info
-	// +kubebuilder:validation:Optional
-	SpawnUpstreamSpan *bool `json:"spawnUpstreamSpan,omitempty"`
-}
-
-// Describes attributes for the active span.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#envoy-v3-api-msg-type-tracing-v3-customtag
-// +kubebuilder:validation:MaxProperties=2
-// +kubebuilder:validation:MinProperties=1
-type CustomAttribute struct {
-	// The name of the attribute
-	// +kubebuilder:validation:Required
-	Name string `json:"name"`
-
-	// A literal attribute value.
-	// +kubebuilder:validation:Optional
-	Literal *CustomAttributeLiteral `json:"literal,omitempty"`
-
-	// An environment attribute value.
-	// +kubebuilder:validation:Optional
-	Environment *CustomAttributeEnvironment `json:"environment,omitempty"`
-
-	// A request header attribute value.
-	// +kubebuilder:validation:Optional
-	RequestHeader *CustomAttributeHeader `json:"requestHeader,omitempty"`
-
-	// An attribute to obtain the value from the metadata.
-	// +kubebuilder:validation:Optional
-	Metadata *CustomAttributeMetadata `json:"metadata,omitempty"`
-}
-
-// Literal type attribute with a static value.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-literal
-type CustomAttributeLiteral struct {
-	// Static literal value to populate the attribute value.
-	// +kubebuilder:validation:Required
-	Value string `json:"value"`
-}
-
-// Environment type attribute with environment name and default value.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-environment
-type CustomAttributeEnvironment struct {
-	// Environment variable name to obtain the value to populate the attribute value.
-	// +kubebuilder:validation:Required
-	Name string `json:"name"`
-
-	// When the environment variable is not found, the attribute value will be populated with this default value if specified,
-	// otherwise no attribute will be populated.
-	// +kubebuilder:validation:Optional
-	DefaultValue *string `json:"defaultValue,omitempty"`
-}
-
-// Header type attribute with header name and default value.
-// https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-header
-type CustomAttributeHeader struct {
-	// Header name to obtain the value to populate the attribute value.
-	// +kubebuilder:validation:Required
-	Name string `json:"name"`
-
-	// When the header does not exist, the attribute value will be populated with this default value if specified,
-	// otherwise no attribute will be populated.
-	// +kubebuilder:validation:Optional
-	DefaultValue *string `json:"defaultValue,omitempty"`
-}
-
-// Metadata type attribute using MetadataKey to retrieve the protobuf value from Metadata, and populate the attribute value with the canonical JSON representation of it.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-metadata
-type CustomAttributeMetadata struct {
-	// Specify what kind of metadata to obtain attribute value from
-	// +kubebuilder:validation:Required
-	Kind MetadataKind `json:"kind"`
-
-	// Metadata key to define the path to retrieve the attribute value.
-	// +kubebuilder:validation:Required
-	MetadataKey MetadataKey `json:"metadataKey"`
-
-	// When no valid metadata is found, the attribute value would be populated with this default value if specified, otherwise no attribute would be populated.
-	// +kubebuilder:validation:Optional
-	DefaultValue *string `json:"defaultValue,omitempty"`
-}
-
-// Describes different types of metadata sources.
-// Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/metadata/v3/metadata.proto#envoy-v3-api-msg-type-metadata-v3-metadatakind-request
-// +kubebuilder:validation:Enum=Request;Route;Cluster;Host
-type MetadataKind string
-
-const (
-	// Request kind of metadata.
-	MetadataKindRequest MetadataKind = "Request"
-	// Route kind of metadata.
-	MetadataKindRoute MetadataKind = "Route"
-	// Cluster kind of metadata.
-	MetadataKindCluster MetadataKind = "Cluster"
-	// Host kind of metadata.
-	MetadataKindHost MetadataKind = "Host"
-)
-
-// MetadataKey provides a way to retrieve values from Metadata using a key and a path.
-type MetadataKey struct {
-	// The key name of the Metadata from which to retrieve the Struct
-	// +kubebuilder:validation:Required
-	Key string `json:"key"`
-
-	// The path used to retrieve a specific Value from the Struct. This can be either a prefix or a full path,
-	// depending on the use case
-	// +kubebuilder:validation:Required
-	Path []MetadataPathSegment `json:"path"`
-}
-
-// Specifies a segment in a path for retrieving values from Metadata.
-type MetadataPathSegment struct {
-	// The key used to retrieve the value in the struct
-	// +kubebuilder:validation:Required
-	Key string `json:"key"`
-}
-
-// TracingProvider defines the list of providers for tracing
-// +kubebuilder:validation:MaxProperties=1
-// +kubebuilder:validation:MinProperties=1
-type TracingProvider struct {
-	// Tracing contains various settings for Envoy's OTel tracer.
-	OpenTelemetry *OpenTelemetryTracingConfig `json:"openTelemetry,omitempty"`
-}
-
-// OpenTelemetryTracingConfig represents the top-level Envoy's OpenTelemetry tracer.
-// See here for more information: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/opentelemetry.proto.html
-type OpenTelemetryTracingConfig struct {
-	// Send traces to the gRPC service
-	// +kubebuilder:validation:Required
-	GrpcService CommonGrpcService `json:"grpcService"`
-
-	// The name for the service. This will be populated in the ResourceSpan Resource attributes
-	// +kubebuilder:validation:Required
-	ServiceName string `json:"serviceName"`
-
-	// An ordered list of resource detectors. Currently supported values are `EnvironmentResourceDetector`
-	// +kubebuilder:validation:Optional
-	ResourceDetectors []ResourceDetector `json:"resourceDetectors,omitempty"`
-
-	// Specifies the sampler to be used by the OpenTelemetry tracer. This field can be left empty. In this case, the default Envoy sampling decision is used.
-	// Currently supported values are `AlwaysOn`
-	// +kubebuilder:validation:Optional
-	Sampler *Sampler `json:"sampler,omitempty"`
-}
-
-// ResourceDetector defines the list of supported ResourceDetectors
-// +kubebuilder:validation:MaxProperties=1
-// +kubebuilder:validation:MinProperties=1
-type ResourceDetector struct {
-	EnvironmentResourceDetector *EnvironmentResourceDetectorConfig `json:"environmentResourceDetector,omitempty"`
-}
-
-// EnvironmentResourceDetectorConfig specified the EnvironmentResourceDetector
-type EnvironmentResourceDetectorConfig struct{}
-
-// Sampler defines the list of supported Samplers
-// +kubebuilder:validation:MaxProperties=1
-// +kubebuilder:validation:MinProperties=1
-type Sampler struct {
-	AlwaysOn *AlwaysOnConfig `json:"alwaysOnConfig,omitempty"`
-}
-
-// AlwaysOnConfig specified the AlwaysOn samplerc
-type AlwaysOnConfig struct{}
-
 // GrpcStatus represents possible gRPC statuses.
 // +kubebuilder:validation:Enum=OK;CANCELED;UNKNOWN;INVALID_ARGUMENT;DEADLINE_EXCEEDED;NOT_FOUND;ALREADY_EXISTS;PERMISSION_DENIED;RESOURCE_EXHAUSTED;FAILED_PRECONDITION;ABORTED;OUT_OF_RANGE;UNIMPLEMENTED;INTERNAL;UNAVAILABLE;DATA_LOSS;UNAUTHENTICATED
 type GrpcStatus string
diff --git a/api/v1alpha1/traffic_policy_types.go b/api/v1alpha1/traffic_policy_types.go
index da3bebd05..aae54f47f 100644
--- a/api/v1alpha1/traffic_policy_types.go
+++ b/api/v1alpha1/traffic_policy_types.go
@@ -2,7 +2,6 @@ package v1alpha1
 
 import (
 	corev1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/api/resource"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gwv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
@@ -35,19 +34,16 @@ type TrafficPolicyList struct {
 	Items           []TrafficPolicy `json:"items"`
 }
 
-// TrafficPolicySpec defines the desired state of a traffic policy.
 type TrafficPolicySpec struct {
 	// TargetRefs specifies the target resources by reference to attach the policy to.
 	// +optional
 	//
 	// +kubebuilder:validation:MinItems=1
 	// +kubebuilder:validation:MaxItems=16
-	// +kubebuilder:validation:XValidation:rule="self.all(r, (r.kind == 'Gateway' || r.kind == 'HTTPRoute' || (r.kind == 'XListenerSet' && r.group == 'gateway.networking.x-k8s.io')) && (!has(r.group) || r.group == 'gateway.networking.k8s.io' || r.group == 'gateway.networking.x-k8s.io'))",message="targetRefs may only reference Gateway, HTTPRoute, or XListenerSet resources"
 	TargetRefs []LocalPolicyTargetReferenceWithSectionName `json:"targetRefs,omitempty"`
 
 	// TargetSelectors specifies the target selectors to select resources to attach the policy to.
 	// +optional
-	// +kubebuilder:validation:XValidation:rule="self.all(r, (r.kind == 'Gateway' || r.kind == 'HTTPRoute' || (r.kind == 'XListenerSet' && r.group == 'gateway.networking.x-k8s.io')) && (!has(r.group) || r.group == 'gateway.networking.k8s.io' || r.group == 'gateway.networking.x-k8s.io'))",message="targetSelectors may only reference Gateway, HTTPRoute, or XListenerSet resources"
 	TargetSelectors []LocalPolicyTargetSelector `json:"targetSelectors,omitempty"`
 
 	// AI is used to configure AI-based policies for the policy.
@@ -80,11 +76,6 @@ type TrafficPolicySpec struct {
 	// Csrf specifies the Cross-Site Request Forgery (CSRF) policy for this traffic policy.
 	// +optional
 	Csrf *CSRFPolicy `json:"csrf,omitempty"`
-
-	// Buffer can be used to set the maximum request size that will be buffered.
-	// Requests exceeding this size will return a 413 response.
-	// +optional
-	Buffer *Buffer `json:"buffer,omitempty"`
 }
 
 // TransformationPolicy config is used to modify envoy behavior at a route level.
@@ -271,7 +262,6 @@ type TokenBucket struct {
 	// This controls the steady-state rate of token generation.
 	// +optional
 	// +kubebuilder:default=1
-	// +kubebuilder:validation:Minimum=1
 	TokensPerFill *uint32 `json:"tokensPerFill,omitempty"`
 
 	// FillInterval defines the time duration between consecutive token fills.
@@ -381,12 +371,3 @@ type CSRFPolicy struct {
 	// +kubebuilder:validation:MaxItems=16
 	AdditionalOrigins []*StringMatcher `json:"additionalOrigins,omitempty"`
 }
-
-type Buffer struct {
-	// MaxRequestSize sets the maximum size in bytes of a message body to buffer.
-	// Requests exceeding this size will receive HTTP 413.
-	// Example format: "1Mi", "512Ki", "1Gi"
-	// +required
-	// +kubebuilder:validation:XValidation:message="maxRequestSize must be greater than 0 and less than 4Gi",rule="quantity(self).isGreaterThan(quantity('0')) && quantity(self).isLessThan(quantity('4Gi'))"
-	MaxRequestSize *resource.Quantity `json:"maxRequestSize"`
-}
diff --git a/api/v1alpha1/zz_generated.deepcopy.go b/api/v1alpha1/zz_generated.deepcopy.go
index 0d16bf012..cfb65e90c 100644
--- a/api/v1alpha1/zz_generated.deepcopy.go
+++ b/api/v1alpha1/zz_generated.deepcopy.go
@@ -133,12 +133,7 @@ func (in *AccessLog) DeepCopyInto(out *AccessLog) {
 	}
 	if in.GrpcService != nil {
 		in, out := &in.GrpcService, &out.GrpcService
-		*out = new(AccessLogGrpcService)
-		(*in).DeepCopyInto(*out)
-	}
-	if in.OpenTelemetry != nil {
-		in, out := &in.OpenTelemetry, &out.OpenTelemetry
-		*out = new(OpenTelemetryAccessLogService)
+		*out = new(GrpcService)
 		(*in).DeepCopyInto(*out)
 	}
 	if in.Filter != nil {
@@ -192,37 +187,6 @@ func (in *AccessLogFilter) DeepCopy() *AccessLogFilter {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *AccessLogGrpcService) DeepCopyInto(out *AccessLogGrpcService) {
-	*out = *in
-	in.CommonAccessLogGrpcService.DeepCopyInto(&out.CommonAccessLogGrpcService)
-	if in.AdditionalRequestHeadersToLog != nil {
-		in, out := &in.AdditionalRequestHeadersToLog, &out.AdditionalRequestHeadersToLog
-		*out = make([]string, len(*in))
-		copy(*out, *in)
-	}
-	if in.AdditionalResponseHeadersToLog != nil {
-		in, out := &in.AdditionalResponseHeadersToLog, &out.AdditionalResponseHeadersToLog
-		*out = make([]string, len(*in))
-		copy(*out, *in)
-	}
-	if in.AdditionalResponseTrailersToLog != nil {
-		in, out := &in.AdditionalResponseTrailersToLog, &out.AdditionalResponseTrailersToLog
-		*out = make([]string, len(*in))
-		copy(*out, *in)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AccessLogGrpcService.
-func (in *AccessLogGrpcService) DeepCopy() *AccessLogGrpcService {
-	if in == nil {
-		return nil
-	}
-	out := new(AccessLogGrpcService)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *AgentGateway) DeepCopyInto(out *AgentGateway) {
 	*out = *in
@@ -310,11 +274,6 @@ func (in *AiExtension) DeepCopyInto(out *AiExtension) {
 		*out = new(AiExtensionStats)
 		(*in).DeepCopyInto(*out)
 	}
-	if in.Tracing != nil {
-		in, out := &in.Tracing, &out.Tracing
-		*out = new(AiExtensionTrace)
-		(*in).DeepCopyInto(*out)
-	}
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AiExtension.
@@ -353,56 +312,6 @@ func (in *AiExtensionStats) DeepCopy() *AiExtensionStats {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *AiExtensionTrace) DeepCopyInto(out *AiExtensionTrace) {
-	*out = *in
-	if in.Sampler != nil {
-		in, out := &in.Sampler, &out.Sampler
-		*out = new(OTelTracesSampler)
-		(*in).DeepCopyInto(*out)
-	}
-	if in.Timeout != nil {
-		in, out := &in.Timeout, &out.Timeout
-		*out = new(apisv1.Duration)
-		**out = **in
-	}
-	if in.Protocol != nil {
-		in, out := &in.Protocol, &out.Protocol
-		*out = new(OTLPTracesProtocolType)
-		**out = **in
-	}
-	if in.TransportSecurity != nil {
-		in, out := &in.TransportSecurity, &out.TransportSecurity
-		*out = new(OTLPTransportSecurityMode)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AiExtensionTrace.
-func (in *AiExtensionTrace) DeepCopy() *AiExtensionTrace {
-	if in == nil {
-		return nil
-	}
-	out := new(AiExtensionTrace)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *AlwaysOnConfig) DeepCopyInto(out *AlwaysOnConfig) {
-	*out = *in
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlwaysOnConfig.
-func (in *AlwaysOnConfig) DeepCopy() *AlwaysOnConfig {
-	if in == nil {
-		return nil
-	}
-	out := new(AlwaysOnConfig)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *AnthropicConfig) DeepCopyInto(out *AnthropicConfig) {
 	*out = *in
@@ -424,38 +333,6 @@ func (in *AnthropicConfig) DeepCopy() *AnthropicConfig {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *AnyValue) DeepCopyInto(out *AnyValue) {
-	*out = *in
-	if in.StringValue != nil {
-		in, out := &in.StringValue, &out.StringValue
-		*out = new(string)
-		**out = **in
-	}
-	if in.ArrayValue != nil {
-		in, out := &in.ArrayValue, &out.ArrayValue
-		*out = make([]AnyValue, len(*in))
-		for i := range *in {
-			(*in)[i].DeepCopyInto(&(*out)[i])
-		}
-	}
-	if in.KvListValue != nil {
-		in, out := &in.KvListValue, &out.KvListValue
-		*out = new(KeyAnyValueList)
-		(*in).DeepCopyInto(*out)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnyValue.
-func (in *AnyValue) DeepCopy() *AnyValue {
-	if in == nil {
-		return nil
-	}
-	out := new(AnyValue)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *AuthHeaderOverride) DeepCopyInto(out *AuthHeaderOverride) {
 	*out = *in
@@ -805,27 +682,6 @@ func (in *BackendStatus) DeepCopy() *BackendStatus {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *BackoffStrategy) DeepCopyInto(out *BackoffStrategy) {
-	*out = *in
-	out.BaseInterval = in.BaseInterval
-	if in.MaxInterval != nil {
-		in, out := &in.MaxInterval, &out.MaxInterval
-		*out = new(metav1.Duration)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackoffStrategy.
-func (in *BackoffStrategy) DeepCopy() *BackoffStrategy {
-	if in == nil {
-		return nil
-	}
-	out := new(BackoffStrategy)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *BodyTransformation) DeepCopyInto(out *BodyTransformation) {
 	*out = *in
@@ -846,26 +702,6 @@ func (in *BodyTransformation) DeepCopy() *BodyTransformation {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *Buffer) DeepCopyInto(out *Buffer) {
-	*out = *in
-	if in.MaxRequestSize != nil {
-		in, out := &in.MaxRequestSize, &out.MaxRequestSize
-		x := (*in).DeepCopy()
-		*out = &x
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Buffer.
-func (in *Buffer) DeepCopy() *Buffer {
-	if in == nil {
-		return nil
-	}
-	out := new(Buffer)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *BufferSettings) DeepCopyInto(out *BufferSettings) {
 	*out = *in
@@ -942,72 +778,6 @@ func (in *CSRFPolicy) DeepCopy() *CSRFPolicy {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *CommonAccessLogGrpcService) DeepCopyInto(out *CommonAccessLogGrpcService) {
-	*out = *in
-	in.CommonGrpcService.DeepCopyInto(&out.CommonGrpcService)
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CommonAccessLogGrpcService.
-func (in *CommonAccessLogGrpcService) DeepCopy() *CommonAccessLogGrpcService {
-	if in == nil {
-		return nil
-	}
-	out := new(CommonAccessLogGrpcService)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *CommonGrpcService) DeepCopyInto(out *CommonGrpcService) {
-	*out = *in
-	if in.BackendRef != nil {
-		in, out := &in.BackendRef, &out.BackendRef
-		*out = new(apisv1.BackendRef)
-		(*in).DeepCopyInto(*out)
-	}
-	if in.Authority != nil {
-		in, out := &in.Authority, &out.Authority
-		*out = new(string)
-		**out = **in
-	}
-	if in.MaxReceiveMessageLength != nil {
-		in, out := &in.MaxReceiveMessageLength, &out.MaxReceiveMessageLength
-		*out = new(uint32)
-		**out = **in
-	}
-	if in.SkipEnvoyHeaders != nil {
-		in, out := &in.SkipEnvoyHeaders, &out.SkipEnvoyHeaders
-		*out = new(bool)
-		**out = **in
-	}
-	if in.Timeout != nil {
-		in, out := &in.Timeout, &out.Timeout
-		*out = new(metav1.Duration)
-		**out = **in
-	}
-	if in.InitialMetadata != nil {
-		in, out := &in.InitialMetadata, &out.InitialMetadata
-		*out = make([]HeaderValue, len(*in))
-		copy(*out, *in)
-	}
-	if in.RetryPolicy != nil {
-		in, out := &in.RetryPolicy, &out.RetryPolicy
-		*out = new(RetryPolicy)
-		(*in).DeepCopyInto(*out)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CommonGrpcService.
-func (in *CommonGrpcService) DeepCopy() *CommonGrpcService {
-	if in == nil {
-		return nil
-	}
-	out := new(CommonGrpcService)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *CommonHttpProtocolOptions) DeepCopyInto(out *CommonHttpProtocolOptions) {
 	*out = *in
@@ -1078,117 +848,6 @@ func (in *CorsPolicy) DeepCopy() *CorsPolicy {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *CustomAttribute) DeepCopyInto(out *CustomAttribute) {
-	*out = *in
-	if in.Literal != nil {
-		in, out := &in.Literal, &out.Literal
-		*out = new(CustomAttributeLiteral)
-		**out = **in
-	}
-	if in.Environment != nil {
-		in, out := &in.Environment, &out.Environment
-		*out = new(CustomAttributeEnvironment)
-		(*in).DeepCopyInto(*out)
-	}
-	if in.RequestHeader != nil {
-		in, out := &in.RequestHeader, &out.RequestHeader
-		*out = new(CustomAttributeHeader)
-		(*in).DeepCopyInto(*out)
-	}
-	if in.Metadata != nil {
-		in, out := &in.Metadata, &out.Metadata
-		*out = new(CustomAttributeMetadata)
-		(*in).DeepCopyInto(*out)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CustomAttribute.
-func (in *CustomAttribute) DeepCopy() *CustomAttribute {
-	if in == nil {
-		return nil
-	}
-	out := new(CustomAttribute)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *CustomAttributeEnvironment) DeepCopyInto(out *CustomAttributeEnvironment) {
-	*out = *in
-	if in.DefaultValue != nil {
-		in, out := &in.DefaultValue, &out.DefaultValue
-		*out = new(string)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CustomAttributeEnvironment.
-func (in *CustomAttributeEnvironment) DeepCopy() *CustomAttributeEnvironment {
-	if in == nil {
-		return nil
-	}
-	out := new(CustomAttributeEnvironment)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *CustomAttributeHeader) DeepCopyInto(out *CustomAttributeHeader) {
-	*out = *in
-	if in.DefaultValue != nil {
-		in, out := &in.DefaultValue, &out.DefaultValue
-		*out = new(string)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CustomAttributeHeader.
-func (in *CustomAttributeHeader) DeepCopy() *CustomAttributeHeader {
-	if in == nil {
-		return nil
-	}
-	out := new(CustomAttributeHeader)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *CustomAttributeLiteral) DeepCopyInto(out *CustomAttributeLiteral) {
-	*out = *in
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CustomAttributeLiteral.
-func (in *CustomAttributeLiteral) DeepCopy() *CustomAttributeLiteral {
-	if in == nil {
-		return nil
-	}
-	out := new(CustomAttributeLiteral)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *CustomAttributeMetadata) DeepCopyInto(out *CustomAttributeMetadata) {
-	*out = *in
-	in.MetadataKey.DeepCopyInto(&out.MetadataKey)
-	if in.DefaultValue != nil {
-		in, out := &in.DefaultValue, &out.DefaultValue
-		*out = new(string)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CustomAttributeMetadata.
-func (in *CustomAttributeMetadata) DeepCopy() *CustomAttributeMetadata {
-	if in == nil {
-		return nil
-	}
-	out := new(CustomAttributeMetadata)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *CustomLabel) DeepCopyInto(out *CustomLabel) {
 	*out = *in
@@ -1358,21 +1017,6 @@ func (in *DynamicForwardProxyBackend) DeepCopy() *DynamicForwardProxyBackend {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *EnvironmentResourceDetectorConfig) DeepCopyInto(out *EnvironmentResourceDetectorConfig) {
-	*out = *in
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EnvironmentResourceDetectorConfig.
-func (in *EnvironmentResourceDetectorConfig) DeepCopy() *EnvironmentResourceDetectorConfig {
-	if in == nil {
-		return nil
-	}
-	out := new(EnvironmentResourceDetectorConfig)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *EnvoyBootstrap) DeepCopyInto(out *EnvoyBootstrap) {
 	*out = *in
@@ -1900,6 +1544,41 @@ func (in *GracefulShutdownSpec) DeepCopy() *GracefulShutdownSpec {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *GrpcService) DeepCopyInto(out *GrpcService) {
+	*out = *in
+	if in.BackendRef != nil {
+		in, out := &in.BackendRef, &out.BackendRef
+		*out = new(apisv1.BackendRef)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.AdditionalRequestHeadersToLog != nil {
+		in, out := &in.AdditionalRequestHeadersToLog, &out.AdditionalRequestHeadersToLog
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+	if in.AdditionalResponseHeadersToLog != nil {
+		in, out := &in.AdditionalResponseHeadersToLog, &out.AdditionalResponseHeadersToLog
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+	if in.AdditionalResponseTrailersToLog != nil {
+		in, out := &in.AdditionalResponseTrailersToLog, &out.AdditionalResponseTrailersToLog
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GrpcService.
+func (in *GrpcService) DeepCopy() *GrpcService {
+	if in == nil {
+		return nil
+	}
+	out := new(GrpcService)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *GrpcStatusFilter) DeepCopyInto(out *GrpcStatusFilter) {
 	*out = *in
@@ -2001,11 +1680,6 @@ func (in *HTTPListenerPolicySpec) DeepCopyInto(out *HTTPListenerPolicySpec) {
 			(*in)[i].DeepCopyInto(&(*out)[i])
 		}
 	}
-	if in.Tracing != nil {
-		in, out := &in.Tracing, &out.Tracing
-		*out = new(Tracing)
-		(*in).DeepCopyInto(*out)
-	}
 	if in.UpgradeConfig != nil {
 		in, out := &in.UpgradeConfig, &out.UpgradeConfig
 		*out = new(UpgradeConfig)
@@ -2074,21 +1748,6 @@ func (in *HeaderTransformation) DeepCopy() *HeaderTransformation {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *HeaderValue) DeepCopyInto(out *HeaderValue) {
-	*out = *in
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HeaderValue.
-func (in *HeaderValue) DeepCopy() *HeaderValue {
-	if in == nil {
-		return nil
-	}
-	out := new(HeaderValue)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *HealthCheck) DeepCopyInto(out *HealthCheck) {
 	*out = *in
@@ -2386,44 +2045,6 @@ func (in *IstioIntegration) DeepCopy() *IstioIntegration {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *KeyAnyValue) DeepCopyInto(out *KeyAnyValue) {
-	*out = *in
-	in.Value.DeepCopyInto(&out.Value)
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyAnyValue.
-func (in *KeyAnyValue) DeepCopy() *KeyAnyValue {
-	if in == nil {
-		return nil
-	}
-	out := new(KeyAnyValue)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *KeyAnyValueList) DeepCopyInto(out *KeyAnyValueList) {
-	*out = *in
-	if in.Values != nil {
-		in, out := &in.Values, &out.Values
-		*out = make([]KeyAnyValue, len(*in))
-		for i := range *in {
-			(*in)[i].DeepCopyInto(&(*out)[i])
-		}
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeyAnyValueList.
-func (in *KeyAnyValueList) DeepCopy() *KeyAnyValueList {
-	if in == nil {
-		return nil
-	}
-	out := new(KeyAnyValueList)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *KubernetesProxyConfig) DeepCopyInto(out *KubernetesProxyConfig) {
 	*out = *in
@@ -2773,41 +2394,6 @@ func (in *Message) DeepCopy() *Message {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *MetadataKey) DeepCopyInto(out *MetadataKey) {
-	*out = *in
-	if in.Path != nil {
-		in, out := &in.Path, &out.Path
-		*out = make([]MetadataPathSegment, len(*in))
-		copy(*out, *in)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MetadataKey.
-func (in *MetadataKey) DeepCopy() *MetadataKey {
-	if in == nil {
-		return nil
-	}
-	out := new(MetadataKey)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *MetadataPathSegment) DeepCopyInto(out *MetadataPathSegment) {
-	*out = *in
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MetadataPathSegment.
-func (in *MetadataPathSegment) DeepCopy() *MetadataPathSegment {
-	if in == nil {
-		return nil
-	}
-	out := new(MetadataPathSegment)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *Moderation) DeepCopyInto(out *Moderation) {
 	*out = *in
@@ -2850,31 +2436,6 @@ func (in *MultiPoolConfig) DeepCopy() *MultiPoolConfig {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *OTelTracesSampler) DeepCopyInto(out *OTelTracesSampler) {
-	*out = *in
-	if in.SamplerType != nil {
-		in, out := &in.SamplerType, &out.SamplerType
-		*out = new(OTelTracesSamplerType)
-		**out = **in
-	}
-	if in.SamplerArg != nil {
-		in, out := &in.SamplerArg, &out.SamplerArg
-		*out = new(string)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OTelTracesSampler.
-func (in *OTelTracesSampler) DeepCopy() *OTelTracesSampler {
-	if in == nil {
-		return nil
-	}
-	out := new(OTelTracesSampler)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *OpenAIConfig) DeepCopyInto(out *OpenAIConfig) {
 	*out = *in
@@ -2896,65 +2457,6 @@ func (in *OpenAIConfig) DeepCopy() *OpenAIConfig {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *OpenTelemetryAccessLogService) DeepCopyInto(out *OpenTelemetryAccessLogService) {
-	*out = *in
-	in.GrpcService.DeepCopyInto(&out.GrpcService)
-	if in.Body != nil {
-		in, out := &in.Body, &out.Body
-		*out = new(string)
-		**out = **in
-	}
-	if in.DisableBuiltinLabels != nil {
-		in, out := &in.DisableBuiltinLabels, &out.DisableBuiltinLabels
-		*out = new(bool)
-		**out = **in
-	}
-	if in.Attributes != nil {
-		in, out := &in.Attributes, &out.Attributes
-		*out = new(KeyAnyValueList)
-		(*in).DeepCopyInto(*out)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenTelemetryAccessLogService.
-func (in *OpenTelemetryAccessLogService) DeepCopy() *OpenTelemetryAccessLogService {
-	if in == nil {
-		return nil
-	}
-	out := new(OpenTelemetryAccessLogService)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *OpenTelemetryTracingConfig) DeepCopyInto(out *OpenTelemetryTracingConfig) {
-	*out = *in
-	in.GrpcService.DeepCopyInto(&out.GrpcService)
-	if in.ResourceDetectors != nil {
-		in, out := &in.ResourceDetectors, &out.ResourceDetectors
-		*out = make([]ResourceDetector, len(*in))
-		for i := range *in {
-			(*in)[i].DeepCopyInto(&(*out)[i])
-		}
-	}
-	if in.Sampler != nil {
-		in, out := &in.Sampler, &out.Sampler
-		*out = new(Sampler)
-		(*in).DeepCopyInto(*out)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenTelemetryTracingConfig.
-func (in *OpenTelemetryTracingConfig) DeepCopy() *OpenTelemetryTracingConfig {
-	if in == nil {
-		return nil
-	}
-	out := new(OpenTelemetryTracingConfig)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *Parameters) DeepCopyInto(out *Parameters) {
 	*out = *in
@@ -3493,26 +2995,6 @@ func (in *RegexMatch) DeepCopy() *RegexMatch {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *ResourceDetector) DeepCopyInto(out *ResourceDetector) {
-	*out = *in
-	if in.EnvironmentResourceDetector != nil {
-		in, out := &in.EnvironmentResourceDetector, &out.EnvironmentResourceDetector
-		*out = new(EnvironmentResourceDetectorConfig)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResourceDetector.
-func (in *ResourceDetector) DeepCopy() *ResourceDetector {
-	if in == nil {
-		return nil
-	}
-	out := new(ResourceDetector)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *ResponseFlagFilter) DeepCopyInto(out *ResponseFlagFilter) {
 	*out = *in
@@ -3533,51 +3015,6 @@ func (in *ResponseFlagFilter) DeepCopy() *ResponseFlagFilter {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *RetryPolicy) DeepCopyInto(out *RetryPolicy) {
-	*out = *in
-	if in.RetryBackOff != nil {
-		in, out := &in.RetryBackOff, &out.RetryBackOff
-		*out = new(BackoffStrategy)
-		(*in).DeepCopyInto(*out)
-	}
-	if in.NumRetries != nil {
-		in, out := &in.NumRetries, &out.NumRetries
-		*out = new(uint32)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RetryPolicy.
-func (in *RetryPolicy) DeepCopy() *RetryPolicy {
-	if in == nil {
-		return nil
-	}
-	out := new(RetryPolicy)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *Sampler) DeepCopyInto(out *Sampler) {
-	*out = *in
-	if in.AlwaysOn != nil {
-		in, out := &in.AlwaysOn, &out.AlwaysOn
-		*out = new(AlwaysOnConfig)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Sampler.
-func (in *Sampler) DeepCopy() *Sampler {
-	if in == nil {
-		return nil
-	}
-	out := new(Sampler)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *SdsBootstrap) DeepCopyInto(out *SdsBootstrap) {
 	*out = *in
@@ -4049,79 +3486,6 @@ func (in *TokenBucket) DeepCopy() *TokenBucket {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *Tracing) DeepCopyInto(out *Tracing) {
-	*out = *in
-	in.Provider.DeepCopyInto(&out.Provider)
-	if in.ClientSampling != nil {
-		in, out := &in.ClientSampling, &out.ClientSampling
-		*out = new(uint32)
-		**out = **in
-	}
-	if in.RandomSampling != nil {
-		in, out := &in.RandomSampling, &out.RandomSampling
-		*out = new(uint32)
-		**out = **in
-	}
-	if in.OverallSampling != nil {
-		in, out := &in.OverallSampling, &out.OverallSampling
-		*out = new(uint32)
-		**out = **in
-	}
-	if in.Verbose != nil {
-		in, out := &in.Verbose, &out.Verbose
-		*out = new(bool)
-		**out = **in
-	}
-	if in.MaxPathTagLength != nil {
-		in, out := &in.MaxPathTagLength, &out.MaxPathTagLength
-		*out = new(uint32)
-		**out = **in
-	}
-	if in.Attributes != nil {
-		in, out := &in.Attributes, &out.Attributes
-		*out = make([]CustomAttribute, len(*in))
-		for i := range *in {
-			(*in)[i].DeepCopyInto(&(*out)[i])
-		}
-	}
-	if in.SpawnUpstreamSpan != nil {
-		in, out := &in.SpawnUpstreamSpan, &out.SpawnUpstreamSpan
-		*out = new(bool)
-		**out = **in
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Tracing.
-func (in *Tracing) DeepCopy() *Tracing {
-	if in == nil {
-		return nil
-	}
-	out := new(Tracing)
-	in.DeepCopyInto(out)
-	return out
-}
-
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *TracingProvider) DeepCopyInto(out *TracingProvider) {
-	*out = *in
-	if in.OpenTelemetry != nil {
-		in, out := &in.OpenTelemetry, &out.OpenTelemetry
-		*out = new(OpenTelemetryTracingConfig)
-		(*in).DeepCopyInto(*out)
-	}
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TracingProvider.
-func (in *TracingProvider) DeepCopy() *TracingProvider {
-	if in == nil {
-		return nil
-	}
-	out := new(TracingProvider)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *TrafficPolicy) DeepCopyInto(out *TrafficPolicy) {
 	*out = *in
@@ -4233,11 +3597,6 @@ func (in *TrafficPolicySpec) DeepCopyInto(out *TrafficPolicySpec) {
 		*out = new(CSRFPolicy)
 		(*in).DeepCopyInto(*out)
 	}
-	if in.Buffer != nil {
-		in, out := &in.Buffer, &out.Buffer
-		*out = new(Buffer)
-		(*in).DeepCopyInto(*out)
-	}
 }
 
 // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TrafficPolicySpec.
diff --git a/design/11177.md b/design/11177.md
deleted file mode 100644
index a9ca5218e..000000000
--- a/design/11177.md
+++ /dev/null
@@ -1,865 +0,0 @@
-# EP-11177: AI Extensions OpenTelemetry Tracing Support
-
-* Issue: [#11177](https://github.com/kgateway-dev/kgateway/issues/11177)
-
-## Background
-
-Currently, AI Gateway has introduced Metrics in the observability domain (Logs, Metrics, Traces). However, when issues occur, Metrics can only tell us 'What' happened, but not 'Where' the issue occurred. The proposal is to implement tracing instrumentation in AI Gateway and provide a way to export data to OTLP-compatible backend storage (Jaeger, Datadog) or a more flexible OTel Collector.
-
-## Motivation
-
-### Goals
-
-- Introduce new Gateway Parameter for configuring [OpenTelemetry tracer](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/opentelemetry.proto.html) and [Span Exporter](https://opentelemetry.io/docs/languages/python/exporters/#usage) to export data to OTel Collector or OTLP-compatible backend storage.
-- Implement instrumentation in the [ai extension server](https://github.com/kgateway-dev/kgateway/blob/2bd89e9e19bf017b9a1e86350808656eed6b4b94/python/ai_extension/ext_proc/server.py) and export traces to the configured backend storage.
-- Allow user to enable or disable this feature via Helm.
-- Provide E2E tests to ensure trace data is completely stored in the backend storage.
-- Provide users with a quick start guide.
-
-### Non-Goals
-
-- Integrating OTel Collector as a plugin into Gateway (For kgateway, OTel Collector should be a separate service, and its control should be left to users)
-
-## Implementation Details
-
-### API Changes
-
-Add new tracing field to GatewayParameters, which is an optional feature. When enabled, it will export traces instrumented in the extproc server to OTel Collector or OTLP-compatible backend storage (Jaeger, Datadog).
-
-Here are the key reasons why this configuration should reside within GatewayParameters:
-
-This configuration is essential at server startup. For example, the [OTel TracerProvider](https://github.com/kgateway-dev/kgateway/blob/main/python/ai_extension/ext_proc/server.py#L734) requires these settings for proper initialization.
-Unlike Envoy tracing, the extproc server's tracing configuration cannot currently be updated dynamically via xDS.
-
-```go
-// AiExtensionTrace defines the tracing configuration for the AI extension
-type AiExtensionTrace struct {
-	// Enabled controls whether tracing is enabled
-	// +kubebuilder:validation:Required
-	Enabled *bool `json:"enabled,omitempty"`
-
-	// EndPoint specifies the URL of the OTLP Exporter for traces.
-	// Example: "http://my-otel-collector.svc.cluster.local:4317"
-	// https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_endpoint
-	// +kubebuilder:validation:Required
-	EndPoint gwv1.AbsoluteURI `json:"endpoint"`
-
-	// Sampler defines the sampling strategy for OpenTelemetry traces.
-	// Sampling helps in reducing the volume of trace data by selectively
-	// recording only a subset of traces.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler
-	// +kubebuilder:validation:option
-	Sampler OTelTracesSampler `json:"sampler,omitempty"`
-
-	// OTLPTimeout specifies timeout configurations for OTLP (OpenTelemetry Protocol) exports.
-	// It allows setting general and trace-specific timeouts for sending data.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_timeout
-	// +kubebuilder:validation:option
-	Timeout time.Duration `json:"timeout,omitempty"`
-
-	// OTLPProtocol specifies the protocol to be used for OTLP exports.
-	// This determines how tracing data is serialized and transported (e.g., gRPC, HTTP/Protobuf).
-	// https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_protocol
-	// +kubebuilder:validation:option
-	Protocol OTLPTracesProtocolType `json:"protocol,omitempty"`
-
-	// TransportSecurity controls the TLS (Transport Layer Security) settings when connecting
-	// to the tracing server. It determines whether certificate verification should be skipped.
-	// +kubebuilder:validation:option
-	TransportSecurity OTLPTransportSecurityMode `json:"transportSecurity,omitempty"`
-}
-
-// OTelTracesSampler defines the configuration for an OpenTelemetry trace sampler.
-// It combines the sampler type with any required arguments for that type.
-type OTelTracesSampler struct {
-	// SamplerType specifies the type of sampler to use (default value: "parentbased_always_on").
-	// Refer to OTelTracesSamplerType for available options.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler
-	SamplerType OTelTracesSamplerType `json:"type"`
-	// SamplerArg provides an argument for the chosen sampler type.
-	// For "traceidratio" or "parentbased_traceidratio" samplers: Sampling probability, a number in the [0..1] range,
-	// e.g. 0.25. Default is 1.0 if unset.
-	// https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler_arg
-	SamplerArg float64 `json:"arg"`
-}
-
-// OTLPTracesProtocolType defines the supported protocols for OTLP exporter.
-type OTLPTracesProtocolType string
-
-const (
-	// OTLPTracesProtocolTypeGrpc specifies OTLP over gRPC protocol.
-	// This is typically the most efficient protocol for OpenTelemetry data transfer.
-	OTLPTracesProtocolTypeGrpc OTLPTracesProtocolType = "grpc"
-	// OTLPTracesProtocolTypeProtobuf specifies OTLP over HTTP with Protobuf serialization.
-	// Data is sent via HTTP POST requests with Protobuf message bodies.
-	OTLPTracesProtocolTypeProtobuf OTLPTracesProtocolType = "http/protobuf"
-	// OTLPTracesProtocolTypeJson specifies OTLP over HTTP with JSON serialization.
-	// Data is sent via HTTP POST requests with JSON message bodies.
-	OTLPTracesProtocolTypeJson OTLPTracesProtocolType = "http/json"
-)
-
-// OTLPTransportSecurityMode defines the transport security options for OTLP connections.
-type OTLPTransportSecurityMode string
-
-const (
-	// OTLPTransportSecuritySecure enables TLS (client transport security) for OTLP connections.
-	// This means the client will verify the server's certificate.
-	OTLPTransportSecuritySecure OTLPTransportSecurityMode = "secure"
-
-	// OTLPTransportSecurityInsecure disables TLS for OTLP connections,
-	// meaning certificate verification is skipped. This is generally not recommended
-	// for production environments due to security risks.
-	OTLPTransportSecurityInsecure OTLPTransportSecurityMode = "insecure"
-)
-
-// OTelTracesSamplerType defines the available OpenTelemetry trace sampler types.
-// These samplers determine which traces are recorded and exported.
-type OTelTracesSamplerType string
-
-const (
-	// OTelTracesSamplerAlwaysOn enables always-on sampling.
-	// All traces will be recorded and exported. Useful for development or low-traffic systems.
-	OTelTracesSamplerAlwaysOn OTelTracesSamplerType = "always_on"
-
-	// OTelTracesSamplerAlwaysOff enables always-off sampling.
-	// No traces will be recorded or exported. Effectively disables tracing.
-	OTelTracesSamplerAlwaysOff OTelTracesSamplerType = "always_off"
-
-	// OTelTracesSamplerTraceidratio enables trace ID ratio based sampling.
-	// Traces are sampled based on a configured probability derived from their trace ID.
-	OTelTracesSamplerTraceidratio OTelTracesSamplerType = "traceidratio"
-
-	// OTelTracesSamplerParentbasedAlwaysOn enables parent-based always-on sampling.
-	// If a parent span exists and is sampled, the child span is also sampled.
-	// If no parent, it defers to an "always_on" strategy.
-	OTelTracesSamplerParentbasedAlwaysOn OTelTracesSamplerType = "parentbased_always_on"
-
-	// OTelTracesSamplerParentbasedAlwaysOff enables parent-based always-off sampling.
-	// If a parent span exists and is not sampled, the child span is also not sampled.
-	// If no parent, it defers to an "always_off" strategy.
-	OTelTracesSamplerParentbasedAlwaysOff OTelTracesSamplerType = "parentbased_always_off"
-
-	// OTelTracesSamplerParentbasedTraceidratio enables parent-based trace ID ratio sampling.
-	// If a parent span exists and is sampled, the child span is also sampled.
-	// If no parent, it defers to a "traceidratio" strategy.
-	OTelTracesSamplerParentbasedTraceidratio OTelTracesSamplerType = "parentbased_traceidratio"
-)
-```
-
-### Configuration
-
-This features will be enabled via a helm flag, disabled by default.
-
-   ```shell
-   helm upgrade -i -n kgateway-system kgateway _test/kgateway-1.0.0-ci1.tgz --version 1.0.0-ci1 \
-     --set image.registry=ghcr.io/kgateway-dev \
-     --set gateway.aiExtension.enabled=true \
-     --set gateway.aiExtension.tracing.enabled=true \
-     --create-namespace
-   ```
-
-```yaml
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: GatewayParameters
-metadata:
-  name: ai-gateway
-  namespace: kgateway-system
-  labels:	
-    app: ai-kgateway
-spec:
-  kube:
-    aiExtension:
-      enabled: true
-      tracing:
-      	enabled: true
-      	endpoint: http://otel.collector.svc.cluster.local:4317
-      	sampler:
-          type: traceidratio
-          arg: 1.0
-      	timeout: 10000
-      	protocol: grpc
-        transportSecurity: secure
-    service:
-      type: LoadBalancer
-```
-
-### Plugin
-
-There are two kinds of dynamic resources that need to be transformed and appended to the Envoy snapshot. To enable the collection and export of tracing data within the AI Gateway, the Envoy proxy requires specific configurations for OTel integration.
-
-#### HttpConnectionManager Tracing Configuration
-
-The `HttpConnectionManager` needs to be configured with tracing block, specifying OpenTelemetry as the tracing provider.
-```yaml
-tracing:
-  provider:
-    name: envoy.tracers.opentelemetry
-    typed_config:
-      "@type": type.googleapis.com/envoy.config.trace.v3.OpenTelemetryConfig
-      grpc_service:
-        envoy_grpc:
-          cluster_name: otel-collector.monitoring.svc.cluster.local
-        timeout: 0.25s
-      service_name: "ai-ext-proc"
-      resource_detectors:
-        - name: envoy.resource_detectors.environment
-          typed_config:
-            "@type": type.googleapis.com/envoy.extensions.resource_detectors.environment.v3.EnvironmentConfig
-      sampler:
-        name: envoy.opentelemetry.samplers.AlwaysOnSampler
-        typed_config:
-          "@type": type.googleapis.com/envoy.extensions.tracers.open_telemetry
-```
-
-When a user configures an `AiExtensionTrace` object within the Gateway parameters, the [HTTP Listener Policy Plugin](https://github.com/kgateway-dev/kgateway/pull/11396/files#diff-2d10e902e14b029ddaf0ec2a348ddfc3d510b8e745213b4dd8c8d530be3e7afaR19) will be responsible for parsing these parameters. 
-It then dynamically translates them into the necessary **Envoy HttpConnectionManager tracing configuration** and the corresponding **cluster definitions**. 
-This fully dynamic process ensures both flexibility and maintainability for your tracing setup.
-#### xDS Cluster for OTLP/gRPC Backend
-
-An xDS Cluster definition is required to specify the upstream backend for the OTLP/gRPC compatible tracing storage (e.g., an OpenTelemetry Collector, Jaeger). This cluster will serve as the destination for the tracing data exported by Envoy.
-
-```yaml
-- name: otel-collector.monitoring.svc.cluster.local
-  type: STRICT_DNS
-  load_assignment:
-    cluster_name: otel-collector.monitoring.svc.cluster.local
-    endpoints:
-      - lb_endpoints:
-          - endpoint:
-              address:
-                socket_address:
-                  address: otel-collector.monitoring.svc.cluster.local
-                  port_value: 4317
-
-```
-
-### ExtProc Server
-
-There are two main tasks to accomplish:
-
-#### Initial TracerProvider
-
-All configuration parameters can be obtained from `/var/run/tracing/tracing.json` and used to initialize the tracer provider.
-
-```python
-class Config(BaseModel):
-		service_name: string = Field(default="kgateway-ai-extension")
-    grpc: Grpc | None = Field(default=None)
-    insecure: bool = Field(default=False)
-
-    def tracer(self) -> Tracer:
-        # Initialize No-Op tracer provider default.
-        tracer_provider: TracerProvider = NoOpTracerProvider()
-        
-        if self.grpc is not None and len(self.grpc.host) > 0 and self.grpc.port > 0:
-            url = f"{self.grpc.host}:{self.grpc.port}"
-            logger.debug(f"tracer publishing to: {url}")
-            
-            resource = Resource.create(attributes={SERVICE_NAME: self.service_name})
-            
-            # If gRPC is configured, override the NoOpTracerProvider with a real one.
-            tracer_provider = TracerProvider(resource=resource)
-            
-            # Configure span processor and exporter
-            span_processor = BatchSpanProcessor(
-                OTLPSpanExporter(endpoint=url, insecure=self.insecure)
-            )
-            tracer_provider.add_span_processor(span_processor)
-        else:
-            logger.warning("No gRPC configuration found. Tracing will not be enabled.")
-        
-        # Set the configured tracer_provider (either real or NoOp) globally.
-				trace.set_tracer_provider(tracer_provider)
-        return trace.get_tracer(__name__)
-```
-
-#### Ensure all request paths are covered
-
-Currently, the main flow, key business logic, and exception handling have basic tracing coverage. To ensure that our generated trace data can be effectively parsed and analyzed by standardized tools (like Jaeger, Grafana, etc.) and interoperate with other OpenTelemetry-compliant systems, we must strictly adhere to the [OpenTelemetry Generative AI Span Semantic Conventions](https://opentelemetry.io/docs/specs/semconv/gen-ai/gen-ai-spans/).
-
-##### *Request Headers*
-
-Add tracing for request header handling with model and provider information:
-
-**Tracing purpose**: Trace the request headers processing flow, capturing initial configuration and model information
-
-**Captured attributes**:
-
-- `gen_ai.system`: LLM provider in use (e.g., "openai", "anthropic")
-- `gen_ai.request.model`: Requested model name (e.g., "gpt-4o")
-
-Example:
-
-```python
-if one_of == "request_headers":
-    with OtelTracer.get().start_as_current_span(
-        "handle_request_headers",
-        context=ctx,
-        attributes={
-            "gen_ai.system": handler.llm_provider,
-            "gen_ai.request.model": handler.request_model,
-        }
-```
----
-
-##### *Request Body*
-
-Add detailed tracing for the main request body handling path.
-
-**Tracing purpose**: Trace request body processing, including model parameters and content moderation
-
-**Captured attributes**:
-
-- Model information:
-  - `gen_ai.operation.name`: Model name
-  - `gen_ai.system`: LLM provider
-- Request parameters:
-  - `gen_ai.output.type`: Output type
-  - `gen_ai.request.choice.count`: Number of generation choices
-  - `gen_ai.request.model`: Requested model
-  - `gen_ai.request.seed`: Random seed
-  - `gen_ai.request.temperature`: Temperature parameter
-  - `gen_ai.request.max_tokens`: Maximum tokens
-  - `gen_ai.request.stop_sequences`: Stop sequences
-- Token information:
-  - `ai.tokens.prompt`: Request token count
-- Content moderation:
-  - `ai.moderation.flagged`: Whether content was flagged
-  - `ai.moderation.categories`: Categories that were flagged
-
-Example:
-```python
-async def handle_request_body(
-    self,
-    req_body: external_processor_pb2.HttpBody,
-    metadict: dict,
-    handler: StreamHandler,
-    parent_span: trace.Span,
-) -> external_processor_pb2.ProcessingResponse:
-...
-if req_body.end_of_stream:
-    with OtelTracer.get().start_as_current_span(
-        handler.llm_provider,
-        context=trace.set_span_in_context(parent_span),
-        attributes={
-            "gen_ai.operation.name" : body.get("model", ""),
-            "gen_ai.system": handler.llm_provider,
-            "gen_ai.output.type": body.get("response_format", {}).get("type", ""),
-            "gen_ai.request.choice.count": body.get("n", 0),
-            "gen_ai.request.model": handler.request_model,
-            "gen_ai.request.seed": body.get("seed", 0),
-            "gen_ai.request.frequency_penalty": body.get("frequency_penalty", 0),
-            "gen_ai.request.max_tokens": body.get("max_tokens", 0),
-            "gen_ai.request.presence_penalty": body.get("presence_penalty", 0),
-            "gen_ai.request.stop_sequences": body.get("stop", []),
-            "gen_ai.request.temperature": body.get("temperature", 0),
-            "gen_ai.request.top_k": body.get("top_k", 0),
-            "gen_ai.request.top_p": body.get("top_p", 0),
-        }
-    ):
-        tokens = handler.provider.get_num_tokens_from_body(body)
-        parent_span.set_attribute("ai.tokens.prompt", tokens)
-    ...
-    if handler.req_moderation:
-        with OtelTracer.get().start_as_current_span(
-            "moderation",
-            context=trace.set_span_in_context(parent_span),
-        ) as moderation_span:
-            moderation_span.set_attribute(
-                "gen_ai.operation.provider", handler.req_moderation[0].provider_name
-            )
-```
----
-
-##### *Webhook*
-Add tracing for webhook request handling:
-
-**Tracing purpose**: Trace webhook request processing flow, record latency and results
-
-**Captured attributes**:
-
-- `ai.webhook.host`: Webhook host
-- `ai.webhook.forward_headers`: Forwarded headers
-- `ai.webhook.latency_ms`: Webhook request latency
-- `ai.webhook.result`: Result ("modified" or "rejected")
-- `ai.webhook.reject_reason`: Rejection reason (if applicable)
-
-```python
-async def handle_request_body_req_webhook(
-    self,
-    body: dict,
-    handler: StreamHandler,
-    webhook_cfg: prompt_guard.Webhook,
-    parent_span: trace.Span,
-) -> external_processor_pb2.ProcessingResponse | None:
-    with OtelTracer.get().start_as_current_span(
-        "webhook",
-        context=trace.set_span_in_context(parent_span),
-    ) as webhook_span:
-        webhook_span.set_attributes(
-            {
-                "ai.webhook.host": webhook_cfg.host,
-                "ai.webhook.forward_headers": webhook_cfg.forwardHeaders,
-            }
-        )
-
-        webhook_start_time = time.time()
-        try:
-            headers = deepcopy(handler.req.headers)
-            TraceContextTextMapPropagator().inject(headers)
-            response: (
-                PromptMessages | RejectAction | None
-            ) = await make_request_webhook_request(
-                webhook_host=webhook_cfg.host,
-                webhook_port=webhook_cfg.port,
-                headers=headers,
-                promptMessages=handler.provider.construct_request_webhook_request_body(
-                    body
-                ),
-            )
-            webhook_span.set_attribute(
-                "ai.webhook.latency_ms", (time.time() - webhook_start_time) * 1000
-            )
-
-            if isinstance(response, PromptMessages):
-                handler.provider.update_request_body_from_webhook(body, response)
-                webhook_span.set_attribute("ai.webhook.result", "modified")
-                webhook_span.add_event("ai.webhook.prompt.modified")
-
-            if isinstance(response, RejectAction):
-                webhook_span.set_attributes(
-                    {
-                        "ai.webhook.result": "rejected",
-                        "ai.webhook.reject_reason": response.reason,
-                    }
-                )
-```
-
---- 
-
-##### *Regex processing*
-Add tracing for regex processing:
-
-**Tracing purpose**: Trace regex expression processing, record rule count and execution time
-
-**Captured attributes**:
-
-- `ai.regex.rules_count`: Number of rules
-- `ai.regex.latency_ms`: Processing latency
-- `ai.regex.result`: Processing result ("passed" or error)
-
-Example:
-
-```python
-def handle_request_body_req_regex(
-    self, body: dict, handler: StreamHandler, parent_span: trace.Span
-) -> external_processor_pb2.ProcessingResponse | None:
-    with OtelTracer.get().start_as_current_span(
-        "regex",
-        context=trace.set_span_in_context(parent_span),
-    ) as regex_span:
-        regex_span.set_attribute("ai.regex.rules_count", len(handler.req_regex))
-
-        regex_start_time = time.time()
-        # If this raises an exception it means that the action was reject, not mask
-        try:
-            handler.provider.iterate_str_req_messages(
-                body=body, cb=handler.req_regex_transform
-            )
-            regex_span.set_attributes(
-                {
-                    "ai.regex.latency_ms": (time.time() - regex_start_time) * 1000,
-                    "ai.regex.result": "passed",
-                }
-            )
-```
-
----
-##### *Response Body*
-
-**Tracing purpose**: Trace response body processing, record model output information
-
-- **Captured attributes**:
-  - `gen_ai.operation.name`: Operation name
-  - `gen_ai.system`: LLM provider
-  - `gen_ai.response.id`: Response ID
-  - `gen_ai.response.model`: Response model
-  - `gen_ai.response.finish_reasons`: Completion reason
-  - `gen_ai.usage.output_tokens`: Output token count
-
-Example:
-
-```python
-async def handle_response_body(
-    self,
-    resp_body: external_processor_pb2.HttpBody,
-    handler: StreamHandler,
-    parent_span: trace.Span,
-) -> external_processor_pb2.ProcessingResponse:
-  finish_reason = ""
-
-  if isinstance(jsn.get("choices"), list) and len(jsn["choices"]) > 0:
-      first_choice = jsn["choices"][0]
-      if isinstance(first_choice, dict):
-          finish_reason = first_choice.get("finish_reason", "")
-
-  completion_tokens = 0
-  if isinstance(jsn.get("usage"), dict):
-      completion_tokens = jsn["usage"].get("completion_tokens", 0)
-
-  with OtelTracer.get().start_as_current_span(
-  jsn.get("model", ""),
-  context=trace.set_span_in_context(parent_span),
-  attributes={
-      "gen_ai.operation.name": jsn.get("model", ""),
-      "gen_ai.system": handler.llm_provider,
-      "gen_ai.response.id": jsn.get("id", ""),
-      "gen_ai.response.model": jsn.get("model", ""),
-      "gen_ai.response.finish_reasons": finish_reason, 
-      "gen_ai.usage.output_tokens": completion_tokens,
-  }
-):
-      pass
-```
-
----
-
-##### *Exception Handling*
-
-Enhanced error tracing by recording exceptions properly:
-
-**Tracing purpose**: Ensure all exceptions are properly recorded for debugging
-
-- **Recording method**:
-  - `span.record_exception(exc)`: Record exception details
-  - `span.set_status(trace.StatusCode.ERROR, str(exc))`: Set error status
-
-- **Covered exceptions**:
-  - JSONDecodeError: JSON parsing errors
-  - RegexRejection: Regex expression rejection
-  - WebhookException: Webhook handling errors
-  - General exceptions
-
-Example:
-```python
-except json.decoder.JSONDecodeError as exc:
-    span.record_exception(exc)
-    span.set_status(
-        trace.StatusCode.ERROR,
-        str(exc),
-    )
-```
-
-```python
-except Exception as e:
-    span.record_exception(e)
-    span.set_status(
-        trace.StatusCode.ERROR,
-        str(e),
-    )
-    return error_response(
-        handler.req_custom_response, "Error with guardrails webhook", e
-    )
-```
-
-```python
-except RegexRejection as e:
-    span.record_exception(e)
-    span.set_status(
-        trace.StatusCode.ERROR,
-        str(e),
-    )
-    return error_response(
-        handler.req_custom_response, "Rejected by guardrails regex", e
-    )
-```
-
----
-
-##### OpenAI Request Example and Trace Output Validation:
-
-The following `curl` request can be used to test the above logic:
-
-```bash
-curl "localhost:8080/openrouter" \
-  -H "Content-Type: application/json" \
-  -d "{
-    \"model\": \"openai/gpt-4o\",
-    \"messages\": [
-      {
-        \"role\": \"user\",
-        \"content\": \"What is the meaning of life?\"
-      }
-    ],
-    \"temperature\": 0.7,
-    \"max_tokens\": 150,
-    \"n\": 2,
-    \"seed\": 123
-  }" | jq
-```
-
-##### Output Example: OpenAI Request Body Span
-
-```json
-{
-    "name": "openai/gpt-4o",
-    "context": {
-        "trace_id": "0x4e4798e9287501bceb734f74b9d25ac9",
-        "span_id": "0x3ac5b25e33326e72",
-        "trace_state": "[]"
-    },
-    "kind": "SpanKind.INTERNAL",
-    "parent_id": "0xf6a5fac786151c7b",
-    "start_time": "2025-06-16T14:22:17.243004Z",
-    "end_time": "2025-06-16T14:22:17.331470Z",
-    "status": {
-		"status_code": "UNSET"
-    },
-		"attributes": {
-        "gen_ai.operation.name": "openai/gpt-4o",
-        "gen_ai.system": "openai",
-        "gen_ai.output.type": "",
-        "gen_ai.request.choice.count": 2,
-        "gen_ai.request.model": "openai/gpt-4o",
-        "gen_ai.request.seed": 123,
-        "gen_ai.request.frequency_penalty": 0,
-        "gen_ai.request.max_tokens": 150,
-        "gen_ai.request.presence_penalty": 0,
-        "gen_ai.request.stop_sequences": [],
-        "gen_ai.request.temperature": 0.7,
-        "gen_ai.request.top_k": 0,
-        "gen_ai.request.top_p": 0
-    },
-    "events": [],
-		"links": [],
-    "resource": {
-        "attributes": {
-            "telemetry.sdk.language": "python",
-            "telemetry.sdk.name": "opentelemetry",
-            "telemetry.sdk.version": "1.34.1",
-            "service.name": "kgateway-ai-extension"
-        },
-        "schema_url": ""
-    }
-}
-```
-
-##### Output Example: OpenAI Response Body Span
-
-```json
-{
-    "name": "openai",
-    "context": {
-        "trace_id": "0xfc1a7624d126b688b463c54378670dea",
-        "span_id": "0x2cec89783790f34f",
-        "trace_state": "[]"
-    },
-    "kind": "SpanKind.INTERNAL",
-    "parent_id": "0x9c4b36bf0bb4a5ba",
-    "start_time": "2025-06-16T14:22:20.205595Z",
-    "end_time": "2025-06-16T14:22:20.205613Z",
-    "status": {
-        "status_code": "UNSET"
-    },
-    "attributes": {
-        "gen_ai.operation.name": "openai/gpt-4o",
-        "gen_ai.system": "openai",
-        "gen_ai.response.id": "gen-1750083737-01qrIBNrwHLQg2QawfHa",
-        "gen_ai.response.model": "openai/gpt-4o",
-        "gen_ai.response.finish_reasons": "stop",
-        "gen_ai.usage.output_tokens": 133
-    },
-    "events": [],
-    "links": [],
-    "resource": {
-        "attributes": {
-            "telemetry.sdk.language": "python",
-            "telemetry.sdk.name": "opentelemetry",
-            "telemetry.sdk.version": "1.34.1",
-            "service.name": "kgateway-ai-extension"
-        },
-        "schema_url": ""
-    }
-}
-```
-
-### Test Plan
-
-#### E2E Test
-
-E2E Tests to validate new API changes and configuration, ensuring traces are produced and exported to the correct backend.
-
-------
-
-##### Deploying Tempo (Monolithic Mode)
-
-We enable the trace search feature via `--set tempo.searchEnabled=true`, which is crucial for retrieving trace data through the query API in E2E tests. Additionally, `--set tempo.target=all` ensures Tempo is deployed in **Monolithic mode**. This mode integrates all components (such as data ingestion, storage, and querying) into a single Pod and defaults to using local storage (boltdb-shipper), making it highly suitable for quick setup and E2E testing environments. The command should be executed using the [Helm client](https://github.com/kgateway-dev/kgateway/blob/47e94dba408fdb26e9f2e0d927237896bc621bef/pkg/utils/helmutils/client.go#L57-L60).
-
-```bash
-helm install tempo grafana/tempo \
-  --namespace ai-test \
-  --set tempo.searchEnabled=true \
-  --set tempo.target=all
-```
-
-##### Use TraceQL to search for traces
-
-All traces are stored in Tempo. We can access the Tempo endpoint and use **TraceQL** to query trace data based on specific conditions. By comparing these results with **mock traces**, we can assert the completeness of the entire tracing pipeline, from trace generation to storage. Our **validation baseline** comes from requests sent to the AI Gateway and data provided by the [mock-ai-provider-server](https://github.com/kgateway-dev/kgateway/blob/47e94dba408fdb26e9f2e0d927237896bc621bef/test/mocks/mock-ai-provider-server/mocks/routing/openai_non_streaming.json#L4).
-
-###### Example: Traces for requests sent to the AI Gateway
-
-This example shows how traces generated by requests to the AI Gateway are stored in Tempo.
-
-```bash
-curl -G -s "http://localhost:3200/api/search" \
-     --data-urlencode 'q={name="openai"}' \
-     --data-urlencode "start=${START_TIME}" \
-     --data-urlencode "end=${END_TIME}" \
-     --data-urlencode "limit=100" | jq
-{
-  "traces": [
-    {
-      "traceID": "45469d52226f30d7076570593c1ed6eb",
-      "rootServiceName": "kgateway-ai-extension",
-      "rootTraceName": "handle_request_body",
-      "startTimeUnixNano": "1750183404673185818",
-      "durationMs": 67,
-      "spanSet": {
-        "spans": [
-          {
-            "spanID": "3fcf91d4fe019790",
-            "name": "openai",
-            "startTimeUnixNano": "1750183404673299778",
-            "durationNanos": "67613092"
-          }
-        ],
-        "matched": 1
-      },
-      "spanSets": [
-        {
-          "spans": [
-            {
-              "spanID": "3fcf91d4fe019790",
-              "name": "openai",
-              "startTimeUnixNano": "1750183404673299778",
-              "durationNanos": "67613092"
-            }
-          ],
-          "matched": 1
-        }
-      ],
-      "serviceStats": {
-        "kgateway-ai-extension": {
-          "spanCount": 2
-        }
-      }
-    }
-  ],
-  "metrics": {
-    "inspectedBytes": "53751",
-    "completedJobs": 1,
-    "totalJobs": 1
-  }
-}
-```
-
-###### Example: Traces for interactions with the Mock AI Provider Server
-
-This example shows how traces related to the [mock-ai-provider-server](https://github.com/kgateway-dev/kgateway/blob/47e94dba408fdb26e9f2e0d927237896bc621bef/test/mocks/mock-ai-provider-server/mocks/routing/openai_non_streaming.json#L4) are stored in Tempo.
-
-```bash
-curl -G -s "http://localhost:3200/api/search" \
-     --data-urlencode 'q={name="openai/gpt-4o"}' \
-     --data-urlencode "start=${START_TIME}" \
-     --data-urlencode "end=${END_TIME}" \
-     --data-urlencode "limit=100" | jq
-{
-  "traces": [
-    {
-      "traceID": "2f4840e4691d88e52f9597cc2be89976",
-      "rootServiceName": "kgateway-ai-extension",
-      "rootTraceName": "handle_response_body",
-      "startTimeUnixNano": "1750408230186355047",
-      "durationMs": 1,
-      "spanSet": {
-        "spans": [
-          {
-            "spanID": "89594cca2f72a814",
-            "name": "openai/gpt-4o",
-            "startTimeUnixNano": "1750408230186455880",
-            "durationNanos": "6875"
-          }
-        ],
-        "matched": 1
-      },
-      "spanSets": [
-        {
-          "spans": [
-            {
-              "spanID": "89594cca2f72a814",
-              "name": "openai/gpt-4o",
-              "startTimeUnixNano": "1750408230186455880",
-              "durationNanos": "6875"
-            }
-          ],
-          "matched": 1
-        }
-      ],
-      "serviceStats": {
-        "kgateway-ai-extension": {
-          "spanCount": 2
-        }
-      }
-    },
-    {
-      "traceID": "5e2f810464667814309b1d82ea48f4dd",
-      "rootServiceName": "kgateway-ai-extension",
-      "rootTraceName": "handle_response_body",
-      "startTimeUnixNano": "1750408020256219799",
-      "durationMs": 2,
-      "spanSet": {
-        "spans": [
-          {
-            "spanID": "bf3f77aec7d8390b",
-            "name": "openai/gpt-4o",
-            "startTimeUnixNano": "1750408020256385298",
-            "durationNanos": "9291"
-          }
-        ],
-        "matched": 1
-      },
-      "spanSets": [
-        {
-          "spans": [
-            {
-              "spanID": "bf3f77aec7d8390b",
-              "name": "openai/gpt-4o",
-              "startTimeUnixNano": "1750408020256385298",
-              "durationNanos": "9291"
-            }
-          ],
-          "matched": 1
-        }
-      ],
-      "serviceStats": {
-        "kgateway-ai-extension": {
-          "spanCount": 2
-        }
-      }
-    }
-  ],
-  "metrics": {
-    "inspectedBytes": "55490",
-    "completedJobs": 1,
-    "totalJobs": 1
-  }
-}
-```
-
-#### Unit Tests 
-
-Unit Tests to verify that spans are generated for all critical paths.
-
-## Alternatives
-
-## Open Questions
diff --git a/design/11376.md b/design/11376.md
deleted file mode 100644
index bc3cb84e3..000000000
--- a/design/11376.md
+++ /dev/null
@@ -1,49 +0,0 @@
-# EP-11376: Modular Deployer
- 
-Status:
- 
-Issue: https://github.com/kgateway-dev/kgateway/issues/11376
- 
-## Background
-Currently kgateway uses a Deployer to automate deploying of gateways and inference pools. Its implementation is tightly coupled with internal representation of gateways, gateway parameters, associated helm chart values, and the inference pool extension is treated as a special case while largely relying abstractions originally developed for gateways.
-The Deployer pattern and its implementation could be reused for handling of deployments of components other than gateways (and extension pools) by creating a common interface for rendering of charts and pushing gateway-specific chart rendering code into a dedicated concrete implementation of that interface.
-
-## Goals
-1. Decouple Deployer from implementation details of gateway and inference pool helm chart rendering
-2. Make Deployer a public sub-module so it can be reused
-3. Support for arbitrary GatewayParameters extensions
-4. Make GatewayParameter merging logic available for reuse
-
-## Non-Goals
-1. Re-use of kgateway controller and inference extensions controller
-2. Support for handling of multiple charts per single Deployer instance
-3. Optimization(s) of helm hart rendering
-
-## Alternatives
-* The Deployer can be further broken up into Applier & Rendered interfaces and their default implementations. 
-
-## Implementation Details
-
-#### Current State
-
-![current implementation of Deployer](resources/deployer-current-implementation.png "current implementation of Deployer")
-1. Deployer exposes a set of functions to render (GetObjsToDeploy, GetEndpointPickerObjs) and deploy (DeployObjs) for gateways and inference pools. The deployer uses hard-coded logic and configuration in Inputs (4) to automatically configure itself for deploying of gateways or inference pools. Rendering of values and helm charts for gateways and inference pools is an implementation detail not exposed outside of internal/deployer package.
-2. helmConfig is used to store helm values generated during GetObjsToDeploy and GetEndpointPickerObjs calls and is not accessible outside of internal/deployer package.
-3. Chart is a reference to a helm chart (helm module) 
-4. Inputs is a set of options used to configure the deployer, such as control plane xds config, inference extension config, image repository config, etc. These are used during rendering of helm charts.
-5, 6. controllers use Deployer to render kgateway and inference extension charts and then sync the changes to the k8s cluster.
-
-#### Proposed Changes
-
-![proposed implementation of Deployer](resources/deployer-proposed-changes.png "proposed implementation of Deployer")
-1. Move [Deployer into pkg/deployer package](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-f3c8137f0e1c7fd0ea790cd1766fded900c4c1466962827294d3efac0e85f840R57); reduce its interface to GetObjsToDeploy (rendering of charts) and DeployObjs (syncing objects to the k8s cluster).
-2. Move [Inputs into pkg/deployer package](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-f3c8137f0e1c7fd0ea790cd1766fded900c4c1466962827294d3efac0e85f840R40); it's a direct dependency of Deployer and is required to create an instance of one.
-3. Chart is a reference to a helm chart (helm module). Charts are no longer loaded inside Deployer factory function, instead it becomes a responsibility of the controllerBuilder.
-4. [HelmValuesGenerator](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-9d7c35479e65bac7fd480cd082cb6c7d34679d56675ab6c79df66e606bb3cd0eR15) is a common interface for generating of helm values used with helm charts. Implementations for handling of [gateway parameters](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-f985bb8743470d3a6c7d2a3c524fae007e8912e37a001e5b3dbadb35c5379fa2R34) (7) and [inference extensions](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-16d2eb16223cdcf1bae9a6cdfadf95052bb0f6ae4aa54dde575795aeac5ac713R12) (8) reside in internal/deployer package.
-5. [HelmConfig](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-03ea6362b8b7909144dd2a063e851ccc3de0602397c1ea0ac771a835e22091a9R10) is now a public struct that is used to store helm values for gateway and inference extension charts. This is done to support reuse of gateway parameters helm values generation.
-6. [pkg/deployer/GatewayParameters](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-9d7c35479e65bac7fd480cd082cb6c7d34679d56675ab6c79df66e606bb3cd0eR53) is a module that makes kgateway default config parameters available for reuse
-7, 8. Helm values renderers, [instantiated by controllerBuilder and then injected](https://github.com/kgateway-dev/kgateway/pull/11377/files#diff-c04d0ac99726d6a18164b34a2ec4a8bacbee9667ec7ee3260b5bb930f545eb42R202) into a Deployer instance.
-9, 10. controllers use Deployer to render kgateway and inference extension charts and then sync the changes to the k8s cluster.
-
-## PoC Implementation
-https://github.com/kgateway-dev/kgateway/pull/11377
\ No newline at end of file
diff --git a/design/11387.md b/design/11387.md
deleted file mode 100644
index c2f2dea67..000000000
--- a/design/11387.md
+++ /dev/null
@@ -1,62 +0,0 @@
-# EP-11387: Allow setting listener perConnectionBufferLimitBytes
-
-* Issue: [#11387](https://github.com/kgateway-dev/kgateway/issues/11387)
-
-## Background
-
-We want to allow users to set the [perConnectionBufferLimitBytes](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-per-connection-buffer-limit-bytes). The listener buffer limit, defined in envoy as `per_connection_buffer_limit_bytes
-`, controls the max size of read and write buffers for new connections.
-
-## Motivation
-
-When using Envoy as an edge proxy, configuring the listener buffer limit is important, since you could be dealing with untrusted downstreams. By setting the limit to a small number, such as 32KiB, you better guard against potential attacks or misconfigured downstreams that could hog the proxy's resources.
-
-## Goals
-
-Allow setting the listener level buffer limit (perConnectionBufferLimitBytes) for a Gateway.
-
-## Non-Goals
-
-Allow setting the perConnectionBufferLimitBytes for each individual listener on a Gateway (instead, we will apply same limit to all listeners).
-
-## Implementation Details
-
-We'll check the gateway for the annotation `kgateway.dev/per-connection-buffer-limit`, which should specify a value in the [resource quantity format](https://kubernetes.io/docs/reference/kubernetes-api/common-definitions/quantity/).
-
-The perConnectionBufferLimitBytes for all listeners on the gateway will be set to this value.
-
-```
-apiVersion: gateway.networking.k8s.io/v1
-kind: Gateway
-metadata:
-  name: example-gateway
-  annotations:
-    kgateway.dev/per-connection-buffer-limit: 64Ki
-spec:
-  gatewayClassName: example-gateway-class
-  listeners:
-  - name: http
-    protocol: HTTP
-    port: 80
-  - name: http2
-    protocol: HTTP
-    port: 3000
-```
-
-### Test Plan
-
-unit tests
-
-## Alternatives
-
-We discussed several options for setting perConnectionBufferLimitBytes.
-- Creating new policy for listener options
-  -  decided against this since it was overkill to create a new policy for one field, and we're unlikely to have other listener level fields even in future
-- adding this option to GatewayParameters
-  - while this makes sense, it will require a lot of up front work to refactor it out of deployer and into krt collections
-  
-We decided using an annotation on the gateway made sense and was straightforward to implement.
-
-## Open Questions
-
-Need to make sure this is documented 
diff --git a/design/11466.md b/design/11466.md
index 24db952c0..a7e821981 100644
--- a/design/11466.md
+++ b/design/11466.md
@@ -63,7 +63,7 @@ When the feature is enabled, the route rules in the [HTTPRoutes with weights](/i
 
 ### Test Plan
 
-Translator and e2e tests are added to ensure correct sorting of routes based on weights and standard precedence rules.
+Unit tests and translator tests will be added to ensure correct sorting of routes based on weights and standard precedence rules.
 
 ## Alternatives
 
diff --git a/design/11584.md b/design/11584.md
deleted file mode 100644
index 9246fc6f6..000000000
--- a/design/11584.md
+++ /dev/null
@@ -1,53 +0,0 @@
-# EP-11584: Global Policy Attachment using targetSelectors
-
-
-* Issue: [#11584](https://github.com/kgateway-dev/kgateway/issues/11584)
-
-
-## Background
-
-Currently, resources (such as `HTTPRoutes`) can only attach to targeting policies defined in the same namespace. This requirement can be limiting in scenarios where policies need to be attachable across multiple application namespace.
-
-## Motivation
-
-Provide the ability to:
-1. Define policies that are meant to be applicable to multiple namespaces to be defined in a single well known namespace.
-1. Use `targetSelectors` to attach such policies to arbitrary resources defined in any namespace.
-1. Allow resources (such as `HTTPRoutes`) to attach to such policies defined in the well known namespace using labels, enabling a more centralized policy management approach.
-
-## Goals
-
-- Preserve same-namespace policy attachment as the default behavior.
-- Enable cross-namespace global policy attachment using `KGW_GLOBAL_POLICY_NAMESPACE` environment variable.
-
-## Non-Goals
-
-- Cross-namespace policy attachment with `targetRefs`.
-
-## Implementation Details
-
-### Feature Enablement
-
-This feature is disabled by default and can be enabled by setting the `KGW_GLOBAL_POLICY_NAMESPACE` environment variable to the namespace where global policies reside.
-
-### Example Behavior
-
-When the feature is enabled with `KGW_GLOBAL_POLICY_NAMESPACE=kgateway-system`, the [configuration](/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/label_based.yaml) enables the `HTTPRoute` `example-route` in the `infra` namespace to attach to the `TrafficPolicy` `global-policy` in the `kgateway-system` namespace.
-
-### Test Plan
-
-Translator and e2e tests are added to ensure cross-namespace policy attachment works with a global policy namespace.
-
-## Alternatives
-
-### 1. Implicitly enable cross-namespace policy attachment
-- **Pros**: Simpler UX.
-- **Cons**: Performance degradation at scale.
-
-### 2. Add namespace to targetSelectors
-- **Pros**: Targeting namespace is explicit.
-- **Cons**: Violates standard policy attachment API, performance degradation at scale.
-
-## Open Questions
-
-n/a
diff --git a/design/resources/deployer-current-implementation.png b/design/resources/deployer-current-implementation.png
deleted file mode 100644
index 5b386973d..000000000
Binary files a/design/resources/deployer-current-implementation.png and /dev/null differ
diff --git a/design/resources/deployer-proposed-changes.png b/design/resources/deployer-proposed-changes.png
deleted file mode 100644
index 0249fb1ea..000000000
Binary files a/design/resources/deployer-proposed-changes.png and /dev/null differ
diff --git a/devel/testing/gateway-translator-tests.md b/devel/testing/gateway-translator-tests.md
deleted file mode 100644
index a4c87fa9a..000000000
--- a/devel/testing/gateway-translator-tests.md
+++ /dev/null
@@ -1,129 +0,0 @@
-# Gateway Translator Tests Guide
-
-This guide explains how to work with gateway translator tests in kgateway, including creating new test cases, managing golden files, and troubleshooting common issues.
-
-## Overview
-
-Gateway translator tests validate that Gateway API resources (Gateways, HTTPRoutes, etc.) are correctly translated into Envoy xDS configuration. These tests use a "golden file" approach where expected outputs are stored as files and compared against actual test results.
-
-## Test Structure
-
-Gateway translator tests are located in:
-
-- **Test file**: `/internal/kgateway/translator/gateway/gateway_translator_test.go`
-- **Input files**: `/internal/kgateway/translator/gateway/testutils/inputs/`
-- **Expected outputs**: `/internal/kgateway/translator/gateway/testutils/outputs/`
-
-### Test Case Structure
-
-Test case follows this pattern:
-
-```go
-Entry("Test description", translatorTestCase{
-    inputFile:  "subfolder/input-file.yaml",      // Input YAML with K8s resources
-    outputFile: "subfolder/expected-output.yaml", // Expected Envoy configuration
-    gwNN: types.NamespacedName{                   // Gateway to test
-        Namespace: "default",
-        Name:      "example-gateway",
-    },
-    assertReports: func(gwNN types.NamespacedName, reportsMap reports.ReportMap) {
-        // Optional: Custom assertions for status reports
-    },
-}),
-```
-
-## Adding a New Test Case
-
-### Step 1: Create Input Files
-
-1. Navigate to `/internal/kgateway/translator/gateway/testutils/inputs/`
-2. Create a new subfolder for your test (e.g., `backendconfigpolicy/`)
-3. Create a YAML file with your Kubernetes resources:
-
-### Step 2: Add Test Entry
-
-Add your test case to `gateway_translator_test.go`:
-
-```go
-Entry("Backend Config Policy with TLS and SAN verification", translatorTestCase{
-    inputFile:  "backendconfigpolicy/tls-san.yaml",
-    outputFile: "backendconfigpolicy/tls-san.yaml",
-    gwNN: types.NamespacedName{
-        Namespace: "default",
-        Name:      "example-gateway",
-    },
-}),
-```
-
-### Step 3: Run the Test
-
-Run your specific test to generate the golden file:
-
-#### Using Make (Recommended)
-
-```bash
-# Run specific test with make
-REFRESH_GOLDEN=true GINKGO_USER_FLAGS="--focus='TLS and SAN' --fail-on-pending=false" make test TEST_PKG=./internal/kgateway/translator/gateway
-```
-
-#### Using Go Test Directly
-
-```bash
-# Run specific test with go test directly
-REFRESH_GOLDEN=true go test ./internal/kgateway/translator/gateway -v -ginkgo.focus="TLS and SAN"
-```
-
-**Note**: The `REFRESH_GOLDEN=true` environment variable is required to generate golden files. Without it, the test will fail if no expected output file exists.
-
-The test framework will automatically create the expected output file if it doesn't exist.
-
-## Working with Golden Files
-
-### What are Golden Files?
-
-Golden files contain the expected Envoy xDS configuration that should be generated from your input. They serve as the "gold standard" for test validation.
-
-### Automatic Generation
-
-When you run a test for the first time, if no output file exists, the framework automatically:
-
-1. Runs the translation
-2. Captures the actual output
-3. Saves it as the expected output file
-4. Marks the test as passing
-
-### Manual Regeneration
-
-To update golden files (when you've made changes to the translator):
-
-```bash
-# Regenerate all golden files using make
-REFRESH_GOLDEN=true make test TEST_PKG=./internal/kgateway/translator/gateway
-
-# Regenerate all golden files using go test
-REFRESH_GOLDEN=true go test ./internal/kgateway/translator/gateway -v
-
-# Regenerate specific test using make
-REFRESH_GOLDEN=true GINKGO_USER_FLAGS="--focus='TLS and SAN' --fail-on-pending=false" make test TEST_PKG=./internal/kgateway/translator/gateway
-
-# Regenerate specific test using go test
-REFRESH_GOLDEN=true go test ./internal/kgateway/translator/gateway -v -ginkgo.focus="TLS and SAN"
-```
-
-### Common Ginkgo Focus Patterns
-
-- Focus on specific test: `--focus="exact test name"`
-- Focus on test category: `--focus="Backend Config Policy"`
-- Focus with regex: `--focus="TLS.*SAN"`
-- Skip tests: `--skip="azure"`
-
-## Examples
-
-See existing tests for reference:
-
-- Basic HTTP routing: `testutils/inputs/http-routing/`
-- TLS configuration: `testutils/inputs/backendconfigpolicy/tls-san.yaml`
-- Traffic policies: `testutils/inputs/traffic-policy/`
-- Error cases: `testutils/inputs/http-routing-invalid-backend/`
-
-This testing approach ensures that Gateway API resources are correctly translated to Envoy configuration and helps prevent regressions as the codebase evolves.
diff --git a/go.mod b/go.mod
index d1bca6afa..a2db01d95 100644
--- a/go.mod
+++ b/go.mod
@@ -5,6 +5,7 @@ go 1.24.4
 require (
 	github.com/avast/retry-go v2.4.3+incompatible
 	github.com/avast/retry-go/v4 v4.3.3
+	github.com/caarlos0/log v0.4.6
 	github.com/cncf/xds/go v0.0.0-20250121191232-2f005788dc42
 	github.com/envoyproxy/go-control-plane v0.13.5-0.20250507123352-93990c5ec02f
 	github.com/envoyproxy/go-control-plane/contrib v1.32.5-0.20250507123352-93990c5ec02f
@@ -21,6 +22,7 @@ require (
 	github.com/mitchellh/hashstructure v1.0.0
 	github.com/onsi/ginkgo/v2 v2.23.3
 	github.com/onsi/gomega v1.37.0
+	github.com/pkg/errors v0.9.1
 	github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966
 	github.com/solo-io/go-list-licenses v0.1.4
 	github.com/solo-io/go-utils v0.27.3
@@ -57,14 +59,12 @@ require (
 	github.com/a8m/envsubst v1.4.3 // indirect
 	github.com/alecthomas/chroma/v2 v2.17.2 // indirect
 	github.com/alecthomas/participle/v2 v2.1.4 // indirect
-	github.com/caarlos0/log v0.4.6 // indirect
 	github.com/dlclark/regexp2 v1.11.5 // indirect
 	github.com/elliotchance/orderedmap v1.8.0 // indirect
 	github.com/goccy/go-yaml v1.17.1 // indirect
 	github.com/jinzhu/copier v0.4.0 // indirect
 	github.com/manuelarte/funcorder v0.2.1 // indirect
 	github.com/mikefarah/yq/v4 v4.45.4 // indirect
-	github.com/pkg/errors v0.9.1 // indirect
 	github.com/rotisserie/eris v0.5.4 // indirect
 	github.com/yuin/gopher-lua v1.1.1 // indirect
 	go.augendre.info/fatcontext v0.8.0 // indirect
@@ -96,8 +96,8 @@ require (
 	github.com/Antonboom/nilnil v1.1.0 // indirect
 	github.com/Antonboom/testifylint v1.6.1 // indirect
 	github.com/Azure/azure-sdk-for-go v68.0.0+incompatible // indirect
-	github.com/Azure/azure-sdk-for-go/sdk/azcore v1.14.0 // indirect
-	github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.7.0 // indirect
+	github.com/Azure/azure-sdk-for-go/sdk/azcore v1.16.0 // indirect
+	github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.0 // indirect
 	github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0 // indirect
 	github.com/Azure/azure-sdk-for-go/sdk/keyvault/azkeys v0.10.0 // indirect
 	github.com/Azure/azure-sdk-for-go/sdk/keyvault/internal v0.7.1 // indirect
@@ -562,7 +562,7 @@ require (
 	go.opentelemetry.io/otel/sdk v1.34.0 // indirect
 	go.opentelemetry.io/otel/sdk/metric v1.34.0 // indirect
 	go.opentelemetry.io/otel/trace v1.34.0 // indirect
-	go.opentelemetry.io/proto/otlp v1.6.0
+	go.opentelemetry.io/proto/otlp v1.6.0 // indirect
 	go.uber.org/atomic v1.11.0 // indirect
 	go.uber.org/automaxprocs v1.6.0 // indirect
 	go.uber.org/multierr v1.11.0 // indirect
@@ -616,7 +616,11 @@ require (
 // Remove once https://github.com/kubernetes-sigs/controller-tools/pull/1224 merges
 replace sigs.k8s.io/controller-tools => github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132
 
-replace github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
+replace (
+	// TODO: replace once https://github.com/agentgateway/agentgateway/pull/157/ merges
+	github.com/agentgateway/agentgateway => github.com/howardjohn/agentgateway v0.0.0-20250709153329-b02466b38629
+	github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
+)
 
 // Use a patched version of gengo to produce consistent zz_generated.openapi.go
 // Ref: https://github.com/kubernetes/gengo/issues/292
diff --git a/go.sum b/go.sum
index a314c8192..d3cf80593 100644
--- a/go.sum
+++ b/go.sum
@@ -104,10 +104,12 @@ github.com/Antonboom/testifylint v1.6.1 h1:6ZSytkFWatT8mwZlmRCHkWz1gPi+q6UBSbiej
 github.com/Antonboom/testifylint v1.6.1/go.mod h1:k+nEkathI2NFjKO6HvwmSrbzUcQ6FAnbZV+ZRrnXPLI=
 github.com/Azure/azure-sdk-for-go v68.0.0+incompatible h1:fcYLmCpyNYRnvJbPerq7U0hS+6+I79yEDJBqVNcqUzU=
 github.com/Azure/azure-sdk-for-go v68.0.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=
-github.com/Azure/azure-sdk-for-go/sdk/azcore v1.14.0 h1:nyQWyZvwGTvunIMxi1Y9uXkcyr+I7TeNrr/foo4Kpk8=
-github.com/Azure/azure-sdk-for-go/sdk/azcore v1.14.0/go.mod h1:l38EPgmsp71HHLq9j7De57JcKOWPyhrsW1Awm1JS6K0=
-github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.7.0 h1:tfLQ34V6F7tVSwoTf/4lH5sE0o6eCJuNDTmH09nDpbc=
-github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.7.0/go.mod h1:9kIvujWAA58nmPmWB1m23fyWic1kYZMxD9CxaWn4Qpg=
+github.com/Azure/azure-sdk-for-go/sdk/azcore v1.16.0 h1:JZg6HRh6W6U4OLl6lk7BZ7BLisIzM9dG1R50zUk9C/M=
+github.com/Azure/azure-sdk-for-go/sdk/azcore v1.16.0/go.mod h1:YL1xnZ6QejvQHWJrX/AvhFl4WW4rqHVoKspWNVwFk0M=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.0 h1:B/dfvscEQtew9dVuoxqxrUKKv8Ih2f55PydknDamU+g=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.0/go.mod h1:fiPSssYvltE08HJchL04dOy+RD4hgrjph0cwGGMntdI=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity/cache v0.3.0 h1:+m0M/LFxN43KvULkDNfdXOgrjtg6UYJPFBJyuEcRCAw=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity/cache v0.3.0/go.mod h1:PwOyop78lveYMRs6oCxjiVyBdyCgIYH6XHIVZO9/SFQ=
 github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0 h1:ywEEhmNahHBihViHepv3xPBn1663uRv2t2q/ESv9seY=
 github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0/go.mod h1:iZDifYGJTIgIIkYRNWPENUnqx6bJ2xnSDFI2tjwZNuY=
 github.com/Azure/azure-sdk-for-go/sdk/keyvault/azkeys v0.10.0 h1:m/sWOGCREuSBqg2htVQTBY8nOZpyajYztF0vUvSZTuM=
@@ -149,6 +151,8 @@ github.com/Azure/go-autorest/logger v0.2.1 h1:IG7i4p/mDa2Ce4TRyAO8IHnVhAVF3RFU+Z
 github.com/Azure/go-autorest/logger v0.2.1/go.mod h1:T9E3cAhj2VqvPOtCYAvby9aBXkZmbF5NWuPV8+WeEW8=
 github.com/Azure/go-autorest/tracing v0.6.0 h1:TYi4+3m5t6K48TGI9AUdb+IzbnSxvnvUMfuitfgcfuo=
 github.com/Azure/go-autorest/tracing v0.6.0/go.mod h1:+vhtPC754Xsa23ID7GlGsrdKBpUA79WCAKPPZVC2DeU=
+github.com/AzureAD/microsoft-authentication-extensions-for-go/cache v0.1.1 h1:WJTmL004Abzc5wDB5VtZG2PJk5ndYDgVacGqfirKxjM=
+github.com/AzureAD/microsoft-authentication-extensions-for-go/cache v0.1.1/go.mod h1:tCcJZ0uHAmvjsVYzEFivsRTN00oz5BEsRgQHu5JZ9WE=
 github.com/AzureAD/microsoft-authentication-library-for-go v1.2.2 h1:XHOnouVk1mxXfQidrMEnLlPk9UMeRtyBTnEFtxkV0kU=
 github.com/AzureAD/microsoft-authentication-library-for-go v1.2.2/go.mod h1:wP83P5OoQ5p6ip3ScPr0BAq0BvuPAvacpEuSzyouqAI=
 github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
@@ -214,8 +218,6 @@ github.com/a8m/envsubst v1.4.3 h1:kDF7paGK8QACWYaQo6KtyYBozY2jhQrTuNNuUxQkhJY=
 github.com/a8m/envsubst v1.4.3/go.mod h1:4jjHWQlZoaXPoLQUb7H2qT4iLkZDdmEQiOUogdUmqVU=
 github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d h1:licZJFw2RwpHMqeKTCYkitsPqHNxTmd4SNR5r94FGM8=
 github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d/go.mod h1:asat636LX7Bqt5lYEZ27JNDcqxfjdBQuJ/MM4CN/Lzo=
-github.com/agentgateway/agentgateway v0.4.31-0.20250519135723-61536c2b3fa0 h1:4THComsdsccCKRdO3lFinPZId6/ISSk6ijEiO44KJps=
-github.com/agentgateway/agentgateway v0.4.31-0.20250519135723-61536c2b3fa0/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/alcortesm/tgz v0.0.0-20161220082320-9c5fe88206d7/go.mod h1:6zEj6s6u/ghQa61ZWa/C2Aw3RkjiTBOix7dkqa1VLIs=
 github.com/alecthomas/assert/v2 v2.11.0 h1:2Q9r3ki8+JYXvGsDyBXwH3LcJ+WK5D0gc5E8vS6K3D0=
 github.com/alecthomas/assert/v2 v2.11.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=
@@ -1059,6 +1061,8 @@ github.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUq
 github.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=
 github.com/hinshun/vt10x v0.0.0-20180616224451-1954e6464174/go.mod h1:DqJ97dSdRW1W22yXSB90986pcOyQ7r45iio1KN2ez1A=
 github.com/hinshun/vt10x v0.0.0-20180809195222-d55458df857c/go.mod h1:DqJ97dSdRW1W22yXSB90986pcOyQ7r45iio1KN2ez1A=
+github.com/howardjohn/agentgateway v0.0.0-20250709153329-b02466b38629 h1:48Q9oTh15xO862CTafbgz6osutPS0ZWIhJ1fOIhqgM8=
+github.com/howardjohn/agentgateway v0.0.0-20250709153329-b02466b38629/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
 github.com/huandu/xstrings v1.5.0 h1:2ag3IFq9ZDANvthTwTiqSSZLjDc+BedvHPAp5tJy2TI=
 github.com/huandu/xstrings v1.5.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
@@ -1161,6 +1165,8 @@ github.com/kelseyhightower/envconfig v1.4.0/go.mod h1:cccZRl6mQpaq41TPp5QxidR+Sa
 github.com/kevinburke/ssh_config v0.0.0-20180830205328-81db2a75821e/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=
 github.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=
 github.com/kevinburke/ssh_config v1.2.0/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=
+github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6 h1:IsMZxCuZqKuao2vNdfD82fjjgPLfyHLpR41Z88viRWs=
+github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6/go.mod h1:3VeWNIJaW+O5xpRQbPp0Ybqu1vJd/pm7s2F473HRrkw=
 github.com/kgateway-dev/gengo/v2 v2.0.0-20250512195215-4fa0a9df2978 h1:UHfLeZ4Sj1OBRE4V4nSlanqC1FQnT2bg1vnu4N24Scw=
 github.com/kgateway-dev/gengo/v2 v2.0.0-20250512195215-4fa0a9df2978/go.mod h1:EJykeLsmFC60UQbYJezXkEsG2FLrt0GPNkU5iK5GWxU=
 github.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=
diff --git a/hack/kind/setup-kind.sh b/hack/kind/setup-kind.sh
index 14c2b46ac..99d1c8546 100755
--- a/hack/kind/setup-kind.sh
+++ b/hack/kind/setup-kind.sh
@@ -60,6 +60,8 @@ if [[ $SKIP_DOCKER == 'true' ]]; then
   # TODO(tim): refactor the Makefile & CI scripts so we're loading local
   # charts to real helm repos, and then we can remove this block.
   echo "SKIP_DOCKER=true, not building images or chart"
+  $HELM repo add gloo https://storage.googleapis.com/solo-public-helm
+  $HELM repo update
 else
   # 2. Make all the docker images and load them to the kind cluster
   VERSION=$VERSION CLUSTER_NAME=$CLUSTER_NAME make kind-build-and-load
diff --git a/hack/utils/oss_compliance/osa_provided.md b/hack/utils/oss_compliance/osa_provided.md
index 03cb653be..74a2b7316 100644
--- a/hack/utils/oss_compliance/osa_provided.md
+++ b/hack/utils/oss_compliance/osa_provided.md
@@ -1,8 +1,9 @@
 Name|Version|License
 ---|---|---
-[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.4.31-0.20250519135723-61536c2b3fa0|Apache License 2.0
+[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.0.0-20250709153329-b02466b38629|Apache License 2.0
 [avast/retry-go](https://github.com/avast/retry-go)|v2.4.3+incompatible|MIT License
 [retry-go/v4](https://github.com/avast/retry-go)|v4.3.3|MIT License
+[caarlos0/log](https://github.com/caarlos0/log)|v0.4.6|MIT License
 [xds/go](https://github.com/cncf/xds)|v0.0.0-20250121191232-2f005788dc42|Apache License 2.0
 [envoyproxy/go-control-plane](https://github.com/envoyproxy/go-control-plane)|v0.13.5-0.20250507123352-93990c5ec02f|Apache License 2.0
 [go-control-plane/contrib](https://github.com/envoyproxy/go-control-plane)|v1.32.5-0.20250507123352-93990c5ec02f|Apache License 2.0
@@ -18,13 +19,13 @@ Name|Version|License
 [mitchellh/hashstructure](https://github.com/mitchellh/hashstructure)|v1.0.0|MIT License
 [ginkgo/v2](https://github.com/onsi/ginkgo)|v2.23.3|MIT License
 [onsi/gomega](https://github.com/onsi/gomega)|v1.37.0|MIT License
+[pkg/errors](https://github.com/pkg/errors)|v0.9.1|BSD 2-clause "Simplified" License
 [prometheus/client_golang](https://github.com/prometheus/client_golang)|v1.22.0|Apache License 2.0
 [prometheus/client_model](https://github.com/prometheus/client_model)|v0.6.2|Apache License 2.0
 [spf13/afero](https://github.com/spf13/afero)|v1.14.0|Apache License 2.0
 [spf13/cobra](https://github.com/spf13/cobra)|v1.9.1|Apache License 2.0
 [stretchr/testify](https://github.com/stretchr/testify)|v1.10.0|MIT License
 [go.opencensus.io](https://go.opencensus.io)|v0.24.0|Apache License 2.0
-[proto/otlp](https://go.opentelemetry.io/proto/otlp)|v1.6.0|Apache License 2.0
 [go.uber.org/zap](https://go.uber.org/zap)|v1.27.0|MIT License
 [x/exp](https://golang.org/x/exp)|v0.0.0-20241215155358-4a5509556b9e|BSD 3-clause "New" or "Revised" License
 [x/net](https://golang.org/x/net)|v0.41.0|BSD 3-clause "New" or "Revised" License
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
index 89fc956bd..f27b83901 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
@@ -135,20 +135,12 @@ spec:
                     - type: string
                     pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                     x-kubernetes-int-or-string: true
-                    x-kubernetes-validations:
-                    - message: InitialConnectionWindowSize must be between 65535 and
-                        2147483647 bytes (inclusive)
-                      rule: quantity(self).isGreaterThan(quantity('65534')) && quantity(self).isLessThan(quantity('2147483648'))
                   initialStreamWindowSize:
                     anyOf:
                     - type: integer
                     - type: string
                     pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                     x-kubernetes-int-or-string: true
-                    x-kubernetes-validations:
-                    - message: InitialStreamWindowSize must be between 65535 and 2147483647
-                        bytes (inclusive)
-                      rule: quantity(self).isGreaterThan(quantity('65534')) && quantity(self).isLessThan(quantity('2147483648'))
                   maxConcurrentStreams:
                     type: integer
                   overrideStreamErrorOnInvalidHttpMessage:
@@ -266,11 +258,6 @@ spec:
                 maxItems: 16
                 minItems: 1
                 type: array
-                x-kubernetes-validations:
-                - message: TargetRefs must reference either a Kubernetes Service or
-                    a Backend API
-                  rule: self.all(r, (r.group == '' && r.kind == 'Service') || (r.group
-                    == 'gateway.kgateway.dev' && r.kind == 'Backend'))
               targetSelectors:
                 items:
                   properties:
@@ -293,11 +280,6 @@ spec:
                   - matchLabels
                   type: object
                 type: array
-                x-kubernetes-validations:
-                - message: TargetSelectors must reference either a Kubernetes Service
-                    or a Backend API
-                  rule: self.all(r, (r.group == '' && r.kind == 'Service') || (r.group
-                    == 'gateway.kgateway.dev' && r.kind == 'Backend'))
               tcpKeepalive:
                 properties:
                   keepAliveInterval:
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
index d49ec65d6..60cd8ef36 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
@@ -456,45 +456,6 @@ spec:
                               type: object
                             type: array
                         type: object
-                      tracing:
-                        properties:
-                          endpoint:
-                            maxLength: 253
-                            minLength: 1
-                            pattern: ^(([^:/?#]+):)(//([^/?#]*))([^?#]*)(\?([^#]*))?(#(.*))?
-                            type: string
-                          protocol:
-                            enum:
-                            - grpc
-                            - http/protobuf
-                            - http/json
-                            type: string
-                          sampler:
-                            properties:
-                              arg:
-                                pattern: ^0(\.\d+)?|1(\.0+)?$
-                                type: string
-                              type:
-                                enum:
-                                - alwaysOn
-                                - alwaysOff
-                                - traceidratio
-                                - parentbasedAlwaysOn
-                                - parentbasedAlwaysOff
-                                - parentbasedTraceidratio
-                                type: string
-                            type: object
-                          timeout:
-                            pattern: ^([0-9]{1,5}(h|m|s|ms)){1,4}$
-                            type: string
-                          transportSecurity:
-                            enum:
-                            - secure
-                            - insecure
-                            type: string
-                        required:
-                        - endpoint
-                        type: object
                     type: object
                   deployment:
                     properties:
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
index 938a9db90..3f229f3da 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
@@ -411,8 +411,6 @@ spec:
                           items:
                             type: string
                           type: array
-                        authority:
-                          type: string
                         backendRef:
                           properties:
                             group:
@@ -453,165 +451,12 @@ spec:
                           - message: Must have port for Service reference
                             rule: '(size(self.group) == 0 && self.kind == ''Service'')
                               ? has(self.port) : true'
-                        initialMetadata:
-                          items:
-                            properties:
-                              key:
-                                type: string
-                              value:
-                                type: string
-                            required:
-                            - key
-                            type: object
-                          type: array
                         logName:
                           type: string
-                        maxReceiveMessageLength:
-                          format: int32
-                          type: integer
-                        retryPolicy:
-                          properties:
-                            numRetries:
-                              format: int32
-                              type: integer
-                            retryBackOff:
-                              properties:
-                                baseInterval:
-                                  type: string
-                                maxInterval:
-                                  type: string
-                              required:
-                              - baseInterval
-                              type: object
-                          type: object
-                        skipEnvoyHeaders:
-                          type: boolean
-                        timeout:
-                          type: string
                       required:
                       - backendRef
                       - logName
                       type: object
-                    openTelemetry:
-                      properties:
-                        attributes:
-                          properties:
-                            values:
-                              items:
-                                properties:
-                                  key:
-                                    type: string
-                                  value:
-                                    maxProperties: 1
-                                    minProperties: 1
-                                    properties:
-                                      arrayValue:
-                                        items:
-                                          type: object
-                                          x-kubernetes-preserve-unknown-fields: true
-                                        type: array
-                                      kvListValue:
-                                        type: object
-                                        x-kubernetes-preserve-unknown-fields: true
-                                      stringValue:
-                                        type: string
-                                    type: object
-                                required:
-                                - key
-                                - value
-                                type: object
-                              type: array
-                          type: object
-                        body:
-                          type: string
-                        disableBuiltinLabels:
-                          type: boolean
-                        grpcService:
-                          properties:
-                            authority:
-                              type: string
-                            backendRef:
-                              properties:
-                                group:
-                                  default: ""
-                                  maxLength: 253
-                                  pattern: ^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
-                                  type: string
-                                kind:
-                                  default: Service
-                                  maxLength: 63
-                                  minLength: 1
-                                  pattern: ^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$
-                                  type: string
-                                name:
-                                  maxLength: 253
-                                  minLength: 1
-                                  type: string
-                                namespace:
-                                  maxLength: 63
-                                  minLength: 1
-                                  pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
-                                  type: string
-                                port:
-                                  format: int32
-                                  maximum: 65535
-                                  minimum: 1
-                                  type: integer
-                                weight:
-                                  default: 1
-                                  format: int32
-                                  maximum: 1000000
-                                  minimum: 0
-                                  type: integer
-                              required:
-                              - name
-                              type: object
-                              x-kubernetes-validations:
-                              - message: Must have port for Service reference
-                                rule: '(size(self.group) == 0 && self.kind == ''Service'')
-                                  ? has(self.port) : true'
-                            initialMetadata:
-                              items:
-                                properties:
-                                  key:
-                                    type: string
-                                  value:
-                                    type: string
-                                required:
-                                - key
-                                type: object
-                              type: array
-                            logName:
-                              type: string
-                            maxReceiveMessageLength:
-                              format: int32
-                              type: integer
-                            retryPolicy:
-                              properties:
-                                numRetries:
-                                  format: int32
-                                  type: integer
-                                retryBackOff:
-                                  properties:
-                                    baseInterval:
-                                      type: string
-                                    maxInterval:
-                                      type: string
-                                  required:
-                                  - baseInterval
-                                  type: object
-                              type: object
-                            skipEnvoyHeaders:
-                              type: boolean
-                            timeout:
-                              type: string
-                          required:
-                          - backendRef
-                          - logName
-                          type: object
-                      required:
-                      - grpcService
-                      type: object
                   type: object
                 maxItems: 16
                 type: array
@@ -647,10 +492,6 @@ spec:
                 maxItems: 16
                 minItems: 1
                 type: array
-                x-kubernetes-validations:
-                - message: targetRefs may only reference Gateway resources
-                  rule: self.all(r, r.kind == 'Gateway' && (!has(r.group) || r.group
-                    == 'gateway.networking.k8s.io'))
               targetSelectors:
                 items:
                   properties:
@@ -673,214 +514,6 @@ spec:
                   - matchLabels
                   type: object
                 type: array
-                x-kubernetes-validations:
-                - message: targetSelectors may only reference Gateway resources
-                  rule: self.all(r, r.kind == 'Gateway' && (!has(r.group) || r.group
-                    == 'gateway.networking.k8s.io'))
-              tracing:
-                properties:
-                  attributes:
-                    items:
-                      maxProperties: 2
-                      minProperties: 1
-                      properties:
-                        environment:
-                          properties:
-                            defaultValue:
-                              type: string
-                            name:
-                              type: string
-                          required:
-                          - name
-                          type: object
-                        literal:
-                          properties:
-                            value:
-                              type: string
-                          required:
-                          - value
-                          type: object
-                        metadata:
-                          properties:
-                            defaultValue:
-                              type: string
-                            kind:
-                              enum:
-                              - Request
-                              - Route
-                              - Cluster
-                              - Host
-                              type: string
-                            metadataKey:
-                              properties:
-                                key:
-                                  type: string
-                                path:
-                                  items:
-                                    properties:
-                                      key:
-                                        type: string
-                                    required:
-                                    - key
-                                    type: object
-                                  type: array
-                              required:
-                              - key
-                              - path
-                              type: object
-                          required:
-                          - kind
-                          - metadataKey
-                          type: object
-                        name:
-                          type: string
-                        requestHeader:
-                          properties:
-                            defaultValue:
-                              type: string
-                            name:
-                              type: string
-                          required:
-                          - name
-                          type: object
-                      required:
-                      - name
-                      type: object
-                    type: array
-                  clientSampling:
-                    format: int32
-                    maximum: 100
-                    minimum: 0
-                    type: integer
-                  maxPathTagLength:
-                    format: int32
-                    type: integer
-                  overallSampling:
-                    format: int32
-                    maximum: 100
-                    minimum: 0
-                    type: integer
-                  provider:
-                    maxProperties: 1
-                    minProperties: 1
-                    properties:
-                      openTelemetry:
-                        properties:
-                          grpcService:
-                            properties:
-                              authority:
-                                type: string
-                              backendRef:
-                                properties:
-                                  group:
-                                    default: ""
-                                    maxLength: 253
-                                    pattern: ^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
-                                    type: string
-                                  kind:
-                                    default: Service
-                                    maxLength: 63
-                                    minLength: 1
-                                    pattern: ^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$
-                                    type: string
-                                  name:
-                                    maxLength: 253
-                                    minLength: 1
-                                    type: string
-                                  namespace:
-                                    maxLength: 63
-                                    minLength: 1
-                                    pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
-                                    type: string
-                                  port:
-                                    format: int32
-                                    maximum: 65535
-                                    minimum: 1
-                                    type: integer
-                                  weight:
-                                    default: 1
-                                    format: int32
-                                    maximum: 1000000
-                                    minimum: 0
-                                    type: integer
-                                required:
-                                - name
-                                type: object
-                                x-kubernetes-validations:
-                                - message: Must have port for Service reference
-                                  rule: '(size(self.group) == 0 && self.kind == ''Service'')
-                                    ? has(self.port) : true'
-                              initialMetadata:
-                                items:
-                                  properties:
-                                    key:
-                                      type: string
-                                    value:
-                                      type: string
-                                  required:
-                                  - key
-                                  type: object
-                                type: array
-                              maxReceiveMessageLength:
-                                format: int32
-                                type: integer
-                              retryPolicy:
-                                properties:
-                                  numRetries:
-                                    format: int32
-                                    type: integer
-                                  retryBackOff:
-                                    properties:
-                                      baseInterval:
-                                        type: string
-                                      maxInterval:
-                                        type: string
-                                    required:
-                                    - baseInterval
-                                    type: object
-                                type: object
-                              skipEnvoyHeaders:
-                                type: boolean
-                              timeout:
-                                type: string
-                            required:
-                            - backendRef
-                            type: object
-                          resourceDetectors:
-                            items:
-                              maxProperties: 1
-                              minProperties: 1
-                              properties:
-                                environmentResourceDetector:
-                                  type: object
-                              type: object
-                            type: array
-                          sampler:
-                            maxProperties: 1
-                            minProperties: 1
-                            properties:
-                              alwaysOnConfig:
-                                type: object
-                            type: object
-                          serviceName:
-                            type: string
-                        required:
-                        - grpcService
-                        - serviceName
-                        type: object
-                    type: object
-                  randomSampling:
-                    format: int32
-                    maximum: 100
-                    minimum: 0
-                    type: integer
-                  spawnUpstreamSpan:
-                    type: boolean
-                  verbose:
-                    type: boolean
-                required:
-                - provider
-                type: object
               upgradeConfig:
                 properties:
                   enabledUpgrades:
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
index cf218cab8..51e1ce2f0 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
@@ -278,21 +278,6 @@ spec:
                     - CHAT_STREAMING
                     type: string
                 type: object
-              buffer:
-                properties:
-                  maxRequestSize:
-                    anyOf:
-                    - type: integer
-                    - type: string
-                    pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
-                    x-kubernetes-int-or-string: true
-                    x-kubernetes-validations:
-                    - message: maxRequestSize must be greater than 0 and less than
-                        4Gi
-                      rule: quantity(self).isGreaterThan(quantity('0')) && quantity(self).isLessThan(quantity('4Gi'))
-                required:
-                - maxRequestSize
-                type: object
               cors:
                 properties:
                   allowCredentials:
@@ -567,7 +552,6 @@ spec:
                           tokensPerFill:
                             default: 1
                             format: int32
-                            minimum: 1
                             type: integer
                         required:
                         - fillInterval
@@ -604,13 +588,6 @@ spec:
                 maxItems: 16
                 minItems: 1
                 type: array
-                x-kubernetes-validations:
-                - message: targetRefs may only reference Gateway, HTTPRoute, or XListenerSet
-                    resources
-                  rule: self.all(r, (r.kind == 'Gateway' || r.kind == 'HTTPRoute'
-                    || (r.kind == 'XListenerSet' && r.group == 'gateway.networking.x-k8s.io'))
-                    && (!has(r.group) || r.group == 'gateway.networking.k8s.io' ||
-                    r.group == 'gateway.networking.x-k8s.io'))
               targetSelectors:
                 items:
                   properties:
@@ -633,13 +610,6 @@ spec:
                   - matchLabels
                   type: object
                 type: array
-                x-kubernetes-validations:
-                - message: targetSelectors may only reference Gateway, HTTPRoute,
-                    or XListenerSet resources
-                  rule: self.all(r, (r.kind == 'Gateway' || r.kind == 'HTTPRoute'
-                    || (r.kind == 'XListenerSet' && r.group == 'gateway.networking.x-k8s.io'))
-                    && (!has(r.group) || r.group == 'gateway.networking.k8s.io' ||
-                    r.group == 'gateway.networking.x-k8s.io'))
               transformation:
                 properties:
                   request:
diff --git a/install/test/README.md b/install/test/README.md
new file mode 100644
index 000000000..6a5b494e5
--- /dev/null
+++ b/install/test/README.md
@@ -0,0 +1,3 @@
+# Running the Helm Test Suite
+- You will need to set the VERSION environment variable - this will need to be a valid semver ex: 1.0.0
+- When running locally, you can set the `renderers`' [`manifestOutputDir`](helm_suite_test.go) field to be the `debugOutputDir` const. This will store the test's rendered chart in the `_output/helm/charts` directory.
diff --git a/install/test/fixtures.go b/install/test/fixtures.go
new file mode 100644
index 000000000..f8b0a8382
--- /dev/null
+++ b/install/test/fixtures.go
@@ -0,0 +1,816 @@
+//go:build ignore
+
+package test
+
+var awsFmtString = `
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: "{{.PodName}}.{{.PodNamespace}}"
+  metadata:
+    # role's value is the key for the in-memory xds cache (projects/gloo/pkg/xds/envoy.go)
+    role: "gloo-system~gateway-proxy"
+static_resources:
+  listeners: # if or $statsConfig.enabled (or $spec.readConfig $spec.extraListenersHelper) # $spec.extraListenersHelper
+  - name: prometheus_listener
+    address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - name: envoy.filters.network.http_connection_manager
+        typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          stat_prefix: prometheus
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - name: prometheus_host
+              domains:
+              - "*"
+              routes:
+              - match:
+                  path: "/ready"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  prefix: "/metrics"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  prefix_rewrite: "/stats/prometheus?usedonly"
+                  cluster: admin_port_cluster
+          http_filters:
+          - name: envoy.filters.http.router # if $spec.tracing # if $statsConfig.enabled # if $spec.readConfig
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+  clusters:
+  - name: gloo.gloo-system.svc.cluster.local:9977
+    alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    http2_protocol_options: {}
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: rest_xds_cluster
+    alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: wasm-cache
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: aws_sts_cluster
+    connect_timeout: 5.000s
+    type: LOGICAL_DNS
+    lb_policy: ROUND_ROBIN
+    transport_socket:
+      name: envoy.transport_sockets.tls
+      typed_config:
+        "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
+        sni: sts.%samazonaws.com
+    load_assignment:
+      cluster_name: aws_sts_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                port_value: 443
+                address: sts.%samazonaws.com # if $.Values.settings.aws.enableServiceAccountCredentials
+  - name: admin_port_cluster
+    connect_timeout: 5.000s
+    type: STATIC
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000 # if or $statsConfig.enabled ($spec.readConfig)
+
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000 # if (empty $spec.configMap.data) ## allows full custom # range $name, $spec := .Values.gatewayProxies# if .Values.gateway.enabled
+`
+
+var confWithoutTracing = `
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: '{{.PodName}}.{{.PodNamespace}}'
+  metadata:
+    role: 'gloo-system~gateway-proxy'
+static_resources:
+  clusters:
+  - alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    http2_protocol_options: {}
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    name: gloo.gloo-system.svc.cluster.local:9977
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    name: rest_xds_cluster
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    name: wasm-cache
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 5.000s
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000
+    name: admin_port_cluster
+    type: STATIC
+  listeners:
+  - address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - domains:
+              - '*'
+              name: prometheus_host
+              routes:
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  path: /ready
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  prefix: /metrics
+                route:
+                  cluster: admin_port_cluster
+                  prefix_rewrite: /stats/prometheus?usedonly
+          stat_prefix: prometheus
+        name: envoy.filters.network.http_connection_manager
+    name: prometheus_listener
+`
+
+var confWithTracingCluster = `
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: '{{.PodName}}.{{.PodNamespace}}'
+  metadata:
+    role: 'gloo-system~gateway-proxy'
+static_resources:
+  clusters:
+  - alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    http2_protocol_options: {}
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    name: gloo.gloo-system.svc.cluster.local:9977
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    name: rest_xds_cluster
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    name: wasm-cache
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 1s
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: zipkin
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: zipkin
+                port_value: 1234
+    name: zipkin
+    respect_dns_ttl: true
+    type: STRICT_DNS
+  - connect_timeout: 5.000s
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000
+    name: admin_port_cluster
+    type: STATIC
+  listeners:
+  - address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - domains:
+              - '*'
+              name: prometheus_host
+              routes:
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  path: /ready
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  prefix: /metrics
+                route:
+                  cluster: admin_port_cluster
+                  prefix_rewrite: /stats/prometheus?usedonly
+          stat_prefix: prometheus
+        name: envoy.filters.network.http_connection_manager
+    name: prometheus_listener
+`
+
+var confWithReadConfig = `
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: '{{.PodName}}.{{.PodNamespace}}'
+  metadata:
+    role: 'gloo-system~gateway-proxy'
+static_resources:
+  clusters:
+  - alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    http2_protocol_options: {}
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    name: gloo.gloo-system.svc.cluster.local:9977
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    name: rest_xds_cluster
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    name: wasm-cache
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 5.000s
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000
+    name: admin_port_cluster
+    type: STATIC
+  listeners:
+  - address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - domains:
+              - '*'
+              name: prometheus_host
+              routes:
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  path: /ready
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  prefix: /metrics
+                route:
+                  cluster: admin_port_cluster
+                  prefix_rewrite: /stats/prometheus?usedonly
+          stat_prefix: prometheus
+        name: envoy.filters.network.http_connection_manager
+    name: prometheus_listener
+  - address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8082
+    filter_chains:
+    - filters:
+      - typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+          route_config:
+            name: read_config_route
+            virtual_hosts:
+            - domains:
+              - '*'
+              name: read_config_host
+              routes:
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  path: /ready
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  prefix: /stats
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  prefix: /config_dump
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  prefix: /clusters
+                route:
+                  cluster: admin_port_cluster
+          stat_prefix: read_config
+        name: envoy.filters.network.http_connection_manager
+    name: read_config_listener
+`
+
+var confWithAccessLogger = `
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: '{{.PodName}}.{{.PodNamespace}}'
+  metadata:
+    role: 'gloo-system~gateway-proxy'
+static_resources:
+  clusters:
+  - alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    http2_protocol_options: {}
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    name: gloo.gloo-system.svc.cluster.local:9977
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    name: rest_xds_cluster
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    name: wasm-cache
+    respect_dns_ttl: true
+    type: STRICT_DNS
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+  - connect_timeout: 5.000s
+    http2_protocol_options: {}
+    load_assignment:
+      cluster_name: access_log_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gateway-proxy-access-logger.gloo-system.svc.cluster.local
+                port_value: 8083
+    name: access_log_cluster
+    type: STRICT_DNS
+  - connect_timeout: 5.000s
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000
+    name: admin_port_cluster
+    type: STATIC
+  listeners:
+  - address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - domains:
+              - '*'
+              name: prometheus_host
+              routes:
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  path: /ready
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  headers:
+                  - exact_match: GET
+                    name: :method
+                  prefix: /metrics
+                route:
+                  cluster: admin_port_cluster
+                  prefix_rewrite: /stats/prometheus?usedonly
+          stat_prefix: prometheus
+        name: envoy.filters.network.http_connection_manager
+    name: prometheus_listener
+`
diff --git a/install/test/fixtures/envoy_config/bootstrap_extensions.yaml b/install/test/fixtures/envoy_config/bootstrap_extensions.yaml
new file mode 100644
index 000000000..544574f38
--- /dev/null
+++ b/install/test/fixtures/envoy_config/bootstrap_extensions.yaml
@@ -0,0 +1,154 @@
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: "{{.PodName}}.{{.PodNamespace}}"
+  metadata:
+    # role's value is the key for the in-memory xds cache (projects/gloo/pkg/xds/envoy.go)
+    role: "gloo-system~gateway-proxy"
+static_resources:
+  listeners:
+  - name: prometheus_listener
+    address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - name: envoy.filters.network.http_connection_manager
+        typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          stat_prefix: prometheus
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - name: prometheus_host
+              domains:
+              - "*"
+              routes:
+              - match:
+                  path: "/ready"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  prefix: "/metrics"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  prefix_rewrite: /stats/prometheus?usedonly
+                  cluster: admin_port_cluster
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+  clusters:
+  - name: gloo.gloo-system.svc.cluster.local:9977
+    alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    http2_protocol_options: {}
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: rest_xds_cluster
+    alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: wasm-cache
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: admin_port_cluster
+    connect_timeout: 5.000s
+    type: STATIC
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000
+
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+bootstrap_extensions:
+- name: envoy.wasm_service
+  typed_config:
+    '@type': type.googleapis.com/envoy.extensions.wasm.v3.WasmService
+    config:
+      name: my_plugin
+      vm_config:
+        code:
+          local:
+            filename: /etc/envoy_filter_http_wasm_example.wasm
+        runtime: envoy.wasm.runtime.v8
+    singleton: true
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
diff --git a/install/test/fixtures/envoy_config/custom_static_bootstrap.yaml b/install/test/fixtures/envoy_config/custom_static_bootstrap.yaml
new file mode 100644
index 000000000..ca35d3767
--- /dev/null
+++ b/install/test/fixtures/envoy_config/custom_static_bootstrap.yaml
@@ -0,0 +1,144 @@
+layered_runtime:
+  layers:
+    - name: static_layer
+      static_layer:
+        envoy.reloadable_features.strict_1xx_and_204_response_headers: false
+        envoy.reloadable_features.disable_tls_inspector_injection: false
+        overload:
+          global_downstream_max_connections: 250000
+        upstream:
+          healthy_panic_threshold:
+            value: 50
+    - name: admin_layer
+      admin_layer: {}
+node:
+  cluster: gateway
+  id: "{{.PodName}}.{{.PodNamespace}}"
+  metadata:
+    # role's value is the key for the in-memory xds cache (projects/gloo/pkg/xds/envoy.go)
+    role: "gloo-system~gateway-proxy"
+static_resources:
+  listeners:
+    - name: prometheus_listener
+      address:
+        socket_address:
+          address: 0.0.0.0
+          port_value: 8081
+      filter_chains:
+        - filters:
+            - name: envoy.filters.network.http_connection_manager
+              typed_config:
+                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+                codec_type: AUTO
+                stat_prefix: prometheus
+                route_config:
+                  name: prometheus_route
+                  virtual_hosts:
+                    - name: prometheus_host
+                      domains:
+                        - "*"
+                      routes:
+                        - match:
+                            path: "/ready"
+                            headers:
+                              - name: ":method"
+                                exact_match: GET
+                          route:
+                            cluster: admin_port_cluster
+                        - match:
+                            prefix: "/metrics"
+                            headers:
+                              - name: ":method"
+                                exact_match: GET
+                          route:
+                            prefix_rewrite: /stats/prometheus?usedonly
+                            cluster: admin_port_cluster
+                http_filters:
+                  - name: envoy.filters.http.router
+                    typed_config:
+                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+  clusters:
+    - name: gloo.gloo-system.svc.cluster.local:9977
+      alt_stat_name: xds_cluster
+      connect_timeout: 5.000s
+      load_assignment:
+        cluster_name: gloo.gloo-system.svc.cluster.local:9977
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: gloo.gloo-system.svc.cluster.local
+                      port_value: 9977
+      http2_protocol_options: {}
+      upstream_connection_options:
+        tcp_keepalive:
+          keepalive_time: 60
+      type: STRICT_DNS
+      respect_dns_ttl: true
+    - name: rest_xds_cluster
+      alt_stat_name: rest_xds_cluster
+      connect_timeout: 5.000s
+      load_assignment:
+        cluster_name: rest_xds_cluster
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: gloo.gloo-system.svc.cluster.local
+                      port_value: 9976
+      upstream_connection_options:
+        tcp_keepalive:
+          keepalive_time: 60
+      type: STRICT_DNS
+      respect_dns_ttl: true
+    - name: wasm-cache
+      connect_timeout: 5.000s
+      load_assignment:
+        cluster_name: wasm-cache
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: gloo.gloo-system.svc.cluster.local
+                      port_value: 9979
+      upstream_connection_options:
+        tcp_keepalive:
+          keepalive_time: 60
+      type: STRICT_DNS
+      respect_dns_ttl: true
+    - name: admin_port_cluster
+      connect_timeout: 5.000s
+      type: STATIC
+      lb_policy: ROUND_ROBIN
+      load_assignment:
+        cluster_name: admin_port_cluster
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: 127.0.0.1
+                      port_value: 19000
+
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+      - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
diff --git a/install/test/fixtures/envoy_config/overload_manager.yaml b/install/test/fixtures/envoy_config/overload_manager.yaml
new file mode 100644
index 000000000..56f6f0264
--- /dev/null
+++ b/install/test/fixtures/envoy_config/overload_manager.yaml
@@ -0,0 +1,147 @@
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: "{{.PodName}}.{{.PodNamespace}}"
+  metadata:
+    # role's value is the key for the in-memory xds cache (projects/gloo/pkg/xds/envoy.go)
+    role: "gloo-system~gateway-proxy"
+static_resources:
+  listeners:
+  - name: prometheus_listener
+    address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - name: envoy.filters.network.http_connection_manager
+        typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          stat_prefix: prometheus
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - name: prometheus_host
+              domains:
+              - "*"
+              routes:
+              - match:
+                  path: "/ready"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  prefix: "/metrics"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  prefix_rewrite: /stats/prometheus?usedonly
+                  cluster: admin_port_cluster
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+  clusters:
+  - name: gloo.gloo-system.svc.cluster.local:9977
+    alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    http2_protocol_options: {}
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: rest_xds_cluster
+    alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: wasm-cache
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: admin_port_cluster
+    connect_timeout: 5.000s
+    type: STATIC
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000
+
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+overload_manager:
+  refresh_interval: 2s
+  resource_monitors: []
+  actions: []
+  buffer_factory_config: {}
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
diff --git a/install/test/fixtures/envoy_config/static_clusters.yaml b/install/test/fixtures/envoy_config/static_clusters.yaml
new file mode 100644
index 000000000..a24db61b9
--- /dev/null
+++ b/install/test/fixtures/envoy_config/static_clusters.yaml
@@ -0,0 +1,155 @@
+layered_runtime:
+  layers:
+  - name: static_layer
+    static_layer:
+      overload:
+        global_downstream_max_connections: 250000
+      upstream:
+        healthy_panic_threshold:
+          value: 50
+  - name: admin_layer
+    admin_layer: {}
+node:
+  cluster: gateway
+  id: "{{.PodName}}.{{.PodNamespace}}"
+  metadata:
+    # role's value is the key for the in-memory xds cache (projects/gloo/pkg/xds/envoy.go)
+    role: "gloo-system~gateway-proxy"
+static_resources:
+  listeners:
+  - name: prometheus_listener
+    address:
+      socket_address:
+        address: 0.0.0.0
+        port_value: 8081
+    filter_chains:
+    - filters:
+      - name: envoy.filters.network.http_connection_manager
+        typed_config:
+          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+          codec_type: AUTO
+          stat_prefix: prometheus
+          route_config:
+            name: prometheus_route
+            virtual_hosts:
+            - name: prometheus_host
+              domains:
+              - "*"
+              routes:
+              - match:
+                  path: "/ready"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  cluster: admin_port_cluster
+              - match:
+                  prefix: "/metrics"
+                  headers:
+                  - name: ":method"
+                    exact_match: GET
+                route:
+                  prefix_rewrite: /stats/prometheus?usedonly
+                  cluster: admin_port_cluster
+          http_filters:
+          - name: envoy.filters.http.router
+            typed_config:
+              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+  clusters:
+  - name: gloo.gloo-system.svc.cluster.local:9977
+    alt_stat_name: xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: gloo.gloo-system.svc.cluster.local:9977
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9977
+    http2_protocol_options: {}
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: rest_xds_cluster
+    alt_stat_name: rest_xds_cluster
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: rest_xds_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9976
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: wasm-cache
+    connect_timeout: 5.000s
+    load_assignment:
+      cluster_name: wasm-cache
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: gloo.gloo-system.svc.cluster.local
+                port_value: 9979
+    upstream_connection_options:
+      tcp_keepalive:
+        keepalive_time: 60
+    type: STRICT_DNS
+    respect_dns_ttl: true
+  - name: admin_port_cluster
+    connect_timeout: 5.000s
+    type: STATIC
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: admin_port_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 19000
+  - connect_timeout: 5.000s
+    lb_policy: ROUND_ROBIN
+    load_assignment:
+      cluster_name: test_cluster
+      endpoints:
+      - lb_endpoints:
+        - endpoint:
+            address:
+              socket_address:
+                address: 127.0.0.1
+                port_value: 8080
+    name: test_cluster
+    type: STATIC
+
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+    - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
diff --git a/install/test/fixtures/envoy_config/tcp_keepalive.yaml b/install/test/fixtures/envoy_config/tcp_keepalive.yaml
new file mode 100644
index 000000000..989c1412a
--- /dev/null
+++ b/install/test/fixtures/envoy_config/tcp_keepalive.yaml
@@ -0,0 +1,142 @@
+layered_runtime:
+  layers:
+    - name: static_layer
+      static_layer:
+        overload:
+          global_downstream_max_connections: 250000
+        upstream:
+          healthy_panic_threshold:
+            value: 50
+    - name: admin_layer
+      admin_layer: {}
+node:
+  cluster: gateway
+  id: "{{.PodName}}.{{.PodNamespace}}"
+  metadata:
+    # role's value is the key for the in-memory xds cache (projects/gloo/pkg/xds/envoy.go)
+    role: "gloo-system~gateway-proxy"
+static_resources:
+  listeners:
+    - name: prometheus_listener
+      address:
+        socket_address:
+          address: 0.0.0.0
+          port_value: 8081
+      filter_chains:
+        - filters:
+            - name: envoy.filters.network.http_connection_manager
+              typed_config:
+                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
+                codec_type: AUTO
+                stat_prefix: prometheus
+                route_config:
+                  name: prometheus_route
+                  virtual_hosts:
+                    - name: prometheus_host
+                      domains:
+                        - "*"
+                      routes:
+                        - match:
+                            path: "/ready"
+                            headers:
+                              - name: ":method"
+                                exact_match: GET
+                          route:
+                            cluster: admin_port_cluster
+                        - match:
+                            prefix: "/metrics"
+                            headers:
+                              - name: ":method"
+                                exact_match: GET
+                          route:
+                            prefix_rewrite: /stats/prometheus?usedonly
+                            cluster: admin_port_cluster
+                http_filters:
+                  - name: envoy.filters.http.router
+                    typed_config:
+                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
+  clusters:
+    - name: gloo.gloo-system.svc.cluster.local:9977
+      alt_stat_name: xds_cluster
+      connect_timeout: 5.000s
+      load_assignment:
+        cluster_name: gloo.gloo-system.svc.cluster.local:9977
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: gloo.gloo-system.svc.cluster.local
+                      port_value: 9977
+      http2_protocol_options: {}
+      upstream_connection_options:
+        tcp_keepalive:
+          keepalive_time: 30
+      type: STRICT_DNS
+      respect_dns_ttl: true
+    - name: rest_xds_cluster
+      alt_stat_name: rest_xds_cluster
+      connect_timeout: 5.000s
+      load_assignment:
+        cluster_name: rest_xds_cluster
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: gloo.gloo-system.svc.cluster.local
+                      port_value: 9976
+      upstream_connection_options:
+        tcp_keepalive:
+          keepalive_time: 30
+      type: STRICT_DNS
+      respect_dns_ttl: true
+    - name: wasm-cache
+      connect_timeout: 5.000s
+      load_assignment:
+        cluster_name: wasm-cache
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: gloo.gloo-system.svc.cluster.local
+                      port_value: 9979
+      upstream_connection_options:
+        tcp_keepalive:
+          keepalive_time: 30
+      type: STRICT_DNS
+      respect_dns_ttl: true
+    - name: admin_port_cluster
+      connect_timeout: 5.000s
+      type: STATIC
+      lb_policy: ROUND_ROBIN
+      load_assignment:
+        cluster_name: admin_port_cluster
+        endpoints:
+          - lb_endpoints:
+              - endpoint:
+                  address:
+                    socket_address:
+                      address: 127.0.0.1
+                      port_value: 19000
+
+dynamic_resources:
+  ads_config:
+    transport_api_version: V3
+    api_type: GRPC
+    rate_limit_settings: {}
+    grpc_services:
+      - envoy_grpc: {cluster_name: gloo.gloo-system.svc.cluster.local:9977}
+  cds_config:
+    resource_api_version: V3
+    ads: {}
+  lds_config:
+    resource_api_version: V3
+    ads: {}
+admin:
+  access_log_path: /dev/null
+  address:
+    socket_address:
+      address: 127.0.0.1
+      port_value: 19000
diff --git a/install/test/fixtures/settings/compressed_proxy_spec.yaml b/install/test/fixtures/settings/compressed_proxy_spec.yaml
new file mode 100644
index 000000000..b981bd4ae
--- /dev/null
+++ b/install/test/fixtures/settings/compressed_proxy_spec.yaml
@@ -0,0 +1,37 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    compressedProxySpec: true
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/consul_config_upstream_discovery.yaml b/install/test/fixtures/settings/consul_config_upstream_discovery.yaml
new file mode 100644
index 000000000..3eb8f0947
--- /dev/null
+++ b/install/test/fixtures/settings/consul_config_upstream_discovery.yaml
@@ -0,0 +1,53 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    enableGatewayController: true
+    readGatewaysFromAllNamespaces: false
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  consulDiscovery:
+    useTlsTagging: true
+    tlsTagName: tag
+    splitTlsServices: true
+    rootCa:
+      name: testName
+      namespace: testNamespace
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/consul_config_values.yaml b/install/test/fixtures/settings/consul_config_values.yaml
new file mode 100644
index 000000000..3e2c1397c
--- /dev/null
+++ b/install/test/fixtures/settings/consul_config_values.yaml
@@ -0,0 +1,64 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    isolateVirtualHostsBySslConfig: false
+    enableGatewayController: true
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  consul:
+    datacenter: datacenter
+    username: user
+    password: password
+    token: aToken
+    caFile: testCaFile
+    caPath: testCaPath
+    certFile: testCertFile
+    keyFile: testKeyFile
+    insecureSkipVerify: true
+    waitTime: 12s
+    serviceDiscovery: 
+      dataCenters:
+        - dc1
+        - dc2
+    httpAddress: 1.2.3.4
+    dnsAddress: 5.6.7.8
+    dnsPollingInterval: 5s
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/disable_kubernetes_destinations.yaml b/install/test/fixtures/settings/disable_kubernetes_destinations.yaml
new file mode 100644
index 000000000..fab3570cd
--- /dev/null
+++ b/install/test/fixtures/settings/disable_kubernetes_destinations.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: true
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/disable_proxy_garbage_collection.yaml b/install/test/fixtures/settings/disable_proxy_garbage_collection.yaml
new file mode 100644
index 000000000..130e0931d
--- /dev/null
+++ b/install/test/fixtures/settings/disable_proxy_garbage_collection.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: true
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/disabled_gateway.yaml b/install/test/fixtures/settings/disabled_gateway.yaml
new file mode 100644
index 000000000..39434d93b
--- /dev/null
+++ b/install/test/fixtures/settings/disabled_gateway.yaml
@@ -0,0 +1,47 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: false
+    persistProxySpec: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      replaceInvalidRoutes: false
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/enable_default_credentials.yaml b/install/test/fixtures/settings/enable_default_credentials.yaml
new file mode 100644
index 000000000..78600d159
--- /dev/null
+++ b/install/test/fixtures/settings/enable_default_credentials.yaml
@@ -0,0 +1,48 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+    awsOptions:
+      enableCredentialsDiscovey: true
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/enable_rest_eds.yaml b/install/test/fixtures/settings/enable_rest_eds.yaml
new file mode 100644
index 000000000..a47add431
--- /dev/null
+++ b/install/test/fixtures/settings/enable_rest_eds.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/enable_rest_eds_and_gloo_mtls.yaml b/install/test/fixtures/settings/enable_rest_eds_and_gloo_mtls.yaml
new file mode 100644
index 000000000..23c9d5911
--- /dev/null
+++ b/install/test/fixtures/settings/enable_rest_eds_and_gloo_mtls.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: "127.0.0.1:9999"
+    restXdsBindAddr: "127.0.0.1:9998"
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/gateway_circuit_breakers.yaml b/install/test/fixtures/settings/gateway_circuit_breakers.yaml
new file mode 100644
index 000000000..2eb6c7756
--- /dev/null
+++ b/install/test/fixtures/settings/gateway_circuit_breakers.yaml
@@ -0,0 +1,51 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    circuitBreakers:
+      maxConnections: 1024
+      maxPendingRequests: 1024
+      maxRequests: 1024
+      maxRetries: 3
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      replaceInvalidRoutes: false
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/gateway_settings.yaml b/install/test/fixtures/settings/gateway_settings.yaml
new file mode 100644
index 000000000..54c889ef1
--- /dev/null
+++ b/install/test/fixtures/settings/gateway_settings.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      replaceInvalidRoutes: true
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/gateway_validation.yaml b/install/test/fixtures/settings/gateway_validation.yaml
new file mode 100644
index 000000000..5cc74a091
--- /dev/null
+++ b/install/test/fixtures/settings/gateway_validation.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: true
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: false
+      serverEnabled: true
+      disableTransformationValidation: true
+      warnRouteShortCircuiting: true
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      replaceInvalidRoutes: false
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/graphql_fds_disabled.yaml b/install/test/fixtures/settings/graphql_fds_disabled.yaml
new file mode 100644
index 000000000..3060c5282
--- /dev/null
+++ b/install/test/fixtures/settings/graphql_fds_disabled.yaml
@@ -0,0 +1,48 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+    fdsOptions:
+      graphqlEnabled: false
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      replaceInvalidRoutes: false
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/isolate_virtual_hosts_by_ssl_config.yaml b/install/test/fixtures/settings/isolate_virtual_hosts_by_ssl_config.yaml
new file mode 100644
index 000000000..64bbf1de0
--- /dev/null
+++ b/install/test/fixtures/settings/isolate_virtual_hosts_by_ssl_config.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: true
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/ratelimit_descriptors.yaml b/install/test/fixtures/settings/ratelimit_descriptors.yaml
new file mode 100644
index 000000000..65b3023a9
--- /dev/null
+++ b/install/test/fixtures/settings/ratelimit_descriptors.yaml
@@ -0,0 +1,53 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
+  ratelimit:
+    descriptors:
+      - key: generic_key
+        value: "per-second"
+        rateLimit:
+          requestsPerUnit: 2
+          unit: SECOND
diff --git a/install/test/fixtures/settings/ratelimit_server.yaml b/install/test/fixtures/settings/ratelimit_server.yaml
new file mode 100644
index 000000000..23530b281
--- /dev/null
+++ b/install/test/fixtures/settings/ratelimit_server.yaml
@@ -0,0 +1,53 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
+  ratelimitServer:
+    ratelimitServerRef:
+      name: ratelimit
+      namespace: ratelimitns
+    denyOnFail: true
+    rateLimitBeforeAuth: true
+    enableXRatelimitHeaders: true
diff --git a/install/test/fixtures/settings/read_gateways_from_all_namespaces.yaml b/install/test/fixtures/settings/read_gateways_from_all_namespaces.yaml
new file mode 100644
index 000000000..1002dae7f
--- /dev/null
+++ b/install/test/fixtures/settings/read_gateways_from_all_namespaces.yaml
@@ -0,0 +1,36 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: true
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/set_regex_max_program_size.yaml b/install/test/fixtures/settings/set_regex_max_program_size.yaml
new file mode 100644
index 000000000..01f674dd6
--- /dev/null
+++ b/install/test/fixtures/settings/set_regex_max_program_size.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    regexMaxProgramSize: 500
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/set_regex_max_program_size_default.yaml b/install/test/fixtures/settings/set_regex_max_program_size_default.yaml
new file mode 100644
index 000000000..c66028a38
--- /dev/null
+++ b/install/test/fixtures/settings/set_regex_max_program_size_default.yaml
@@ -0,0 +1,46 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    regexMaxProgramSize: 1024
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/set_secretSettings_in_settings.yaml b/install/test/fixtures/settings/set_secretSettings_in_settings.yaml
new file mode 100644
index 000000000..7ee6966be
--- /dev/null
+++ b/install/test/fixtures/settings/set_secretSettings_in_settings.yaml
@@ -0,0 +1,56 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  secretOptions:
+    sources:
+      - vault:
+          address: http://vault-internal.vault:8200
+          aws:
+            iamServerIdHeader: vault.gloo.example.com
+            mountPath: aws
+            leaseIncrement: 10
+            region: us-east-1
+          pathPrefix: dev
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/sts_discovery.yaml b/install/test/fixtures/settings/sts_discovery.yaml
new file mode 100644
index 000000000..30fc1a0c9
--- /dev/null
+++ b/install/test/fixtures/settings/sts_discovery.yaml
@@ -0,0 +1,52 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+    awsOptions:
+      serviceAccountCredentials:
+        cluster: aws_sts_cluster
+        uri: sts.us-east-2.amazonaws.com
+        region: us-east-2
+      propagateOriginalRouting: true
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/translate_empty_gateway.yaml b/install/test/fixtures/settings/translate_empty_gateway.yaml
new file mode 100644
index 000000000..2b65bf3b8
--- /dev/null
+++ b/install/test/fixtures/settings/translate_empty_gateway.yaml
@@ -0,0 +1,38 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    translateEmptyGateways: true
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
+ 
diff --git a/install/test/fixtures/settings/uds_disabled.yaml b/install/test/fixtures/settings/uds_disabled.yaml
new file mode 100644
index 000000000..61661c073
--- /dev/null
+++ b/install/test/fixtures/settings/uds_disabled.yaml
@@ -0,0 +1,48 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+    udsOptions:
+      enabled: false
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      replaceInvalidRoutes: false
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/fixtures/settings/watched_discovery_labels.yaml b/install/test/fixtures/settings/watched_discovery_labels.yaml
new file mode 100644
index 000000000..223f2788a
--- /dev/null
+++ b/install/test/fixtures/settings/watched_discovery_labels.yaml
@@ -0,0 +1,49 @@
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: {{ . }}
+spec:
+  discovery:
+    fdsMode: WHITELIST
+    udsOptions:
+      watchLabels:
+        A: B
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      proxyValidationServerAddr: gloo:9988
+      validationServerGrpcMaxSizeBytes: 104857600
+  gloo:
+    regexMaxProgramSize: 1024
+    enableRestEds: false
+    xdsBindAddr: 0.0.0.0:9977
+    restXdsBindAddr: 0.0.0.0:9976
+    proxyDebugBindAddr: 0.0.0.0:9966
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      replaceInvalidRoutes: false
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.
+      invalidRouteResponseCode: 404
+    istioOptions:
+     appendXForwardedHost: true
+     enableAutoMtls: false
+     enableIntegration: false
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+  discoveryNamespace: {{ . }}
diff --git a/install/test/grpc_json_transcoder_test.go b/install/test/grpc_json_transcoder_test.go
new file mode 100644
index 000000000..b08fc0dcd
--- /dev/null
+++ b/install/test/grpc_json_transcoder_test.go
@@ -0,0 +1,176 @@
+//go:build ignore
+
+package test
+
+import (
+	"encoding/base64"
+	"fmt"
+	"os"
+	"strconv"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/onsi/gomega/types"
+	. "github.com/solo-io/k8s-utils/manifesttestutils"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/gateway/pkg/defaults"
+	glootestutils "github.com/kgateway-dev/kgateway/v2/test/testutils"
+)
+
+var _ = Describe("GrpcJsonTranscoder helm test", func() {
+	var allTests = func(rendererTestCase renderTestCase) {
+
+		var (
+			testManifest    TestManifest
+			protoDescriptor = getExampleProtoDescriptor()
+
+			// Create a TestManifest out of the custom resource yaml from the configmap,
+			// and then perform assertions on the resources (which are assumed to all be Gateways).
+			// `matchers` is a map of Gateway name to the assertion to be made on that Gateway.
+			// There must be a matcher for every Gateway that's expected to be in the manifest.
+			assertCustomResourceManifest = func(matchers map[string]types.GomegaMatcher) {
+				configMap := getConfigMap(testManifest, namespace, customResourceConfigMapName)
+				ExpectWithOffset(1, configMap.Data).NotTo(BeNil())
+				customResourceYaml := configMap.Data["custom-resources"]
+				customResourceManifest := NewTestManifestFromYaml(customResourceYaml)
+				// make sure that the number of resources found in the manifest equals the number of
+				// matchers passed in, so we can ensure that every resource has an associated matcher
+				ExpectWithOffset(1, customResourceManifest.NumResources()).To(Equal(len(matchers)))
+				for gwName, matcher := range matchers {
+					customResourceManifest.ExpectUnstructured("Gateway", namespace, gwName).To(matcher)
+				}
+			}
+		)
+		prepareManifest := func(namespace string, values glootestutils.HelmValues) {
+			GinkgoHelper()
+			tm, err := rendererTestCase.renderer.RenderManifest(namespace, values)
+			Expect(err).NotTo(HaveOccurred(), "Failed to render manifest")
+			testManifest = tm
+		}
+
+		Context("protoDescriptorBin field", func() {
+			BeforeEach(func() {
+				prepareManifest(namespace, glootestutils.HelmValues{
+					ValuesArgs: []string{
+						fmt.Sprintf("gatewayProxies.gatewayProxy.gatewaySettings.customHttpGateway.options.grpcJsonTranscoder.protoDescriptorBin=%s", protoDescriptor),
+						fmt.Sprintf("gatewayProxies.gatewayProxy.gatewaySettings.customHttpsGateway.options.grpcJsonTranscoder.protoDescriptorBin=%s", protoDescriptor),
+					},
+				})
+			})
+			It("renders with the proto descriptor", func() {
+				gw := makeUnstructuredGatewayWithProtoDescriptorBin(namespace, "gateway-proxy", false)
+				gwSsl := makeUnstructuredGatewayWithProtoDescriptorBin(namespace, "gateway-proxy", true)
+				assertCustomResourceManifest(map[string]types.GomegaMatcher{
+					defaults.GatewayProxyName:                    BeEquivalentTo(gw),
+					getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+				})
+			})
+		})
+		Context("protoDescriptorConfigMap field", func() {
+			BeforeEach(func() {
+				prepareManifest(namespace, glootestutils.HelmValues{
+					ValuesArgs: []string{
+						"gatewayProxies.gatewayProxy.gatewaySettings.customHttpGateway.options.grpcJsonTranscoder.protoDescriptorConfigMap.configMapRef.name=my-config-map",
+						"gatewayProxies.gatewayProxy.gatewaySettings.customHttpGateway.options.grpcJsonTranscoder.protoDescriptorConfigMap.configMapRef.namespace=gloo-system",
+						"gatewayProxies.gatewayProxy.gatewaySettings.customHttpGateway.options.grpcJsonTranscoder.protoDescriptorConfigMap.key=my-key",
+						"gatewayProxies.gatewayProxy.gatewaySettings.customHttpsGateway.options.grpcJsonTranscoder.protoDescriptorConfigMap.configMapRef.name=my-config-map",
+						"gatewayProxies.gatewayProxy.gatewaySettings.customHttpsGateway.options.grpcJsonTranscoder.protoDescriptorConfigMap.configMapRef.namespace=gloo-system",
+						"gatewayProxies.gatewayProxy.gatewaySettings.customHttpsGateway.options.grpcJsonTranscoder.protoDescriptorConfigMap.key=my-key",
+						"global.configMaps[0].name=my-config-map",
+						"global.configMaps[0].namespace=gloo-system",
+						"global.configMaps[0].data.my-key=" + protoDescriptor,
+					},
+				})
+			})
+			It("renders with the proto descriptor", func() {
+				gw := makeUnstructuredGatewayWithProtoDescriptorConfigMap(namespace, "gateway-proxy", false)
+				gwSsl := makeUnstructuredGatewayWithProtoDescriptorConfigMap(namespace, "gateway-proxy", true)
+				assertCustomResourceManifest(map[string]types.GomegaMatcher{
+					defaults.GatewayProxyName:                    BeEquivalentTo(gw),
+					getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+				})
+			})
+		})
+	}
+
+	runTests(allTests)
+})
+
+//nolint:unparam // namespace always receives "gloo-system"
+func makeUnstructuredGatewayWithProtoDescriptorBin(namespace string, name string, ssl bool) *unstructured.Unstructured {
+	GinkgoHelper()
+
+	port := "8080"
+	gwName := name
+	if ssl {
+		port = "8443"
+		gwName = getSslGatewayName(name)
+	}
+
+	return makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  labels:
+    app: gloo
+  name: ` + gwName + `
+  namespace: ` + namespace + `
+spec:
+  bindAddress: '::'
+  bindPort: ` + port + `
+  httpGateway: 
+    options:
+      grpcJsonTranscoder: 
+        protoDescriptorBin: '` + getExampleProtoDescriptor() + `'
+  proxyNames:
+  - ` + name + `
+  ssl: ` + strconv.FormatBool(ssl) + `
+  useProxyProto: false
+`)
+}
+
+//nolint:unparam // namespace always receives "gloo-system"
+func makeUnstructuredGatewayWithProtoDescriptorConfigMap(namespace string, name string, ssl bool) *unstructured.Unstructured {
+	GinkgoHelper()
+
+	port := "8080"
+	gwName := name
+	if ssl {
+		port = "8443"
+		gwName = getSslGatewayName(name)
+	}
+
+	return makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  labels:
+    app: gloo
+  name: ` + gwName + `
+  namespace: ` + namespace + `
+spec:
+  bindAddress: '::'
+  bindPort: ` + port + `
+  httpGateway: 
+    options:
+      grpcJsonTranscoder: 
+        protoDescriptorConfigMap: 
+          configMapRef:
+            name: my-config-map
+            namespace: gloo-system
+          key: my-key
+  proxyNames:
+  - ` + name + `
+  ssl: ` + strconv.FormatBool(ssl) + `
+  useProxyProto: false
+`)
+}
+
+// return a base64-encoded proto descriptor to use for testing
+func getExampleProtoDescriptor() string {
+	pathToDescriptors := "../../test/v1helpers/test_grpc_service/descriptors/proto.pb"
+	bytes, err := os.ReadFile(pathToDescriptors)
+	Expect(err).NotTo(HaveOccurred())
+	return base64.StdEncoding.EncodeToString(bytes)
+}
diff --git a/install/test/helm_suite_test.go b/install/test/helm_suite_test.go
new file mode 100644
index 000000000..278fac5aa
--- /dev/null
+++ b/install/test/helm_suite_test.go
@@ -0,0 +1,228 @@
+//go:build ignore
+
+package test
+
+import (
+	"bytes"
+	"fmt"
+	"os"
+	"path/filepath"
+	"testing"
+	"text/template"
+
+	"github.com/ghodss/yaml"
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/pkg/errors"
+	soloHelm "github.com/solo-io/go-utils/helmutils"
+	"github.com/solo-io/go-utils/testutils"
+	"github.com/solo-io/k8s-utils/installutils/kuberesource"
+	. "github.com/solo-io/k8s-utils/manifesttestutils"
+	"helm.sh/helm/v3/pkg/action"
+	"helm.sh/helm/v3/pkg/chart/loader"
+	"helm.sh/helm/v3/pkg/release"
+	corev1 "k8s.io/api/core/v1"
+	rbacv1 "k8s.io/api/rbac/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/gloo/cli/pkg/cmd/install"
+	"github.com/kgateway-dev/kgateway/v2/internal/gloo/pkg/defaults"
+	"github.com/kgateway-dev/kgateway/v2/pkg/cliutil/helm"
+	"github.com/kgateway-dev/kgateway/v2/test/makefile"
+	glootestutils "github.com/kgateway-dev/kgateway/v2/test/testutils"
+)
+
+const (
+	namespace      = defaults.GlooSystem
+	releaseName    = "gloo"
+	chartDir       = "../helm/gloo"
+	debugOutputDir = "../../_output/helm/charts"
+
+	// the Gateway CR helm templates are stored as yaml in a configmap with this name
+	customResourceConfigMapName = "gloo-custom-resource-config"
+)
+
+var (
+	version    string
+	pullPolicy corev1.PullPolicy
+)
+
+func TestHelm(t *testing.T) {
+	RegisterFailHandler(Fail)
+	testutils.RegisterCommonFailHandlers()
+	RunSpecs(t, "Helm Suite")
+}
+
+var _ = BeforeSuite(func() {
+	version = makefile.MustGetVersion(".", "-C", "../../")
+	pullPolicy = corev1.PullIfNotPresent
+	// generate the values.yaml and Chart.yaml files
+	makefile.MustMake(".", "-C", "../../", "generate-helm-files", "-B")
+})
+
+type renderTestCase struct {
+	rendererName string
+	renderer     ChartRenderer
+}
+
+var renderers = []renderTestCase{
+	{"Helm 3", helm3Renderer{
+		chartDir:          chartDir,
+		manifestOutputDir: "", // set to the value of the const debugOutputDir when debugging locally
+	}},
+}
+
+func runTests(callback func(testCase renderTestCase)) {
+	for _, r := range renderers {
+		callback(r)
+	}
+}
+
+type ChartRenderer interface {
+	// returns a TestManifest containing all resources
+	RenderManifest(namespace string, values glootestutils.HelmValues) (TestManifest, error)
+}
+
+var _ ChartRenderer = &helm3Renderer{}
+
+type helm3Renderer struct {
+	chartDir string
+	// manifestOutputDir is a useful field to set when running tests locally
+	// it will output the generated manifest to a directory that you can easily
+	// inspect. If this value is an empty string, it will print the manifest to a temporary
+	// file and automatically clean it up.
+	manifestOutputDir string
+}
+
+func (h3 helm3Renderer) RenderManifest(namespace string, values glootestutils.HelmValues) (TestManifest, error) {
+	rel, err := buildHelm3Release(h3.chartDir, namespace, values)
+	if err != nil {
+		return nil, errors.Errorf("failure in buildHelm3Release: %s", err.Error())
+	}
+
+	// the test manifest utils can only read from a file
+	var testManifestFile *os.File
+
+	if h3.manifestOutputDir == "" {
+		testManifestFile, err = os.CreateTemp("", "*.yaml")
+		Expect(err).NotTo(HaveOccurred(), "Should be able to write a temp file for the helm unit test manifest")
+		defer func() {
+			_ = os.Remove(testManifestFile.Name())
+
+		}()
+	} else {
+		// Create a new file, with the version name, or truncate the file if one already exists
+		testManifestFile, err = os.Create(fmt.Sprintf("%s.yaml", filepath.Join(h3.manifestOutputDir, version)))
+		Expect(err).NotTo(HaveOccurred(), "Should be able to write a file to the manifestOutputDir for the helm unit test manifest")
+	}
+
+	_, err = testManifestFile.Write([]byte(rel.Manifest))
+	Expect(err).NotTo(HaveOccurred(), "Should be able to write the release manifest to the manifest file for the helm unit tests")
+
+	hooks, err := helm.GetHooks(rel.Hooks)
+	Expect(err).NotTo(HaveOccurred(), "Should be able to get the hooks in the helm unit test setup")
+
+	for _, hook := range hooks {
+		manifest := hook.Manifest
+		_, err = testManifestFile.Write([]byte("\n---\n" + manifest))
+		Expect(err).NotTo(HaveOccurred(), "Should be able to write the hook manifest to the manifest file for the helm unit tests")
+	}
+
+	err = testManifestFile.Close()
+	Expect(err).NotTo(HaveOccurred(), "Should be able to close the manifest file")
+
+	// check the manifest for lines that are not correctly parsed
+	manifestData, err := os.ReadFile(testManifestFile.Name())
+	Expect(err).ToNot(HaveOccurred())
+	windowsFound := soloHelm.FindHelmChartWhiteSpaces(string(manifestData), soloHelm.HelmDetectOptions{})
+	Expect(windowsFound).To(BeEmpty(), "Helm chart has parsing, white spacing, or formatting issues present")
+
+	return NewTestManifest(testManifestFile.Name()), nil
+}
+
+func buildHelm3Release(chartDir, namespace string, values glootestutils.HelmValues) (*release.Release, error) {
+	chartRequested, err := loader.Load(chartDir)
+	if err != nil {
+		return nil, errors.Errorf("failed to load chart directory: %s", err.Error())
+	}
+
+	helmValues, err := glootestutils.BuildHelmValues(values)
+	if err != nil {
+		return nil, errors.Errorf("failure in buildHelmValues: %s", err.Error())
+	}
+
+	// Validate that the provided values match the Go types used to construct out docs
+	err = glootestutils.ValidateHelmValues(helmValues)
+	if err != nil {
+		return nil, errors.Errorf("failure in ValidateHelmValues: %s", err.Error())
+	}
+
+	// Install the chart
+	installAction, err := createInstallAction(namespace)
+	if err != nil {
+		return nil, errors.Errorf("failure in createInstallAction: %s", err.Error())
+	}
+	release, err := installAction.Run(chartRequested, helmValues)
+	if err != nil {
+		return nil, errors.Errorf("failure in installAction.run: %s", err.Error())
+	}
+	return release, err
+}
+
+func createInstallAction(namespace string) (*action.Install, error) {
+	settings := install.NewCLISettings(namespace, "")
+	actionConfig := new(action.Configuration)
+	noOpDebugLog := func(format string, v ...interface{}) {}
+
+	if err := actionConfig.Init(
+		settings.RESTClientGetter(),
+		namespace,
+		os.Getenv("HELM_DRIVER"),
+		noOpDebugLog,
+	); err != nil {
+		return nil, err
+	}
+
+	renderer := action.NewInstall(actionConfig)
+	renderer.DryRun = true
+	renderer.Namespace = namespace
+	renderer.ReleaseName = releaseName
+	renderer.ClientOnly = true
+
+	return renderer, nil
+}
+
+func makeUnstructured(yam string) *unstructured.Unstructured {
+	jsn, err := yaml.YAMLToJSON([]byte(yam))
+	ExpectWithOffset(1, err).NotTo(HaveOccurred())
+	runtimeObj, err := runtime.Decode(unstructured.UnstructuredJSONScheme, jsn)
+	ExpectWithOffset(1, err).NotTo(HaveOccurred())
+	return runtimeObj.(*unstructured.Unstructured)
+}
+
+//nolint:unparam // values always receives "gloo-system"
+func makeUnstructureFromTemplateFile(fixtureName string, values interface{}) *unstructured.Unstructured {
+	tmpl, err := template.ParseFiles(fixtureName)
+	ExpectWithOffset(1, err).NotTo(HaveOccurred())
+	var b bytes.Buffer
+	err = tmpl.Execute(&b, values)
+	ExpectWithOffset(1, err).NotTo(HaveOccurred())
+	return makeUnstructured(b.String())
+}
+
+func makeRoleBindingFromUnstructured(resource *unstructured.Unstructured) *rbacv1.RoleBinding {
+	bindingObject, err := kuberesource.ConvertUnstructured(resource)
+	Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("RoleBinding %+v should be able to convert from unstructured", resource))
+	structuredRoleBinding, ok := bindingObject.(*rbacv1.RoleBinding)
+	Expect(ok).To(BeTrue(), fmt.Sprintf("RoleBinding %+v should be able to cast to a structured role binding", resource))
+	return structuredRoleBinding
+}
+
+func makeClusterRoleBindingFromUnstructured(resource *unstructured.Unstructured) *rbacv1.ClusterRoleBinding {
+	bindingObject, err := kuberesource.ConvertUnstructured(resource)
+	Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("ClusterRoleBinding %+v should be able to convert from unstructured", resource))
+	structuredClusterRoleBinding, ok := bindingObject.(*rbacv1.ClusterRoleBinding)
+	Expect(ok).To(BeTrue(), fmt.Sprintf("ClusterRoleBinding %+v should be able to cast to a structured cluster role binding", resource))
+	return structuredClusterRoleBinding
+}
diff --git a/install/test/helm_test.go b/install/test/helm_test.go
new file mode 100644
index 000000000..0ce18bce5
--- /dev/null
+++ b/install/test/helm_test.go
@@ -0,0 +1,7682 @@
+//go:build ignore
+
+package test
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"os/exec"
+	"reflect"
+	"strconv"
+	"strings"
+	"unicode"
+
+	"github.com/ghodss/yaml"
+	"github.com/golang/protobuf/proto"
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/onsi/gomega/format"
+	"github.com/onsi/gomega/types"
+	"github.com/solo-io/k8s-utils/installutils/kuberesource"
+	"github.com/solo-io/solo-kit/pkg/api/v1/resources"
+	skprotoutils "github.com/solo-io/solo-kit/pkg/utils/protoutils"
+	"github.com/solo-io/solo-kit/pkg/utils/statusutils"
+	appsv1 "k8s.io/api/apps/v1"
+	batchv1 "k8s.io/api/batch/v1"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/resource"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/util/intstr"
+	"k8s.io/apimachinery/pkg/util/sets"
+	"k8s.io/utils/pointer"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/deployer"
+
+	values "github.com/kgateway-dev/kgateway/v2/install/helm/gloo/generate"
+	"github.com/kgateway-dev/kgateway/v2/install/test/securitycontext"
+	"github.com/kgateway-dev/kgateway/v2/internal/gateway/pkg/defaults"
+	"github.com/kgateway-dev/kgateway/v2/pkg/utils/kubeutils"
+	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
+	"github.com/kgateway-dev/kgateway/v2/test/helpers"
+	glootestutils "github.com/kgateway-dev/kgateway/v2/test/testutils"
+)
+
+func GetPodNamespaceStats() corev1.EnvVar {
+	return corev1.EnvVar{
+		Name:  "START_STATS_SERVER",
+		Value: "true",
+	}
+}
+
+func GetPodNameEnvVar() corev1.EnvVar {
+	return corev1.EnvVar{
+		Name: "POD_NAME",
+		ValueFrom: &corev1.EnvVarSource{
+			FieldRef: &corev1.ObjectFieldSelector{
+				FieldPath: "metadata.name",
+			},
+		},
+	}
+}
+
+func GetLogLevelEnvVar(level string) corev1.EnvVar {
+	return corev1.EnvVar{
+		Name:  "LOG_LEVEL",
+		Value: level,
+	}
+}
+
+func GetTestExtraEnvVar() corev1.EnvVar {
+	return corev1.EnvVar{
+		Name:  "TEST_EXTRA_ENV_VAR",
+		Value: "test",
+	}
+}
+
+func GetValidationEnvVar() corev1.EnvVar {
+	return corev1.EnvVar{
+		Name:  "VALIDATION_MUST_START",
+		Value: "true",
+	}
+}
+
+func ConvertKubeResource(unst *unstructured.Unstructured, res resources.Resource) {
+	byt, err := unst.MarshalJSON()
+	Expect(err).NotTo(HaveOccurred())
+
+	err = skprotoutils.UnmarshalResource(byt, res)
+	Expect(err).NotTo(HaveOccurred())
+}
+
+var _ = Describe("Helm Test", func() {
+	allTests := func(rendererTestCase renderTestCase) {
+		var (
+			glooPorts = []corev1.ContainerPort{
+				{Name: "grpc-xds", ContainerPort: 9977, Protocol: "TCP"},
+				{Name: "rest-xds", ContainerPort: 9976, Protocol: "TCP"},
+				{Name: "grpc-validation", ContainerPort: 9988, Protocol: "TCP"},
+				{Name: "grpc-proxydebug", ContainerPort: 9966, Protocol: "TCP"},
+				{Name: "wasm-cache", ContainerPort: 9979, Protocol: "TCP"},
+			}
+			selector         map[string]string
+			testManifest     TestManifest
+			renderErr        error
+			statsAnnotations map[string]string
+		)
+
+		// Create a TestManifest out of the custom resource yaml from the configmap,
+		// and then perform assertions on the resources (which are assumed to all be Gateways).
+		// `matchers` is a map of Gateway name to the assertion to be made on that Gateway.
+		// There must be a matcher for every Gateway that's expected to be in the manifest.
+		assertCustomResourceManifest := func(matchers map[string]types.GomegaMatcher) {
+			configMap := getConfigMap(testManifest, namespace, customResourceConfigMapName)
+			ExpectWithOffset(1, configMap.Data).NotTo(BeNil())
+			customResourceYaml := configMap.Data["custom-resources"]
+			customResourceManifest := NewTestManifestFromYaml(customResourceYaml)
+			// make sure that the number of resources found in the manifest equals the number of
+			// matchers passed in, so we can ensure that every resource has an associated matcher
+			ExpectWithOffset(1, customResourceManifest.NumResources()).To(Equal(len(matchers)))
+			for gwName, matcher := range matchers {
+				customResourceManifest.ExpectUnstructured("Gateway", namespace, gwName).To(matcher)
+			}
+		}
+
+		BeforeEach(func() {
+			// Ensure that tests do not share manifests or renderErrs by accident
+			testManifest = nil
+			renderErr = nil
+		})
+
+		Describe(rendererTestCase.rendererName, func() {
+			// each entry in ValuesArgs should look like `path.to.helm.field=value`
+			prepareMakefile := func(namespace string, values glootestutils.HelmValues) {
+				tm, err := rendererTestCase.renderer.RenderManifest(namespace, values)
+				ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to render manifest")
+				testManifest = tm
+			}
+
+			expectRenderError := func(namespace string, values glootestutils.HelmValues) {
+				_, err := rendererTestCase.renderer.RenderManifest(namespace, values)
+				ExpectWithOffset(1, err).To(HaveOccurred())
+				renderErr = err
+			}
+
+			// helper for passing a values file
+			prepareMakefileFromValuesFile := func(valuesFile string) {
+				prepareMakefile(namespace, glootestutils.HelmValues{
+					ValuesFile: valuesFile,
+					ValuesArgs: []string{
+						"gatewayProxies.gatewayProxy.service.extraAnnotations.test=test",
+					},
+				})
+			}
+			BeforeEach(func() {
+				statsAnnotations = map[string]string{
+					"prometheus.io/path":   "/metrics",
+					"prometheus.io/port":   "9091",
+					"prometheus.io/scrape": "true",
+				}
+			})
+
+			It("should allow image digest pinning", func() {
+				shaTest := "sha256:1234123412341234123412341234213412341234123412341234123412341234"
+				prepareMakefile(namespace, glootestutils.HelmValues{
+					ValuesArgs: []string{
+						"gloo.deployment.image.digest=" + shaTest,
+					},
+				})
+				testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+					return resource.GetKind() == "Deployment" && resource.GetName() == "gloo"
+				}).ExpectAll(func(deployment *unstructured.Unstructured) {
+					deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+					ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to render manifest")
+					structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+					Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+					containers := structuredDeployment.Spec.Template.Spec.Containers
+					Expect(containers).To(HaveLen(1), "should have exactly 1 container")
+					image := containers[0].Image
+					Expect(image).To(ContainSubstring(shaTest), "should have sha digest in image")
+				})
+			})
+
+			It("should have all resources marked with a namespace", func() {
+				prepareMakefile(namespace, glootestutils.HelmValues{
+					ValuesArgs: []string{
+						// TODO: re-enable once our k8s gw integration supports namespaced rbac
+						"kubeGateway.enabled=false",
+					},
+				})
+
+				nonNamespacedKinds := sets.NewString(
+					"ClusterRole",
+					"ClusterRoleBinding",
+					"ValidatingWebhookConfiguration",
+				)
+
+				// all namespaced resources should have a namespace set on them
+				// this tests that nothing winds up in the default kube namespace from your config when you install (unless that's what you intended)
+				testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+					return !nonNamespacedKinds.Has(resource.GetKind())
+				}).ExpectAll(func(resource *unstructured.Unstructured) {
+					ExpectWithOffset(1, resource.GetNamespace()).NotTo(BeEmpty(), fmt.Sprintf("Resource %+v does not have a namespace", resource))
+				})
+			})
+
+			It("Should have no duplicate resources", func() {
+				prepareMakefile(namespace, glootestutils.HelmValues{})
+
+				var resources []*unstructured.Unstructured
+				// This piece of work is the simplest way to directly access the unstructured resources list backing a testManifest struct
+				// without updating go-utils and adding a direct access function to the TestManifest interface.
+				// We aren't doing that because updating gloo's go-utils dependency is its own task to be addressed some other time.
+				testManifest.SelectResources(func(unstructured *unstructured.Unstructured) bool {
+					resources = append(resources, unstructured)
+					return true
+				})
+
+				for idx1, resource1 := range resources {
+					for idx2, resource2 := range resources {
+						if idx1 == idx2 {
+							continue
+						}
+						Expect(constructResourceID(resource1)).NotTo(Equal(constructResourceID(resource2)))
+					}
+				}
+			})
+
+			It("does not create the gloo pdb by default", func() {
+				prepareMakefile(namespace, glootestutils.HelmValues{})
+
+				testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, "gloo-pdb").To(BeNil())
+			})
+
+			It("can create gloo pdb with minAvailable", func() {
+				prepareMakefile(namespace, glootestutils.HelmValues{
+					ValuesArgs: []string{
+						"gloo.podDisruptionBudget.minAvailable='2'",
+					},
+				})
+
+				pdb := makeUnstructured(`
+apiVersion: policy/v1
+kind: PodDisruptionBudget
+metadata:
+  name: gloo-pdb
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  minAvailable: '2'
+  selector:
+    matchLabels:
+      gloo: gloo
+`)
+
+				testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, "gloo-pdb").To(BeEquivalentTo(pdb))
+			})
+
+			It("can create gloo pdb with maxUnavailable", func() {
+				prepareMakefile(namespace, glootestutils.HelmValues{
+					ValuesArgs: []string{
+						"gloo.podDisruptionBudget.maxUnavailable='2'",
+					},
+				})
+
+				pdb := makeUnstructured(`
+apiVersion: policy/v1
+kind: PodDisruptionBudget
+metadata:
+  name: gloo-pdb
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  maxUnavailable: '2'
+  selector:
+    matchLabels:
+      gloo: gloo
+`)
+
+				testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, "gloo-pdb").To(BeEquivalentTo(pdb))
+			})
+
+			It("errors rendering when gloo pdb has both maxUnavailable and minAvailable set", func() {
+				expectRenderError(namespace, glootestutils.HelmValues{
+					ValuesArgs: []string{
+						"gloo.podDisruptionBudget.maxUnavailable='2'",
+						"gloo.podDisruptionBudget.minAvailable='2'",
+					},
+				})
+
+				Expect(renderErr).To(HaveOccurred())
+				Expect(renderErr.Error()).To(ContainSubstring("gloo PDB values minAvailable and maxUnavailable are mutually exclusive"))
+			})
+
+			Context("stats server settings", func() {
+				var (
+					normalPromAnnotations = map[string]string{
+						"prometheus.io/path":   "/metrics",
+						"prometheus.io/port":   "9091",
+						"prometheus.io/scrape": "true",
+					}
+
+					gatewayProxyDeploymentPromAnnotations = map[string]string{
+						"prometheus.io/path":   "/metrics",
+						"prometheus.io/port":   "8081",
+						"prometheus.io/scrape": "true",
+					}
+				)
+
+				It("should be able to configure a stats server by default on all relevant deployments", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						promAnnotations := normalPromAnnotations
+						if structuredDeployment.GetName() == "gateway-proxy" {
+							promAnnotations = gatewayProxyDeploymentPromAnnotations
+						}
+
+						deploymentAnnotations := structuredDeployment.Spec.Template.ObjectMeta.Annotations
+						for annotation, value := range promAnnotations {
+							ExpectWithOffset(1, deploymentAnnotations[annotation]).To(Equal(value), fmt.Sprintf("Annotation %s should be set to %s on deployment %+v", deployment, annotation, value))
+						}
+
+						if structuredDeployment.GetName() != "gateway-proxy" {
+							for _, container := range structuredDeployment.Spec.Template.Spec.Containers {
+								foundExpected := false
+								for _, envVar := range container.Env {
+									if envVar.Name == "START_STATS_SERVER" {
+										foundExpected = true
+										ExpectWithOffset(1, envVar.Value).To(Equal("true"), fmt.Sprintf("Should have the START_STATS_SERVER env var set to 'true' on deployment %+v", deployment))
+									}
+								}
+
+								ExpectWithOffset(1, foundExpected).To(BeTrue(), fmt.Sprintf("Should have found the START_STATS_SERVER env var on deployment %+v", deployment))
+							}
+						}
+					})
+				})
+
+				It("should be able to set custom labels for pods", func() {
+					// This test expects ALL pods to be capable of setting custom labels unless exceptions are added
+					// here, which means that this test will fail if new deployments are added to the helm chart without
+					// custom labeling, unless those deployments aren't enabled by default (like the accessLogger).
+					// Note: test panics if values-template.yaml doesn't contain at least an empty definition
+					// of each label object that's modified here.
+					// Note note: Update number in final expectation if you add new labels here.
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gloo.deployment.extraGlooLabels.foo=bar",
+							"discovery.deployment.extraDiscoveryLabels.foo=bar",
+							"gatewayProxies.gatewayProxy.podTemplate.extraGatewayProxyLabels.foo=bar",
+							"accessLogger.enabled=true", // required to test accessLogger
+							"accessLogger.extraAccessLoggerLabels.foo=bar",
+							"ingress.deployment.extraIngressLabels.foo=bar",
+							"ingress.enabled=true", // required to test Ingress Proxy, but not Ingress.
+							"ingressProxy.deployment.extraIngressProxyLabels.foo=bar",
+							"settings.integrations.knative.enabled=true", // required to test cluster ingress proxy and knative labels.
+							"settings.integrations.knative.extraKnativeExternalLabels.foo=bar",
+							"settings.integrations.knative.extraKnativeInternalLabels.foo=bar",
+							"gloo.deployment.extraGlooAnnotations.foo=bar",
+							"ingress.deployment.extraIngressAnnotations.foo=bar",
+							"settings.integrations.knative.extraKnativeExternalAnnotations.foo=bar",
+							"settings.integrations.knative.extraKnativeInternalAnnotations.foo=bar",
+							"discovery.deployment.extraDiscoveryAnnotations.foo=bar",
+							"accessLogger.extraAccessLoggerAnnotations.foo=bar",
+							"settings.integrations.knative.proxy.extraClusterIngressProxyAnnotations.foo=bar",
+						},
+					})
+
+					resourcesTested := 0
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						deploymentLabels := structuredDeployment.Spec.Template.Labels
+						foundTestValue := false
+						for label, value := range deploymentLabels {
+							if label == "foo" {
+								ExpectWithOffset(1, value).To(Equal("bar"), fmt.Sprintf("Deployment %s expected test label to have"+
+									" value bar. Found value %s", deployment.GetName(), value))
+								foundTestValue = true
+							}
+						}
+						ExpectWithOffset(1, foundTestValue).To(BeTrue(), fmt.Sprintf("Coundn't find test label 'foo' in deployment %s", deployment.GetName()))
+						resourcesTested += 1
+					})
+					// Is there an elegant way to parameterized the expected number of deployments based on the valueArgs?
+					Expect(resourcesTested).To(Equal(8), "Tested %d resources when we were expecting 9."+
+						" Was a new pod added, or is an existing pod no longer being generated?", resourcesTested)
+				})
+
+				// due to the version requirements for rendering knative-related templates, the cluster ingress proxy
+				// template is mutually exclusive to the other knative templates, and needs to be tested separately.
+				It("should be able to set custom labels for cluster ingress proxy pod", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"settings.integrations.knative.enabled=true",
+							"settings.integrations.knative.version=0.7.0",
+							"settings.integrations.knative.proxy.extraClusterIngressProxyLabels.foo=bar",
+						},
+					})
+
+					resourcesTested := 0
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						deploymentLabels := structuredDeployment.Spec.Template.Labels
+						if structuredDeployment.Name != "clusteringress-proxy" {
+							return
+						}
+						foundTestValue := false
+						for label, value := range deploymentLabels {
+							if label == "foo" {
+								ExpectWithOffset(1, value).To(Equal("bar"), fmt.Sprintf("Deployment %s expected test label to have"+
+									" value bar. Found value %s", deployment.GetName(), value))
+								foundTestValue = true
+							}
+						}
+						ExpectWithOffset(1, foundTestValue).To(BeTrue(), fmt.Sprintf("Coundn't find test label 'foo' in deployment %s", deployment.GetName()))
+						resourcesTested += 1
+					})
+					// Is there an elegant way to parameterized the expected number of deployments based on the valueArgs?
+					Expect(resourcesTested).To(Equal(1), "Tested %d resources when we were expecting 1."+
+						"What happened to the clusteringress-proxy deployment?", resourcesTested)
+				})
+
+				Context("should be able to set custom labels and annotations on jobs", func() {
+					// creates a template from the specified ValuesArgs, then confirms the jobs with the specified names
+					// have the expected labels and annotations
+					testJobLabelsAndAnnotations := func(ValuesArgs []string, jobNames []string, expectedLabels map[string]string, expectedAnnotations map[string]string) {
+						// create the chart with the specified values args
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: ValuesArgs,
+						})
+
+						// convert the job names we expect to be affected into a map, for easy lookup
+						expectedNames := map[string]bool{}
+						for _, name := range jobNames {
+							expectedNames[name] = true
+						}
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							// get jobs with the expected names
+							return resource.GetKind() == "Job" && expectedNames[resource.GetName()]
+						}).ExpectAll(func(job *unstructured.Unstructured) {
+							// convert the job to a structured object
+							jobObject, err := kuberesource.ConvertUnstructured(job)
+							ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Job %+v should be able to convert from unstructured", job))
+							structuredJob, ok := jobObject.(*batchv1.Job)
+							ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Job %+v should be able to cast to a structured job", job))
+
+							// check the labels
+							jobLabels := structuredJob.Spec.Template.Labels
+							foundTestValue := false
+							for label, expectedValue := range expectedLabels {
+								ExpectWithOffset(1, jobLabels[label]).To(Equal(expectedValue), fmt.Sprintf("Job %s expected test label to have"+
+									" value %s. Found value %s", job.GetName(), expectedValue, jobLabels[label]))
+								foundTestValue = true
+							}
+							ExpectWithOffset(1, foundTestValue).To(BeTrue(), fmt.Sprintf("Coundn't find test label 'foo' in job %s", job.GetName()))
+
+							// check the annotations
+							jobAnnotations := structuredJob.Spec.Template.Annotations
+							foundTestValue = false
+							for label, expectedValue := range expectedAnnotations {
+								ExpectWithOffset(1, jobAnnotations[label]).To(Equal(expectedValue), fmt.Sprintf("Job %s expected test annotation to have"+
+									" value %s. Found value %s", job.GetName(), expectedValue, jobAnnotations[label]))
+								foundTestValue = true
+							}
+							ExpectWithOffset(1, foundTestValue).To(BeTrue(), fmt.Sprintf("Coundn't find test annotation 'foo2' in job %s", job.GetName()))
+						})
+					}
+
+					It("should be able to set custom labels and annotations on certGenJob", func() {
+						values := []string{
+							"gateway.certGenJob.extraPodLabels.foo=bar",
+							"gateway.certGenJob.extraPodAnnotations.foo2=baz",
+						}
+						jobNames := []string{
+							"gloo-mtls-certgen-cronjob",
+							"gloo-mtls-certgen",
+							"gateway-certgen",
+							"gateway-certgen-cronjob",
+						}
+
+						expectedLabels := map[string]string{
+							"foo": "bar",
+						}
+
+						expectedAnnotations := map[string]string{
+							"foo2": "baz",
+						}
+
+						testJobLabelsAndAnnotations(values, jobNames, expectedLabels, expectedAnnotations)
+					})
+
+					It("should be able to set custom labels and annotations on cleanupJob", func() {
+						values := []string{
+							"gateway.cleanupJob.extraPodLabels.foo=bar",
+							"gateway.cleanupJob.extraPodAnnotations.foo2=baz",
+						}
+
+						jobNames := []string{
+							"gloo-resource-cleanup",
+						}
+
+						expectedLabels := map[string]string{
+							"foo": "bar",
+						}
+
+						expectedAnnotations := map[string]string{
+							"foo2": "baz",
+						}
+
+						testJobLabelsAndAnnotations(values, jobNames, expectedLabels, expectedAnnotations)
+					})
+
+					It("should be able to set custom labels and annotations on rolloutJob", func() {
+						values := []string{
+							"gateway.rolloutJob.extraPodLabels.foo=bar",
+							"gateway.rolloutJob.extraPodAnnotations.foo2=baz",
+						}
+
+						jobNames := []string{
+							"gloo-resource-rollout",
+							"gloo-resource-migration",
+						}
+
+						expectedLabels := map[string]string{
+							"foo": "bar",
+						}
+
+						expectedAnnotations := map[string]string{
+							"foo2": "baz",
+						}
+
+						testJobLabelsAndAnnotations(values, jobNames, expectedLabels, expectedAnnotations)
+					})
+				})
+
+				It("should set route prefix_rewrite in clusteringress-envoy-config from global.glooStats", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"settings.integrations.knative.enabled=true",
+							"settings.integrations.knative.version=0.7.0",
+							"settings.integrations.knative.proxy.stats=true",
+							"global.glooStats.routePrefixRewrite=/stats?format=json",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("ConfigMap %+v should be able to cast to a structured config map", configMap))
+
+						if structuredConfigMap.GetName() == "clusteringress-envoy-config" {
+							expectedPrefixRewrite := "prefix_rewrite: /stats?format=json"
+							ExpectWithOffset(1, structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring(expectedPrefixRewrite))
+						}
+					})
+				})
+
+				It("should set route prefix_rewrite in knative proxy configs from global.glooStats", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"settings.integrations.knative.enabled=true",
+							"settings.integrations.knative.version=0.8.0",
+							"settings.integrations.knative.proxy.stats=true",
+							"global.glooStats.routePrefixRewrite=/stats?format=json",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("ConfigMap %+v should be able to cast to a structured config map", configMap))
+
+						if structuredConfigMap.GetName() == "knative-internal-proxy-config" ||
+							structuredConfigMap.GetName() == "knative-external-proxy-config" {
+							expectedPrefixRewrite := "prefix_rewrite: /stats?format=json"
+							ExpectWithOffset(1, structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring(expectedPrefixRewrite))
+						}
+					})
+				})
+
+				It("should be able to set consul config values", func() {
+					settings := makeUnstructureFromTemplateFile("fixtures/settings/consul_config_values.yaml", namespace)
+					prepareMakefileFromValuesFile("values/val_consul_test_inputs.yaml")
+					testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+				})
+
+				It("should be able to set consul config upstream discovery values", func() {
+					settings := makeUnstructureFromTemplateFile("fixtures/settings/consul_config_upstream_discovery.yaml", namespace)
+					prepareMakefileFromValuesFile("values/val_consul_discovery_test_inputs.yaml")
+					testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+				})
+
+				deploymentContainsMonitoringPort := func(deployment *appsv1.Deployment) bool {
+					for _, container := range deployment.Spec.Template.Spec.Containers {
+						for _, containerPort := range container.Ports {
+							if containerPort.Name == "http-monitoring" {
+								return true
+							}
+						}
+					}
+					return false
+				}
+
+				serviceContainsMonitoringPort := func(service *corev1.Service) bool {
+					for _, servicePort := range service.Spec.Ports {
+						if servicePort.Name == "http-monitoring" {
+							return true
+						}
+					}
+					return false
+				}
+
+				It("should be able to override global defaults", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"discovery.deployment.stats.enabled=true",
+							"discovery.deployment.stats.podMonitorEnabled=true",
+
+							"global.glooStats.enabled=false",
+							"global.glooStats.podMonitorEnabled=false",
+						},
+					})
+
+					// assert that discovery has stats enabled
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment" && resource.GetName() == "discovery"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						for annotation, value := range normalPromAnnotations {
+							ExpectWithOffset(1, structuredDeployment.Spec.Template.ObjectMeta.Annotations[annotation]).To(Equal(value), fmt.Sprintf("Annotation %s should be set to %s on deployment %+v", deployment, annotation, value))
+						}
+
+						foundMonitoringPort := deploymentContainsMonitoringPort(structuredDeployment)
+						ExpectWithOffset(1, foundMonitoringPort).To(BeTrue(), fmt.Sprintf("'http-monitoring' port should be set on deployment %+v", deployment))
+					})
+
+					// assert that gloo has stats disabled
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment" && resource.GetName() == "gloo"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						ExpectWithOffset(1, structuredDeployment.Spec.Template.ObjectMeta.Annotations).To(BeEmpty(), fmt.Sprintf("No annotations should be present on deployment %+v", structuredDeployment))
+
+						foundMonitoringPort := deploymentContainsMonitoringPort(structuredDeployment)
+						ExpectWithOffset(1, foundMonitoringPort).To(BeFalse(), fmt.Sprintf("'http-monitoring' port should not be set on deployment %+v", deployment))
+					})
+				})
+
+				It("should be able to expose http-monitoring port on all relevant services", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							// to enable accessLogger service
+							"gateway.enabled=true",
+							"accessLogger.enabled=true",
+							"accessLogger.stats.serviceMonitorEnabled=true",
+
+							"global.glooStats.enabled=true",
+							"global.glooStats.serviceMonitorEnabled=true",
+						},
+					})
+
+					expectedServicesWithHttpMonitoring := []string{
+						"gloo",
+						"discovery",
+						"gateway-proxy-access-logger",
+						"gateway-proxy-monitoring-service",
+					}
+					var actualServicesWithHttpMonitoring []string
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Service"
+					}).ExpectAll(func(service *unstructured.Unstructured) {
+						serviceObject, err := kuberesource.ConvertUnstructured(service)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Service %+v should be able to convert from unstructured", service))
+						structuredService, ok := serviceObject.(*corev1.Service)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Service %+v should be able to cast to a structured service", service))
+						ExpectWithOffset(1, structuredService.Labels["app"]).To(Equal("gloo"), "Service has app=gloo label")
+
+						if serviceContainsMonitoringPort(structuredService) {
+							actualServicesWithHttpMonitoring = append(actualServicesWithHttpMonitoring, structuredService.GetName())
+						}
+					})
+
+					Expect(actualServicesWithHttpMonitoring).To(Equal(expectedServicesWithHttpMonitoring))
+				})
+
+				It("should be able to expose http-monitoring port on all relevant deployments", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							// to enable accessLogger deployment
+							"gateway.enabled=true",
+							"accessLogger.enabled=true",
+							"accessLogger.stats.podMonitorEnabled=true",
+
+							"global.glooStats.enabled=true",
+							"global.glooStats.podMonitorEnabled=true",
+						},
+					})
+
+					expectedDeploymentsWithHttpMonitoring := []string{
+						"gloo",
+						"discovery",
+						"gateway-proxy-access-logger",
+						"gateway-proxy",
+					}
+					var actualDeploymentsWithHttpMonitoring []string
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						ExpectWithOffset(1, ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+						ExpectWithOffset(1, structuredDeployment.Labels["app"]).To(Equal("gloo"), "Deployment has app=gloo label")
+
+						if deploymentContainsMonitoringPort(structuredDeployment) {
+							actualDeploymentsWithHttpMonitoring = append(actualDeploymentsWithHttpMonitoring, structuredDeployment.GetName())
+						}
+					})
+
+					Expect(actualDeploymentsWithHttpMonitoring).To(Equal(expectedDeploymentsWithHttpMonitoring))
+				})
+			})
+
+			Context("gloo mtls settings", func() {
+				var (
+					glooMtlsSecretVolume = corev1.Volume{
+						Name: "gloo-mtls-certs",
+						VolumeSource: corev1.VolumeSource{
+							Secret: &corev1.SecretVolumeSource{
+								SecretName:  "gloo-mtls-certs",
+								Items:       nil,
+								DefaultMode: proto.Int32(420),
+							},
+						},
+					}
+
+					haveEnvoySidecar = func(containers []corev1.Container) bool {
+						for _, c := range containers {
+							if c.Name == "envoy-sidecar" {
+								return true
+							}
+						}
+						return false
+					}
+
+					haveSdsSidecar = func(containers []corev1.Container) bool {
+						for _, c := range containers {
+							if c.Name == "sds" {
+								return true
+							}
+						}
+						return false
+					}
+				)
+
+				It("should put the secret volume in the Gloo and Gateway-Proxy Deployment and add a sidecar in the Gloo Deployment", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{"global.glooMtls.enabled=true"},
+					})
+
+					foundGlooMtlsCertgenJob := false
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Job"
+					}).ExpectAll(func(job *unstructured.Unstructured) {
+						jobObject, err := kuberesource.ConvertUnstructured(job)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Job %+v should be able to convert from unstructured", job))
+						structuredDeployment, ok := jobObject.(*batchv1.Job)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Job %+v should be able to cast to a structured job", job))
+
+						if structuredDeployment.GetName() == "gloo-mtls-certgen" {
+							foundGlooMtlsCertgenJob = true
+						}
+					})
+					Expect(foundGlooMtlsCertgenJob).To(BeTrue(), "Did not find the gloo-mtls-certgen job")
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						if structuredDeployment.GetName() == "gloo" {
+							Î©(haveEnvoySidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue())
+							Î©(haveSdsSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue())
+							Expect(structuredDeployment.Spec.Template.Spec.Volumes).To(ContainElement(glooMtlsSecretVolume))
+						}
+
+						if structuredDeployment.GetName() == "gateway-proxy" {
+							Î©(haveSdsSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue())
+							Expect(structuredDeployment.Spec.Template.Spec.Volumes).To(ContainElement(glooMtlsSecretVolume))
+						}
+					})
+				})
+
+				It("should add an additional listener to the gateway-proxy-envoy-config if $spec.extraListenersHelper is defined", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{"global.glooMtls.enabled=true,gatewayProxies.gatewayProxy.extraListenersHelper=gloo.testlistener"},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("ConfigMap %+v should be able to cast to a structured config map", configMap))
+
+						if structuredConfigMap.GetName() == "gateway-proxy-envoy-config" {
+							expectedTestListener := "    - name: test_listener"
+							Expect(structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring(expectedTestListener))
+						}
+					})
+				})
+
+				It("should set route prefix_rewrite in gateway-proxy-envoy-config from global.glooStats", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.glooStats.enabled=true",
+							"global.glooStats.routePrefixRewrite=/stats?format=json",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("ConfigMap %+v should be able to cast to a structured config map", configMap))
+
+						if structuredConfigMap.GetName() == "gateway-proxy-envoy-config" {
+							expectedPrefixRewrite := "prefix_rewrite: /stats?format=json"
+							Expect(structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring(expectedPrefixRewrite))
+						}
+					})
+				})
+
+				It("should set route prefix_rewrite in gateway-proxy-envoy-config from gatewayProxies.gatewayProxy", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gatewayProxies.gatewayProxy.stats.enabled=true",
+							"gatewayProxies.gatewayProxy.stats.routePrefixRewrite=/stats?format=json",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("ConfigMap %+v should be able to cast to a structured config map", configMap))
+
+						if structuredConfigMap.GetName() == "gateway-proxy-envoy-config" {
+							expectedPrefixRewrite := "prefix_rewrite: /stats?format=json"
+							Expect(structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring(expectedPrefixRewrite))
+						}
+					})
+				})
+
+				It("should set stats_config in gateway-proxy-envoy-config from gatewayProxies.gatewayProxy.envoyStatsConfig", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gatewayProxies.gatewayProxy.envoyStatsConfig.stats_tags[0].fixed_value=zero",
+							"gatewayProxies.gatewayProxy.envoyStatsConfig.stats_tags[0].tag_name=one",
+						},
+					})
+
+					resources := testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap" && resource.GetName() == "gateway-proxy-envoy-config"
+					})
+
+					Expect(resources.NumResources()).To(Equal(1), "Should find only one gateway-proxy-envoy-config ConfigMap")
+
+					resources.ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("ConfigMap %+v should be able to cast to a structured config map", configMap))
+
+						expect := Expect(structuredConfigMap.Data["envoy.yaml"])
+						expect.To(ContainSubstring("stats_config:"))
+						expect.To(ContainSubstring("stats_tags:"))
+						expect.To(ContainSubstring("- fixed_value: zero"))
+					})
+				})
+
+				It("Should have 'pre-install' and 'pre-upgrade' hook if gateway.certGenJob.runOnUpdate is true", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.glooMtls.enabled=true",
+							"gateway.certGenJob.runOnUpdate=true",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Job"
+					}).ExpectAll(func(job *unstructured.Unstructured) {
+						jobObject, err := kuberesource.ConvertUnstructured(job)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Job %+v should be able to convert from unstructured", job))
+						structuredDeployment, ok := jobObject.(*batchv1.Job)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Job %+v should be able to cast to a structured job", job))
+
+						if structuredDeployment.GetName() == "gloo-mtls-certgen" {
+							for annotation_name, annotation_value := range structuredDeployment.GetAnnotations() {
+								if annotation_name == "helm.sh/hook" {
+									Expect(annotation_value).To(Equal("pre-install, pre-upgrade"))
+								}
+							}
+						}
+					})
+				})
+
+				It("Should have only 'pre-install' hook if gateway.certGenJob.runOnUpdate is false", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.glooMtls.enabled=true",
+							"gateway.certGenJob.runOnUpdate=false",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Job"
+					}).ExpectAll(func(job *unstructured.Unstructured) {
+						jobObject, err := kuberesource.ConvertUnstructured(job)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Job %+v should be able to convert from unstructured", job))
+						structuredDeployment, ok := jobObject.(*batchv1.Job)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Job %+v should be able to cast to a structured job", job))
+
+						if structuredDeployment.GetName() == "gloo-mtls-certgen" {
+							for annotation_name, annotation_value := range structuredDeployment.GetAnnotations() {
+								if annotation_name == "helm.sh/hook" {
+									Expect(annotation_value).To(Equal("pre-install"))
+								}
+							}
+						}
+					})
+				})
+			})
+
+			Context("gloo with linkerd settings", func() {
+				linkerdInjectionLabel := "linkerd.io/inject"
+				It("linkerd injection should always be disabled in job pod templates when linkerd is enabled", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"settings.linkerd=true",
+						},
+					})
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Job"
+					}).ExpectAll(func(job *unstructured.Unstructured) {
+						jobObj, err := kuberesource.ConvertUnstructured(job)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Job %+v should be able to convert from unstructured", job))
+						structuredJob, ok := jobObj.(*batchv1.Job)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Job %+v should be able to cast to a structured job", job))
+
+						val, ok := structuredJob.Spec.Template.ObjectMeta.Annotations[linkerdInjectionLabel]
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Job %s should contain an linkerd injection annotation", job.GetName()))
+						Expect(val).To(Equal("disabled"), fmt.Sprintf("Job %s should have an linkerd injection annotation with value of 'disabled'", job.GetName()))
+					})
+				})
+			})
+
+			Context("gloo with istio sds settings", func() {
+				var (
+					IstioInjectionLabel          = "sidecar.istio.io/inject"
+					istioExcludedPortsAnnotation = "traffic.sidecar.istio.io/excludeInboundPorts"
+					IstioRevisionLabel           = "istio.io/rev"
+					istioCertsVolume             = corev1.Volume{
+						Name: "istio-certs",
+						VolumeSource: corev1.VolumeSource{
+							EmptyDir: &corev1.EmptyDirVolumeSource{
+								Medium: corev1.StorageMediumMemory,
+							},
+						},
+					}
+
+					haveIstioSidecar = func(containers []corev1.Container) bool {
+						for _, c := range containers {
+							if c.Name == deployer.IstioContainerName {
+								return true
+							}
+						}
+						return false
+					}
+
+					istioSidecarVersion = func(containers []corev1.Container) string {
+						for _, c := range containers {
+							if c.Name == "istio-proxy" {
+								return c.Image
+							}
+						}
+						return ""
+					}
+
+					haveSdsSidecar = func(containers []corev1.Container) bool {
+						for _, c := range containers {
+							if c.Name == deployer.SdsContainerName {
+								return true
+							}
+						}
+						return false
+					}
+
+					sdsIsIstioMode = func(containers []corev1.Container) bool {
+						for _, c := range containers {
+							if c.Name == deployer.SdsContainerName {
+								for _, e := range c.Env {
+									if e.Name == "ISTIO_MTLS_SDS_ENABLED" && e.Value == "true" {
+										return true
+									}
+								}
+							}
+						}
+						return false
+					}
+				)
+
+				It("should add an sds sidecar AND an istio-proxy sidecar in the Gateway-Proxy Deployment", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.istioIntegration.enabled=true",
+							"gloo.logLevel=debug",
+							"global.glooMtls.sds.logLevel=error",
+							"global.glooMtls.istioProxy.logLevel=warning",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						if structuredDeployment.GetName() == "gateway-proxy" {
+							Expect(structuredDeployment.Spec.Template.Spec.Containers).To(HaveLen(3), "should have exactly 3 containers")
+							Î©(haveSdsSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue(), "gateway-proxy should have an sds sidecar")
+							Î©(istioSidecarVersion(structuredDeployment.Spec.Template.Spec.Containers)).To(Equal("docker.io/istio/proxyv2:1.22.0"), "istio proxy sidecar should be the default")
+							Î©(haveIstioSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue(), "gateway-proxy should have an istio-proxy sidecar")
+							Î©(sdsIsIstioMode(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue(), "sds sidecar should have istio mode enabled")
+							Expect(structuredDeployment.Spec.Template.Spec.Volumes).To(ContainElement(istioCertsVolume), "should have istio-certs volume mounted")
+							for _, c := range structuredDeployment.Spec.Template.Spec.Containers {
+								if c.Name == deployer.SdsContainerName {
+									Expect(c.Env).Should(ContainElement(GetLogLevelEnvVar("error")))
+								} else if c.Name == "istio-proxy" {
+									Expect(c.Args).Should(ContainElement("--proxyLogLevel=warning"))
+								}
+							}
+						}
+
+						// Make sure gloo didn't pick up any sidecars for istio SDS (which it would for glooMTLS SDS)
+						if structuredDeployment.GetName() == "gloo" {
+							Î©(haveIstioSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeFalse(), "should not have istio-proxy sidecar in gloo")
+							Î©(haveSdsSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeFalse(), "should not have sds sidecar in gloo")
+							Expect(structuredDeployment.Spec.Template.Spec.Containers).To(HaveLen(1), "should have exactly 1 container")
+							Expect(structuredDeployment.Spec.Template.Spec.Volumes).NotTo(ContainElement(istioCertsVolume), "should not mount istio-certs in gloo")
+							Expect(structuredDeployment.Spec.Template.Spec.Containers[0].Env).Should(ContainElement(GetLogLevelEnvVar("debug")))
+						}
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", configMap))
+
+						if structuredConfigMap.Name == "gateway-proxy-envoy-config" {
+							Expect(structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring("gateway_proxy_sds"), "should have an sds cluster configured")
+						}
+					})
+				})
+
+				It("should allow setting a custom istio sidecar in the Gateway-Proxy Deployment", func() {
+					prepareMakefileFromValuesFile("values/val_custom_istio_sidecar.yaml")
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						if structuredDeployment.GetName() == "gateway-proxy" {
+							Expect(structuredDeployment.Spec.Template.Spec.Containers).To(HaveLen(3), "should have exactly 3 containers")
+							Î©(haveSdsSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue(), "gateway-proxy should have an sds sidecar")
+							Î©(haveIstioSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue(), "gateway-proxy should have an istio-proxy sidecar")
+							Î©(istioSidecarVersion(structuredDeployment.Spec.Template.Spec.Containers)).To(Equal("docker.io/istio/proxyv2:1.6.6"), "istio-proxy sidecar should be from the override file")
+							Î©(sdsIsIstioMode(structuredDeployment.Spec.Template.Spec.Containers)).To(BeTrue(), "sds sidecar should have istio mode enabled")
+							Expect(structuredDeployment.Spec.Template.Spec.Volumes).To(ContainElement(istioCertsVolume), "should have istio-certs volume mounted")
+						}
+
+						// Make sure gloo didn't pick up any sidecars for istio SDS (which it would for glooMTLS SDS)
+						if structuredDeployment.GetName() == "gloo" {
+							Î©(haveIstioSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeFalse(), "should not have istio-proxy sidecar in gloo")
+							Î©(haveSdsSidecar(structuredDeployment.Spec.Template.Spec.Containers)).To(BeFalse(), "should not have sds sidecar in gloo")
+							Expect(structuredDeployment.Spec.Template.Spec.Containers).To(HaveLen(1), "should have exactly 1 container")
+							Expect(structuredDeployment.Spec.Template.Spec.Volumes).NotTo(ContainElement(istioCertsVolume), "should not mount istio-certs in gloo")
+						}
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", configMap))
+
+						if structuredConfigMap.Name == "gateway-proxy-envoy-config" {
+							Expect(structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring("gateway_proxy_sds"), "should have an sds cluster configured")
+						}
+					})
+				})
+
+				It("should add an anti-injection label to gateway-proxy pods when disableAutoinjection is enabled", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.istioIntegration.disableAutoinjection=true",
+							"settings.integrations.knative.enabled=true", // ensure that as many pods as possible are checked
+							"ingress.enabled=true",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentName := deployment.GetName()
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						if deploymentName == "gateway-proxy" {
+							// ensure every deployment has a istio annotation set to false
+							val, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio injection label", deploymentName))
+							Expect(val).To(Equal("false"), fmt.Sprintf("Deployment %s should have an istio annotation with value of 'false'", deploymentName))
+						}
+					})
+				})
+
+				It("should add an Istio injection label for pods that can be configured for it", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.istioIntegration.whitelistDiscovery=true",
+							"global.istioIntegration.disableAutoinjection=false",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						// Ensure that the discovery pod has a true label, gateway-proxy has a false label (default), and nothing else has any annoation.
+						// todo if we ever decide to add more pods to the list of 'allow istio injection' pods, then change this to a whitelist check
+						if structuredDeployment.GetName() == "discovery" {
+							val, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio injection annotation", deployment.GetName()))
+							Expect(val).To(Equal("true"), fmt.Sprintf("Deployment %s should have an istio annotation with value of 'true'", deployment.GetName()))
+							_, ok = structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioRevisionLabel]
+							Expect(ok).To(BeFalse(), fmt.Sprintf("Deployment %s should not contain an istio revision annotation", deployment.GetName()))
+						} else {
+							_, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeFalse(), fmt.Sprintf("Deployment %s should not contain an istio injection label", deployment.GetName()))
+						}
+					})
+				})
+
+				It("should add an Istio injection label for pods that can be configured for it", func() {
+					httpPort := 8080
+					httpsPort := 8443
+					secondDeploymentHttpPort := 1337
+					secondDeploymentHttpsPort := 1338
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.istioIntegration.whitelistDiscovery=true",
+							"global.istioIntegration.enableIstioSidecarOnGateway=true",
+							fmt.Sprintf("gatewayProxies.gatewayProxy.podTemplate.httpPort=%d", httpPort),
+							fmt.Sprintf("gatewayProxies.gatewayProxy.podTemplate.httpsPort=%d", httpsPort),
+							// shortcut to get a proxy with a name and mostly default values but avoid hiding any bugs around needing to set disabled=false
+							fmt.Sprintf("gatewayProxies.secondGatewayProxy.podTemplate.httpPort=%d", secondDeploymentHttpPort),
+							fmt.Sprintf("gatewayProxies.secondGatewayProxy.podTemplate.httpsPort=%d", secondDeploymentHttpsPort),
+						},
+					})
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						// Ensure that the discovery pod has a true annotation, gateway-proxy has a false annotation (default), and nothing else has any annoation.
+						// todo if we ever decide to add more pods to the list of 'allow istio injection' pods, then change this to a whitelist check
+						deploymentName := structuredDeployment.GetName()
+						if deploymentName == "discovery" {
+							val, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio injection annotation", deployment.GetName()))
+							Expect(val).To(Equal("true"), fmt.Sprintf("Deployment %s should have an istio annotation with value of 'true'", deployment.GetName()))
+						} else if deploymentName == "gateway-proxy" {
+							_, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio injection annotation", deploymentName))
+							excludedPortString, ok := structuredDeployment.Spec.Template.ObjectMeta.Annotations[istioExcludedPortsAnnotation]
+							Expect(ok).To(BeTrue())
+							Expect(excludedPortString).To(Equal(fmt.Sprintf("%d,%d", httpPort, httpsPort)), fmt.Sprintf("Deployment %s should exclude specified ports", deploymentName))
+						} else if deploymentName == "second-gateway-proxy" {
+							_, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio injection annotation", deploymentName))
+							excludedPortString, ok := structuredDeployment.Spec.Template.ObjectMeta.Annotations[istioExcludedPortsAnnotation]
+							Expect(ok).To(BeTrue())
+							Expect(excludedPortString).To(Equal(fmt.Sprintf("%d,%d", secondDeploymentHttpPort, secondDeploymentHttpsPort)), fmt.Sprintf("Deployment %s should exclude specified ports", deploymentName))
+						} else if deploymentName == "named-gateway-proxy" {
+							excludedPortString, ok := structuredDeployment.Spec.Template.ObjectMeta.Annotations[istioExcludedPortsAnnotation]
+							Expect(ok).To(BeTrue())
+							Expect(excludedPortString).To(Equal(fmt.Sprintf("%d,%d", httpPort, httpsPort)), fmt.Sprintf("Deployment %s should exclude the same specified ports as the default", deploymentName))
+						}
+					})
+				})
+
+				It("should add an Istio revision label for pods that can be configured for it", func() {
+					httpPort := 8080
+					httpsPort := 8443
+					secondDeploymentHttpPort := 1337
+					secondDeploymentHttpsPort := 1338
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.istioIntegration.whitelistDiscovery=true",
+							"global.istioIntegration.enableIstioSidecarOnGateway=true",
+							"global.istioIntegration.istioSidecarRevTag=some-revision",
+							fmt.Sprintf("gatewayProxies.gatewayProxy.podTemplate.httpPort=%d", httpPort),
+							fmt.Sprintf("gatewayProxies.gatewayProxy.podTemplate.httpsPort=%d", httpsPort),
+							// shortcut to get a proxy with a name and mostly default values but avoid hiding any bugs around needing to set disabled=false
+							fmt.Sprintf("gatewayProxies.secondGatewayProxy.podTemplate.httpPort=%d", secondDeploymentHttpPort),
+							fmt.Sprintf("gatewayProxies.secondGatewayProxy.podTemplate.httpsPort=%d", secondDeploymentHttpsPort),
+						},
+					})
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					}).ExpectAll(func(deployment *unstructured.Unstructured) {
+						deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+						// Ensure that the discovery pod has a true annotation, gateway-proxy has a false annotation (default), and nothing else has any annoation.
+						// todo if we ever decide to add more pods to the list of 'allow istio injection' pods, then change this to a whitelist check
+						deploymentName := structuredDeployment.GetName()
+						if deploymentName == "discovery" {
+							val, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeFalse(), fmt.Sprintf("Deployment %s should contain an istio injection annotation", deployment.GetName()))
+							val, ok = structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioRevisionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio revision annotation", deployment.GetName()))
+							Expect(val).To(Equal("some-revision"), fmt.Sprintf("Deployment %s should have a label for the istio revision tag", deployment.GetName()))
+						} else if deploymentName == "gateway-proxy" {
+							_, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeFalse(), fmt.Sprintf("Deployment %s should not contain a default istio injection annotation", deploymentName))
+							val, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioRevisionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio revision annotation", deployment.GetName()))
+							Expect(val).To(Equal("some-revision"), fmt.Sprintf("Deployment %s should have a label for the istio revision tag", deployment.GetName()))
+							excludedPortString, ok := structuredDeployment.Spec.Template.ObjectMeta.Annotations[istioExcludedPortsAnnotation]
+							Expect(ok).To(BeTrue())
+							Expect(excludedPortString).To(Equal(fmt.Sprintf("%d,%d", httpPort, httpsPort)), fmt.Sprintf("Deployment %s should exclude specified ports", deploymentName))
+						} else if deploymentName == "second-gateway-proxy" {
+							_, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeFalse(), fmt.Sprintf("Deployment %s should not contain an istio injection annotation", deploymentName))
+							val, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioRevisionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio revision annotation", deployment.GetName()))
+							Expect(val).To(Equal("some-revision"), fmt.Sprintf("Deployment %s should have a label for the istio revision tag", deployment.GetName()))
+							excludedPortString, ok := structuredDeployment.Spec.Template.ObjectMeta.Annotations[istioExcludedPortsAnnotation]
+							Expect(ok).To(BeTrue())
+							Expect(excludedPortString).To(Equal(fmt.Sprintf("%d,%d", secondDeploymentHttpPort, secondDeploymentHttpsPort)), fmt.Sprintf("Deployment %s should exclude specified ports", deploymentName))
+						} else if deploymentName == "named-gateway-proxy" {
+							_, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+							Expect(ok).To(BeFalse(), fmt.Sprintf("Deployment %s should not contain an istio injection annotation", deploymentName))
+							val, ok := structuredDeployment.Spec.Template.ObjectMeta.Labels[IstioRevisionLabel]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %s should contain an istio revision annotation", deployment.GetName()))
+							Expect(val).To(Equal("some-revision"), fmt.Sprintf("Deployment %s should have a label for the istio revision tag", deployment.GetName()))
+							excludedPortString, ok := structuredDeployment.Spec.Template.ObjectMeta.Annotations[istioExcludedPortsAnnotation]
+							Expect(ok).To(BeTrue())
+							Expect(excludedPortString).To(Equal(fmt.Sprintf("%d,%d", httpPort, httpsPort)), fmt.Sprintf("Deployment %s should exclude the same specified ports as the default", deploymentName))
+						}
+					})
+				})
+				It("istio injection should always be disabled in job pod templates", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.istioIntegration.disableAutoinjection=false",
+							"global.glooMtls.enabled=true",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Job"
+					}).ExpectAll(func(job *unstructured.Unstructured) {
+						jobObj, err := kuberesource.ConvertUnstructured(job)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Job %+v should be able to convert from unstructured", job))
+						structuredJob, ok := jobObj.(*batchv1.Job)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Job %+v should be able to cast to a structured job", job))
+
+						val, ok := structuredJob.Spec.Template.ObjectMeta.Labels[IstioInjectionLabel]
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Job %s should contain an istio injection annotation", job.GetName()))
+						Expect(val).To(Equal("false"), fmt.Sprintf("Job %s should have an istio annotation with value of 'false'", job.GetName()))
+					})
+				})
+
+				It("The created namespace can be labeled for Istio discovery", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"namespace.create=true",
+							"global.istioIntegration.labelInstallNamespace=true",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Namespace"
+					}).ExpectAll(func(namespace *unstructured.Unstructured) {
+						namespaceObject, err := kuberesource.ConvertUnstructured(namespace)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Namespace %+v should be able to convert from unstructured", namespace))
+						structuredNamespace, ok := namespaceObject.(*corev1.Namespace)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", namespace))
+
+						// Ensure that the discovery pod has a true annotation, gateway-proxy has a false annotation (default), and nothing else has any annoation.
+						if structuredNamespace.GetName() == "gloo-system" {
+							val, ok := structuredNamespace.ObjectMeta.Labels["istio-injection"]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Namespace %s should contain an Istio discovery label", structuredNamespace.GetName()))
+							Expect(val).To(Equal("enabled"), fmt.Sprintf("Namespace %s should have an Istio discovery label with value of 'enabled'", structuredNamespace.GetName()))
+						}
+					})
+				})
+				It("The created namespace can be labeled with a revision tag for Istio discovery", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"namespace.create=true",
+							"global.istioIntegration.labelInstallNamespace=true",
+							"global.istioIntegration.istioSidecarRevTag=some-revision",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Namespace"
+					}).ExpectAll(func(namespace *unstructured.Unstructured) {
+						namespaceObject, err := kuberesource.ConvertUnstructured(namespace)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Namespace %+v should be able to convert from unstructured", namespace))
+						structuredNamespace, ok := namespaceObject.(*corev1.Namespace)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", namespace))
+
+						// Ensure that the discovery pod has a true annotation, gateway-proxy has a false annotation (default), and nothing else has any annoation.
+						if structuredNamespace.GetName() == "gloo-system" {
+							_, ok := structuredNamespace.ObjectMeta.Labels["istio-injection"]
+							Expect(ok).To(BeFalse(), fmt.Sprintf("Namespace %s should not contain a generic Istio discovery label", structuredNamespace.GetName()))
+							val, ok := structuredNamespace.ObjectMeta.Labels["istio.io/rev"]
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Namespace %s should contain a revisioned Istio discovery label", structuredNamespace.GetName()))
+							Expect(val).To(Equal("some-revision"))
+						}
+					})
+				})
+
+				It("should set AppendXForwardHost to false in Settings when value is false", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{"global.istioIntegration.appendXForwardedHost=false"},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Settings"
+					}).ExpectAll(func(settings *unstructured.Unstructured) {
+						field := getFieldFromUnstructured(settings, "spec", "gloo", "istioOptions", "appendXForwardedHost")
+						Expect(field).To(BeFalse())
+					})
+				})
+			})
+
+			Context("gateway", func() {
+				var labels map[string]string
+				BeforeEach(func() {
+					labels = map[string]string{
+						"app":              "gloo",
+						"gloo":             "gateway-proxy",
+						"gateway-proxy-id": "gateway-proxy",
+					}
+					selector = map[string]string{
+						"gateway-proxy":    "live",
+						"gateway-proxy-id": "gateway-proxy",
+					}
+				})
+
+				It("has a namespace", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{"gatewayProxies.gatewayProxy.service.extraAnnotations.test=test"},
+					})
+					rb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      defaults.GatewayProxyName,
+						Labels:    labels,
+						Service: ServiceSpec{
+							Ports: []PortSpec{
+								{
+									Name: "http",
+									Port: 80,
+								},
+								{
+									Name: "https",
+									Port: 443,
+								},
+							},
+						},
+					}
+					svc := rb.GetService()
+					svc.Spec.Selector = selector
+					svc.Spec.Type = corev1.ServiceTypeLoadBalancer
+					svc.Spec.Ports[0].TargetPort = intstr.FromInt32(8080)
+					svc.Spec.Ports[1].TargetPort = intstr.FromInt32(8443)
+					svc.Annotations = map[string]string{"test": "test"}
+					testManifest.ExpectService(svc)
+				})
+
+				Context("access logging service", func() {
+					var (
+						accessLoggerName          = "gateway-proxy-access-logger"
+						gatewayProxyConfigMapName = "gateway-proxy-envoy-config"
+					)
+					BeforeEach(func() {
+						labels = map[string]string{
+							"app":  "gloo",
+							"gloo": "gateway-proxy-access-logger",
+						}
+					})
+
+					It("can create an access logging deployment/service", func() {
+						prepareMakefileFromValuesFile("values/val_access_logger.yaml")
+						container := GetQuayContainerSpec("access-logger", version, GetPodNamespaceEnvVar(), GetPodNameEnvVar(),
+							corev1.EnvVar{
+								Name:  "SERVICE_NAME",
+								Value: "AccessLog",
+							},
+							corev1.EnvVar{
+								Name:  "SERVER_PORT",
+								Value: "8083",
+							},
+						)
+						container.PullPolicy = "IfNotPresent"
+						svcBuilder := &ResourceBuilder{
+							Namespace:  namespace,
+							Name:       accessLoggerName,
+							Labels:     cloneMap(labels),
+							Containers: []ContainerSpec{container},
+							Service: ServiceSpec{
+								Ports: []PortSpec{
+									{
+										Name: "http",
+										Port: 8083,
+									},
+								},
+							},
+						}
+						svc := svcBuilder.GetService()
+						svc.Spec.Selector = map[string]string{
+							"app":  "gloo",
+							"gloo": "gateway-proxy-access-logger",
+						}
+						svc.Spec.Type = ""
+						svc.Spec.Ports[0].TargetPort = intstr.FromInt(8083)
+						svc.Spec.Selector = cloneMap(labels)
+
+						deploymentBuilder := &ResourceBuilder{
+							Namespace:  namespace,
+							Name:       accessLoggerName,
+							Labels:     cloneMap(labels),
+							Containers: []ContainerSpec{container},
+							Service: ServiceSpec{
+								Ports: []PortSpec{
+									{
+										Name: "http",
+										Port: 8083,
+									},
+								},
+							},
+						}
+						dep := deploymentBuilder.GetDeploymentAppsv1()
+						dep.Spec.Template.ObjectMeta.Labels = cloneMap(labels)
+						dep.Spec.Selector.MatchLabels = cloneMap(labels)
+						dep.Spec.Template.Spec.Containers[0].Ports = []corev1.ContainerPort{
+							{Name: "http", ContainerPort: 8083, Protocol: "TCP"},
+						}
+						dep.Spec.Template.Annotations = statsAnnotations
+						dep.Spec.Template.Spec.ServiceAccountName = "gateway-proxy"
+
+						truez := true
+						defaultUser := int64(10101)
+						dep.Spec.Template.Spec.SecurityContext = &corev1.PodSecurityContext{
+							RunAsUser:    &defaultUser,
+							RunAsNonRoot: &truez,
+						}
+						testManifest.ExpectDeploymentAppsV1(dep)
+						testManifest.ExpectService(svc)
+					})
+
+					It("has a proxy with access logging cluster", func() {
+						prepareMakefileFromValuesFile("values/val_access_logger.yaml")
+						proxySpec := make(map[string]string)
+						labels = map[string]string{
+							"gloo":             "gateway-proxy",
+							"app":              "gloo",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						proxySpec["envoy.yaml"] = confWithAccessLogger
+						cmRb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      gatewayProxyConfigMapName,
+							Labels:    labels,
+							Data:      proxySpec,
+						}
+						proxy := cmRb.GetConfigMap()
+						testManifest.ExpectConfigMapWithYamlData(proxy)
+					})
+				})
+
+				Context("default gateways", func() {
+					// Gateways are not directly included in the helm manifest anymore; instead, their contents are
+					// stored in a ConfigMap, and the resource rollout job mounts the ConfigMap as a file and applies
+					// the file via kubectl.
+					// In these tests, to confirm the existence of the Gateway CRs, we look for the gateway in the
+					// ConfigMap data.
+
+					gw := makeUnstructuredGateway(namespace, defaults.GatewayProxyName, false)
+					gwSsl := makeUnstructuredGateway(namespace, defaults.GatewayProxyName, true)
+
+					It("does not render when gatewaySettings is disabled", func() {
+						// by default, gateway-proxy should render
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName:                    BeEquivalentTo(gw),
+							getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+						})
+
+						// if explicitly setting enabled=true, gateway-proxy should render
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.gatewaySettings.enabled=true"},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName:                    BeEquivalentTo(gw),
+							getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+						})
+
+						// if explicitly setting enabled=false, gateway-proxy should not render
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.gatewaySettings.enabled=false"},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{})
+					})
+
+					It("does not render when gatewayProxy is disabled", func() {
+						// by default, gateway-proxy should render
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName:                    BeEquivalentTo(gw),
+							getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+						})
+
+						// if explicitly setting disabled=false, gateway-proxy should render
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.disabled=false"},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName:                    BeEquivalentTo(gw),
+							getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+						})
+
+						// if explicitly setting disabled=true, gateway-proxy should not render
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.disabled=true"},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{})
+					})
+
+					It("renders custom gateway when gatewayProxy is disabled", func() {
+						// when explicitly disabling both gateways, neither should render
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.disabled=true",
+								"gatewayProxies.anotherGatewayProxy.disabled=true",
+							},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{})
+
+						// when disabling default gateway and enabling custom gateway, only custom gateway should render
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.disabled=true",
+								"gatewayProxies.anotherGatewayProxy.disabled=false",
+							},
+						})
+						anotherGw := makeUnstructuredGateway(namespace, "another-gateway-proxy", false)
+						anotherGwSsl := makeUnstructuredGateway(namespace, "another-gateway-proxy", true)
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"another-gateway-proxy":     BeEquivalentTo(anotherGw),
+							"another-gateway-proxy-ssl": BeEquivalentTo(anotherGwSsl),
+						})
+					})
+
+					It("renders custom gateway when gatewayProxy is disabled and custom disabled is not set", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.disabled=true",
+								// anotherGatewayProxy should exist but not have a value for disabled
+								"gatewayProxies.anotherGatewayProxy.loopbackAddress=127.0.0.1",
+							},
+						})
+						anotherGw := makeUnstructuredGateway(namespace, "another-gateway-proxy", false)
+						anotherGwSsl := makeUnstructuredGateway(namespace, "another-gateway-proxy", true)
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"another-gateway-proxy":     BeEquivalentTo(anotherGw),
+							"another-gateway-proxy-ssl": BeEquivalentTo(anotherGwSsl),
+						})
+					})
+
+					It("does not overwrite nodeSelectors specified for custom gateway proxy", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.nodeSelector.default=default",
+								// anotherGatewayProxy should have its own nodeSelector and not the default
+								"gatewayProxies.anotherGatewayProxy.podTemplate.nodeSelector.custom=custom",
+							},
+						})
+						gwp := getDeployment(testManifest, namespace, "another-gateway-proxy")
+						Expect(gwp.Spec.Template.Spec.NodeSelector).To(Equal(map[string]string{"custom": "custom"}))
+					})
+
+					It("has a different checksum for each gateway-proxy-envoy-config", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.globalDownstreamMaxConnections=54321",
+								// anotherGatewayProxy should a different value of globalDownstreamMaxConnections to ensure that the config maps generated are different
+								"gatewayProxies.anotherGatewayProxy.globalDownstreamMaxConnections=12345",
+							},
+						})
+
+						defaultGWPconfigMap := getConfigMap(testManifest, namespace, "gateway-proxy-envoy-config")
+						anotherGWPconfigMap := getConfigMap(testManifest, namespace, "another-gateway-proxy-envoy-config")
+						Expect(defaultGWPconfigMap.Data["envoy.yaml"]).ToNot(Equal(anotherGWPconfigMap.Data["envoy.yaml"]))
+
+						defaultGWP := getDeployment(testManifest, namespace, "gateway-proxy")
+						anotherGWP := getDeployment(testManifest, namespace, "another-gateway-proxy")
+						Expect(defaultGWP.Spec.Template.Annotations["checksum/gateway-proxy-envoy-config"]).ToNot(Equal(anotherGWP.Spec.Template.Annotations["checksum/another-gateway-proxy-envoy-config"]))
+					})
+
+					It("uses default nodeSelectors for custom gateway proxy when none is specified", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.nodeSelector.default=default",
+								// anotherGatewayProxy should get the default nodeSelector
+								"gatewayProxies.anotherGatewayProxy.loopbackAddress=127.0.0.1",
+							},
+						})
+						gwp := getDeployment(testManifest, namespace, "another-gateway-proxy")
+						Expect(gwp.Spec.Template.Spec.NodeSelector).To(Equal(map[string]string{"default": "default"}))
+					})
+
+					It("uses appropriate nodeSelectors for custom gateway proxies depending on whether any is specified", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								// unspecifiedGatewayProxy should get the default nodeSelector
+								"gatewayProxies.unspecifiedGatewayProxy.loopbackAddress=127.0.0.1",
+								// specifiedGatewayProxy should keep its specified nodeSelector
+								"gatewayProxies.specifiedGatewayProxy.podTemplate.nodeSelector.custom=custom",
+								// default specified last to catch accidental overwriting
+								"gatewayProxies.gatewayProxy.podTemplate.nodeSelector.default=default",
+							},
+						})
+
+						unspecified := getDeployment(testManifest, namespace, "unspecified-gateway-proxy")
+						Expect(unspecified.Spec.Template.Spec.NodeSelector).To(Equal(map[string]string{"default": "default"}))
+
+						specified := getDeployment(testManifest, namespace, "specified-gateway-proxy")
+						Expect(specified.Spec.Template.Spec.NodeSelector).To(Equal(map[string]string{"custom": "custom"}))
+
+						gwp := getDeployment(testManifest, namespace, "gateway-proxy")
+						Expect(gwp.Spec.Template.Spec.NodeSelector).To(Equal(map[string]string{"default": "default"}))
+					})
+
+					It("renders with http/https gateways by default", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName:                    BeEquivalentTo(gw),
+							getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+						})
+					})
+
+					It("can disable rendering http/https gateways", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.gatewaySettings.disableGeneratedGateways=true"},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{})
+					})
+
+					It("can disable http gateway", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.gatewaySettings.disableHttpGateway=true"},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							getSslGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwSsl),
+						})
+					})
+
+					It("disabling http gateway disables corresponding service port", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.gatewaySettings.disableHttpGateway=true"},
+						})
+
+						var gatewayProxyService *corev1.Service
+
+						serviceLabels := map[string]string{
+							"app":              "gloo",
+							"gloo":             "gateway-proxy",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						rb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      "gateway-proxy",
+							Args:      nil,
+							Labels:    serviceLabels,
+						}
+						gatewayProxyService = rb.GetService()
+						selectorLabels := map[string]string{
+							"gateway-proxy-id": "gateway-proxy",
+							"gateway-proxy":    "live",
+						}
+						gatewayProxyService.Spec.Selector = selectorLabels
+						gatewayProxyService.Spec.Ports = []corev1.ServicePort{
+							{
+								Name:       "https",
+								Protocol:   "TCP",
+								Port:       443,
+								TargetPort: intstr.IntOrString{IntVal: 8443},
+							},
+						}
+						gatewayProxyService.Spec.Type = corev1.ServiceTypeLoadBalancer
+
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("can disable https gateway", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.gatewaySettings.disableHttpsGateway=true"},
+						})
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName: BeEquivalentTo(gw),
+						})
+					})
+
+					It("disabling https gateway disables corresponding service port", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.gatewaySettings.disableHttpsGateway=true"},
+						})
+
+						var gatewayProxyService *corev1.Service
+
+						serviceLabels := map[string]string{
+							"app":              "gloo",
+							"gloo":             "gateway-proxy",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						rb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      "gateway-proxy",
+							Args:      nil,
+							Labels:    serviceLabels,
+						}
+						gatewayProxyService = rb.GetService()
+						selectorLabels := map[string]string{
+							"gateway-proxy-id": "gateway-proxy",
+							"gateway-proxy":    "live",
+						}
+						gatewayProxyService.Spec.Selector = selectorLabels
+						gatewayProxyService.Spec.Ports = []corev1.ServicePort{
+							{
+								Name:       "http",
+								Protocol:   "TCP",
+								Port:       80,
+								TargetPort: intstr.IntOrString{IntVal: 8080},
+							},
+						}
+						gatewayProxyService.Spec.Type = corev1.ServiceTypeLoadBalancer
+
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("sets http hybrid gateway", func() {
+						gwHybrid := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8080
+  hybridGateway:
+    matchedGateways:
+    - httpGateway:
+        virtualServices:
+        - name: default
+          namespace: gloo-system
+      matcher:
+        sourcePrefixRanges:
+        - addressPrefix: 0.0.0.0
+          prefixLen: 1
+    - httpGateway:
+        virtualServices:
+        - name: client-ip-reject
+          namespace: gloo-system
+      matcher: {}
+  httpGateway: {}
+  useProxyProto: false
+  ssl: false
+  proxyNames:
+  - gateway-proxy
+`)
+						prepareMakefileFromValuesFile("values/val_gwp_http_hybrid_gateway.yaml")
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"gateway-proxy":     BeEquivalentTo(gwHybrid),
+							"gateway-proxy-ssl": BeEquivalentTo(gwSsl),
+						})
+					})
+
+					It("sets https hybrid gateway", func() {
+						gwHybrid := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy-ssl
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8443
+  hybridGateway:
+    matchedGateways:
+    - httpGateway:
+        virtualServices:
+        - name: default
+          namespace: gloo-system
+      matcher:
+        sourcePrefixRanges:
+        - addressPrefix: 0.0.0.0
+          prefixLen: 1
+        sslConfig:
+          secretRef:
+            name: gloo-cert
+            namespace: gloo-system
+    - httpGateway:
+        virtualServices:
+        - name: client-ip-reject
+          namespace: gloo-system
+      matcher:
+        sslConfig:
+          secretRef:
+            name: gloo-cert
+            namespace: gloo-system
+  httpGateway: {}
+  useProxyProto: false
+  ssl: true
+  proxyNames:
+  - gateway-proxy
+`)
+						prepareMakefileFromValuesFile("values/val_gwp_https_hybrid_gateway.yaml")
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"gateway-proxy":     BeEquivalentTo(gw),
+							"gateway-proxy-ssl": BeEquivalentTo(gwHybrid),
+						})
+					})
+
+					It("can set accessLoggingService", func() {
+						gwAls := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8080
+  httpGateway: {}
+  options:
+    accessLoggingService:
+      accessLog:
+      - fileSink:
+          path: /dev/stdout
+          stringFormat: ""
+  useProxyProto: false
+  ssl: false
+  proxyNames:
+  - gateway-proxy
+`)
+
+						gwAlsSsl := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy-ssl
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8443
+  httpGateway: {}
+  options:
+    accessLoggingService:
+      accessLog:
+      - fileSink:
+          path: /dev/stdout
+          stringFormat: ""
+  useProxyProto: false
+  ssl: true
+  proxyNames:
+  - gateway-proxy
+`)
+
+						prepareMakefileFromValuesFile("values/val_default_gateway_access_logging_service.yaml")
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"gateway-proxy":     BeEquivalentTo(gwAls),
+							"gateway-proxy-ssl": BeEquivalentTo(gwAlsSsl),
+						})
+					})
+
+					It("can set tracing provider", func() {
+						gwTracing := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8080
+  httpGateway:
+    options:
+      httpConnectionManagerSettings:
+        tracing:
+          zipkinConfig:
+            collector_cluster: zipkin
+            collector_endpoint: /api/v2/spans
+  useProxyProto: false
+  ssl: false
+  proxyNames:
+  - gateway-proxy
+`)
+
+						gwTracingSsl := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy-ssl
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8443
+  httpGateway:
+    options:
+      httpConnectionManagerSettings:
+        tracing:
+          zipkinConfig:
+            collector_cluster: zipkin
+            collector_endpoint: /api/v2/spans
+  useProxyProto: false
+  ssl: true
+  proxyNames:
+  - gateway-proxy
+`)
+						prepareMakefileFromValuesFile("values/val_tracing_provider_cluster.yaml")
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"gateway-proxy":     BeEquivalentTo(gwTracing),
+							"gateway-proxy-ssl": BeEquivalentTo(gwTracingSsl),
+						})
+					})
+
+					It("gwp hpa disabled by default", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+
+						testManifest.ExpectUnstructured("HorizontalPodAutoscaler", namespace, defaults.GatewayProxyName+"-hpa").To(BeNil())
+					})
+
+					It("can create gwp autoscaling/v1 hpa", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.horizontalPodAutoscaler.apiVersion=autoscaling/v1",
+								"gatewayProxies.gatewayProxy.horizontalPodAutoscaler.minReplicas=1",
+								"gatewayProxies.gatewayProxy.horizontalPodAutoscaler.maxReplicas=2",
+								"gatewayProxies.gatewayProxy.horizontalPodAutoscaler.targetCPUUtilizationPercentage=75",
+							},
+						})
+
+						hpa := makeUnstructured(`
+kind: HorizontalPodAutoscaler
+metadata:
+  labels:
+    gateway-proxy-id: gateway-proxy
+    gloo: gateway-proxy
+    app: gloo
+  name: gateway-proxy-hpa
+  namespace: gloo-system
+spec:
+  maxReplicas: 2
+  minReplicas: 1
+  scaleTargetRef:
+    apiVersion: apps/v1
+    kind: Deployment
+    name: gateway-proxy
+  targetCPUUtilizationPercentage: 75
+apiVersion: autoscaling/v1
+`)
+
+						testManifest.ExpectUnstructured("HorizontalPodAutoscaler", namespace, defaults.GatewayProxyName+"-hpa").To(BeEquivalentTo(hpa))
+					})
+
+					It("can create gwp autoscaling/v2beta2 hpa", func() {
+						prepareMakefileFromValuesFile("values/val_gwp_hpa_v2beta2.yaml")
+
+						hpa := makeUnstructured(`
+kind: HorizontalPodAutoscaler
+metadata:
+  labels:
+    gateway-proxy-id: gateway-proxy
+    gloo: gateway-proxy
+    app: gloo
+  name: gateway-proxy-hpa
+  namespace: gloo-system
+spec:
+  maxReplicas: 2
+  minReplicas: 1
+  scaleTargetRef:
+    apiVersion: apps/v1
+    kind: Deployment
+    name: gateway-proxy
+  metrics:
+    - type: Resource
+      resource:
+        name: cpu
+        target:
+          type: Utilization
+          averageUtilization: 50
+  behavior:
+    scaleDown:
+      policies:
+      - type: Pods
+        value: 4
+        periodSeconds: 60
+      - type: Percent
+        value: 10
+        periodSeconds: 60
+apiVersion: autoscaling/v2beta2
+`)
+
+						testManifest.ExpectUnstructured("HorizontalPodAutoscaler", namespace, defaults.GatewayProxyName+"-hpa").To(BeEquivalentTo(hpa))
+					})
+
+					It("can create gwp autoscaling/v2 hpa", func() {
+						prepareMakefileFromValuesFile("values/val_gwp_hpa_v2.yaml")
+
+						hpa := makeUnstructured(`
+apiVersion: autoscaling/v2
+kind: HorizontalPodAutoscaler
+metadata:
+  labels:
+    app: gloo
+    gateway-proxy-id: gateway-proxy
+    gloo: gateway-proxy
+  name: gateway-proxy-hpa
+  namespace: gloo-system
+spec:
+  maxReplicas: 2
+  metrics:
+    - type: Resource
+      resource:
+        name: cpu
+        target:
+          type: Utilization
+          averageUtilization: 75
+  minReplicas: 1
+  scaleTargetRef:
+    apiVersion: apps/v1
+    kind: Deployment
+    name: gateway-proxy
+  behavior:
+    scaleUp:
+      stabilizationWindowSeconds: 0
+      policies:
+      - type: Percent
+        value: 100
+        periodSeconds: 15
+      - type: Pods
+        value: 4
+        periodSeconds: 15
+      selectPolicy: Max
+    scaleDown:
+      policies:
+      - type: Percent
+        value: 100
+        periodSeconds: 15
+      stabilizationWindowSeconds: 300
+`)
+
+						testManifest.ExpectUnstructured("HorizontalPodAutoscaler", namespace, defaults.GatewayProxyName+"-hpa").To(BeEquivalentTo(hpa))
+					})
+
+					It("gwp pdb disabled by default", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+
+						testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, defaults.GatewayProxyName+"-pdb").To(BeNil())
+					})
+
+					It("can create gwp pdb with minAvailable", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podDisruptionBudget.minAvailable='2'",
+							},
+						})
+
+						pdb := makeUnstructured(`
+apiVersion: policy/v1
+kind: PodDisruptionBudget
+metadata:
+  name: gateway-proxy-pdb
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  minAvailable: '2'
+  selector:
+    matchLabels:
+      gateway-proxy-id: gateway-proxy
+`)
+
+						testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, defaults.GatewayProxyName+"-pdb").To(BeEquivalentTo(pdb))
+					})
+
+					It("can create gwp pdb with maxUnavailable", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podDisruptionBudget.maxUnavailable='2'",
+							},
+						})
+
+						pdb := makeUnstructured(`
+apiVersion: policy/v1
+kind: PodDisruptionBudget
+metadata:
+  name: gateway-proxy-pdb
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  maxUnavailable: '2'
+  selector:
+    matchLabels:
+      gateway-proxy-id: gateway-proxy
+`)
+
+						testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, defaults.GatewayProxyName+"-pdb").To(BeEquivalentTo(pdb))
+					})
+
+					It("can create gwp pdb for multiple gateways with unique selectors", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podDisruptionBudget.maxUnavailable='2'",
+								"gatewayProxies.gatewayProxyTwo.podDisruptionBudget.maxUnavailable='2'",
+							},
+						})
+
+						pdbFormat := `
+apiVersion: policy/v1
+kind: PodDisruptionBudget
+metadata:
+  name: %s-pdb
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  maxUnavailable: '2'
+  selector:
+    matchLabels:
+      gateway-proxy-id: %s
+`
+
+						testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, defaults.GatewayProxyName+"-pdb").To(BeEquivalentTo(makeUnstructured(fmt.Sprintf(pdbFormat, defaults.GatewayProxyName, defaults.GatewayProxyName))))
+						testManifest.ExpectUnstructured("PodDisruptionBudget", namespace, defaults.GatewayProxyName+"-two-pdb").To(BeEquivalentTo(makeUnstructured(fmt.Sprintf(pdbFormat, defaults.GatewayProxyName+"-two", defaults.GatewayProxyName+"-two"))))
+					})
+
+					It("can render with custom listener yaml", func() {
+						prepareMakefileFromValuesFile("values/val_custom_gateways.yaml")
+						gws := []*unstructured.Unstructured{
+							makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8080
+  httpGateway:
+    virtualServices:
+    - name: one
+      namespace: one
+  useProxyProto: true
+  ssl: false
+  proxyNames:
+  - gateway-proxy
+`),
+							makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: gateway-proxy-ssl
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8443
+  httpGateway:
+    virtualServices:
+    - name: one
+      namespace: one
+  useProxyProto: true
+  ssl: true
+  proxyNames:
+  - gateway-proxy
+`),
+							makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: test-name
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8081
+  httpGateway:
+    virtualServices:
+    - name: one
+      namespace: one
+  useProxyProto: true
+  ssl: false
+  proxyNames:
+  - test-name
+`),
+							makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: test-name-ssl
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8444
+  httpGateway:
+    virtualServices:
+    - name: one
+      namespace: one
+  useProxyProto: true
+  ssl: true
+  proxyNames:
+  - test-name
+`),
+						}
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"gateway-proxy":     BeEquivalentTo(gws[0]),
+							"gateway-proxy-ssl": BeEquivalentTo(gws[1]),
+							"test-name":         BeEquivalentTo(gws[2]),
+							"test-name-ssl":     BeEquivalentTo(gws[3]),
+						})
+					})
+				})
+
+				Context("Failover Gateway", func() {
+					gwFailover := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: ` + getFailoverGatewayName(defaults.GatewayProxyName) + `
+  namespace: ` + namespace + `
+  labels:
+    app: gloo
+spec:
+  bindAddress: "` + defaults.GatewayBindAddress + `"
+  bindPort: 15444
+  tcpGateway:
+    tcpHosts:
+    - name: failover
+      sslConfig:
+        secretRef:
+          name: failover-downstream
+          namespace: gloo-system
+      destination:
+        forwardSniClusterName: {}
+  proxyNames:
+  - ` + defaults.GatewayProxyName)
+
+					It("renders with http/https gateways by default", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.failover.enabled=true",
+								"gatewayProxies.gatewayProxy.failover.port=15444",
+							},
+						})
+
+						// expect the 2 default gateways + failover gateway
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName:                         Not(BeNil()),
+							getSslGatewayName(defaults.GatewayProxyName):      Not(BeNil()),
+							getFailoverGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwFailover),
+						})
+					})
+
+					It("by default will not render failover gateway", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						// expect only the 2 default gateways
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							defaults.GatewayProxyName:                    Not(BeNil()),
+							getSslGatewayName(defaults.GatewayProxyName): Not(BeNil()),
+						})
+					})
+				})
+
+				Context("custom gateway", func() {
+					Context("when the default values weren't overridden", func() {
+						BeforeEach(func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"gatewayProxies.anotherGatewayProxy.gatewaySettings.options.socketOptions[0].description=enable keep-alive",
+								},
+							})
+						})
+						It("uses default values for the gateway", func() {
+							anotherGw := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  labels:
+    app: gloo
+  name: another-gateway-proxy
+  namespace: ` + namespace + `
+spec:
+  bindAddress: '::'
+  bindPort: 8080
+  httpGateway: {}
+  options:
+    socketOptions:
+    - description: "enable keep-alive"
+  proxyNames:
+  - another-gateway-proxy
+  ssl: false
+  useProxyProto: false
+`)
+							// expect 2 default gateways + another-gateway-proxy + another-gateway-proxy-ssl
+							assertCustomResourceManifest(map[string]types.GomegaMatcher{
+								defaults.GatewayProxyName:                    Not(BeNil()),
+								getSslGatewayName(defaults.GatewayProxyName): Not(BeNil()),
+								"another-gateway-proxy":                      BeEquivalentTo(anotherGw),
+								getSslGatewayName("another-gateway-proxy"):   Not(BeNil()),
+							})
+						})
+						It("uses default values for the deployment", func() {
+							deployment := getDeployment(testManifest, namespace, "another-gateway-proxy")
+							Expect(*deployment.Spec.Replicas).To(Equal(int32(1)))
+						})
+						It("uses default values for the service", func() {
+							service := getService(testManifest, namespace, "another-gateway-proxy")
+							Expect(service.Spec.Type).To(Equal(corev1.ServiceType("LoadBalancer")))
+						})
+						It("uses default values for the config map", func() {
+							configMap := getConfigMap(testManifest, namespace, "another-gateway-proxy-envoy-config")
+							Expect(configMap.Data).ToNot(BeNil()) // Uses the default config data
+						})
+					})
+
+					Context("when default values are overridden by custom gatewayproxy", func() {
+						BeforeEach(func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"gatewayProxies.anotherGatewayProxy.podTemplate.httpPort=9999",          // used by gateway
+									"gatewayProxies.anotherGatewayProxy.kind.deployment.replicas=50",        // used by deployment
+									"gatewayProxies.anotherGatewayProxy.service.type=NodePort",              // used by service
+									"gatewayProxies.anotherGatewayProxy.configMap.data.customData=someData", // used by config map
+								},
+							})
+						})
+						It("uses merged values for the gateway", func() {
+							anotherGw := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  labels:
+    app: gloo
+  name: another-gateway-proxy
+  namespace: ` + namespace + `
+spec:
+  bindAddress: '::'
+  bindPort: 9999
+  httpGateway: {}
+  proxyNames:
+  - another-gateway-proxy
+  ssl: false
+  useProxyProto: false
+`)
+							// expect 2 default gateways + another-gateway-proxy + another-gateway-proxy-ssl
+							assertCustomResourceManifest(map[string]types.GomegaMatcher{
+								defaults.GatewayProxyName:                    Not(BeNil()),
+								getSslGatewayName(defaults.GatewayProxyName): Not(BeNil()),
+								"another-gateway-proxy":                      BeEquivalentTo(anotherGw),
+								getSslGatewayName("another-gateway-proxy"):   Not(BeNil()),
+							})
+						})
+						It("uses merged values for the deployment", func() {
+							deployment := getDeployment(testManifest, namespace, "another-gateway-proxy")
+							Expect(*deployment.Spec.Replicas).To(Equal(int32(50)))
+						})
+						It("uses merged values for the service", func() {
+							service := getService(testManifest, namespace, "another-gateway-proxy")
+							Expect(service.Spec.Type).To(Equal(corev1.ServiceType("NodePort")))
+						})
+						It("uses merged values for the config map", func() {
+							configMap := getConfigMap(testManifest, namespace, "another-gateway-proxy-envoy-config")
+							Expect(configMap.Data).To(Equal(map[string]string{"customData": "someData"}))
+						})
+					})
+
+					Context("when non-default values are overridden by custom gatewayproxy", func() {
+						BeforeEach(func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"gatewayProxies.gatewayProxy.service.extraAnnotations.original=original",
+									"gatewayProxies.anotherGatewayProxy.service.extraAnnotations.override=override",
+								},
+							})
+						})
+
+						It("does not merge extraAnnotations for service", func() {
+							service := getService(testManifest, namespace, "another-gateway-proxy")
+							Expect(service.ObjectMeta.Annotations).To(Equal(map[string]string{"override": "override"}))
+						})
+					})
+				})
+
+				Context("when multiple custom gatewayproxy override disabled default proxy", func() {
+					BeforeEach(func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.disabled=true",
+								"gatewayProxies.gatewayProxy.gatewaySettings.disableHttpGateway=true",
+								"gatewayProxies.gatewayProxy.gatewaySettings.customHttpsGateway.virtualServiceSelector.gateway=default",
+								"gatewayProxies.firstGatewayProxy.disabled=false",
+								"gatewayProxies.firstGatewayProxy.gatewaySettings.customHttpsGateway.virtualServiceSelector.gateway=first",
+								"gatewayProxies.secondGatewayProxy.disabled=false",
+								"gatewayProxies.secondGatewayProxy.gatewaySettings.customHttpsGateway.virtualServiceSelector.gateway=second",
+							},
+						})
+					})
+					It("correctly merges custom gatewayproxy values", func() {
+						// only the first and second ssl gateways should be enabled
+						firstGwSsl := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: first-gateway-proxy-ssl
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8443
+  httpGateway:
+    virtualServiceSelector:
+      gateway: first
+  useProxyProto: false
+  ssl: true
+  proxyNames:
+  - first-gateway-proxy
+`)
+						secondGwSsl := makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  name: second-gateway-proxy-ssl
+  namespace: gloo-system
+  labels:
+    app: gloo
+spec:
+  bindAddress: "::"
+  bindPort: 8443
+  httpGateway:
+    virtualServiceSelector:
+      gateway: second
+  useProxyProto: false
+  ssl: true
+  proxyNames:
+  - second-gateway-proxy
+`)
+						assertCustomResourceManifest(map[string]types.GomegaMatcher{
+							"first-gateway-proxy-ssl":  BeEquivalentTo(firstGwSsl),
+							"second-gateway-proxy-ssl": BeEquivalentTo(secondGwSsl),
+						})
+					})
+				})
+
+				Context("gateway-proxy service account", func() {
+					var gatewayProxyServiceAccount *corev1.ServiceAccount
+
+					BeforeEach(func() {
+						saLabels := map[string]string{
+							"app":  "gloo",
+							"gloo": "gateway-proxy",
+						}
+						rb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      "gateway-proxy",
+							Args:      nil,
+							Labels:    saLabels,
+						}
+						gatewayProxyServiceAccount = rb.GetServiceAccount()
+						gatewayProxyServiceAccount.AutomountServiceAccountToken = proto.Bool(false)
+					})
+
+					It("sets extra annotations", func() {
+						gatewayProxyServiceAccount.ObjectMeta.Annotations = map[string]string{"foo": "bar", "bar": "baz"}
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.proxyServiceAccount.extraAnnotations.foo=bar",
+								"gateway.proxyServiceAccount.extraAnnotations.bar=baz",
+								"gateway.proxyServiceAccount.disableAutomount=true",
+							},
+						})
+						testManifest.ExpectServiceAccount(gatewayProxyServiceAccount)
+					})
+				})
+
+				Context("gateway-proxy service", func() {
+					var gatewayProxyService *corev1.Service
+
+					BeforeEach(func() {
+						serviceLabels := map[string]string{
+							"app":              "gloo",
+							"gloo":             "gateway-proxy",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						rb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      "gateway-proxy",
+							Args:      nil,
+							Labels:    serviceLabels,
+						}
+						gatewayProxyService = rb.GetService()
+						selectorLabels := map[string]string{
+							"gateway-proxy-id": "gateway-proxy",
+							"gateway-proxy":    "live",
+						}
+						gatewayProxyService.Spec.Selector = selectorLabels
+						gatewayProxyService.Spec.Ports = []corev1.ServicePort{
+							{
+								Name:       "http",
+								Protocol:   "TCP",
+								Port:       80,
+								TargetPort: intstr.IntOrString{IntVal: 8080},
+							},
+							{
+								Name:       "https",
+								Protocol:   "TCP",
+								Port:       443,
+								TargetPort: intstr.IntOrString{IntVal: 8443},
+							},
+						}
+						gatewayProxyService.Spec.Type = corev1.ServiceTypeLoadBalancer
+					})
+
+					It("is not created if disabled", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						testManifest.ExpectService(gatewayProxyService)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.disabled=false"},
+						})
+						testManifest.ExpectService(gatewayProxyService)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.disabled=true"},
+						})
+						testManifest.Expect("Service", namespace, defaults.GatewayProxyName).To(BeNil())
+					})
+
+					It("sets extra annotations", func() {
+						gatewayProxyService.ObjectMeta.Annotations = map[string]string{"foo": "bar", "bar": "baz"}
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.service.extraAnnotations.foo=bar",
+								"gatewayProxies.gatewayProxy.service.extraAnnotations.bar=baz",
+							},
+						})
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("sets externalIPs", func() {
+						gatewayProxyService.Spec.Type = corev1.ServiceTypeLoadBalancer
+						gatewayProxyService.Spec.ExternalIPs = []string{"130.211.204.1", "130.211.204.2"}
+						gatewayProxyService.Annotations = map[string]string{"test": "test"}
+						prepareMakefileFromValuesFile("values/val_lb_external_ips.yaml")
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("sets external traffic policy", func() {
+						gatewayProxyService.Spec.ExternalTrafficPolicy = corev1.ServiceExternalTrafficPolicyTypeLocal
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.service.externalTrafficPolicy=" + string(corev1.ServiceExternalTrafficPolicyTypeLocal),
+							},
+						})
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("sets cluster IP", func() {
+						gatewayProxyService.Spec.Type = corev1.ServiceTypeClusterIP
+						gatewayProxyService.Spec.ClusterIP = "test-ip"
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.service.type=ClusterIP",
+								"gatewayProxies.gatewayProxy.service.clusterIP=test-ip",
+							},
+						})
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("sets load balancer IP", func() {
+						gatewayProxyService.Spec.Type = corev1.ServiceTypeLoadBalancer
+						gatewayProxyService.Spec.LoadBalancerIP = "test-lb-ip"
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.service.type=LoadBalancer",
+								"gatewayProxies.gatewayProxy.service.loadBalancerIP=test-lb-ip",
+							},
+						})
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("sets load balancer source ranges", func() {
+						gatewayProxyService.Spec.Type = corev1.ServiceTypeLoadBalancer
+						gatewayProxyService.Spec.LoadBalancerSourceRanges = []string{"130.211.204.1/32", "130.211.204.2/32"}
+						gatewayProxyService.Annotations = map[string]string{"test": "test"}
+						prepareMakefileFromValuesFile("values/val_lb_source_ranges.yaml")
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("sets custom service name", func() {
+						gatewayProxyService.ObjectMeta.Name = "gateway-proxy-custom"
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.service.name=gateway-proxy-custom",
+							},
+						})
+						testManifest.ExpectService(gatewayProxyService)
+					})
+
+					It("adds failover port", func() {
+						gatewayProxyService.Spec.Ports = append(gatewayProxyService.Spec.Ports, corev1.ServicePort{
+							Name:     "failover",
+							Protocol: corev1.ProtocolTCP,
+							Port:     15444,
+							TargetPort: intstr.IntOrString{
+								Type:   intstr.Int,
+								IntVal: 15444,
+							},
+							NodePort: 32000,
+						})
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.failover.enabled=true",
+								"gatewayProxies.gatewayProxy.failover.port=15444",
+								"gatewayProxies.gatewayProxy.failover.nodePort=32000",
+							},
+						})
+						testManifest.ExpectService(gatewayProxyService)
+					})
+				})
+
+				Context("gateway-proxy deployment", func() {
+					var gatewayProxyDeployment *appsv1.Deployment
+
+					checkDiscoveryAddressEqual := func(expected string) {
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment" && resource.GetName() == "gateway-proxy"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), "Deployment should be able to convert from unstructured")
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), "Deployment should be able to cast to a structured deployment")
+							isProxyConfigSet := false
+
+							var discoveryAddress interface{}
+							for _, container := range structuredDeployment.Spec.Template.Spec.Containers {
+								for _, env := range container.Env {
+									if env.Name == "PROXY_CONFIG" {
+										isProxyConfigSet = true
+										var proxyConfigMap map[string]interface{}
+										err := yaml.Unmarshal([]byte(env.Value), &proxyConfigMap)
+										Expect(err).ToNot(HaveOccurred())
+										discoveryAddress, ok = proxyConfigMap["discoveryAddress"]
+										Expect(ok).To(BeTrue(), "discoveryAddress should be set in PROXY_CONFIG")
+										Expect(discoveryAddress).To(Equal(expected), fmt.Sprintf("discovery address should be value: %v", expected))
+										break
+									}
+								}
+							}
+
+							Expect(isProxyConfigSet).To(BeTrue(), "Istio's PROXY_CONFIG and discoveryAddress were not set")
+						})
+					}
+
+					checkSpiffeCertProviderAddressEqual := func(expected string) {
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment" && resource.GetName() == "gateway-proxy"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), "Deployment should be able to convert from unstructured")
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), "Deployment should be able to cast to a structured deployment")
+							isCAAddrSet := false
+
+							for _, container := range structuredDeployment.Spec.Template.Spec.Containers {
+								for _, env := range container.Env {
+									if env.Name == "CA_ADDR" {
+										isCAAddrSet = true
+										Expect(env.Value).To(Equal(expected), fmt.Sprintf("SPIFFE cert address should be value: %v", expected))
+										break
+									}
+								}
+							}
+
+							Expect(isCAAddrSet).To(BeTrue(), "Istio's CA_ADDR was not set")
+						})
+					}
+
+					BeforeEach(func() {
+						selector = map[string]string{
+							"gloo":             "gateway-proxy",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						podLabels := map[string]string{
+							"gloo":             "gateway-proxy",
+							"gateway-proxy":    "live",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						podname := corev1.EnvVar{
+							Name: "POD_NAME",
+							ValueFrom: &corev1.EnvVarSource{
+								FieldRef: &corev1.ObjectFieldSelector{
+									FieldPath: "metadata.name",
+								},
+							},
+						}
+						container := GetQuayContainerSpec("gloo-envoy-wrapper", version, GetPodNamespaceEnvVar(), podname)
+						container.Name = "gateway-proxy"
+						container.Args = []string{"--disable-hot-restart"}
+
+						rb := ResourceBuilder{
+							Namespace:  namespace,
+							Name:       "gateway-proxy",
+							Labels:     labels,
+							Containers: []ContainerSpec{container},
+						}
+						deploy := rb.GetDeploymentAppsv1()
+						deploy.Spec.Selector = &metav1.LabelSelector{
+							MatchLabels: selector,
+						}
+						deploy.Spec.Template.ObjectMeta.Labels = podLabels
+						deploy.Spec.Template.ObjectMeta.Annotations = map[string]string{
+							"prometheus.io/path":   "/metrics",
+							"prometheus.io/port":   "8081",
+							"prometheus.io/scrape": "true",
+							// This annotation was introduced to resolve https://github.com/kgateway-dev/kgateway/issues/8392
+							// It triggers a new rollout of the gateway proxy if the config map it uses changes
+							// As of PR 8733, changing the values of the deployment spec doesn't change the gateway-proxy config map, so it is safe to hardcode the checksum in the tests
+							"checksum/gateway-proxy-envoy-config": "27068cd033014d38f6c77522484e957ab25fa1be34a900a1f5241b8f7d62f525",
+						}
+						deploy.Spec.Template.Spec.Volumes = []corev1.Volume{{
+							Name: "envoy-config",
+							VolumeSource: corev1.VolumeSource{
+								ConfigMap: &corev1.ConfigMapVolumeSource{
+									LocalObjectReference: corev1.LocalObjectReference{
+										Name: "gateway-proxy-envoy-config",
+									},
+								},
+							},
+						}}
+						deploy.Spec.Template.Spec.Containers[0].ImagePullPolicy = pullPolicy
+						deploy.Spec.Template.Spec.Containers[0].Ports = []corev1.ContainerPort{
+							{Name: "http", ContainerPort: 8080, Protocol: "TCP"},
+							{Name: "https", ContainerPort: 8443, Protocol: "TCP"},
+						}
+						deploy.Spec.Template.Spec.Containers[0].VolumeMounts = []corev1.VolumeMount{{
+							Name:      "envoy-config",
+							ReadOnly:  false,
+							MountPath: "/etc/envoy",
+							SubPath:   "",
+						}}
+						truez := true
+						falsez := false
+						defaultUser := int64(10101)
+
+						deploy.Spec.Template.Spec.SecurityContext = &corev1.PodSecurityContext{
+							FSGroup:   &defaultUser,
+							RunAsUser: &defaultUser,
+						}
+
+						deploy.Spec.Template.Spec.Containers[0].SecurityContext = &corev1.SecurityContext{
+							Capabilities: &corev1.Capabilities{
+								Drop: []corev1.Capability{"ALL"},
+							},
+							ReadOnlyRootFilesystem:   &truez,
+							AllowPrivilegeEscalation: &falsez,
+							RunAsNonRoot:             &truez,
+							RunAsUser:                &defaultUser,
+						}
+						deploy.Spec.Template.Spec.ServiceAccountName = "gateway-proxy"
+						deploy.Spec.Template.Spec.Containers[0].Env = append(
+							deploy.Spec.Template.Spec.Containers[0].Env,
+							corev1.EnvVar{
+								Name:  "DISABLE_CORE_DUMPS",
+								Value: "false",
+							})
+						gatewayProxyDeployment = deploy
+					})
+
+					Context("gateway-proxy daemonset", func() {
+						var daemonSet *appsv1.DaemonSet
+						BeforeEach(func() {
+							daemonSet = &appsv1.DaemonSet{
+								TypeMeta: metav1.TypeMeta{
+									Kind:       "DaemonSet",
+									APIVersion: "apps/v1",
+								},
+								ObjectMeta: gatewayProxyDeployment.ObjectMeta,
+								Spec: appsv1.DaemonSetSpec{
+									Selector: gatewayProxyDeployment.Spec.Selector,
+									Template: gatewayProxyDeployment.Spec.Template,
+								},
+							}
+							for i, port := range daemonSet.Spec.Template.Spec.Containers[0].Ports {
+								port.HostPort = port.ContainerPort
+								daemonSet.Spec.Template.Spec.Containers[0].Ports[i] = port
+							}
+							daemonSet.Spec.Template.Spec.DNSPolicy = corev1.DNSClusterFirstWithHostNet
+							daemonSet.Spec.Template.Spec.HostNetwork = true
+						})
+
+						It("creates a daemonset", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"gatewayProxies.gatewayProxy.kind.deployment=null",
+									"gatewayProxies.gatewayProxy.kind.daemonSet.hostPort=true",
+								},
+							})
+							testManifest.Expect("DaemonSet", gatewayProxyDeployment.Namespace, gatewayProxyDeployment.Name).To(BeEquivalentTo(daemonSet))
+						})
+
+						It("can set the DISABLE_CORE_DUMPS environment variable", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{"gatewayProxies.gatewayProxy.disableCoreDumps=true"},
+							})
+							testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+								return resource.GetKind() == "Deployment" && resource.GetName() == "gateway-proxy"
+							}).ExpectAll(func(deployment *unstructured.Unstructured) {
+								deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+								Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+								structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+								Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+								Expect(structuredDeployment.Spec.Template.Spec.Containers).To(HaveLen(1))
+								expectEnvVarExists(structuredDeployment.Spec.Template.Spec.Containers[0],
+									corev1.EnvVar{
+										Name:  "DISABLE_CORE_DUMPS",
+										Value: "true",
+									})
+							})
+						})
+
+						It("can explicitly disable hostNetwork", func() {
+							daemonSet.Spec.Template.Spec.HostNetwork = false
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"gatewayProxies.gatewayProxy.kind.deployment=null",
+									"gatewayProxies.gatewayProxy.kind.daemonSet.hostPort=true",
+									"gatewayProxies.gatewayProxy.kind.daemonSet.hostNetwork=false",
+								},
+							})
+							testManifest.Expect("DaemonSet", gatewayProxyDeployment.Namespace, gatewayProxyDeployment.Name).To(BeEquivalentTo(daemonSet))
+						})
+					})
+
+					It("creates a deployment", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("supports multiple deployments", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxyInternal.kind.deployment.replicas=1",
+								"gatewayProxies.gatewayProxyInternal.configMap.data=null",
+								"gatewayProxies.gatewayProxyInternal.service.extraAnnotations=null",
+								"gatewayProxies.gatewayProxyInternal.service.type=ClusterIP",
+								"gatewayProxies.gatewayProxyInternal.podTemplate.httpPort=8081",
+								"gatewayProxies.gatewayProxyInternal.podTemplate.image.tag=dev",
+							},
+						})
+						deploymentName := "gateway-proxy-internal"
+						// deployment exists for for second declaration of gateway proxy
+						testManifest.Expect("Deployment", namespace, deploymentName).NotTo(BeNil())
+						testManifest.Expect("Deployment", namespace, "gateway-proxy").NotTo(BeNil())
+					})
+
+					DescribeTable("supports deploying the specified tag, digest, and variant of the envoy image", func(registry, repo, tag, digest, variant, expectedImage string) {
+						vals := []string{
+							"global.image.variant=" + variant,
+							"gatewayProxies.gatewayProxy.podTemplate.image.registry=" + registry,
+							"gatewayProxies.gatewayProxy.podTemplate.image.repository=" + repo,
+							"gatewayProxies.gatewayProxy.podTemplate.image.tag=" + tag,
+						}
+						// set the digest value corresponding to the variant
+						switch variant {
+						case "fips":
+							vals = append(vals, "gatewayProxies.gatewayProxy.podTemplate.image.fipsDigest="+digest)
+						case "distroless":
+							vals = append(vals, "gatewayProxies.gatewayProxy.podTemplate.image.distrolessDigest="+digest)
+						case "fips-distroless":
+							vals = append(vals, "gatewayProxies.gatewayProxy.podTemplate.image.fipsDistrolessDigest="+digest)
+						case "":
+							fallthrough
+						case "standard":
+							fallthrough
+						default:
+							vals = append(vals, "gatewayProxies.gatewayProxy.podTemplate.image.digest="+digest)
+						}
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: vals,
+						})
+
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Image = expectedImage
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					},
+						// EE envoy image supports both fips and distroless
+						Entry("No tag, digest, or variant specified", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "", "", "quay.io/solo-io/gloo-ee-envoy-wrapper"),
+						Entry("Only tag specified", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "", "", "quay.io/solo-io/gloo-ee-envoy-wrapper:tag1"),
+						Entry("Only digest specified", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "digest1", "", "quay.io/solo-io/gloo-ee-envoy-wrapper@digest1"),
+						Entry("Only variant specified (standard)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "", "standard", "quay.io/solo-io/gloo-ee-envoy-wrapper"),
+						Entry("Only variant specified (fips)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "", "fips", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips"),
+						Entry("Only variant specified (distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "", "distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper"),
+						Entry("Only variant specified (fips-distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "", "fips-distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips"),
+						Entry("Tag and digest specified", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "digest1", "", "quay.io/solo-io/gloo-ee-envoy-wrapper:tag1@digest1"),
+						Entry("Tag and variant specified (standard)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "", "standard", "quay.io/solo-io/gloo-ee-envoy-wrapper:tag1"),
+						Entry("Tag and variant specified (fips)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "", "fips", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips:tag1"),
+						Entry("Tag and variant specified (distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "", "distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper:tag1-distroless"),
+						Entry("Tag and variant specified (fips-distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "", "fips-distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips:tag1-distroless"),
+						Entry("Digest and variant specified (standard)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "digest1", "standard", "quay.io/solo-io/gloo-ee-envoy-wrapper@digest1"),
+						Entry("Digest and variant specified (fips)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "digest1", "fips", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips@digest1"),
+						Entry("Digest and variant specified (distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "digest1", "distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper@digest1"),
+						Entry("Digest and variant specified (fips-distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "", "digest1", "fips-distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips@digest1"),
+						Entry("Tag, digest, and variant specified (standard)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "digest1", "standard", "quay.io/solo-io/gloo-ee-envoy-wrapper:tag1@digest1"),
+						Entry("Tag, digest, and variant specified (fips)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "digest1", "fips", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips:tag1@digest1"),
+						Entry("Tag, digest, and variant specified (distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "digest1", "distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper:tag1-distroless@digest1"),
+						Entry("Tag, digest, and variant specified (fips-distroless)", "quay.io/solo-io", "gloo-ee-envoy-wrapper", "tag1", "digest1", "fips-distroless", "quay.io/solo-io/gloo-ee-envoy-wrapper-fips:tag1-distroless@digest1"),
+						// OSS envoy image does not support fips, so whenever a fips variant is requested, it should use the standard repo name instead of -fips
+						Entry("No tag, digest, or variant specified", "quay.io/solo-io", "gloo-envoy-wrapper", "", "", "", "quay.io/solo-io/gloo-envoy-wrapper"),
+						Entry("Only tag specified", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "", "", "quay.io/solo-io/gloo-envoy-wrapper:tag1"),
+						Entry("Only digest specified", "quay.io/solo-io", "gloo-envoy-wrapper", "", "digest1", "", "quay.io/solo-io/gloo-envoy-wrapper@digest1"),
+						Entry("Only variant specified (standard)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "", "standard", "quay.io/solo-io/gloo-envoy-wrapper"),
+						Entry("Only variant specified (fips)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "", "fips", "quay.io/solo-io/gloo-envoy-wrapper"),
+						Entry("Only variant specified (distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "", "distroless", "quay.io/solo-io/gloo-envoy-wrapper"),
+						Entry("Only variant specified (fips-distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "", "fips-distroless", "quay.io/solo-io/gloo-envoy-wrapper"),
+						Entry("Tag and digest specified", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "digest1", "", "quay.io/solo-io/gloo-envoy-wrapper:tag1@digest1"),
+						Entry("Tag and variant specified (standard)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "", "standard", "quay.io/solo-io/gloo-envoy-wrapper:tag1"),
+						Entry("Tag and variant specified (fips)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "", "fips", "quay.io/solo-io/gloo-envoy-wrapper:tag1"),
+						Entry("Tag and variant specified (distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "", "distroless", "quay.io/solo-io/gloo-envoy-wrapper:tag1-distroless"),
+						Entry("Tag and variant specified (fips-distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "", "fips-distroless", "quay.io/solo-io/gloo-envoy-wrapper:tag1-distroless"),
+						Entry("Digest and variant specified (standard)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "digest1", "standard", "quay.io/solo-io/gloo-envoy-wrapper@digest1"),
+						Entry("Digest and variant specified (fips)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "digest1", "fips", "quay.io/solo-io/gloo-envoy-wrapper@digest1"),
+						Entry("Digest and variant specified (distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "digest1", "distroless", "quay.io/solo-io/gloo-envoy-wrapper@digest1"),
+						Entry("Digest and variant specified (fips-distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "", "digest1", "fips-distroless", "quay.io/solo-io/gloo-envoy-wrapper@digest1"),
+						Entry("Tag, digest, and variant specified (standard)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "digest1", "standard", "quay.io/solo-io/gloo-envoy-wrapper:tag1@digest1"),
+						Entry("Tag, digest, and variant specified (fips)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "digest1", "fips", "quay.io/solo-io/gloo-envoy-wrapper:tag1@digest1"),
+						Entry("Tag, digest, and variant specified (distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "digest1", "distroless", "quay.io/solo-io/gloo-envoy-wrapper:tag1-distroless@digest1"),
+						Entry("Tag, digest, and variant specified (fips-distroless)", "quay.io/solo-io", "gloo-envoy-wrapper", "tag1", "digest1", "fips-distroless", "quay.io/solo-io/gloo-envoy-wrapper:tag1-distroless@digest1"),
+					)
+
+					It("supports deploying the fips envoy image via the deprecated global.image.fips helm value", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.image.fips=true",
+								"gatewayProxies.gatewayProxy.podTemplate.image.repository=gloo-ee-envoy-wrapper",
+							},
+						})
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Image = "quay.io/solo-io/gloo-ee-envoy-wrapper-fips:" + version
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("doesn't break containers when enabling multiple containers", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioIntegration.enabled=true",
+							},
+						})
+
+						// Containers we expect to have
+						expectedContainers := map[string]struct{}{
+							"gateway-proxy":             {},
+							deployer.IstioContainerName: {},
+							deployer.SdsContainerName:   {},
+						}
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment" && resource.GetName() == "gateway-proxy"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+							for _, container := range structuredDeployment.Spec.Template.Spec.Containers {
+								if _, ok := expectedContainers[container.Name]; ok {
+									// delete found containers from our expectedContainers list
+									delete(expectedContainers, container.Name)
+								} else {
+									Fail(fmt.Sprintf("Unexpected container found: %+v", container.Name))
+								}
+							}
+						})
+
+						// An expected container was not correctly set
+						Expect(expectedContainers).To(BeEmpty(), "all enabled containers must have been found")
+					})
+
+					It("doesn't break containers when enabling multiple containers with deprecated IstioSDS.enabled", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioSDS.enabled=true",
+							},
+						})
+
+						// Containers we expect to have
+						expectedContainers := map[string]struct{}{
+							"gateway-proxy": {},
+							"istio-proxy":   {},
+							"sds":           {},
+						}
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment" && resource.GetName() == "gateway-proxy"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+							for _, container := range structuredDeployment.Spec.Template.Spec.Containers {
+								if _, ok := expectedContainers[container.Name]; ok {
+									// delete found containers from our expectedContainers list
+									delete(expectedContainers, container.Name)
+								} else {
+									Fail(fmt.Sprintf("Unexpected container found: %+v", container.Name))
+								}
+							}
+						})
+
+						// An expected container was not correctly set
+						Expect(expectedContainers).To(BeEmpty(), "all enabled containers must have been found")
+					})
+
+					It("supports extra args to envoy", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.extraEnvoyArgs[0]=--log-format",
+								// note that things that start with a percent make break yaml
+								// hence the test.
+								"gatewayProxies.gatewayProxy.extraEnvoyArgs[1]=%L%m%d %T.%e %t envoy] [%t][%n]%v",
+							},
+						})
+						// deployment exists for for second declaration of gateway proxy
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Args = append(
+							gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Args,
+							"--log-format", "%L%m%d %T.%e %t envoy] [%t][%n]%v")
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("supports not specifying replicas to envoy", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.kind.deployment.replicas=0",
+							},
+						})
+						// deployment exists for for second declaration of gateway proxy
+						gatewayProxyDeployment.Spec.Replicas = nil
+						testManifest.Expect("Deployment", namespace, "gateway-proxy").To(matchers.BeEquivalentToDiff(gatewayProxyDeployment))
+					})
+
+					It("disables net bind", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.podTemplate.disableNetBind=true"},
+						})
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].SecurityContext.Capabilities.Add = nil
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("unprivileged user", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.podTemplate.runUnprivileged=true"},
+						})
+						truez := true
+						uid := int64(10101)
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].SecurityContext.RunAsNonRoot = &truez
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].SecurityContext.RunAsUser = &uid
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("allows setting custom runAsUser", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.runAsUser=10102",
+								"gatewayProxies.gatewayProxy.podTemplate.runUnprivileged=true",
+							},
+						})
+						uid := int64(10102)
+						truez := true
+						gatewayProxyDeployment.Spec.Template.Spec.SecurityContext.RunAsUser = &uid
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].SecurityContext.RunAsUser = &uid
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].SecurityContext.RunAsNonRoot = &truez
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("allows removing pod security context", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.podTemplate.enablePodSecurityContext=false"},
+						})
+						gatewayProxyDeployment.Spec.Template.Spec.SecurityContext = nil
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("enables anti affinity ", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.antiAffinity=true"},
+						})
+						gatewayProxyDeployment.Spec.Template.Spec.Affinity = &corev1.Affinity{
+							PodAntiAffinity: &corev1.PodAntiAffinity{
+								PreferredDuringSchedulingIgnoredDuringExecution: []corev1.WeightedPodAffinityTerm{{
+									Weight: 100,
+									PodAffinityTerm: corev1.PodAffinityTerm{
+										TopologyKey: "kubernetes.io/hostname",
+										LabelSelector: &metav1.LabelSelector{
+											MatchLabels: map[string]string{"gloo": "gateway-proxy"},
+										},
+									},
+								}},
+							},
+						}
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("sets affinity", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.Affinity = &corev1.Affinity{
+							NodeAffinity: &corev1.NodeAffinity{
+								RequiredDuringSchedulingIgnoredDuringExecution: &corev1.NodeSelector{
+									NodeSelectorTerms: []corev1.NodeSelectorTerm{
+										{
+											MatchExpressions: []corev1.NodeSelectorRequirement{
+												{
+													Key:      "kubernetes.io/e2e-az-name",
+													Operator: corev1.NodeSelectorOpIn,
+													Values:   []string{"e2e-az1", "e2e-az2"},
+												},
+											},
+										},
+									},
+								},
+							},
+						}
+
+						prepareMakefileFromValuesFile("values/val_gwp_affinity.yaml")
+
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("sets topologySpreadConstraints", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.TopologySpreadConstraints = append(
+							gatewayProxyDeployment.Spec.Template.Spec.TopologySpreadConstraints,
+							corev1.TopologySpreadConstraint{
+								MaxSkew:           1,
+								TopologyKey:       "zone",
+								WhenUnsatisfiable: "ScheduleAnyway",
+								LabelSelector: &metav1.LabelSelector{
+									MatchLabels: map[string]string{"gloo": "gateway-proxy"},
+								},
+							})
+
+						prepareMakefileFromValuesFile("values/val_gwp_topologyspreadconstraints.yaml")
+
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("enables probes", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.probes=true",
+								"gatewayProxies.gatewayProxy.podTemplate.livenessProbeEnabled=true",
+							},
+						})
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].ReadinessProbe = &corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								Exec: &corev1.ExecAction{
+									Command: []string{
+										"wget", "-O", "/dev/null", "127.0.0.1:19000/ready",
+									},
+								},
+							},
+							InitialDelaySeconds: 3,
+							PeriodSeconds:       10,
+							FailureThreshold:    3,
+						}
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].LivenessProbe = &corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								Exec: &corev1.ExecAction{
+									Command: []string{
+										"wget", "-O", "/dev/null", "127.0.0.1:19000/server_info",
+									},
+								},
+							},
+							InitialDelaySeconds: 3,
+							PeriodSeconds:       10,
+							FailureThreshold:    3,
+						}
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("enables priorityClassName", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.kind.deployment.priorityClassName=example-priority",
+							},
+						})
+
+						gatewayProxyDeployment.Spec.Template.Spec.PriorityClassName = "example-priority"
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("supports custom readiness and liveness probe", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.probes=true",
+								"gatewayProxies.gatewayProxy.podTemplate.livenessProbeEnabled=true",
+								"gatewayProxies.gatewayProxy.podTemplate.customReadinessProbe.initialDelaySeconds=3",
+								"gatewayProxies.gatewayProxy.podTemplate.customReadinessProbe.failureThreshold=3",
+								"gatewayProxies.gatewayProxy.podTemplate.customReadinessProbe.periodSeconds=10",
+								"gatewayProxies.gatewayProxy.podTemplate.customReadinessProbe.httpGet.path=/ready",
+								"gatewayProxies.gatewayProxy.podTemplate.customReadinessProbe.httpGet.port=19000",
+								"gatewayProxies.gatewayProxy.podTemplate.customReadinessProbe.httpGet.scheme=HTTP",
+								"gatewayProxies.gatewayProxy.podTemplate.customLivenessProbe.initialDelaySeconds=3",
+								"gatewayProxies.gatewayProxy.podTemplate.customLivenessProbe.failureThreshold=3",
+								"gatewayProxies.gatewayProxy.podTemplate.customLivenessProbe.periodSeconds=10",
+								"gatewayProxies.gatewayProxy.podTemplate.customLivenessProbe.httpGet.path=/server_info",
+								"gatewayProxies.gatewayProxy.podTemplate.customLivenessProbe.httpGet.port=19000",
+								"gatewayProxies.gatewayProxy.podTemplate.customLivenessProbe.httpGet.scheme=HTTP",
+							},
+						})
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].ReadinessProbe = &corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								HTTPGet: &corev1.HTTPGetAction{
+									Path:   "/ready",
+									Port:   intstr.FromInt32(19000),
+									Scheme: "HTTP",
+								},
+							},
+							InitialDelaySeconds: 3,
+							PeriodSeconds:       10,
+							FailureThreshold:    3,
+						}
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].LivenessProbe = &corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								HTTPGet: &corev1.HTTPGetAction{
+									Path:   "/server_info",
+									Port:   intstr.FromInt32(19000),
+									Scheme: "HTTP",
+								},
+							},
+							InitialDelaySeconds: 3,
+							PeriodSeconds:       10,
+							FailureThreshold:    3,
+						}
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("renders terminationGracePeriodSeconds when present", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.terminationGracePeriodSeconds=45",
+							},
+						})
+
+						intz := int64(45)
+						gatewayProxyDeployment.Spec.Template.Spec.TerminationGracePeriodSeconds = &intz
+
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("renders preStop hook for gracefulShutdown", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.gracefulShutdown.enabled=true",
+							},
+						})
+
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Lifecycle = &corev1.Lifecycle{
+							PreStop: &corev1.LifecycleHandler{
+								Exec: &corev1.ExecAction{
+									Command: []string{
+										"/bin/sh",
+										"-c",
+										"wget --post-data \"\" -O /dev/null 127.0.0.1:19000/healthcheck/fail; sleep 25",
+									},
+								},
+							},
+						}
+
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("renders preStop hook for gracefulShutdown with custom sleep time", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.gracefulShutdown.enabled=true",
+								"gatewayProxies.gatewayProxy.podTemplate.gracefulShutdown.sleepTimeSeconds=45",
+							},
+						})
+
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Lifecycle = &corev1.Lifecycle{
+							PreStop: &corev1.LifecycleHandler{
+								Exec: &corev1.ExecAction{
+									Command: []string{
+										"/bin/sh",
+										"-c",
+										"wget --post-data \"\" -O /dev/null 127.0.0.1:19000/healthcheck/fail; sleep 45",
+									},
+								},
+							},
+						}
+
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("has limits", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.resources.limits.memory=2Mi",
+								"gatewayProxies.gatewayProxy.podTemplate.resources.limits.cpu=3m",
+								"gatewayProxies.gatewayProxy.podTemplate.resources.requests.memory=4Mi",
+								"gatewayProxies.gatewayProxy.podTemplate.resources.requests.cpu=5m",
+							},
+						})
+
+						// Add the limits we are testing:
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Resources = corev1.ResourceRequirements{
+							Limits: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("2Mi"),
+								corev1.ResourceCPU:    resource.MustParse("3m"),
+							},
+							Requests: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("4Mi"),
+								corev1.ResourceCPU:    resource.MustParse("5m"),
+							},
+						}
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can overwrite the container image information", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Image = fmt.Sprintf("gcr.io/solo-public/gloo-envoy-wrapper:%s", version)
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].ImagePullPolicy = "Always"
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.image.pullPolicy=Always",
+								"gatewayProxies.gatewayProxy.podTemplate.image.registry=gcr.io/solo-public",
+							},
+						})
+
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can render Extra Containers", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.Containers = append(gatewayProxyDeployment.Spec.Template.Spec.Containers, gatewayProxyDeployment.Spec.Template.Spec.Containers[0])
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0] = corev1.Container{
+							Image: "gcr.io/solo-public",
+							Name:  "podName",
+							Command: []string{
+								"sh",
+								"-c",
+							},
+						}
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.extraContainers[0].image=gcr.io/solo-public",
+								"gatewayProxies.gatewayProxy.podTemplate.extraContainers[0].name=podName",
+								"gatewayProxies.gatewayProxy.podTemplate.extraContainers[0].command[0]=sh",
+								"gatewayProxies.gatewayProxy.podTemplate.extraContainers[0].command[1]=-c",
+							},
+						})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can render Extra Init Containers", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.InitContainers = append(gatewayProxyDeployment.Spec.Template.Spec.InitContainers, corev1.Container{
+							Image: "gcr.io/solo-public",
+							Name:  "podName",
+							Command: []string{
+								"sh",
+								"-c",
+							},
+						})
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.podTemplate.extraInitContainers[0].image=gcr.io/solo-public",
+								"gatewayProxies.gatewayProxy.podTemplate.extraInitContainers[0].name=podName",
+								"gatewayProxies.gatewayProxy.podTemplate.extraInitContainers[0].command[0]=sh",
+								"gatewayProxies.gatewayProxy.podTemplate.extraInitContainers[0].command[1]=-c",
+							},
+						})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can overwrite sds and istioProxy images", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioIntegration.enabled=true",
+								"global.glooMtls.sds.image.tag=my-sds-tag",
+								"global.glooMtls.sds.image.repository=my-sds-repo",
+								"global.glooMtls.sds.image.registry=my-sds-reg",
+								"global.glooMtls.istioProxy.image.tag=my-istio-tag",
+								"global.glooMtls.istioProxy.image.repository=my-istio-repo",
+								"global.glooMtls.istioProxy.image.registry=my-istio-reg",
+								"global.glooMtls.istioProxy.image.pullPolicy=Always",
+							},
+						})
+
+						gwpDepl := getDeployment(testManifest, namespace, "gateway-proxy")
+						Expect(gwpDepl.Spec.Template.Spec.Containers).To(HaveLen(3))
+
+						sdsContainer := gwpDepl.Spec.Template.Spec.Containers[1]
+						Expect(sdsContainer.Name).To(Equal(deployer.SdsContainerName))
+						Expect(sdsContainer.Image).To(Equal("my-sds-reg/my-sds-repo:my-sds-tag"))
+						Expect(sdsContainer.ImagePullPolicy).To(Equal(corev1.PullIfNotPresent))
+
+						istioProxyContainer := gwpDepl.Spec.Template.Spec.Containers[2]
+						Expect(istioProxyContainer.Name).To(Equal(deployer.IstioContainerName))
+						Expect(istioProxyContainer.Image).To(Equal("my-istio-reg/my-istio-repo:my-istio-tag"))
+						Expect(istioProxyContainer.ImagePullPolicy).To(Equal(corev1.PullAlways))
+
+						// Volumes env added to support more recent istio versions as of https://github.com/kgateway-dev/kgateway/pull/8666
+						Expect(istioProxyContainer.VolumeMounts[4]).To(Equal(corev1.VolumeMount{Name: "credential-socket", MountPath: "/var/run/secrets/credential-uds"}))
+						Expect(istioProxyContainer.VolumeMounts[5]).To(Equal(corev1.VolumeMount{Name: "workload-socket", MountPath: "/var/run/secrets/workload-spiffe-uds"}))
+						Expect(istioProxyContainer.VolumeMounts[6]).To(Equal(corev1.VolumeMount{Name: "workload-certs", MountPath: "/var/run/secrets/workload-spiffe-credentials"}))
+						Expect(gwpDepl.Spec.Template.Spec.Volumes[5]).To(Equal(corev1.Volume{Name: "credential-socket", VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}}}))
+						Expect(gwpDepl.Spec.Template.Spec.Volumes[6]).To(Equal(corev1.Volume{Name: "workload-socket", VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}}}))
+						Expect(gwpDepl.Spec.Template.Spec.Volumes[7]).To(Equal(corev1.Volume{Name: "workload-certs", VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}}}))
+					})
+
+					It("can overwrite sds and istioProxy images using deprecated istioSDS.enabled", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioSDS.enabled=true",
+								"global.glooMtls.sds.image.tag=my-sds-tag",
+								"global.glooMtls.sds.image.repository=my-sds-repo",
+								"global.glooMtls.sds.image.registry=my-sds-reg",
+								"global.glooMtls.istioProxy.image.tag=my-istio-tag",
+								"global.glooMtls.istioProxy.image.repository=my-istio-repo",
+								"global.glooMtls.istioProxy.image.registry=my-istio-reg",
+								"global.glooMtls.istioProxy.image.pullPolicy=Always",
+							},
+						})
+
+						gwpDepl := getDeployment(testManifest, namespace, "gateway-proxy")
+						Expect(gwpDepl.Spec.Template.Spec.Containers).To(HaveLen(3))
+
+						sdsContainer := gwpDepl.Spec.Template.Spec.Containers[1]
+						Expect(sdsContainer.Name).To(Equal(deployer.SdsContainerName))
+						Expect(sdsContainer.Image).To(Equal("my-sds-reg/my-sds-repo:my-sds-tag"))
+						Expect(sdsContainer.ImagePullPolicy).To(Equal(corev1.PullIfNotPresent))
+
+						istioProxyContainer := gwpDepl.Spec.Template.Spec.Containers[2]
+						Expect(istioProxyContainer.Name).To(Equal(deployer.IstioContainerName))
+						Expect(istioProxyContainer.Image).To(Equal("my-istio-reg/my-istio-repo:my-istio-tag"))
+						Expect(istioProxyContainer.ImagePullPolicy).To(Equal(corev1.PullAlways))
+
+						// Volumes env added to support more recent istio versions as of https://github.com/kgateway-dev/kgateway/pull/8666
+						Expect(istioProxyContainer.VolumeMounts[4]).To(Equal(corev1.VolumeMount{Name: "credential-socket", MountPath: "/var/run/secrets/credential-uds"}))
+						Expect(istioProxyContainer.VolumeMounts[5]).To(Equal(corev1.VolumeMount{Name: "workload-socket", MountPath: "/var/run/secrets/workload-spiffe-uds"}))
+						Expect(istioProxyContainer.VolumeMounts[6]).To(Equal(corev1.VolumeMount{Name: "workload-certs", MountPath: "/var/run/secrets/workload-spiffe-credentials"}))
+						Expect(gwpDepl.Spec.Template.Spec.Volumes[5]).To(Equal(corev1.Volume{Name: "credential-socket", VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}}}))
+						Expect(gwpDepl.Spec.Template.Spec.Volumes[6]).To(Equal(corev1.Volume{Name: "workload-socket", VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}}}))
+						Expect(gwpDepl.Spec.Template.Spec.Volumes[7]).To(Equal(corev1.Volume{Name: "workload-certs", VolumeSource: corev1.VolumeSource{EmptyDir: &corev1.EmptyDirVolumeSource{}}}))
+					})
+
+					DescribeTable("supports deploying the specified tag, digest, and variant of the istioProxy image", func(registry, repo, tag, digest, variant, expectedImage string) {
+						vals := []string{
+							"global.glooMtls.enabled=true",
+							"global.istioSDS.enabled=true",
+							"global.image.variant=" + variant,
+							"global.glooMtls.istioProxy.image.registry=" + registry,
+							"global.glooMtls.istioProxy.image.repository=" + repo,
+							"global.glooMtls.istioProxy.image.tag=" + tag,
+						}
+						// set the digest value corresponding to the variant
+						switch variant {
+						case "fips":
+							vals = append(vals, "global.glooMtls.istioProxy.image.fipsDigest="+digest)
+						case "distroless":
+							vals = append(vals, "global.glooMtls.istioProxy.image.distrolessDigest="+digest)
+						case "fips-distroless":
+							vals = append(vals, "global.glooMtls.istioProxy.image.fipsDistrolessDigest="+digest)
+						case "":
+							fallthrough
+						case "standard":
+							fallthrough
+						default:
+							vals = append(vals, "global.glooMtls.istioProxy.image.digest="+digest)
+						}
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: vals,
+						})
+
+						gwpDepl := getDeployment(testManifest, namespace, "gateway-proxy")
+						Expect(gwpDepl.Spec.Template.Spec.Containers).To(HaveLen(3))
+
+						istioProxyContainer := gwpDepl.Spec.Template.Spec.Containers[2]
+						Expect(istioProxyContainer.Name).To(Equal(deployer.IstioContainerName))
+						Expect(istioProxyContainer.Image).To(Equal(expectedImage))
+					},
+						// there is no fips or distroless version of the istioProxy image so we don't add the -fips or -distroless suffixes for any variants
+						Entry("No tag, digest, or variant specified", "my-istio-reg", "my-istio-repo", "", "", "", "my-istio-reg/my-istio-repo"),
+						Entry("Only tag specified", "my-istio-reg", "my-istio-repo", "tag1", "", "", "my-istio-reg/my-istio-repo:tag1"),
+						Entry("Only digest specified", "my-istio-reg", "my-istio-repo", "", "digest1", "", "my-istio-reg/my-istio-repo@digest1"),
+						Entry("Only variant specified (standard)", "my-istio-reg", "my-istio-repo", "", "", "standard", "my-istio-reg/my-istio-repo"),
+						Entry("Only variant specified (fips)", "my-istio-reg", "my-istio-repo", "", "", "fips", "my-istio-reg/my-istio-repo"),
+						Entry("Only variant specified (distroless)", "my-istio-reg", "my-istio-repo", "", "", "distroless", "my-istio-reg/my-istio-repo"),
+						Entry("Only variant specified (fips-distroless)", "my-istio-reg", "my-istio-repo", "", "", "fips-distroless", "my-istio-reg/my-istio-repo"),
+						Entry("Tag and digest specified", "my-istio-reg", "my-istio-repo", "tag1", "digest1", "", "my-istio-reg/my-istio-repo:tag1@digest1"),
+						Entry("Tag and variant specified (standard)", "my-istio-reg", "my-istio-repo", "tag1", "", "standard", "my-istio-reg/my-istio-repo:tag1"),
+						Entry("Tag and variant specified (fips)", "my-istio-reg", "my-istio-repo", "tag1", "", "fips", "my-istio-reg/my-istio-repo:tag1"),
+						Entry("Tag and variant specified (distroless)", "my-istio-reg", "my-istio-repo", "tag1", "", "distroless", "my-istio-reg/my-istio-repo:tag1"),
+						Entry("Tag and variant specified (fips-distroless)", "my-istio-reg", "my-istio-repo", "tag1", "", "fips-distroless", "my-istio-reg/my-istio-repo:tag1"),
+						Entry("Digest and variant specified (standard)", "my-istio-reg", "my-istio-repo", "", "digest1", "standard", "my-istio-reg/my-istio-repo@digest1"),
+						Entry("Digest and variant specified (fips)", "my-istio-reg", "my-istio-repo", "", "digest1", "fips", "my-istio-reg/my-istio-repo@digest1"),
+						Entry("Digest and variant specified (distroless)", "my-istio-reg", "my-istio-repo", "", "digest1", "distroless", "my-istio-reg/my-istio-repo@digest1"),
+						Entry("Digest and variant specified (fips-distroless)", "my-istio-reg", "my-istio-repo", "", "digest1", "fips-distroless", "my-istio-reg/my-istio-repo@digest1"),
+						Entry("Tag, digest, and variant specified (standard)", "my-istio-reg", "my-istio-repo", "tag1", "digest1", "standard", "my-istio-reg/my-istio-repo:tag1@digest1"),
+						Entry("Tag, digest, and variant specified (fips)", "my-istio-reg", "my-istio-repo", "tag1", "digest1", "fips", "my-istio-reg/my-istio-repo:tag1@digest1"),
+						Entry("Tag, digest, and variant specified (distroless)", "my-istio-reg", "my-istio-repo", "tag1", "digest1", "distroless", "my-istio-reg/my-istio-repo:tag1@digest1"),
+						Entry("Tag, digest, and variant specified (fips-distroless)", "my-istio-reg", "my-istio-repo", "tag1", "digest1", "fips-distroless", "my-istio-reg/my-istio-repo:tag1@digest1"),
+					)
+
+					DescribeTable("Uses the correct image for the sds-ee container", func(variant string, expectedImage string) {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.glooMtls.sds.image.registry=my-sds-reg",
+								"global.glooMtls.sds.image.tag=my-sds-tag",
+								"global.glooMtls.sds.image.repository=sds-ee",
+								"global.image.variant=" + variant,
+							},
+						})
+
+						gwpDepl := getDeployment(testManifest, namespace, "gateway-proxy")
+						Expect(gwpDepl.Spec.Template.Spec.Containers).To(HaveLen(2))
+
+						sdsContainer := gwpDepl.Spec.Template.Spec.Containers[1]
+						Expect(sdsContainer.Name).To(Equal(deployer.SdsContainerName))
+						Expect(sdsContainer.Image).To(Equal(expectedImage))
+						Expect(sdsContainer.ImagePullPolicy).To(Equal(corev1.PullIfNotPresent))
+					},
+						Entry("No variant specified", "", "my-sds-reg/sds-ee:my-sds-tag"),
+						Entry("Standard variant", "standard", "my-sds-reg/sds-ee:my-sds-tag"),
+						Entry("Fips variant", "fips", "my-sds-reg/sds-ee-fips:my-sds-tag"),
+						Entry("Distroless variant", "distroless", "my-sds-reg/sds-ee:my-sds-tag-distroless"),
+						Entry("Fips-Distroless variant", "fips-distroless", "my-sds-reg/sds-ee-fips:my-sds-tag-distroless"))
+
+					It("adds readConfig annotations", func() {
+						gatewayProxyDeployment.Spec.Template.Annotations["readconfig-stats"] = "/stats"
+						gatewayProxyDeployment.Spec.Template.Annotations["readconfig-ready"] = "/ready"
+						gatewayProxyDeployment.Spec.Template.Annotations["readconfig-config_dump"] = "/config_dump"
+						gatewayProxyDeployment.Spec.Template.Annotations["readconfig-port"] = "8082"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.readConfig=true"},
+						})
+						// Since changing the value of gatewayProxies.gatewayProxy.readConfig changes the gateway-proxy-envoy-config configmap, we need to update the checksum on the deployment as well.
+						// This also doubles as a check to validate that changes in the configmap change the checksum annotation on the deployment which will trigger a rollout.
+						gatewayProxyDeployment.Spec.Template.Annotations["checksum/gateway-proxy-envoy-config"] = "3e431b3dbb3fa7e31cedf9594474ad19e6ecc0e5a7bba59b99cf044d51546eaa"
+
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can add extra sidecar containers to the gateway-proxy deployment", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.Containers = append(
+							gatewayProxyDeployment.Spec.Template.Spec.Containers,
+							corev1.Container{
+								Name:  "nginx",
+								Image: "nginx:1.7.9",
+								Ports: []corev1.ContainerPort{{ContainerPort: 80}},
+							})
+
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].VolumeMounts = append(
+							gatewayProxyDeployment.Spec.Template.Spec.Containers[0].VolumeMounts,
+							corev1.VolumeMount{
+								Name:      "shared-data",
+								MountPath: "/usr/share/shared-data",
+							})
+
+						gatewayProxyDeployment.Spec.Template.Spec.Volumes = append(
+							gatewayProxyDeployment.Spec.Template.Spec.Volumes,
+							corev1.Volume{
+								Name: "shared-data",
+								VolumeSource: corev1.VolumeSource{
+									EmptyDir: &corev1.EmptyDirVolumeSource{},
+								},
+							})
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.extraContainersHelper=gloo.testcontainer"},
+						})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("ISTIO_META_MESH_ID env var default value set", func() {
+						value := "cluster.local"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",         // adds gloo/gateway proxy side containers
+								"global.istioIntegration.enabled=true", // add default istio sds sidecar
+							},
+						})
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment" && resource.GetName() == "gateway-proxy"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+							// get ISTIO_META_MESH_ID env var value
+							var istioMetaMeshID string
+							for _, c := range structuredDeployment.Spec.Template.Spec.Containers {
+								for _, e := range c.Env {
+									if e.Name == "ISTIO_META_MESH_ID" {
+										istioMetaMeshID = e.Value
+										break
+									}
+								}
+							}
+							Expect(istioMetaMeshID).To(Equal(value), "ISTIO_META_MESH_ID should equal "+value)
+						})
+					})
+
+					It("can set ISTIO_META_MESH_ID env var", func() {
+						value := "foo"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",         // adds gloo/gateway proxy side containers
+								"global.istioIntegration.enabled=true", // add default istio sds sidecar
+								"gatewayProxies.gatewayProxy.istioMetaMeshId=" + value,
+							},
+						})
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+							// get ISTIO_META_MESH_ID env var value
+							var istioMetaMeshID string
+							for _, c := range structuredDeployment.Spec.Template.Spec.Containers {
+								for _, e := range c.Env {
+									if e.Name == "ISTIO_META_MESH_ID" {
+										istioMetaMeshID = e.Value
+										break
+									}
+								}
+							}
+							if structuredDeployment.GetName() == "gateway-proxy" {
+								Expect(istioMetaMeshID).To(Equal(value), "ISTIO_META_MESH_ID should equal "+value)
+							}
+						})
+					})
+
+					It("ISTIO_META_CLUSTER_ID env var default value set", func() {
+						value := "Kubernetes"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",         // adds gloo/gateway proxy side containers
+								"global.istioIntegration.enabled=true", // add default istio sds sidecar
+							},
+						})
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+							// get ISTIO_META_CLUSTER_ID env var value
+							var istioMetaClusterID string
+							for _, c := range structuredDeployment.Spec.Template.Spec.Containers {
+								for _, e := range c.Env {
+									if e.Name == "ISTIO_META_CLUSTER_ID" {
+										istioMetaClusterID = e.Value
+										break
+									}
+								}
+							}
+							if structuredDeployment.GetName() == "gateway-proxy" {
+								Expect(istioMetaClusterID).To(Equal(value), "ISTIO_META_CLUSTER_ID should equal "+value)
+							}
+						})
+					})
+
+					It("can set ISTIO_META_CLUSTER_ID env var", func() {
+						value := "bar"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",         // adds gloo/gateway proxy side containers
+								"global.istioIntegration.enabled=true", // add default istio sds sidecar
+								"gatewayProxies.gatewayProxy.istioMetaClusterId=" + value,
+							},
+						})
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "Deployment"
+						}).ExpectAll(func(deployment *unstructured.Unstructured) {
+							deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+							Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", deployment))
+							structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", deployment))
+
+							// get ISTIO_META_CLUSTER_ID env var value
+							var istioMetaClusterID string
+							for _, c := range structuredDeployment.Spec.Template.Spec.Containers {
+								for _, e := range c.Env {
+									if e.Name == "ISTIO_META_CLUSTER_ID" {
+										istioMetaClusterID = e.Value
+										break
+									}
+								}
+							}
+							if structuredDeployment.GetName() == "gateway-proxy" {
+								Expect(istioMetaClusterID).To(Equal(value), "ISTIO_META_CLUSTER_ID should equal "+value)
+							}
+						})
+					})
+
+					It("can set discoveryAddress value in PROXY_CONFIG env var", func() {
+						val := "istiod-1-8-6.istio-system.svc:15012"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioIntegration.enabled=true",
+								"gatewayProxies.gatewayProxy.istioDiscoveryAddress=" + val,
+							},
+						})
+
+						checkDiscoveryAddressEqual(val)
+						checkSpiffeCertProviderAddressEqual(val)
+					})
+
+					It("can set spiffeCertProviderAddress value in CA_ADDR env var", func() {
+						val := "istiod-1-8-6.istio-system.svc:15012"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioIntegration.enabled=true",
+								"gatewayProxies.gatewayProxy.istioSpiffeCertProviderAddress=" + val,
+							},
+						})
+
+						checkSpiffeCertProviderAddressEqual(val)
+					})
+
+					It("istio's discoveryAddress default value set", func() {
+						def := "istiod.istio-system.svc:15012"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioIntegration.enabled=true",
+							},
+						})
+
+						checkDiscoveryAddressEqual(def)
+					})
+
+					It("istio's spiffeCertProviderAddress default value set", func() {
+						def := "istiod.istio-system.svc:15012"
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"global.istioIntegration.enabled=true",
+							},
+						})
+
+						checkSpiffeCertProviderAddressEqual(def)
+					})
+
+					It("can add extra volume mounts to the gateway-proxy container deployment", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].VolumeMounts = append(
+							gatewayProxyDeployment.Spec.Template.Spec.Containers[0].VolumeMounts,
+							corev1.VolumeMount{
+								Name:      "tls-crt",
+								MountPath: "/certs/crt",
+								ReadOnly:  true,
+							},
+							corev1.VolumeMount{
+								Name:      "tls-key",
+								MountPath: "/certs/key",
+								ReadOnly:  true,
+							},
+							corev1.VolumeMount{
+								Name:      "sds-uds-path",
+								MountPath: "/var/run/sds",
+							},
+						)
+
+						gatewayProxyDeployment.Spec.Template.Spec.Volumes = append(
+							gatewayProxyDeployment.Spec.Template.Spec.Volumes,
+							corev1.Volume{
+								Name: "tls-crt",
+								VolumeSource: corev1.VolumeSource{
+									Secret: &corev1.SecretVolumeSource{
+										SecretName: "gloo-test-cert",
+										Items: []corev1.KeyToPath{
+											{Key: "tls.crt", Path: "tls.crt"},
+										},
+									},
+								},
+							},
+							corev1.Volume{
+								Name: "tls-key",
+								VolumeSource: corev1.VolumeSource{
+									Secret: &corev1.SecretVolumeSource{
+										SecretName: "gloo-test-cert",
+										Items: []corev1.KeyToPath{
+											{Key: "tls.key", Path: "tls.key"},
+										},
+									},
+								},
+							},
+							corev1.Volume{
+								Name: "sds-uds-path",
+								VolumeSource: corev1.VolumeSource{
+									HostPath: &corev1.HostPathVolumeSource{
+										Path: "/var/run/sds",
+									},
+								},
+							})
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.extraProxyVolumeMounts[0].mountPath=/certs/crt",
+								"gatewayProxies.gatewayProxy.extraProxyVolumeMounts[0].name=tls-crt",
+								"gatewayProxies.gatewayProxy.extraProxyVolumeMounts[0].readOnly=true",
+								"gatewayProxies.gatewayProxy.extraProxyVolumeMounts[1].mountPath=/certs/key",
+								"gatewayProxies.gatewayProxy.extraProxyVolumeMounts[1].name=tls-key",
+								"gatewayProxies.gatewayProxy.extraProxyVolumeMounts[1].readOnly=true",
+								"gatewayProxies.gatewayProxy.extraVolumes[0].Name=tls-crt",
+								"gatewayProxies.gatewayProxy.extraVolumes[0].Secret.secretName=gloo-test-cert",
+								"gatewayProxies.gatewayProxy.extraVolumes[0].Secret.items[0].key=tls.crt",
+								"gatewayProxies.gatewayProxy.extraVolumes[0].Secret.items[0].path=tls.crt",
+								"gatewayProxies.gatewayProxy.extraVolumes[1].Name=tls-key",
+								"gatewayProxies.gatewayProxy.extraVolumes[1].Secret.secretName=gloo-test-cert",
+								"gatewayProxies.gatewayProxy.extraVolumes[1].Secret.items[0].key=tls.key",
+								"gatewayProxies.gatewayProxy.extraVolumes[1].Secret.items[0].path=tls.key",
+								"gatewayProxies.gatewayProxy.extraVolumeHelper=gloo.testVolume",
+								"gatewayProxies.gatewayProxy.extraProxyVolumeMountHelper=gloo.testVolumeMount",
+							},
+						})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can set envoy log level", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Args = append(
+							gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Args,
+							"--log-level debug",
+						)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.envoyLogLevel=debug"},
+						})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can accept extra env vars", func() {
+						gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Env = append(
+							[]corev1.EnvVar{GetTestExtraEnvVar()},
+							gatewayProxyDeployment.Spec.Template.Spec.Containers[0].Env...,
+						)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.kind.deployment.customEnv[0].Name=TEST_EXTRA_ENV_VAR",
+								"gatewayProxies.gatewayProxy.kind.deployment.customEnv[0].Value=test",
+							},
+						})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("can accept custom port values", func() {
+						const testName = "TEST_CUSTOM_PORT"
+						const testPort = int32(1234)
+						const testTargetPort = int32(1235)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								fmt.Sprintf("gatewayProxies.gatewayProxy.service.customPorts[0].name=%s", testName),
+								fmt.Sprintf("gatewayProxies.gatewayProxy.service.customPorts[0].port=%d", testPort),
+								fmt.Sprintf("gatewayProxies.gatewayProxy.service.customPorts[0].targetPort=%d", testTargetPort),
+								"gatewayProxies.gatewayProxy.service.customPorts[0].protocol=TCP",
+							},
+						})
+						// pull proxy service, cast it, then check for custom resources (which should always be the
+						// first element of the Ports array).
+						service := testManifest.ExpectCustomResource("Service", namespace, defaults.GatewayProxyName)
+						serviceObject, err := kuberesource.ConvertUnstructured(service)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Service %+v should be able to convert from unstructured", service))
+						structuredService, ok := serviceObject.(*corev1.Service)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Service %+v should be able to cast to a structured deployment", service))
+						customPort := structuredService.Spec.Ports[2]
+						Expect(customPort.Name).To(Equal(testName))
+						Expect(customPort.Protocol).To(Equal(corev1.ProtocolTCP))
+						Expect(customPort.Port).To(Equal(testPort))
+						Expect(customPort.TargetPort.IntVal).To(Equal(testTargetPort))
+					})
+
+					It("does not disable gateway proxy", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.disabled=false"},
+						})
+						testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+					})
+
+					It("disables gateway proxy", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.disabled=true"},
+						})
+						testManifest.Expect(gatewayProxyDeployment.Kind,
+							gatewayProxyDeployment.GetNamespace(),
+							gatewayProxyDeployment.GetName()).To(BeNil())
+					})
+
+					It("Adds rest_xds_cluster when enableRestEds is true", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"settings.enableRestEds=true"},
+						})
+
+						testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+							return resource.GetKind() == "ConfigMap"
+						}).ExpectAll(func(configMap *unstructured.Unstructured) {
+							configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+							Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Deployment %+v should be able to convert from unstructured", configMap))
+							structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+							Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", configMap))
+
+							if structuredConfigMap.Name == "gateway-proxy-envoy-config" {
+								Expect(structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring("rest_xds_cluster"), "should have an rest_xds_cluster configured")
+							}
+						})
+					})
+
+					Context("pass image pull secrets", func() {
+						pullSecretName := "test-pull-secret"
+						pullSecret := []corev1.LocalObjectReference{
+							{Name: pullSecretName},
+						}
+
+						It("via global values", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									fmt.Sprintf("global.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							gatewayProxyDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+						})
+
+						It("via podTemplate values", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									fmt.Sprintf("gatewayProxies.gatewayProxy.podTemplate.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							gatewayProxyDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+						})
+
+						It("podTemplate values win over global", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"global.image.pullSecret=wrong",
+									fmt.Sprintf("gatewayProxies.gatewayProxy.podTemplate.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							gatewayProxyDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(gatewayProxyDeployment)
+						})
+					})
+				})
+
+				Context("gateway validation resources", func() {
+					It("creates a service for the gateway validation port", func() {
+						glooService := makeUnstructured(`
+---
+# Source: gloo/templates/2-gloo-service.yaml
+apiVersion: v1
+kind: Service
+metadata:
+  labels:
+    app: gloo
+    gloo: gloo
+  name: gloo
+  namespace: ` + namespace + `
+spec:
+  ports:
+  - name: grpc-xds
+    port: 9977
+    protocol: TCP
+  - name: rest-xds
+    port: 9976
+    protocol: TCP
+  - name: grpc-validation
+    port: 9988
+    protocol: TCP
+  - name: grpc-proxydebug
+    port: 9966
+    protocol: TCP
+  - name: wasm-cache
+    port: 9979
+    protocol: TCP
+  - name: https
+    port: 443
+    protocol: TCP
+    # this should map to projects/gateway/pkg/defaults.ValidationWebhookBindPort
+    targetPort: 8443
+  selector:
+    gloo: gloo
+`)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						testManifest.ExpectUnstructured(glooService.GetKind(), glooService.GetNamespace(), glooService.GetName()).To(BeEquivalentTo(glooService))
+					})
+
+					It("creates settings with the gateway config with old mapping", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/gateway_settings.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.invalidConfigPolicy.replaceInvalidRoutes=true",
+								"settings.invalidConfigPolicy.invalidRouteResponseBody=Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.",
+								"settings.invalidConfigPolicy.invalidRouteResponseCode=404",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("creates settings with the gateway config", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/gateway_settings.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.invalidConfigPolicy.replaceInvalidRoutes=true",
+								"settings.invalidConfigPolicy.invalidRouteResponseBody=Gloo Gateway has invalid configuration. Administrators should run `glooctl check` to find and fix config errors.",
+								"settings.invalidConfigPolicy.invalidRouteResponseCode=404",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("correctly sets the `disableKubernetesDestinations` field in the settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/disable_kubernetes_destinations.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.disableKubernetesDestinations=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("correctly sets the gateway validation fields in the settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/gateway_validation.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.validation.disableTransformationValidation=true",
+								"gateway.validation.warnRouteShortCircuiting=true",
+								"gateway.validation.warnMissingTlsSecret=false",
+								"gateway.validation.fullEnvoyValidation=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("correctly sets the gateway circuitBreakers fields in the settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/gateway_circuit_breakers.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.circuitBreakers.maxConnections=1024",
+								"settings.circuitBreakers.maxPendingRequests=1024",
+								"settings.circuitBreakers.maxRequests=1024",
+								"settings.circuitBreakers.maxRetries=3",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("always enables persisting proxy specs when not in gateway mode", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/disabled_gateway.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.enabled=false",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("correctly allows setting readGatewaysFromAllNamespaces field in the settings when validation disabled", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/read_gateways_from_all_namespaces.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.validation.enabled=false",
+								"gateway.readGatewaysFromAllNamespaces=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("correctly allows setting compressedProxySpec field in the settings when validation disabled", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/compressed_proxy_spec.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.validation.enabled=false",
+								"gateway.compressedProxySpec=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("correctly allows setting ratelimit descriptors in the rateLimit field.", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/ratelimit_descriptors.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.rateLimit.descriptors[0].key=generic_key",
+								"settings.rateLimit.descriptors[0].value=per-second",
+								"settings.rateLimit.descriptors[0].rateLimit.requestsPerUnit=2",
+								"settings.rateLimit.descriptors[0].rateLimit.unit=SECOND",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("correctly allows setting ratelimitServer field.", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/ratelimit_server.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.ratelimitServer.ratelimitServerRef.name=ratelimit",
+								"settings.ratelimitServer.ratelimitServerRef.namespace=ratelimitns",
+								"settings.ratelimitServer.denyOnFail=true",
+								"settings.ratelimitServer.rateLimitBeforeAuth=true",
+								"settings.ratelimitServer.enableXRatelimitHeaders=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("correctly sets the `disableProxyGarbageCollection` field in the settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/disable_proxy_garbage_collection.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.disableProxyGarbageCollection=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("correctly sets the `regexMaxProgramSize` field to the default of 1024 in the settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/set_regex_max_program_size_default.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("correctly sets the `regexMaxProgramSize` field in the settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/set_regex_max_program_size.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.regexMaxProgramSize=500",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("correctly sets the `gloo.enableRestEds` to false in the settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/enable_rest_eds.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.enableRestEds=false",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("correctly sets the `gloo.enableRestEds` when glooMtls is enabled", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/enable_rest_eds_and_gloo_mtls.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",
+								"settings.enableRestEds=false",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("enable default credentials", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/enable_default_credentials.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.aws.enableCredentialsDiscovery=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+					It("sets secretOptions in settings", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/set_secretSettings_in_settings.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.secretOptions.sources[0].vault.address=http://vault-internal.vault:8200",
+								"settings.secretOptions.sources[0].vault.aws.iamServerIdHeader=vault.gloo.example.com",
+								"settings.secretOptions.sources[0].vault.aws.mountPath=aws",
+								"settings.secretOptions.sources[0].vault.aws.region=us-east-1",
+								"settings.secretOptions.sources[0].vault.pathPrefix=dev",
+								"settings.secretOptions.sources[0].vault.aws.leaseIncrement=10",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("can enable isolateVirtualHostsBySslConfig", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/isolate_virtual_hosts_by_ssl_config.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.isolateVirtualHostsBySslConfig=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("allows setting extauth", func() {
+						expectedYaml := makeUnstructured(`
+apiVersion: gloo.solo.io/v1
+kind: Settings
+metadata:
+  labels:
+    app: gloo
+    gloo: settings
+  name: default
+  namespace: gloo-system
+spec:
+  gloo:
+    regexMaxProgramSize: 1024
+    xdsBindAddr: "0.0.0.0:9977"
+    restXdsBindAddr: "0.0.0.0:9976"
+    proxyDebugBindAddr: "0.0.0.0:9966"
+    enableRestEds: false
+    disableKubernetesDestinations: false
+    disableProxyGarbageCollection: false
+    invalidConfigPolicy:
+      invalidRouteResponseBody: Gloo Gateway has invalid configuration. Administrators should run ` + "`glooctl check`" + ` to find and fix config errors.
+      invalidRouteResponseCode: 404
+      replaceInvalidRoutes: false
+    istioOptions:
+      appendXForwardedHost: true
+      enableAutoMtls: false
+      enableIntegration: false
+  discoveryNamespace: gloo-system
+  kubernetesArtifactSource: {}
+  kubernetesConfigSource: {}
+  kubernetesSecretSource: {}
+  refreshRate: 60s
+
+  gateway:
+    readGatewaysFromAllNamespaces: false
+    enableGatewayController: true
+    isolateVirtualHostsBySslConfig: false
+    validation:
+      fullEnvoyValidation: false
+      proxyValidationServerAddr: gloo:9988
+      alwaysAccept: true
+      allowWarnings: true
+      warnMissingTlsSecret: true
+      serverEnabled: true
+      disableTransformationValidation: false
+      warnRouteShortCircuiting: false
+      validationServerGrpcMaxSizeBytes: 104857600
+  discovery:
+    fdsMode: WHITELIST
+  extauth:
+    extauthzServerRef:
+      name: test
+      namespace: testspace
+`)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.extensions.extAuth.extauthzServerRef.name=test",
+								"global.extensions.extAuth.extauthzServerRef.namespace=testspace",
+							},
+						})
+
+						testManifest.ExpectUnstructured(expectedYaml.GetKind(), expectedYaml.GetNamespace(), expectedYaml.GetName()).To(BeEquivalentTo(expectedYaml))
+					})
+
+					It("finds resources on all containers, with identical resources on all sds and sidecar containers", func() {
+						envoySidecarVals := []string{"100Mi", "200m", "300Mi", "400m"}
+						sdsVals := []string{"101Mi", "201m", "301Mi", "401m"}
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.glooMtls.enabled=true",         // adds gloo/gateway proxy side containers
+								"global.istioIntegration.enabled=true", // add default istio sds sidecar
+								fmt.Sprintf("global.glooMtls.envoySidecarResources.requests.memory=%s", envoySidecarVals[0]),
+								fmt.Sprintf("global.glooMtls.envoySidecarResources.requests.cpu=%s", envoySidecarVals[1]),
+								fmt.Sprintf("global.glooMtls.envoySidecarResources.limits.memory=%s", envoySidecarVals[2]),
+								fmt.Sprintf("global.glooMtls.envoySidecarResources.limits.cpu=%s", envoySidecarVals[3]),
+								fmt.Sprintf("global.glooMtls.sdsResources.requests.memory=%s", sdsVals[0]),
+								fmt.Sprintf("global.glooMtls.sdsResources.requests.cpu=%s", sdsVals[1]),
+								fmt.Sprintf("global.glooMtls.sdsResources.limits.memory=%s", sdsVals[2]),
+								fmt.Sprintf("global.glooMtls.sdsResources.limits.cpu=%s", sdsVals[3]),
+							},
+						})
+
+						// get all deployments for arbitrary examination/testing
+						var deployments []*unstructured.Unstructured
+						testManifest.SelectResources(func(unstructured *unstructured.Unstructured) bool {
+							if unstructured.GetKind() == "Deployment" {
+								deployments = append(deployments, unstructured)
+							}
+							return true
+						})
+
+						for _, deployment := range deployments {
+							// marshall unstructured object into deployment
+							rawDeploy, err := deployment.MarshalJSON()
+							Expect(err).NotTo(HaveOccurred())
+							deploy := appsv1.Deployment{}
+							err = json.Unmarshal(rawDeploy, &deploy)
+							Expect(err).NotTo(HaveOccurred())
+
+							// look for sidecar and sds containers, then test their resource values.
+							for _, container := range deploy.Spec.Template.Spec.Containers {
+								// still make sure non-sds/sidecar containers have non-nil resources, since all
+								// other containers should have default resources values set in their templates.
+								Expect(container.Resources).NotTo(BeNil(), "deployment/container %s/%s had nil resources", deployment.GetName(), container.Name)
+								if container.Name == "envoy-sidecar" || container.Name == "sds" || container.Name == "istio-proxy" {
+									expectedVals := sdsVals
+									// Two deployments employ proxy containers requiring the envoySidecar resources config:
+									// - gloo (whose sidecar container is named: "envoy-sidecar")
+									// - gateway-proxy (named: "istio-proxy")
+									if container.Name == "envoy-sidecar" || container.Name == "istio-proxy" {
+										expectedVals = envoySidecarVals
+									}
+
+									Expect(container.Resources.Requests.Memory().String()).To(Equal(expectedVals[0]),
+										"deployment/container %s/%s had incorrect request memory: expected %s, got %s",
+										deployment.GetName(), container.Name, expectedVals[0], container.Resources.Requests.Memory().String())
+
+									Expect(container.Resources.Requests.Cpu().String()).To(Equal(expectedVals[1]),
+										"deployment/container %s/%s had incorrect request cpu: expected %s, got %s",
+										deployment.GetName(), container.Name, expectedVals[1], container.Resources.Requests.Cpu().String())
+
+									Expect(container.Resources.Limits.Memory().String()).To(Equal(expectedVals[2]),
+										"deployment/container %s/%s had incorrect limit memory: expected %s, got %s",
+										deployment.GetName(), container.Name, expectedVals[2], container.Resources.Limits.Memory().String())
+
+									Expect(container.Resources.Limits.Cpu().String()).To(Equal(expectedVals[3]),
+										"deployment/container %s/%s had incorrect limit cpu: expected %s, got %s",
+										deployment.GetName(), container.Name, expectedVals[3], container.Resources.Limits.Cpu().String())
+								}
+							}
+						}
+					})
+
+					It("enable sts discovery", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/sts_discovery.yaml", namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.aws.enableServiceAccountCredentials=true",
+								"settings.aws.stsCredentialsRegion=us-east-2",
+								"settings.aws.propagateOriginalRouting=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("adds the validation port and mounts the certgen secret to the gloo deployment", func() {
+						glooDeployment := makeUnstructured(`
+# Source: gloo/templates/1-gloo-deployment.yaml
+
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      gloo: gloo
+  template:
+    metadata:
+      labels:
+        gloo: gloo
+      annotations:
+        prometheus.io/path: /metrics
+        prometheus.io/port: "9091"
+        prometheus.io/scrape: "true"
+        gloo.solo.io/oss-image-tag: "` + version + `"
+    spec:
+      serviceAccountName: gloo
+      volumes:
+      - name: labels-volume
+        downwardAPI:
+          items:
+            - path: "labels"
+              fieldRef:
+                fieldPath: metadata.labels
+      - name: validation-certs
+        secret:
+          secretName: gateway-validation-certs
+          defaultMode: 420
+      containers:
+      - image: quay.io/solo-io/gloo:` + version + `
+        imagePullPolicy: IfNotPresent
+        name: gloo
+        resources:
+          requests:
+            cpu: 500m
+            memory: 256Mi
+        securityContext:
+          readOnlyRootFilesystem: true
+          allowPrivilegeEscalation: false
+          runAsNonRoot: true
+          runAsUser: 10101
+          capabilities:
+            drop:
+            - ALL
+        ports:
+        - containerPort: 9977
+          name: grpc-xds
+          protocol: TCP
+        - containerPort: 9976
+          protocol: TCP
+          name: rest-xds
+        - containerPort: 9988
+          name: grpc-validation
+          protocol: TCP
+        - containerPort: 9966
+          name: grpc-proxydebug
+          protocol: TCP
+        - containerPort: 9979
+          name: wasm-cache
+          protocol: TCP
+        volumeMounts:
+        - mountPath: /etc/gateway/validation-certs
+          name: validation-certs
+        - name: labels-volume
+          mountPath: /etc/gloo
+          readOnly: true
+        env:
+          - name: POD_NAMESPACE
+            valueFrom:
+              fieldRef:
+                fieldPath: metadata.namespace
+          - name: START_STATS_SERVER
+            value: "true"
+          - name: VALIDATION_MUST_START
+            value: "true"
+        readinessProbe:
+          tcpSocket:
+            port: 9977
+          initialDelaySeconds: 3
+          periodSeconds: 10
+          failureThreshold: 3
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  labels:
+    app: gloo
+    gloo: gloo
+  name: gloo
+  namespace: ` + namespace)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.validation.livenessProbeEnabled=true",
+							},
+						})
+						testManifest.ExpectUnstructured(glooDeployment.GetKind(), glooDeployment.GetNamespace(), glooDeployment.GetName()).To(BeEquivalentTo(glooDeployment))
+					})
+
+					Context("custom resource lifecycle", func() {
+						It("creates migration, rollout, and cleanup jobs", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{}})
+
+							// getJob will fail if the job doesn't exist
+							_ = getJob(testManifest, namespace, "gloo-resource-migration")
+							_ = getJob(testManifest, namespace, "gloo-resource-cleanup")
+
+							// rollout job should wait for deployment
+							rolloutJob := getJob(testManifest, namespace, "gloo-resource-rollout")
+							Expect(rolloutJob.Spec.Template.Spec.Containers[0].Command[2]).To(ContainSubstring("kubectl rollout"))
+						})
+
+						It("does not wait for deployment when validation webhook is disabled", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{
+								"gateway.validation.webhook.enabled=false",
+							}})
+							job := getJob(testManifest, namespace, "gloo-resource-rollout")
+							Expect(job.Spec.Template.Spec.Containers[0].Command[2]).NotTo(ContainSubstring("kubectl rollout"))
+						})
+
+						It("configmap should contain gateway yaml when default gateways are enabled", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.gatewaySettings.enabled=true",
+							}})
+
+							configMap := getConfigMap(testManifest, namespace, customResourceConfigMapName)
+							Expect(configMap.Data).ToNot(BeNil())
+							Expect(configMap.Data["custom-resources"]).To(ContainSubstring("kind: Gateway"))
+							Expect(configMap.Data["has-custom-resources"]).To(Equal("true"))
+						})
+
+						It("configmap should not contain gateway yaml when default gateways are disabled", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.gatewaySettings.enabled=false",
+							}})
+
+							configMap := getConfigMap(testManifest, namespace, customResourceConfigMapName)
+							Expect(configMap.Data).ToNot(BeNil())
+							Expect(configMap.Data["custom-resources"]).NotTo(ContainSubstring("kind:"))
+							Expect(configMap.Data["has-custom-resources"]).To(Equal("false"))
+						})
+
+						It("can disable rollout, migration, and cleanup jobs", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{
+								"gateway.rolloutJob.enabled=false",
+								"gateway.cleanupJob.enabled=false",
+							}})
+							testManifest.Expect("Job", namespace, "gloo-resource-rollout").To(BeNil())
+							testManifest.Expect("Job", namespace, "gloo-resource-migration").To(BeNil())
+							testManifest.Expect("Job", namespace, "gloo-resource-cleanup").To(BeNil())
+						})
+
+						It("can set resource requirements for rollout, migration, and cleanup jobs", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{
+								"gateway.rolloutJob.resources.requests.memory=100Mi",
+								"gateway.rolloutJob.resources.requests.cpu=200m",
+								"gateway.rolloutJob.resources.limits.memory=300Mi",
+								"gateway.rolloutJob.resources.limits.cpu=400m",
+								"gateway.cleanupJob.resources.requests.memory=150Mi",
+								"gateway.cleanupJob.resources.requests.cpu=250m",
+								"gateway.cleanupJob.resources.limits.memory=350Mi",
+								"gateway.cleanupJob.resources.limits.cpu=450m",
+							}})
+							// rollout and migration jobs both use the gateway.rolloutJob helm values
+							rolloutJob := getJob(testManifest, namespace, "gloo-resource-rollout")
+							Expect(rolloutJob.Spec.Template.Spec.Containers[0].Resources.Requests.Memory().String()).To(Equal("100Mi"))
+							Expect(rolloutJob.Spec.Template.Spec.Containers[0].Resources.Requests.Cpu().String()).To(Equal("200m"))
+							Expect(rolloutJob.Spec.Template.Spec.Containers[0].Resources.Limits.Memory().String()).To(Equal("300Mi"))
+							Expect(rolloutJob.Spec.Template.Spec.Containers[0].Resources.Limits.Cpu().String()).To(Equal("400m"))
+							migrationJob := getJob(testManifest, namespace, "gloo-resource-migration")
+							Expect(migrationJob.Spec.Template.Spec.Containers[0].Resources.Requests.Memory().String()).To(Equal("100Mi"))
+							Expect(migrationJob.Spec.Template.Spec.Containers[0].Resources.Requests.Cpu().String()).To(Equal("200m"))
+							Expect(migrationJob.Spec.Template.Spec.Containers[0].Resources.Limits.Memory().String()).To(Equal("300Mi"))
+							Expect(migrationJob.Spec.Template.Spec.Containers[0].Resources.Limits.Cpu().String()).To(Equal("400m"))
+							cleanupJob := getJob(testManifest, namespace, "gloo-resource-cleanup")
+							Expect(cleanupJob.Spec.Template.Spec.Containers[0].Resources.Requests.Memory().String()).To(Equal("150Mi"))
+							Expect(cleanupJob.Spec.Template.Spec.Containers[0].Resources.Requests.Cpu().String()).To(Equal("250m"))
+							Expect(cleanupJob.Spec.Template.Spec.Containers[0].Resources.Limits.Memory().String()).To(Equal("350Mi"))
+							Expect(cleanupJob.Spec.Template.Spec.Containers[0].Resources.Limits.Cpu().String()).To(Equal("450m"))
+						})
+
+						Context("Timeout waiting for the resource rollout job", func() {
+							It("sets the default value when none specified", func() {
+								prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{}})
+
+								rolloutCheckJob := getJob(testManifest, namespace, "gloo-resource-rollout-check")
+								Expect(rolloutCheckJob.Spec.Template.Spec.Containers[0].Command[2]).To(ContainSubstring("--timeout=120s || exit 1"))
+							})
+
+							It("sets the custom values specified", func() {
+								prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{
+									"gateway.rolloutJob.timeout=800",
+								}})
+
+								rolloutCheckJob := getJob(testManifest, namespace, "gloo-resource-rollout-check")
+								Expect(rolloutCheckJob.Spec.Template.Spec.Containers[0].Command[2]).To(ContainSubstring("--timeout=800s || exit 1"))
+							})
+						})
+					})
+
+					It("creates the certgen job, rbac, and service account", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{ValuesArgs: []string{
+							"global.glooMtls.enabled=true",
+							"gateway.certGenJob.resources.requests.memory=64Mi",
+							"gateway.certGenJob.resources.requests.cpu=250m",
+							"gateway.certGenJob.resources.limits.memory=128Mi",
+							"gateway.certGenJob.resources.limits.cpu=500m",
+							"gateway.certGenJob.forceRotation=true",
+							"gateway.certGenJob.rotationDuration=30s",
+						}})
+						gwJob := makeUnstructured(`
+apiVersion: batch/v1
+kind: Job
+metadata:
+  labels:
+    app: gloo
+    gloo: gateway-certgen
+    gloo.solo.io/component: certgen
+  name: gateway-certgen
+  namespace: ` + namespace + `
+  annotations:
+    "helm.sh/hook": pre-install,pre-upgrade
+    "helm.sh/hook-delete-policy": before-hook-creation
+    "helm.sh/hook-weight": "10"
+spec:
+  ttlSecondsAfterFinished: 60
+  template:
+    metadata:
+      labels:
+        sidecar.istio.io/inject: "false"
+        gloo: gateway-certgen
+    spec:
+      serviceAccountName: certgen
+      containers:
+        - image: quay.io/solo-io/certgen:` + version + `
+          imagePullPolicy: IfNotPresent
+          name: certgen
+          securityContext:
+            runAsUser: 10101
+            runAsNonRoot: true
+          env:
+            - name: POD_NAMESPACE
+              valueFrom:
+                fieldRef:
+                  fieldPath: metadata.namespace
+          resources:
+            requests:
+              cpu: 250m
+              memory: 64Mi
+            limits:
+              cpu: 500m
+              memory: 128Mi
+          args:
+            - "--secret-name=gateway-validation-certs"
+            - "--svc-name=gloo"
+            - "--validating-webhook-configuration-name=gloo-gateway-validation-webhook-` + namespace + `"
+            - "--force-rotation=true"
+      restartPolicy: OnFailure
+`)
+						testManifest.ExpectUnstructured(gwJob.GetKind(), gwJob.GetNamespace(), gwJob.GetName()).To(BeEquivalentTo(gwJob))
+
+						mtlsJob := makeUnstructured(`
+apiVersion: batch/v1
+kind: Job
+metadata:
+  labels:
+    app: gloo
+    gloo: gloo-mtls-certgen
+  name: gloo-mtls-certgen
+  namespace: ` + namespace + `
+  annotations:
+    "helm.sh/hook": pre-install
+    "helm.sh/hook-weight": "10"
+spec:
+  ttlSecondsAfterFinished: 60
+  template:
+    metadata:
+      labels:
+        gloo: gloo-mtls-certs
+        sidecar.istio.io/inject: "false"
+    spec:
+      serviceAccountName: certgen
+      restartPolicy: OnFailure
+      containers:
+        - image: quay.io/solo-io/certgen:` + version + `
+          imagePullPolicy: IfNotPresent
+          name: certgen
+          securityContext:
+            runAsNonRoot: true
+            runAsUser: 10101
+          env:
+            - name: POD_NAMESPACE
+              valueFrom:
+                fieldRef:
+                  fieldPath: metadata.namespace
+          resources:
+            requests:
+              cpu: 250m
+              memory: 64Mi
+            limits:
+              cpu: 500m
+              memory: 128Mi
+          args:
+            - "--secret-name=gloo-mtls-certs"
+            - "--svc-name=gloo"
+            - "--rotation-duration=30s"
+            - "--force-rotation=true"
+`)
+						testManifest.ExpectUnstructured(mtlsJob.GetKind(), mtlsJob.GetNamespace(), mtlsJob.GetName()).To(BeEquivalentTo(mtlsJob))
+
+						role := makeUnstructured(`
+
+# this role requires access to cluster-scoped resources
+kind: Role
+apiVersion: rbac.authorization.k8s.io/v1
+metadata:
+    name: gloo-gateway-secret-create-` + namespace + `
+    namespace: ` + namespace + `
+    labels:
+        app: gloo
+        gloo: rbac
+        gloo.solo.io/component: certgen
+    annotations:
+      "helm.sh/hook": "pre-install,pre-upgrade"
+      "helm.sh/hook-weight": "5"
+rules:
+- apiGroups: [""]
+  resources: ["secrets"]
+  verbs: ["create", "get", "update"]
+`)
+						testManifest.ExpectUnstructured(role.GetKind(), role.GetNamespace(), role.GetName()).To(BeEquivalentTo(role))
+
+						roleBinding := makeUnstructured(`
+# this role requires access to cluster-scoped resources
+kind: RoleBinding
+apiVersion: rbac.authorization.k8s.io/v1
+metadata:
+  name: gloo-gateway-secret-create-` + namespace + `
+  namespace: ` + namespace + `
+  labels:
+    app: gloo
+    gloo: rbac
+    gloo.solo.io/component: certgen
+  annotations:
+    "helm.sh/hook": "pre-install,pre-upgrade"
+    "helm.sh/hook-weight": "5"
+subjects:
+- kind: ServiceAccount
+  name: certgen
+  namespace: ` + namespace + `
+roleRef:
+  kind: Role
+  name: gloo-gateway-secret-create-` + namespace + `
+  apiGroup: rbac.authorization.k8s.io
+---
+`)
+						testManifest.ExpectUnstructured(roleBinding.GetKind(), roleBinding.GetNamespace(), roleBinding.GetName()).To(BeEquivalentTo(roleBinding))
+
+						serviceAccount := makeUnstructured(`
+
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  labels:
+    app: gloo
+    gloo: rbac
+    gloo.solo.io/component: certgen
+  annotations:
+    "helm.sh/hook": "pre-install,pre-upgrade"
+    "helm.sh/hook-weight": "5"
+  name: certgen
+  namespace: ` + namespace + `
+
+`)
+						testManifest.ExpectUnstructured(serviceAccount.GetKind(), serviceAccount.GetNamespace(), serviceAccount.GetName()).To(BeEquivalentTo(serviceAccount))
+					})
+				})
+			})
+
+			Context("gloo service account", func() {
+				var glooServiceAccount *corev1.ServiceAccount
+
+				BeforeEach(func() {
+					saLabels := map[string]string{
+						"app":  "gloo",
+						"gloo": "gloo",
+					}
+					rb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      "gloo",
+						Args:      nil,
+						Labels:    saLabels,
+					}
+					glooServiceAccount = rb.GetServiceAccount()
+					glooServiceAccount.AutomountServiceAccountToken = proto.Bool(false)
+				})
+
+				It("sets extra annotations", func() {
+					glooServiceAccount.ObjectMeta.Annotations = map[string]string{"foo": "bar", "bar": "baz"}
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gloo.serviceAccount.extraAnnotations.foo=bar",
+							"gloo.serviceAccount.extraAnnotations.bar=baz",
+							"gloo.serviceAccount.disableAutomount=true",
+						},
+					})
+					testManifest.ExpectServiceAccount(glooServiceAccount)
+				})
+			})
+
+			Context("control plane deployments", func() {
+				updateDeployment := func(deploy *appsv1.Deployment) {
+					deploy.Spec.Selector = &metav1.LabelSelector{
+						MatchLabels: selector,
+					}
+					deploy.Spec.Template.ObjectMeta.Labels = map[string]string{}
+					for k, v := range selector {
+						deploy.Spec.Template.ObjectMeta.Labels[k] = v
+					}
+
+					truez := true
+					falsez := false
+					user := int64(10101)
+					deploy.Spec.Template.Spec.Containers[0].SecurityContext = &corev1.SecurityContext{
+						Capabilities: &corev1.Capabilities{
+							Drop: []corev1.Capability{"ALL"},
+						},
+						RunAsNonRoot:             &truez,
+						RunAsUser:                &user,
+						ReadOnlyRootFilesystem:   &truez,
+						AllowPrivilegeEscalation: &falsez,
+					}
+					deploy.Spec.Template.Spec.Containers[0].ImagePullPolicy = pullPolicy
+				}
+
+				Context("gloo deployment", func() {
+					var (
+						glooDeployment *appsv1.Deployment
+						labels         map[string]string
+					)
+					BeforeEach(func() {
+						format.MaxLength = 0
+						labels = map[string]string{
+							"gloo": "gloo",
+							"app":  "gloo",
+						}
+						selector = map[string]string{
+							"gloo": "gloo",
+						}
+						container := GetQuayContainerSpec("gloo", version, GetPodNamespaceEnvVar(), GetPodNamespaceStats(), GetValidationEnvVar())
+						glooAnnotations := make(map[string]string)
+						for k, v := range statsAnnotations {
+							glooAnnotations[k] = v
+						}
+						glooAnnotations["gloo.solo.io/oss-image-tag"] = version
+						rb := ResourceBuilder{
+							Namespace:   namespace,
+							Name:        "gloo",
+							Labels:      labels,
+							Annotations: glooAnnotations,
+							Containers:  []ContainerSpec{container},
+						}
+						deploy := rb.GetDeploymentAppsv1()
+						updateDeployment(deploy)
+						deploy.Spec.Template.Spec.Volumes = []corev1.Volume{
+							{
+								Name: "labels-volume",
+								VolumeSource: corev1.VolumeSource{
+									DownwardAPI: &corev1.DownwardAPIVolumeSource{
+										Items: []corev1.DownwardAPIVolumeFile{{
+											Path: "labels",
+											FieldRef: &corev1.ObjectFieldSelector{
+												FieldPath: "metadata.labels",
+											},
+										}},
+									},
+								},
+							},
+							{
+								Name: "validation-certs",
+								VolumeSource: corev1.VolumeSource{
+									Secret: &corev1.SecretVolumeSource{
+										SecretName:  "gateway-validation-certs",
+										DefaultMode: proto.Int(420),
+									},
+								},
+							},
+						}
+						deploy.Spec.Template.Spec.Containers[0].VolumeMounts = []corev1.VolumeMount{
+							{
+								Name:      "validation-certs",
+								MountPath: "/etc/gateway/validation-certs",
+								ReadOnly:  false,
+							},
+							{
+								Name:      "labels-volume",
+								MountPath: "/etc/gloo",
+								ReadOnly:  true,
+							},
+						}
+
+						deploy.Spec.Template.Spec.Containers[0].Ports = glooPorts
+						deploy.Spec.Template.Spec.Containers[0].Resources = corev1.ResourceRequirements{
+							Requests: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("256Mi"),
+								corev1.ResourceCPU:    resource.MustParse("500m"),
+							},
+						}
+
+						deploy.Spec.Template.Spec.Containers[0].ReadinessProbe = &corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								TCPSocket: &corev1.TCPSocketAction{
+									Port: intstr.FromInt32(9977),
+								},
+							},
+							InitialDelaySeconds: 3,
+							PeriodSeconds:       10,
+							FailureThreshold:    3,
+						}
+						deploy.Spec.Template.Spec.ServiceAccountName = "gloo"
+						glooDeployment = deploy
+					})
+
+					It("should create a deployment", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						testManifest.ExpectDeploymentAppsV1(glooDeployment)
+					})
+
+					It("should allow overriding runAsUser", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gloo.deployment.runAsUser=10102"},
+						})
+						uid := int64(10102)
+						glooDeployment.Spec.Template.Spec.Containers[0].SecurityContext.RunAsUser = &uid
+						testManifest.ExpectDeploymentAppsV1(glooDeployment)
+					})
+
+					It("can set both requests and limits", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gloo.deployment.resources.limits.memory=2Mi",
+								"gloo.deployment.resources.limits.cpu=3m",
+								"gloo.deployment.resources.requests.memory=4Mi",
+								"gloo.deployment.resources.requests.cpu=5m",
+							},
+						})
+
+						// make sure the resource requests and limits are set in the pod template
+						deploy := getStructuredDeployment(testManifest, helpers.DefaultKgatewayDeploymentName)
+						glooContainer := deploy.Spec.Template.Spec.Containers[0]
+						Expect(glooContainer.Resources).To(Equal(corev1.ResourceRequirements{
+							Limits: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("2Mi"),
+								corev1.ResourceCPU:    resource.MustParse("3m"),
+							},
+							Requests: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("4Mi"),
+								corev1.ResourceCPU:    resource.MustParse("5m"),
+							},
+						}))
+
+						// should set GOMEMLIMIT and GOMAXPROCS when resource limits are set
+						expectEnvVarExists(glooContainer, corev1.EnvVar{
+							Name: "GOMEMLIMIT",
+							ValueFrom: &corev1.EnvVarSource{
+								ResourceFieldRef: &corev1.ResourceFieldSelector{
+									Resource: string(corev1.ResourceLimitsMemory),
+									Divisor:  resource.MustParse("1"),
+								},
+							}})
+						expectEnvVarExists(glooContainer, corev1.EnvVar{
+							Name: "GOMAXPROCS",
+							ValueFrom: &corev1.EnvVarSource{
+								ResourceFieldRef: &corev1.ResourceFieldSelector{
+									Resource: string(corev1.ResourceLimitsCPU),
+									Divisor:  resource.MustParse("1"),
+								},
+							}})
+					})
+
+					It("can set requests only", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gloo.deployment.resources.requests.memory=6Mi",
+								"gloo.deployment.resources.requests.cpu=7m",
+							},
+						})
+
+						// make sure the resource requests are set in the pod template
+						deploy := getStructuredDeployment(testManifest, helpers.DefaultKgatewayDeploymentName)
+						glooContainer := deploy.Spec.Template.Spec.Containers[0]
+						Expect(glooContainer.Resources).To(Equal(corev1.ResourceRequirements{
+							Requests: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("6Mi"),
+								corev1.ResourceCPU:    resource.MustParse("7m"),
+							},
+						}))
+
+						// since no resource limits are set, GOMEMLIMIT and GOMAXPROCS should also not be set
+						expectEnvVarDoesNotExist(glooContainer, "GOMEMLIMIT")
+						expectEnvVarDoesNotExist(glooContainer, "GOMAXPROCS")
+					})
+
+					It("can overwrite the container image information", func() {
+						container := GetContainerSpec("gcr.io/solo-public", "gloo", version, GetPodNamespaceEnvVar(), GetPodNamespaceStats())
+						container.PullPolicy = "Always"
+						rb := ResourceBuilder{
+							Namespace:   namespace,
+							Name:        "gloo",
+							Labels:      labels,
+							Annotations: statsAnnotations,
+							Containers:  []ContainerSpec{container},
+						}
+						deploy := rb.GetDeploymentAppsv1()
+						updateDeployment(deploy)
+						deploy.Spec.Template.Spec.Containers[0].Ports = glooPorts
+						deploy.Spec.Template.Spec.ServiceAccountName = "gloo"
+
+						glooDeployment = deploy
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gloo.deployment.image.pullPolicy=Always",
+								"gloo.deployment.image.registry=gcr.io/solo-public",
+							},
+						})
+					})
+
+					It("can set log level env var", func() {
+						glooDeployment.Spec.Template.Spec.Containers[0].Env = append(
+							glooDeployment.Spec.Template.Spec.Containers[0].Env,
+							GetLogLevelEnvVar("debug"),
+						)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gloo.logLevel=debug"},
+						})
+						testManifest.ExpectDeploymentAppsV1(glooDeployment)
+					})
+					It("can set disable leader election env var", func() {
+						glooDeployment.Spec.Template.Spec.Containers[0].Env = append(
+							glooDeployment.Spec.Template.Spec.Containers[0].Env,
+							corev1.EnvVar{
+								Name:  "DISABLE_LEADER_ELECTION",
+								Value: "true",
+							})
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gloo.disableLeaderElection=true"},
+						})
+						testManifest.ExpectDeploymentAppsV1(glooDeployment)
+					})
+					It("can set secret namespace match env var", func() {
+						glooDeployment.Spec.Template.Spec.Containers[0].Env = append(
+							glooDeployment.Spec.Template.Spec.Containers[0].Env,
+							corev1.EnvVar{
+								Name:  "HEADER_SECRET_REF_NS_MATCHES_US",
+								Value: "true",
+							})
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gloo.headerSecretRefNsMatchesUs=true"},
+						})
+						testManifest.ExpectDeploymentAppsV1(glooDeployment)
+					})
+					It("can disable validation", func() {
+						glooDeployment.Spec.Template.Spec.Containers[0].Env = []corev1.EnvVar{GetPodNamespaceEnvVar(), GetPodNamespaceStats()}
+						glooDeployment.Spec.Template.Spec.Volumes = []corev1.Volume{
+							{
+								Name: "labels-volume",
+								VolumeSource: corev1.VolumeSource{
+									DownwardAPI: &corev1.DownwardAPIVolumeSource{
+										Items: []corev1.DownwardAPIVolumeFile{{
+											Path: "labels",
+											FieldRef: &corev1.ObjectFieldSelector{
+												FieldPath: "metadata.labels",
+											},
+										}},
+									},
+								},
+							},
+						}
+						glooDeployment.Spec.Template.Spec.Containers[0].VolumeMounts = []corev1.VolumeMount{
+							{
+								Name:      "labels-volume",
+								MountPath: "/etc/gloo",
+								ReadOnly:  true,
+							},
+						}
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gateway.validation.enabled=false"},
+						})
+						testManifest.ExpectDeploymentAppsV1(glooDeployment)
+					})
+					It("can accept extra env vars", func() {
+						glooDeployment.Spec.Template.Spec.Containers[0].Env = append(
+							[]corev1.EnvVar{GetTestExtraEnvVar()},
+							glooDeployment.Spec.Template.Spec.Containers[0].Env...,
+						)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gloo.deployment.customEnv[0].Name=TEST_EXTRA_ENV_VAR",
+								"gloo.deployment.customEnv[0].Value=test",
+							},
+						})
+						testManifest.ExpectDeploymentAppsV1(glooDeployment)
+					})
+
+					Context("pass image pull secrets", func() {
+						pullSecretName := "test-pull-secret"
+						pullSecret := []corev1.LocalObjectReference{
+							{Name: pullSecretName},
+						}
+
+						It("via global values", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									fmt.Sprintf("global.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							glooDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(glooDeployment)
+						})
+
+						It("via podTemplate values", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									fmt.Sprintf("gloo.deployment.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							glooDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(glooDeployment)
+						})
+
+						It("podTemplate values win over global", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"global.image.pullSecret=wrong",
+									fmt.Sprintf("gloo.deployment.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							glooDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(glooDeployment)
+						})
+					})
+				})
+
+				Context("discovery service account", func() {
+					var discoveryServiceAccount *corev1.ServiceAccount
+
+					BeforeEach(func() {
+						saLabels := map[string]string{
+							"app":  "gloo",
+							"gloo": "discovery",
+						}
+						rb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      "discovery",
+							Args:      nil,
+							Labels:    saLabels,
+						}
+						discoveryServiceAccount = rb.GetServiceAccount()
+						discoveryServiceAccount.AutomountServiceAccountToken = proto.Bool(false)
+					})
+
+					It("sets extra annotations", func() {
+						discoveryServiceAccount.ObjectMeta.Annotations = map[string]string{"foo": "bar", "bar": "baz"}
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.serviceAccount.extraAnnotations.foo=bar",
+								"discovery.serviceAccount.extraAnnotations.bar=baz",
+								"discovery.serviceAccount.disableAutomount=true",
+							},
+						})
+						testManifest.ExpectServiceAccount(discoveryServiceAccount)
+					})
+
+					It("is not created when service is disabled", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.enabled=false",
+							},
+						})
+						testManifest.ExpectUnstructured(
+							discoveryServiceAccount.Kind,
+							discoveryServiceAccount.Namespace,
+							discoveryServiceAccount.Name).To(BeNil())
+					})
+				})
+
+				Context("discovery deployment", func() {
+					var (
+						discoveryDeployment *appsv1.Deployment
+						labels              map[string]string
+					)
+					BeforeEach(func() {
+						labels = map[string]string{
+							"gloo": "discovery",
+							"app":  "gloo",
+						}
+						selector = map[string]string{
+							"gloo": "discovery",
+						}
+						container := GetQuayContainerSpec("discovery", version, GetPodNamespaceEnvVar(), GetPodNamespaceStats())
+
+						rb := ResourceBuilder{
+							Namespace:   namespace,
+							Name:        "discovery",
+							Labels:      labels,
+							Annotations: statsAnnotations,
+							Containers:  []ContainerSpec{container},
+						}
+						deploy := rb.GetDeploymentAppsv1()
+						updateDeployment(deploy)
+						deploy.Spec.Template.Spec.ServiceAccountName = "discovery"
+						user := int64(10101)
+						deploy.Spec.Template.Spec.SecurityContext = &corev1.PodSecurityContext{
+							FSGroup:   &user,
+							RunAsUser: &user,
+						}
+						discoveryDeployment = deploy
+					})
+
+					It("has a creates a deployment", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{})
+						testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+					})
+
+					It("can set both requests and limits", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.deployment.resources.limits.memory=2Mi",
+								"discovery.deployment.resources.limits.cpu=3m",
+								"discovery.deployment.resources.requests.memory=4Mi",
+								"discovery.deployment.resources.requests.cpu=5m",
+							},
+						})
+
+						// make sure the resource requests and limits are set in the pod template
+						deploy := getStructuredDeployment(testManifest, kubeutils.DiscoveryDeploymentName)
+						discoveryContainer := deploy.Spec.Template.Spec.Containers[0]
+						Expect(discoveryContainer.Resources).To(Equal(corev1.ResourceRequirements{
+							Limits: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("2Mi"),
+								corev1.ResourceCPU:    resource.MustParse("3m"),
+							},
+							Requests: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("4Mi"),
+								corev1.ResourceCPU:    resource.MustParse("5m"),
+							},
+						}))
+
+						// should set GOMEMLIMIT and GOMAXPROCS when resource limits are set
+						expectEnvVarExists(discoveryContainer, corev1.EnvVar{
+							Name: "GOMEMLIMIT",
+							ValueFrom: &corev1.EnvVarSource{
+								ResourceFieldRef: &corev1.ResourceFieldSelector{
+									Resource: string(corev1.ResourceLimitsMemory),
+									Divisor:  resource.MustParse("1"),
+								},
+							}})
+						expectEnvVarExists(discoveryContainer, corev1.EnvVar{
+							Name: "GOMAXPROCS",
+							ValueFrom: &corev1.EnvVarSource{
+								ResourceFieldRef: &corev1.ResourceFieldSelector{
+									Resource: string(corev1.ResourceLimitsCPU),
+									Divisor:  resource.MustParse("1"),
+								},
+							}})
+					})
+
+					It("can set requests only", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.deployment.resources.requests.memory=6Mi",
+								"discovery.deployment.resources.requests.cpu=7m",
+							},
+						})
+
+						// make sure the resource requests are set in the pod template
+						deploy := getStructuredDeployment(testManifest, kubeutils.DiscoveryDeploymentName)
+						discoveryContainer := deploy.Spec.Template.Spec.Containers[0]
+						Expect(discoveryContainer.Resources).To(Equal(corev1.ResourceRequirements{
+							Requests: corev1.ResourceList{
+								corev1.ResourceMemory: resource.MustParse("6Mi"),
+								corev1.ResourceCPU:    resource.MustParse("7m"),
+							},
+						}))
+
+						// since no resource limits are set, GOMEMLIMIT and GOMAXPROCS should also not be set
+						expectEnvVarDoesNotExist(discoveryContainer, "GOMEMLIMIT")
+						expectEnvVarDoesNotExist(discoveryContainer, "GOMAXPROCS")
+					})
+
+					It("can overwrite the container image information", func() {
+						container := GetContainerSpec("gcr.io/solo-public", "discovery", version, GetPodNamespaceEnvVar(), GetPodNamespaceStats())
+						container.PullPolicy = "Always"
+						rb := ResourceBuilder{
+							Namespace:   namespace,
+							Name:        "discovery",
+							Labels:      labels,
+							Annotations: statsAnnotations,
+							Containers:  []ContainerSpec{container},
+						}
+						deploy := rb.GetDeploymentAppsv1()
+						updateDeployment(deploy)
+
+						discoveryDeployment = deploy
+						deploy.Spec.Template.Spec.ServiceAccountName = "discovery"
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.deployment.image.pullPolicy=Always",
+								"discovery.deployment.image.registry=gcr.io/solo-public",
+							},
+						})
+					})
+
+					DescribeTable("supports deploying the correct discovery-ee image variant", func(variant string, expectedImage string) {
+						discoveryDeployment.Spec.Template.Spec.Containers[0].Image = expectedImage
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"global.image.variant=" + variant,
+								"discovery.deployment.image.tag=1.2.3",
+								"discovery.deployment.image.repository=discovery-ee",
+							},
+						})
+
+						testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+					},
+						Entry("No variant specified", "", "quay.io/solo-io/discovery-ee:1.2.3"),
+						Entry("Standard variant", "standard", "quay.io/solo-io/discovery-ee:1.2.3"),
+						Entry("Fips variant", "fips", "quay.io/solo-io/discovery-ee-fips:1.2.3"),
+						Entry("Distroless variant", "distroless", "quay.io/solo-io/discovery-ee:1.2.3-distroless"),
+						Entry("Fips-Distroless variant", "fips-distroless", "quay.io/solo-io/discovery-ee-fips:1.2.3-distroless"),
+					)
+
+					It("can set log level env var", func() {
+						discoveryDeployment.Spec.Template.Spec.Containers[0].Env = append(
+							discoveryDeployment.Spec.Template.Spec.Containers[0].Env,
+							GetLogLevelEnvVar("debug"),
+						)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"discovery.logLevel=debug"},
+						})
+						testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+					})
+
+					It("can accept extra env vars", func() {
+						discoveryDeployment.Spec.Template.Spec.Containers[0].Env = append(
+							[]corev1.EnvVar{GetTestExtraEnvVar()},
+							discoveryDeployment.Spec.Template.Spec.Containers[0].Env...,
+						)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.deployment.customEnv[0].Name=TEST_EXTRA_ENV_VAR",
+								"discovery.deployment.customEnv[0].Value=test",
+							},
+						})
+						testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+					})
+
+					It("allows setting custom runAsUser", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"discovery.deployment.runAsUser=10102"},
+						})
+						uid := int64(10102)
+						discoveryDeployment.Spec.Template.Spec.SecurityContext.RunAsUser = &uid
+						discoveryDeployment.Spec.Template.Spec.Containers[0].SecurityContext.RunAsUser = &uid
+						testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+					})
+
+					It("allows removing pod security context", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"discovery.deployment.enablePodSecurityContext=false"},
+						})
+						discoveryDeployment.Spec.Template.Spec.SecurityContext = nil
+						testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+					})
+
+					It("allows disabling FDS GraphQL discovery", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/graphql_fds_disabled.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.fdsOptions.graphqlEnabled=false",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("allows disabling upstream discovery", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/uds_disabled.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.udsOptions.enabled=false",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("allows setting watchedLabels for discovery", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/watched_discovery_labels.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"discovery.udsOptions.watchLabels.A=B",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					It("allows setting translateEmptyGateways for gateway translation", func() {
+						settings := makeUnstructureFromTemplateFile("fixtures/settings/translate_empty_gateway.yaml", namespace)
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gateway.validation.enabled=false",
+								"gateway.translateEmptyGateways=true",
+							},
+						})
+						testManifest.ExpectUnstructured(settings.GetKind(), settings.GetNamespace(), settings.GetName()).To(BeEquivalentTo(settings))
+					})
+
+					Context("pass image pull secrets", func() {
+						pullSecretName := "test-pull-secret"
+						pullSecret := []corev1.LocalObjectReference{
+							{Name: pullSecretName},
+						}
+
+						It("via global values", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									fmt.Sprintf("global.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							discoveryDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+						})
+
+						It("via podTemplate values", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									fmt.Sprintf("discovery.deployment.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							discoveryDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+						})
+
+						It("podTemplate values win over global", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"global.image.pullSecret=wrong",
+									fmt.Sprintf("discovery.deployment.image.pullSecret=%s", pullSecretName),
+								},
+							})
+							discoveryDeployment.Spec.Template.Spec.ImagePullSecrets = pullSecret
+							testManifest.ExpectDeploymentAppsV1(discoveryDeployment)
+						})
+					})
+				})
+			})
+
+			Describe("configmaps", func() {
+				gatewayProxyConfigMapName := "gateway-proxy-envoy-config"
+
+				labels := map[string]string{
+					"gloo":             "gateway-proxy",
+					"app":              "gloo",
+					"gateway-proxy-id": "gateway-proxy",
+				}
+
+				It("should allow customising tcp keepalive on custom gateway proxies", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"",
+							"gatewayProxies.gatewayProxy.tcpKeepaliveTimeSeconds=30",
+							"gatewayProxies.anotherGatewayProxy.tcpKeepaliveTimeSeconds=33",
+						},
+					})
+					gatewayProxyKeepaliveSeen := false
+					anotherGatewayProxyKeepaliveSeen := false
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("configMap %+v should be able to cast to a structured configMap", configMap))
+						configMapName := structuredConfigMap.GetName()
+						envoyConfig := structuredConfigMap.Data["envoy.yaml"]
+						if configMapName == "gateway-proxy-envoy-config" {
+							gatewayProxyKeepaliveSeen = true
+							Expect(envoyConfig).To(ContainSubstring("keepalive_time: 30"), "Should set custom value for gatewayProxy")
+						} else if configMapName == "another-gateway-proxy-envoy-config" {
+							anotherGatewayProxyKeepaliveSeen = true
+							Expect(envoyConfig).To(ContainSubstring("keepalive_time: 33"), "Should set custom value for another custom gatewayProxy value")
+						}
+					})
+					Expect(gatewayProxyKeepaliveSeen).To(BeTrue())
+					Expect(anotherGatewayProxyKeepaliveSeen).To(BeTrue())
+				})
+
+				It("should allow customising tcp keepalive", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"",
+							"gatewayProxies.gatewayProxy.tcpKeepaliveTimeSeconds=30",
+						},
+					})
+					byt, err := os.ReadFile("fixtures/envoy_config/tcp_keepalive.yaml")
+					Expect(err).ToNot(HaveOccurred())
+					envoyBootstrapYaml := string(byt)
+
+					envoyBootstrapSpec := make(map[string]string)
+					envoyBootstrapSpec["envoy.yaml"] = envoyBootstrapYaml
+
+					cmRb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      gatewayProxyConfigMapName,
+						Labels:    labels,
+						Data:      envoyBootstrapSpec,
+					}
+					envoyBootstrapCm := cmRb.GetConfigMap()
+					testManifest.ExpectConfigMapWithYamlData(envoyBootstrapCm)
+				})
+
+				It("is not created if disabled", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"settings.aws.enableServiceAccountCredentials=true",
+							"gatewayProxies.gatewayProxy.disabled=false",
+						},
+					})
+					proxySpec := make(map[string]string)
+					proxySpec["envoy.yaml"] = fmt.Sprintf(awsFmtString, "", "")
+					cmRb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      gatewayProxyConfigMapName,
+						Labels:    labels,
+						Data:      proxySpec,
+					}
+					proxy := cmRb.GetConfigMap()
+					testManifest.ExpectConfigMapWithYamlData(proxy)
+
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{"gatewayProxies.gatewayProxy.disabled=true"},
+					})
+					testManifest.Expect("ConfigMap", namespace, defaults.GatewayProxyName).To(BeNil())
+				})
+
+				It("can create a gateway proxy with added static clusters", func() {
+					prepareMakefileFromValuesFile("values/val_static_clusters.yaml")
+
+					byt, err := os.ReadFile("fixtures/envoy_config/static_clusters.yaml")
+					Expect(err).ToNot(HaveOccurred())
+					envoyBootstrapYaml := string(byt)
+
+					envoyBootstrapSpec := make(map[string]string)
+					envoyBootstrapSpec["envoy.yaml"] = envoyBootstrapYaml
+
+					cmRb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      gatewayProxyConfigMapName,
+						Labels:    labels,
+						Data:      envoyBootstrapSpec,
+					}
+					envoyBootstrapCm := cmRb.GetConfigMap()
+					testManifest.ExpectConfigMapWithYamlData(envoyBootstrapCm)
+				})
+
+				It("can create a gateway proxy with added overload manager config", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gatewayProxies.gatewayProxy.envoyOverloadManager.enabled=true",
+							"gatewayProxies.gatewayProxy.envoyOverloadManager.refreshInterval=2s",
+							"gatewayProxies.gatewayProxy.disabled=false",
+						},
+					})
+
+					byt, err := os.ReadFile("fixtures/envoy_config/overload_manager.yaml")
+					Expect(err).ToNot(HaveOccurred())
+					envoyBootstrapYaml := string(byt)
+
+					envoyBootstrapSpec := make(map[string]string)
+					envoyBootstrapSpec["envoy.yaml"] = envoyBootstrapYaml
+
+					cmRb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      gatewayProxyConfigMapName,
+						Labels:    labels,
+						Data:      envoyBootstrapSpec,
+					}
+					envoyBootstrapCm := cmRb.GetConfigMap()
+					testManifest.ExpectConfigMapWithYamlData(envoyBootstrapCm)
+				})
+
+				It("can create a gateway proxy config with added bootstrap extensions", func() {
+					prepareMakefileFromValuesFile("values/val_custom_bootstrap_extensions.yaml")
+
+					byt, err := os.ReadFile("fixtures/envoy_config/bootstrap_extensions.yaml")
+					Expect(err).ToNot(HaveOccurred())
+					envoyBootstrapYaml := string(byt)
+
+					envoyBootstrapSpec := make(map[string]string)
+					envoyBootstrapSpec["envoy.yaml"] = envoyBootstrapYaml
+
+					cmRb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      gatewayProxyConfigMapName,
+						Labels:    labels,
+						Data:      envoyBootstrapSpec,
+					}
+					envoyBootstrapCm := cmRb.GetConfigMap()
+					testManifest.ExpectConfigMapWithYamlData(envoyBootstrapCm)
+				})
+
+				It("can create a gateway proxy config with custom static layer", func() {
+					prepareMakefileFromValuesFile("values/val_custom_static_bootstrap.yaml")
+
+					byt, err := os.ReadFile("fixtures/envoy_config/custom_static_bootstrap.yaml")
+					Expect(err).ToNot(HaveOccurred())
+					envoyBootstrapYaml := string(byt)
+
+					envoyBootstrapSpec := make(map[string]string)
+					envoyBootstrapSpec["envoy.yaml"] = envoyBootstrapYaml
+
+					cmRb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      gatewayProxyConfigMapName,
+						Labels:    labels,
+						Data:      envoyBootstrapSpec,
+					}
+					envoyBootstrapCm := cmRb.GetConfigMap()
+					testManifest.ExpectConfigMapWithYamlData(envoyBootstrapCm)
+				})
+
+				It("can create arbitrary configmaps", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"global.configMaps[0].name=my-config-map",
+							"global.configMaps[0].namespace=my-ns",
+							"global.configMaps[0].data.key1=value1",
+							"global.configMaps[0].data.key2=value2",
+						},
+					})
+					cmRb := ResourceBuilder{
+						Namespace: "my-ns",
+						Name:      "my-config-map",
+						Labels:    map[string]string{"app": "gloo", "gloo": "gloo"},
+						Data:      map[string]string{"key1": "value1", "key2": "value2"},
+					}
+					cm := cmRb.GetConfigMap()
+					testManifest.ExpectConfigMapWithYamlData(cm)
+				})
+
+				Describe("gateway proxy - AWS", func() {
+					It("has a global cluster", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"settings.aws.enableServiceAccountCredentials=true"},
+						})
+						proxySpec := make(map[string]string)
+						proxySpec["envoy.yaml"] = fmt.Sprintf(awsFmtString, "", "")
+						cmRb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      gatewayProxyConfigMapName,
+							Labels:    labels,
+							Data:      proxySpec,
+						}
+						proxy := cmRb.GetConfigMap()
+						testManifest.ExpectConfigMapWithYamlData(proxy)
+					})
+
+					It("has a regional cluster", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"settings.aws.enableServiceAccountCredentials=true",
+								"settings.aws.stsCredentialsRegion=us-east-2",
+							},
+						})
+						proxySpec := make(map[string]string)
+						proxySpec["envoy.yaml"] = fmt.Sprintf(awsFmtString, "us-east-2.", "us-east-2.")
+						cmRb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      gatewayProxyConfigMapName,
+							Labels:    labels,
+							Data:      proxySpec,
+						}
+						proxy := cmRb.GetConfigMap()
+						testManifest.ExpectConfigMapWithYamlData(proxy)
+					})
+				})
+
+				Describe("gateway proxy - tracing config", func() {
+					It("has a proxy without tracing", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.service.extraAnnotations.test=test"},
+						})
+						proxySpec := make(map[string]string)
+						proxySpec["envoy.yaml"] = confWithoutTracing
+						cmRb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      gatewayProxyConfigMapName,
+							Labels:    labels,
+							Data:      proxySpec,
+						}
+						proxy := cmRb.GetConfigMap()
+						testManifest.ExpectConfigMapWithYamlData(proxy)
+					})
+
+					It("has a proxy with tracing cluster", func() {
+						prepareMakefileFromValuesFile("values/val_tracing_provider_cluster.yaml")
+						proxySpec := make(map[string]string)
+						proxySpec["envoy.yaml"] = confWithTracingCluster
+						cmRb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      gatewayProxyConfigMapName,
+							Labels:    labels,
+							Data:      proxySpec,
+						}
+						proxy := cmRb.GetConfigMap()
+						testManifest.ExpectConfigMapWithYamlData(proxy)
+					})
+				})
+
+				Describe("gateway proxy -- readConfig config", func() {
+					It("has a listener for reading a subset of the admin api", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{"gatewayProxies.gatewayProxy.readConfig=true"},
+						})
+						proxySpec := make(map[string]string)
+						proxySpec["envoy.yaml"] = confWithReadConfig
+						cmRb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      gatewayProxyConfigMapName,
+							Labels:    labels,
+							Data:      proxySpec,
+						}
+						proxy := cmRb.GetConfigMap()
+						testManifest.ExpectConfigMapWithYamlData(proxy)
+					})
+				})
+				Describe("gateway proxy -- readConfigMulticluster config", func() {
+					It("has a service for the gateway proxy config dump port", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxy.readConfig=true",
+								"gatewayProxies.gatewayProxy.readConfigMulticluster=true",
+							},
+						})
+						serviceLabels := map[string]string{
+							"app":              "gloo",
+							"gloo":             "gateway-proxy",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						serviceSelector := map[string]string{
+							"gloo":             "gateway-proxy",
+							"gateway-proxy-id": "gateway-proxy",
+						}
+						rb := ResourceBuilder{
+							Namespace: namespace,
+							Name:      "gateway-proxy-config-dump-service",
+							Args:      nil,
+							Labels:    serviceLabels,
+						}
+						gatewayProxyConfigDumpService := rb.GetService()
+						gatewayProxyConfigDumpService.Spec.Selector = serviceSelector
+						gatewayProxyConfigDumpService.Spec.Ports = []corev1.ServicePort{
+							{
+								Protocol: "TCP",
+								Port:     8082,
+							},
+						}
+						gatewayProxyConfigDumpService.Spec.Type = corev1.ServiceTypeClusterIP
+						testManifest.ExpectService(gatewayProxyConfigDumpService)
+					})
+				})
+				Describe("supports multiple gateway proxy config maps", func() {
+					It("can parse multiple config maps", func() {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: []string{
+								"gatewayProxies.gatewayProxyInternal.kind.deployment.replicas=0",
+								"gatewayProxies.gatewayProxyInternal.configMap.data=null",
+								"gatewayProxies.gatewayProxyInternal.service.extraAnnotations=null",
+								"gatewayProxies.gatewayProxyInternal.service.type=ClusterIP",
+								"gatewayProxies.gatewayProxyInternal.podTemplate.httpPort=8081",
+								"gatewayProxies.gatewayProxyInternal.podTemplate.image.tag=dev",
+							},
+						})
+						cmName := "gateway-proxy-internal-envoy-config"
+						// cm exists for for second declaration of gateway proxy
+						testManifest.Expect("ConfigMap", namespace, cmName).NotTo(BeNil())
+						testManifest.Expect("ConfigMap", namespace, "gateway-proxy-envoy-config").NotTo(BeNil())
+					})
+				})
+			})
+
+			Context("ingress-proxy service", func() {
+				var ingressProxyService *corev1.Service
+
+				BeforeEach(func() {
+					serviceLabels := map[string]string{
+						"app":  "gloo",
+						"gloo": "ingress-proxy",
+					}
+					rb := ResourceBuilder{
+						Namespace: namespace,
+						Name:      "ingress-proxy",
+						Args:      nil,
+						Labels:    serviceLabels,
+					}
+					ingressProxyService = rb.GetService()
+					selectorLabels := map[string]string{
+						"gloo": "ingress-proxy",
+					}
+					ingressProxyService.Spec.Selector = selectorLabels
+					ingressProxyService.Spec.Ports = []corev1.ServicePort{
+						{
+							Name:       "http",
+							Protocol:   "TCP",
+							Port:       80,
+							TargetPort: intstr.IntOrString{IntVal: 8080},
+						},
+						{
+							Name:       "https",
+							Protocol:   "TCP",
+							Port:       443,
+							TargetPort: intstr.IntOrString{IntVal: 8443},
+						},
+					}
+					ingressProxyService.Spec.Type = corev1.ServiceTypeLoadBalancer
+				})
+
+				It("sets extra annotations", func() {
+					ingressProxyService.ObjectMeta.Annotations = map[string]string{"foo": "bar", "bar": "baz"}
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"ingress.enabled=true",
+							"ingressProxy.service.extraAnnotations.foo=bar",
+							"ingressProxy.service.extraAnnotations.bar=baz",
+						},
+					})
+					testManifest.ExpectService(ingressProxyService)
+				})
+
+				It("sets type", func() {
+					ingressProxyService.Spec.Type = corev1.ServiceTypeNodePort
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"ingress.enabled=true",
+							"ingressProxy.service.type=NodePort",
+						},
+					})
+					testManifest.ExpectService(ingressProxyService)
+				})
+
+				It("sets loadBalancerIP", func() {
+					ingressProxyService.Spec.LoadBalancerIP = "1.2.3.4"
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"ingress.enabled=true",
+							"ingressProxy.service.loadBalancerIP=1.2.3.4",
+						},
+					})
+					testManifest.ExpectService(ingressProxyService)
+				})
+
+				It("should set route prefix_rewrite in ingress-envoy-config from global.glooStats", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"ingress.enabled=true",
+							"ingressProxy.deployment.stats=true",
+							"global.glooStats.enabled=true",
+							"global.glooStats.routePrefixRewrite=/stats?format=json",
+						},
+					})
+
+					testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ConfigMap"
+					}).ExpectAll(func(configMap *unstructured.Unstructured) {
+						configMapObject, err := kuberesource.ConvertUnstructured(configMap)
+						Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("ConfigMap %+v should be able to convert from unstructured", configMap))
+						structuredConfigMap, ok := configMapObject.(*corev1.ConfigMap)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("ConfigMap %+v should be able to cast to a structured config map", configMap))
+
+						if structuredConfigMap.GetName() == "ingress-envoy-config" {
+							expectedPrefixRewrite := "prefix_rewrite: /stats?format=json"
+							Expect(structuredConfigMap.Data["envoy.yaml"]).To(ContainSubstring(expectedPrefixRewrite))
+						}
+					})
+				})
+			})
+
+			Describe("merge ingress and gateway", func() {
+				// helper for passing a values file
+				prepareMakefileFromValuesFile := func(valuesFile string) {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesFile: valuesFile,
+					})
+				}
+
+				It("merges the config correctly, allow override of ingress without altering gloo", func() {
+					deploymentLabels := map[string]string{
+						"app": "gloo", "gloo": "gloo",
+					}
+					selectors := map[string]string{
+						"gloo": "gloo",
+					}
+					podLabels := map[string]string{
+						"gloo": "gloo",
+					}
+					glooAnnotations := make(map[string]string)
+					for k, v := range statsAnnotations {
+						glooAnnotations[k] = v
+					}
+					glooAnnotations["gloo.solo.io/oss-image-tag"] = version
+					glooDeploymentPostMerge := &appsv1.Deployment{
+						TypeMeta: metav1.TypeMeta{
+							Kind:       "Deployment",
+							APIVersion: "apps/v1",
+						},
+						ObjectMeta: metav1.ObjectMeta{
+							Name:      "gloo",
+							Namespace: "gloo-system",
+							Labels:    deploymentLabels,
+						},
+						Spec: appsv1.DeploymentSpec{
+							Replicas: pointer.Int32Ptr(1),
+							Selector: &metav1.LabelSelector{MatchLabels: selectors},
+							Template: corev1.PodTemplateSpec{
+								ObjectMeta: metav1.ObjectMeta{
+									Labels:      podLabels,
+									Annotations: glooAnnotations,
+								},
+								Spec: corev1.PodSpec{
+									Volumes: []corev1.Volume{
+										{
+											Name: "labels-volume",
+											VolumeSource: corev1.VolumeSource{
+												DownwardAPI: &corev1.DownwardAPIVolumeSource{
+													Items: []corev1.DownwardAPIVolumeFile{{
+														Path: "labels",
+														FieldRef: &corev1.ObjectFieldSelector{
+															FieldPath: "metadata.labels",
+														},
+													}},
+												},
+											},
+										},
+									},
+									ServiceAccountName: "gloo",
+									Containers: []corev1.Container{
+										{
+											VolumeMounts: []corev1.VolumeMount{{
+												Name:      "labels-volume",
+												MountPath: "/etc/gloo",
+												ReadOnly:  true,
+											}},
+											Name: "gloo",
+											// Note: this was NOT overwritten
+											Image: fmt.Sprintf("quay.io/solo-io/gloo:%v", version),
+											Ports: glooPorts,
+											Env: []corev1.EnvVar{
+												{
+													Name: statusutils.PodNamespaceEnvName,
+													ValueFrom: &corev1.EnvVarSource{
+														FieldRef: &corev1.ObjectFieldSelector{APIVersion: "", FieldPath: "metadata.namespace"},
+													},
+												},
+												{
+													Name:  "START_STATS_SERVER",
+													Value: "true",
+												},
+												{
+													Name:  "VALIDATION_MUST_START",
+													Value: "true",
+												},
+											},
+											Resources: corev1.ResourceRequirements{
+												Limits: nil,
+												Requests: corev1.ResourceList{
+													corev1.ResourceMemory: resource.MustParse("256Mi"),
+													corev1.ResourceCPU:    resource.MustParse("500m"),
+												},
+											},
+											ImagePullPolicy: "IfNotPresent",
+											SecurityContext: &corev1.SecurityContext{
+												Capabilities:             &corev1.Capabilities{Add: nil, Drop: []corev1.Capability{"ALL"}},
+												RunAsUser:                pointer.Int64Ptr(10101),
+												RunAsNonRoot:             pointer.BoolPtr(true),
+												ReadOnlyRootFilesystem:   pointer.BoolPtr(true),
+												AllowPrivilegeEscalation: pointer.BoolPtr(false),
+											},
+											ReadinessProbe: &corev1.Probe{
+												ProbeHandler: corev1.ProbeHandler{
+													TCPSocket: &corev1.TCPSocketAction{
+														Port: intstr.FromInt(9977),
+													},
+												},
+												InitialDelaySeconds: 3,
+												PeriodSeconds:       10,
+												FailureThreshold:    3,
+											},
+										},
+									},
+								},
+							},
+						},
+					}
+					ingressDeploymentLabels := map[string]string{
+						"app": "gloo", "gloo": "ingress",
+					}
+					ingressSelector := map[string]string{
+						"gloo": "ingress",
+					}
+					ingressPodLabels := map[string]string{
+						"gloo": "ingress",
+					}
+					ingressDeploymentPostMerge := &appsv1.Deployment{
+						TypeMeta: metav1.TypeMeta{
+							Kind:       "Deployment",
+							APIVersion: "apps/v1",
+						},
+						ObjectMeta: metav1.ObjectMeta{
+							Name:      "ingress",
+							Namespace: "gloo-system",
+							Labels:    ingressDeploymentLabels,
+						},
+						Spec: appsv1.DeploymentSpec{
+							Replicas: pointer.Int32Ptr(1),
+							Selector: &metav1.LabelSelector{MatchLabels: ingressSelector},
+							Template: corev1.PodTemplateSpec{
+								ObjectMeta: metav1.ObjectMeta{
+									Labels: ingressPodLabels,
+								},
+								Spec: corev1.PodSpec{
+									SecurityContext: &corev1.PodSecurityContext{
+										RunAsUser:    pointer.Int64Ptr(10101),
+										RunAsNonRoot: pointer.BoolPtr(true),
+									},
+									Containers: []corev1.Container{
+										{
+											Name: "ingress",
+											// Note: this WAS overwritten
+											Image: "docker.io/ilackarms/ingress:test-ilackarms",
+											Env: []corev1.EnvVar{
+												{
+													Name: statusutils.PodNamespaceEnvName,
+													ValueFrom: &corev1.EnvVarSource{
+														FieldRef: &corev1.ObjectFieldSelector{APIVersion: "", FieldPath: "metadata.namespace"},
+													},
+												},
+												{
+													Name:  "ENABLE_KNATIVE_INGRESS",
+													Value: "true",
+												},
+												{
+													Name:  "KNATIVE_VERSION",
+													Value: "0.8.0",
+												},
+												{
+													Name:  "DISABLE_KUBE_INGRESS",
+													Value: "true",
+												},
+											},
+											Resources: corev1.ResourceRequirements{
+												Limits: nil,
+											},
+											ImagePullPolicy: "Always",
+										},
+									},
+								},
+							},
+						},
+					}
+					prepareMakefileFromValuesFile("merge_ingress_values.yaml")
+					testManifest.ExpectDeploymentAppsV1(glooDeploymentPostMerge)
+					testManifest.ExpectDeploymentAppsV1(ingressDeploymentPostMerge)
+				})
+			})
+
+			Describe("Deployment Privileges Test", func() {
+				// Helper func for testing pod & container root privileges logic
+				expectNonRoot := func(testManifest TestManifest) {
+					deployments := testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "Deployment"
+					})
+
+					Expect(deployments.NumResources()).NotTo(BeZero())
+
+					deployments.ExpectAll(func(resource *unstructured.Unstructured) {
+						rawDeploy, err := resource.MarshalJSON()
+						Expect(err).NotTo(HaveOccurred(), "resource.MarshalJSON error")
+
+						deploy := appsv1.Deployment{}
+						err = json.Unmarshal(rawDeploy, &deploy)
+						Expect(err).NotTo(HaveOccurred(), "json.Unmarshall error")
+						Expect(deploy.Spec.Template).NotTo(BeNil(), "generated spec template is non-nil")
+
+						By(fmt.Sprintf("Validating Deployment %s", deploy.GetName()))
+
+						podLevelSecurity := false
+
+						// Check for root at the pod level
+						if deploy.Spec.Template.Spec.SecurityContext != nil {
+							Expect(deploy.Spec.Template.Spec.SecurityContext.RunAsUser).To(HaveValue(Equal(int64(10101))), "pod level security context should be set to non-root")
+							podLevelSecurity = true
+						}
+
+						// Check for root at the container level
+						for _, container := range deploy.Spec.Template.Spec.Containers {
+							if !podLevelSecurity {
+								Expect(container.SecurityContext).NotTo(BeNil())
+								Expect(container.SecurityContext.RunAsUser).To(HaveValue(Equal(int64(10101))), fmt.Sprintf("If pod level security is not set, container %s need to explicitly not be run as root", container.Name))
+							} else if container.SecurityContext != nil {
+								Expect(container.SecurityContext.RunAsUser).To(HaveValue(Equal(int64(10101))), "If podLevel security is set to non-root, make sure containers don't override it")
+							}
+						}
+					})
+				}
+				Context("Gloo", func() {
+					Context("all cluster-scoped deployments", func() {
+						It("is running all deployments with non root user permissions by default", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{})
+
+							expectNonRoot(testManifest)
+						})
+
+						It("is running all deployments with non root user permissions with knative, accessLogger, ingress, and mTLS enabled", func() {
+							prepareMakefile(namespace, glootestutils.HelmValues{
+								ValuesArgs: []string{
+									"gateway.enabled=false",
+									"settings.integrations.knative.enabled=true",
+									"accessLogger.enabled=true",
+									"ingress.enabled=true",
+									"global.glooMtls.enabled=true",
+								},
+							})
+
+							expectNonRoot(testManifest)
+						})
+					})
+				})
+			})
+
+			Describe("Standard k8s values", func() {
+				DescribeTable("PodSpec affinity, tolerations, nodeName, hostAliases, nodeSelector, priorityClassName, restartPolicy, initContainers, on Deployments and Jobs",
+					func(kind string, resourceName string, value string, extraArgs ...string) {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: append([]string{
+								value + ".nodeSelector.label=someLabel",
+								value + ".nodeName=someNodeName",
+								value + ".tolerations[0].operator=someToleration",
+								value + ".hostAliases[0]=someHostAlias",
+								value + ".affinity.nodeAffinity=someNodeAffinity",
+								value + ".restartPolicy=someRestartPolicy",
+								value + ".priorityClassName=somePriorityClass",
+								value + ".initContainers[0].image=gcr.io/solo-public",
+								value + ".initContainers[0].name=containerName",
+								value + ".initContainers[0].command[0]=sh",
+								value + ".initContainers[0].command[1]=-c",
+							}, extraArgs...),
+						})
+						resources := testManifest.SelectResources(func(u *unstructured.Unstructured) bool {
+							var prefixPath []string
+							if kind == "CronJob" {
+								prefixPath = []string{"spec", "jobTemplate"}
+							}
+							if u.GetKind() == kind && u.GetName() == resourceName {
+								a := getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "nodeSelector")...)
+								Expect(a).To(Equal(map[string]interface{}{"label": "someLabel"}))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "priorityClassName")...)
+								Expect(a).To(Equal("somePriorityClass"))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "nodeName")...)
+								Expect(a).To(Equal("someNodeName"))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "tolerations")...)
+								Expect(a).To(Equal([]interface{}{map[string]interface{}{"operator": "someToleration"}}))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "hostAliases")...)
+								Expect(a).To(Equal([]interface{}{"someHostAlias"}))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "affinity")...)
+								Expect(a).To(Equal(map[string]interface{}{"nodeAffinity": "someNodeAffinity"}))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "restartPolicy")...)
+								Expect(a).To(Equal("someRestartPolicy"))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "template", "spec", "initContainers")...)
+								Expect(a).To(Equal([]interface{}{map[string]interface{}{"image": "gcr.io/solo-public", "name": "containerName", "command": []interface{}{"sh", "-c"}}}))
+								return true
+							}
+							return false
+						})
+						Expect(resources.NumResources()).To(Equal(1))
+					},
+					Entry("gloo deployment", "Deployment", "gloo", "gloo.deployment"),
+					Entry("discovery deployment", "Deployment", "discovery", "discovery.deployment"),
+					Entry("ingress deployment", "Deployment", "ingress", "ingress.deployment", "ingress.enabled=true"),
+					Entry("cluster-ingress deployment", "Deployment", "clusteringress-proxy", "settings.integrations.knative.proxy", "settings.integrations.knative.version=0.7.0", "settings.integrations.knative.enabled=true"),
+					Entry("knative external proxy deployment", "Deployment", "knative-external-proxy", "settings.integrations.knative.proxy", "settings.integrations.knative.version=0.9.0", "settings.integrations.knative.enabled=true"),
+					Entry("knative internal proxy deployment", "Deployment", "knative-internal-proxy", "settings.integrations.knative.proxy", "settings.integrations.knative.version=0.9.0", "settings.integrations.knative.enabled=true"),
+					Entry("gateway certgen job", "Job", "gateway-certgen", "gateway.certGenJob"),
+					Entry("mtls certgen job", "Job", "gloo-mtls-certgen", "gateway.certGenJob", "global.glooMtls.enabled=true"),
+					Entry("mtls certgen cronjob", "CronJob", "gloo-mtls-certgen-cronjob", "gateway.certGenJob", "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("gateway certgen cronjob", "CronJob", "gateway-certgen-cronjob", "gateway.certGenJob", "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("resource rollout job", "Job", "gloo-resource-rollout", "gateway.rolloutJob"),
+					Entry("resource migration job", "Job", "gloo-resource-migration", "gateway.rolloutJob"),
+					Entry("resource cleanup job", "Job", "gloo-resource-cleanup", "gateway.cleanupJob"),
+				)
+
+				const (
+					ACTIVE_DEADLINE_SECONDS    = 123
+					TTL_SECONDS_AFTER_FINISHED = 42
+					BACKOFF_LIMIT              = 10
+					COMPLETIONS                = 5
+					MANUAL_SELECTOR            = true
+					PARALLELISM                = 7
+				)
+				DescribeTable("can set JobSpec fields on Jobs",
+					func(kind string, resourceName string, jobValuesPrefix string, extraArgs ...string) {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: append([]string{
+								jobValuesPrefix + ".activeDeadlineSeconds=" + strconv.Itoa(ACTIVE_DEADLINE_SECONDS),
+								jobValuesPrefix + ".ttlSecondsAfterFinished=" + strconv.Itoa(TTL_SECONDS_AFTER_FINISHED),
+								jobValuesPrefix + ".backoffLimit=" + strconv.Itoa(BACKOFF_LIMIT),
+								jobValuesPrefix + ".completions=" + strconv.Itoa(COMPLETIONS),
+								jobValuesPrefix + ".manualSelector=" + strconv.FormatBool(MANUAL_SELECTOR),
+								jobValuesPrefix + ".parallelism=" + strconv.Itoa(PARALLELISM),
+							}, extraArgs...),
+						})
+						resources := testManifest.SelectResources(func(u *unstructured.Unstructured) bool {
+							var prefixPath []string
+							if kind == "CronJob" {
+								prefixPath = []string{"spec", "jobTemplate"}
+							}
+							if u.GetKind() == kind && u.GetName() == resourceName {
+								a := getFieldFromUnstructured(u, append(prefixPath, "spec", "activeDeadlineSeconds")...)
+								Expect(a).To(Equal(int64(ACTIVE_DEADLINE_SECONDS)))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "ttlSecondsAfterFinished")...)
+								Expect(a).To(Equal(int64(TTL_SECONDS_AFTER_FINISHED)))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "backoffLimit")...)
+								Expect(a).To(Equal(int64(BACKOFF_LIMIT)))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "completions")...)
+								Expect(a).To(Equal(int64(COMPLETIONS)))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "parallelism")...)
+								Expect(a).To(Equal(int64(PARALLELISM)))
+								a = getFieldFromUnstructured(u, append(prefixPath, "spec", "manualSelector")...)
+								Expect(a).To(Equal(MANUAL_SELECTOR))
+								return true
+							}
+							return false
+						})
+						Expect(resources.NumResources()).To(Equal(1))
+					},
+					Entry("gateway certgen job", "Job", "gateway-certgen", "gateway.certGenJob"),
+					Entry("mtls certgen job", "Job", "gloo-mtls-certgen", "gateway.certGenJob", "global.glooMtls.enabled=true"),
+					Entry("mtls certgen cronjob", "CronJob", "gloo-mtls-certgen-cronjob", "gateway.certGenJob", "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("gateway certgen cronjob", "CronJob", "gateway-certgen-cronjob", "gateway.certGenJob", "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("resource rollout job", "Job", "gloo-resource-rollout", "gateway.rolloutJob"),
+					Entry("resource migration job", "Job", "gloo-resource-migration", "gateway.rolloutJob"),
+					Entry("resource cleanup job", "Job", "gloo-resource-cleanup", "gateway.cleanupJob"),
+				)
+
+				DescribeTable("setTtlAfterFinished=false suppresses ttlSecondsAfterFinished on Jobs",
+					func(kind string, resourceName string, jobValuesPrefix string, extraArgs ...string) {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: append([]string{
+								jobValuesPrefix + ".setTtlAfterFinished=false",
+								jobValuesPrefix + ".ttlSecondsAfterFinished=" + strconv.Itoa(TTL_SECONDS_AFTER_FINISHED),
+							}, extraArgs...),
+						})
+						resources := testManifest.SelectResources(func(u *unstructured.Unstructured) bool {
+							var prefixPath []string
+							if kind == "CronJob" {
+								prefixPath = []string{"spec", "jobTemplate"}
+							}
+							if u.GetKind() == kind && u.GetName() == resourceName {
+								a := getFieldFromUnstructured(u, append(prefixPath, "spec", "ttlSecondsAfterFinished")...)
+								Expect(a).To(BeNil())
+								if kind == "Job" {
+									helmHookDeletePolicy, ok := u.GetAnnotations()["helm.sh/hook-delete-policy"]
+									Expect(ok).To(BeTrue())
+									Expect(helmHookDeletePolicy).To(ContainSubstring("hook-succeeded"))
+								}
+								return true
+							}
+							return false
+						})
+						Expect(resources.NumResources()).To(Equal(1))
+					},
+					Entry("gateway certgen job", "Job", "gateway-certgen", "gateway.certGenJob"),
+					Entry("mtls certgen job", "Job", "gloo-mtls-certgen", "gateway.certGenJob", "global.glooMtls.enabled=true"),
+					Entry("mtls certgen cronjob", "CronJob", "gloo-mtls-certgen-cronjob", "gateway.certGenJob", "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("gateway certgen cronjob", "CronJob", "gateway-certgen-cronjob", "gateway.certGenJob", "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+				)
+
+				DescribeTable("Setting setTtlAfterFinished=true includes ttlSecondsAfterFinished on Jobs",
+					func(kind string, resourceName string, jobValuesPrefix string, expectAnnotation bool, extraArgs ...string) {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: append([]string{
+								jobValuesPrefix + ".setTtlAfterFinished=true",
+								jobValuesPrefix + ".ttlSecondsAfterFinished=" + strconv.Itoa(TTL_SECONDS_AFTER_FINISHED),
+							}, extraArgs...),
+						})
+						resources := testManifest.SelectResources(func(u *unstructured.Unstructured) bool {
+							var prefixPath []string
+							if kind == "CronJob" {
+								prefixPath = []string{"spec", "jobTemplate"}
+							}
+							if u.GetKind() == kind && u.GetName() == resourceName {
+								a := getFieldFromUnstructured(u, append(prefixPath, "spec", "ttlSecondsAfterFinished")...)
+								Expect(a).To(Equal(int64(TTL_SECONDS_AFTER_FINISHED)))
+								if kind == "Job" {
+									helmHookDeletePolicy, ok := u.GetAnnotations()["helm.sh/hook-delete-policy"]
+									if expectAnnotation {
+										Expect(ok).To(BeTrue())
+										Expect(helmHookDeletePolicy).NotTo(ContainSubstring("hook-succeeded"))
+									} else {
+										Expect(ok).To(BeFalse())
+									}
+								}
+								return true
+							}
+							return false
+						})
+						Expect(resources.NumResources()).To(Equal(1))
+					},
+					Entry("gateway certgen job", "Job", "gateway-certgen", "gateway.certGenJob", true),
+					Entry("mtls certgen job", "Job", "gloo-mtls-certgen", "gateway.certGenJob", false, "global.glooMtls.enabled=true"),
+					Entry("mtls certgen cronjob", "CronJob", "gloo-mtls-certgen-cronjob", "gateway.certGenJob", false, "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+				)
+
+				DescribeTable("When setTtlAfterFinished is unset, includes ttlSecondsAfterFinished on Jobs",
+					func(kind string, resourceName string, jobValuesPrefix string, expectAnnotation bool, extraArgs ...string) {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: append([]string{
+								jobValuesPrefix + ".ttlSecondsAfterFinished=" + strconv.Itoa(TTL_SECONDS_AFTER_FINISHED),
+							}, extraArgs...),
+						})
+						resources := testManifest.SelectResources(func(u *unstructured.Unstructured) bool {
+							var prefixPath []string
+							if kind == "CronJob" {
+								prefixPath = []string{"spec", "jobTemplate"}
+							}
+							if u.GetKind() == kind && u.GetName() == resourceName {
+								a := getFieldFromUnstructured(u, append(prefixPath, "spec", "ttlSecondsAfterFinished")...)
+								Expect(a).To(Equal(int64(TTL_SECONDS_AFTER_FINISHED)))
+								if kind == "Job" {
+									helmHookDeletePolicy, ok := u.GetAnnotations()["helm.sh/hook-delete-policy"]
+									if expectAnnotation {
+										Expect(ok).To(BeTrue())
+										Expect(helmHookDeletePolicy).NotTo(ContainSubstring("hook-succeeded"))
+									} else if resourceName == "gloo-mtls-certgen" {
+										Expect(ok).To(BeFalse())
+									}
+								}
+								return true
+							}
+							return false
+						})
+						Expect(resources.NumResources()).To(Equal(1))
+					},
+					Entry("gateway certgen job", "Job", "gateway-certgen", "gateway.certGenJob", true),
+					Entry("mtls certgen job", "Job", "gloo-mtls-certgen", "gateway.certGenJob", false, "global.glooMtls.enabled=true"),
+					Entry("mtls certgen cronjob", "CronJob", "gloo-mtls-certgen-cronjob", "gateway.certGenJob", false, "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("gateway certgen cronjob", "CronJob", "gateway-certgen-cronjob", "gateway.certGenJob", false, "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+				)
+
+				DescribeTable("by default, activeDeadlineSeconds is unset on Jobs",
+					func(kind string, resourceName string, extraArgs ...string) {
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: append([]string{}, extraArgs...),
+						})
+						resources := testManifest.SelectResources(func(u *unstructured.Unstructured) bool {
+							var prefixPath []string
+							if kind == "CronJob" {
+								prefixPath = []string{"spec", "jobTemplate"}
+							}
+							if u.GetKind() == kind && u.GetName() == resourceName {
+								a := getFieldFromUnstructured(u, append(prefixPath, "spec", "activeDeadlineSeconds")...)
+								Expect(a).To(BeNil())
+								return true
+							}
+							return false
+						})
+						Expect(resources.NumResources()).To(Equal(1))
+					},
+					Entry("gateway certgen job", "Job", "gateway-certgen"),
+					Entry("mtls certgen job", "Job", "gloo-mtls-certgen", "global.glooMtls.enabled=true"),
+					Entry("mtls certgen cronjob", "CronJob", "gloo-mtls-certgen-cronjob", "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("gateway certgen cronjob", "CronJob", "gateway-certgen-cronjob", "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("resource rollout job", "Job", "gloo-resource-rollout"),
+					Entry("resource migration job", "Job", "gloo-resource-migration"),
+					Entry("resource cleanup job", "Job", "gloo-resource-cleanup"),
+				)
+
+				DescribeTable("overrides resources for container security contexts", func(resourceName string, containerName string, resourceType string, securityRoot string, extraArgs ...string) {
+					// Split the securityContext fields into two groups so each one gets tested as in and not in the values file
+					helmValuesA := securityContextFieldsStripeGroupA(securityRoot, extraArgs...)
+
+					// 2nd group of fields to test. Switch up the default 'no-merge' to the explict version
+					extraArgs = append([]string{
+						securityRoot + ".mergePolicy=no-merge",
+					}, extraArgs...)
+					helmValuesB := securityContextFieldsStripeGroupB(securityRoot, extraArgs...)
+
+					// First Group of fields to test
+					prepareMakefile(namespace, helmValuesA)
+
+					container := getContainer(testManifest, resourceType, resourceName, containerName)
+					Expect(container.SecurityContext).To(Equal(
+						&corev1.SecurityContext{
+							RunAsUser:                pointer.Int64(int64(1234)),
+							AllowPrivilegeEscalation: pointer.Bool(true),
+							ReadOnlyRootFilesystem:   pointer.Bool(true),
+							RunAsNonRoot:             pointer.Bool(true),
+							SELinuxOptions: &corev1.SELinuxOptions{
+								Level: "seLevel",
+								Role:  "seRole",
+								Type:  "seType",
+								User:  "seUser",
+							},
+						},
+					))
+
+					prepareMakefile(namespace, helmValuesB)
+
+					container = getContainer(testManifest, resourceType, resourceName, containerName)
+					Expect(container.SecurityContext).To(Equal(
+						&corev1.SecurityContext{
+							Capabilities: &corev1.Capabilities{
+								Add:  []corev1.Capability{"ADD"},
+								Drop: []corev1.Capability{"DROP"},
+							},
+							SeccompProfile: &corev1.SeccompProfile{
+								LocalhostProfile: pointer.String("seccompLHP"),
+								Type:             "seccompType",
+							},
+							WindowsOptions: &corev1.WindowsSecurityContextOptions{
+								GMSACredentialSpecName: pointer.String("winGmsaCredSpecName"),
+								GMSACredentialSpec:     pointer.String("winGmsaCredSpec"),
+								RunAsUserName:          pointer.String("winUser"),
+								HostProcess:            pointer.Bool(true),
+							},
+						},
+					))
+				},
+					Entry("7-gateway-proxy-deployment-gateway-proxy", "gateway-proxy", "gateway-proxy", "Deployment", "gatewayProxies.gatewayProxy.podTemplate.glooContainerSecurityContext"),
+					Entry("7-gateway-proxy-deployment-sds", "gateway-proxy", "sds", "Deployment", "global.glooMtls.sds.securityContext", "global.glooMtls.enabled=true"),
+					Entry("7-gateway-proxy-deployment-istio-proxy", "gateway-proxy", "istio-proxy", "Deployment", "global.glooMtls.istioProxy.securityContext", "global.istioIntegration.enabled=true"),
+					Entry("1-gloo-deployment-gloo", "gloo", "gloo", "Deployment", "gloo.deployment.glooContainerSecurityContext", "global.glooMtls.enabled=true"),
+					Entry("1-gloo-deployment-envoy-sidecar", "gloo", "envoy-sidecar", "Deployment", "global.glooMtls.envoy.securityContext", "global.glooMtls.enabled=true"),
+					Entry("1-gloo-deployment-sds", "gloo", "sds", "Deployment", "global.glooMtls.sds.securityContext", "global.glooMtls.enabled=true"),
+					Entry("19-gloo-mtls-certgen-job.yaml", "gloo-mtls-certgen", "certgen", "Job", "gateway.certGenJob.containerSecurityContext", "global.glooMtls.enabled=true"),
+					Entry("3-discovery-deployment.yaml", "discovery", "discovery", "Deployment", "discovery.deployment.discoveryContainerSecurityContext"),
+					Entry("5-resource-cleanup-job.yaml", "gloo-resource-cleanup", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-migration-job.yaml", "gloo-resource-migration", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-rollout-check-job.yaml", "gloo-resource-rollout-check", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-rollout-cleanup-job.yaml", "gloo-resource-rollout-cleanup", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-rollout-job.yaml", "gloo-resource-rollout", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("6.5-gateway-certgen-job.yaml", "gateway-certgen", "certgen", "Job", "gateway.certGenJob.containerSecurityContext"),
+					Entry("6.5-gateway-certgen-cronjob.yaml", "gateway-certgen-cronjob", "certgen", "CronJob", "gateway.certGenJob.containerSecurityContext", "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("6-access-logger-deployment.yaml", "gateway-proxy-access-logger", "access-logger", "Deployment", "accessLogger.accessLoggerContainerSecurityContext", "accessLogger.enabled=true"),
+					Entry("10-ingress-deployment.yaml", "ingress", "ingress", "Deployment", "ingress.deployment.ingressContainerSecurityContext", "ingress.enabled=true"),
+					Entry("11-ingress-proxy-deployment.yaml", "ingress-proxy", "ingress-proxy", "Deployment", "ingressProxy.deployment.ingressProxyContainerSecurityContext", "ingress.enabled=true"),
+					Entry("14-clusteringress-proxy-deployment.yaml", "clusteringress-proxy", "clusteringress-proxy", "Deployment", "settings.integrations.knative.proxy.containerSecurityContext", "settings.integrations.knative.version=0.1.0", "settings.integrations.knative.enabled=true"),
+					Entry("26-knative-external-proxy-deployment.yaml", "knative-external-proxy", "knative-external-proxy", "Deployment", "settings.integrations.knative.proxy.containerSecurityContext", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("29-knative-internal-proxy-deployment.yaml", "knative-internal-proxy", "knative-internal-proxy", "Deployment", "settings.integrations.knative.proxy.containerSecurityContext", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("19-gloo-mtls-certgen-cronjob.yaml", "gloo-mtls-certgen-cronjob", "certgen", "CronJob", "gateway.certGenJob.containerSecurityContext", "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+				)
+
+				DescribeTable("merges resources for container security contexts", func(resourceName string, containerName string, resourceType string, securityRoot string, extraArgs ...string) {
+					// First helm template generates the baseline
+					// Run once "plain" to get the baseline as generated with no helm values passed
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: extraArgs,
+					})
+
+					// Strip out the revelant security context
+					container := getContainer(testManifest, resourceType, resourceName, containerName)
+					initialSecurityContext := container.SecurityContext
+					if initialSecurityContext == nil {
+						initialSecurityContext = &corev1.SecurityContext{}
+					}
+					// Make a copy so we can restore it later
+					var initialSecurityContextClean *corev1.SecurityContext
+					deepCopy(&initialSecurityContext, &initialSecurityContextClean)
+
+					// add "mergePolicy" to the security context
+					extraArgs = append([]string{
+						securityRoot + ".mergePolicy=helm-merge",
+					}, extraArgs...)
+
+					// Split the securityContext fields into two groups so each one gets tested as in and not in the values file
+					helmValuesA := securityContextFieldsStripeGroupA(securityRoot, extraArgs...)
+					helmValuesB := securityContextFieldsStripeGroupB(securityRoot, extraArgs...)
+
+					//
+					// Run again with security context A helm values applied
+					prepareMakefile(namespace, helmValuesA)
+					container = getContainer(testManifest, resourceType, resourceName, containerName)
+
+					// Test that all the values are set
+					Expect(container.SecurityContext.RunAsNonRoot).To(Equal(pointer.Bool(true)))
+					initialSecurityContext.RunAsNonRoot = pointer.Bool(true)
+					Expect(container.SecurityContext.RunAsUser).To(Equal(pointer.Int64(int64(1234))))
+					initialSecurityContext.RunAsUser = pointer.Int64(int64(1234))
+					Expect(container.SecurityContext.AllowPrivilegeEscalation).To(Equal(pointer.Bool(true)))
+					initialSecurityContext.AllowPrivilegeEscalation = pointer.Bool(true)
+					Expect(container.SecurityContext.ReadOnlyRootFilesystem).To(Equal(pointer.Bool(true)))
+					initialSecurityContext.ReadOnlyRootFilesystem = pointer.Bool(true)
+					expectedSELinuxOptions := &corev1.SELinuxOptions{
+						Level: "seLevel",
+						Role:  "seRole",
+						Type:  "seType",
+						User:  "seUser",
+					}
+					Expect(container.SecurityContext.SELinuxOptions).To(Equal(expectedSELinuxOptions))
+					initialSecurityContext.SELinuxOptions = expectedSELinuxOptions
+
+					// We've test/updated all the fields we passed, so now we can compare the whole thing
+					Expect(container.SecurityContext).To(Equal(initialSecurityContext))
+
+					//
+					// Run again with security context B
+					prepareMakefile(namespace, helmValuesB)
+					initialSecurityContext = &corev1.SecurityContext{}
+					deepCopy(&initialSecurityContextClean, &initialSecurityContext)
+					container = getContainer(testManifest, resourceType, resourceName, containerName)
+
+					// Test that all the values are set
+					expectedCapabilities := &corev1.Capabilities{
+						Add:  []corev1.Capability{"ADD"},
+						Drop: []corev1.Capability{"DROP"},
+					}
+					Expect(container.SecurityContext.Capabilities).To(Equal(expectedCapabilities))
+					initialSecurityContext.Capabilities = expectedCapabilities
+					expectedSeccompProfile := &corev1.SeccompProfile{
+						LocalhostProfile: pointer.String("seccompLHP"),
+						Type:             "seccompType",
+					}
+					Expect(container.SecurityContext.SeccompProfile).To(Equal(expectedSeccompProfile))
+					initialSecurityContext.SeccompProfile = expectedSeccompProfile
+					expectedWindowsOptions := &corev1.WindowsSecurityContextOptions{
+						GMSACredentialSpecName: pointer.String("winGmsaCredSpecName"),
+						GMSACredentialSpec:     pointer.String("winGmsaCredSpec"),
+						RunAsUserName:          pointer.String("winUser"),
+						HostProcess:            pointer.Bool(true),
+					}
+					Expect(container.SecurityContext.WindowsOptions).To(Equal(expectedWindowsOptions))
+					initialSecurityContext.WindowsOptions = expectedWindowsOptions
+
+					Expect(container.SecurityContext).To(Equal(initialSecurityContext))
+				},
+					Entry("7-gateway-proxy-deployment-gateway-proxy", "gateway-proxy", "gateway-proxy", "Deployment", "gatewayProxies.gatewayProxy.podTemplate.glooContainerSecurityContext"),
+					Entry("7-gateway-proxy-deployment-sds", "gateway-proxy", "sds", "Deployment", "global.glooMtls.sds.securityContext", "global.glooMtls.enabled=true"),
+					Entry("7-gateway-proxy-deployment-istio-proxy", "gateway-proxy", "istio-proxy", "Deployment", "global.glooMtls.istioProxy.securityContext", "global.istioIntegration.enabled=true"),
+					Entry("1-gloo-deployment-gloo", "gloo", "gloo", "Deployment", "gloo.deployment.glooContainerSecurityContext", "global.glooMtls.enabled=true"),
+					Entry("1-gloo-deployment-envoy-sidecar", "gloo", "envoy-sidecar", "Deployment", "global.glooMtls.envoy.securityContext", "global.glooMtls.enabled=true"),
+					Entry("1-gloo-deployment-sds", "gloo", "sds", "Deployment", "global.glooMtls.sds.securityContext", "global.glooMtls.enabled=true"),
+					Entry("19-gloo-mtls-certgen-job.yaml", "gloo-mtls-certgen", "certgen", "Job", "gateway.certGenJob.containerSecurityContext", "global.glooMtls.enabled=true"),
+					Entry("3-discovery-deployment.yaml", "discovery", "discovery", "Deployment", "discovery.deployment.discoveryContainerSecurityContext"),
+					Entry("5-resource-cleanup-job.yaml", "gloo-resource-cleanup", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-migration-job.yaml", "gloo-resource-migration", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-rollout-check-job.yaml", "gloo-resource-rollout-check", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-rollout-cleanup-job.yaml", "gloo-resource-rollout-cleanup", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("5-resource-rollout-job.yaml", "gloo-resource-rollout", "kubectl", "Job", "gateway.rolloutJob.containerSecurityContext"),
+					Entry("6.5-gateway-certgen-job.yaml", "gateway-certgen", "certgen", "Job", "gateway.certGenJob.containerSecurityContext"),
+					Entry("6.5-gateway-certgen-cronjob.yaml", "gateway-certgen-cronjob", "certgen", "CronJob", "gateway.certGenJob.containerSecurityContext", "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("6-access-logger-deployment.yaml", "gateway-proxy-access-logger", "access-logger", "Deployment", "accessLogger.accessLoggerContainerSecurityContext", "accessLogger.enabled=true"),
+					Entry("10-ingress-deployment.yaml", "ingress", "ingress", "Deployment", "ingress.deployment.ingressContainerSecurityContext", "ingress.enabled=true"),
+					Entry("11-ingress-proxy-deployment.yaml", "ingress-proxy", "ingress-proxy", "Deployment", "ingressProxy.deployment.ingressProxyContainerSecurityContext", "ingress.enabled=true"),
+					Entry("14-clusteringress-proxy-deployment.yaml", "clusteringress-proxy", "clusteringress-proxy", "Deployment", "settings.integrations.knative.proxy.containerSecurityContext", "settings.integrations.knative.version=0.1.0", "settings.integrations.knative.enabled=true"),
+					Entry("26-knative-external-proxy-deployment.yaml", "knative-external-proxy", "knative-external-proxy", "Deployment", "settings.integrations.knative.proxy.containerSecurityContext", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("29-knative-internal-proxy-deployment.yaml", "knative-internal-proxy", "knative-internal-proxy", "Deployment", "settings.integrations.knative.proxy.containerSecurityContext", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("19-gloo-mtls-certgen-cronjob.yaml", "gloo-mtls-certgen-cronjob", "certgen", "CronJob", "gateway.certGenJob.containerSecurityContext", "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+				)
+
+				It("applies global security settings to containers", func() {
+					helmArgs := append(
+						helmRenderEverythingValues(),
+						"global.securitySettings.floatingUserId=true",
+					)
+
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: helmArgs,
+					})
+
+					securitycontext.ValidateSecurityContexts(
+						testManifest,
+						func(container corev1.Container, resourceName string) {
+							// If securityContext is nil, then it means runAsUser has not been set
+							if container.SecurityContext != nil {
+								Expect(container.SecurityContext.RunAsUser).To(BeNil(), "resource: %s, container: %s", resourceName, container.Name)
+							}
+						},
+						Equal(securitycontext.ExpectedContainers),
+					)
+				})
+
+				It("global security setings override container-specific values", func() {
+					helmArgs := append(
+						helmRenderEverythingValues(),
+						"global.securitySettings.floatingUserId=true",
+					)
+
+					for _, securityRoot := range securitycontext.ContainerSecurityContextRoots {
+						helmArgs = append(helmArgs, securityRoot+".runAsUser=1234")
+					}
+
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: helmArgs,
+					})
+
+					securitycontext.ValidateSecurityContexts(
+						testManifest,
+						func(container corev1.Container, resourceName string) {
+							// If securityContext is nil, then it means runAsUser has not been set
+							if container.SecurityContext != nil {
+								Expect(container.SecurityContext.RunAsUser).To(BeNil(), "resource: %s, container: %s", resourceName, container.Name)
+							}
+						},
+						Equal(securitycontext.ExpectedContainers),
+					)
+				})
+
+				// Most of the containers are covered in the test above which loops over the entire deployment, but we can't
+				// render all possible charts at the same time because some templates render when
+				// .Values.settings.integrations.knative.version >= 0.8.0 and others render when < 0.8.0
+				DescribeTable("(applies global security setings (one-offs)", func(resourceName string, containerName string, resourceType string, applyDefaults securitycontext.ApplyContainerSecurityDefaults, extraArgs ...string) {
+					helmArgs := append(
+						extraArgs,
+						"global.securitySettings.floatingUserId=true",
+					)
+
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: helmArgs,
+					})
+
+					container := getContainer(testManifest, resourceType, resourceName, containerName)
+					// If securityContext is nil, then it means runAsUser has not been set
+					if container.SecurityContext != nil {
+						Expect(container.SecurityContext.RunAsUser).To(BeNil(), "resource: %s, container: %s", resourceName, container.Name)
+					}
+				},
+					Entry("14-clusteringress-proxy-deployment.yaml", "clusteringress-proxy", "clusteringress-proxy", "Deployment", securitycontext.ApplyClusterIngressSecurityDefaults, "settings.integrations.knative.version=0.1.0", "settings.integrations.knative.enabled=true"),
+				)
+
+				DescribeTable("applies global security setings for pod security contexts", func(resourceName string, securityRoot string, expectContextOmitted bool, extraArgs ...string) {
+					// "expectContextOmitted" argument indicates that in this test, the global `floatingUserId=true` is expected to also act like the local `enableSecurityConext=false`
+					fsGroup := int64(4321)
+					helmArgs := append(
+						extraArgs,
+						"global.securitySettings.floatingUserId=true",
+						securityRoot+".runAsUser=1234",
+						fmt.Sprintf("%s.fsGroup=%d", securityRoot, fsGroup),
+					)
+
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: helmArgs,
+					})
+
+					structuredDeployment := getStructuredDeployment(testManifest, resourceName)
+					securityContext := structuredDeployment.Spec.Template.Spec.SecurityContext
+
+					if expectContextOmitted {
+						Expect(securityContext).To(BeNil(), "resource: %s", resourceName)
+					} else {
+						Expect(securityContext.RunAsUser).To(BeNil(), "resource: %s", resourceName)
+						Expect(*securityContext.FSGroup).To(Equal(fsGroup), "resource: %s", resourceName)
+					}
+				},
+					Entry("1-gloo-deployment", "gloo", "gloo.deployment.podSecurityContext", false),
+					Entry("3-discovery-deployment", "discovery", "discovery.deployment", true, "discovery.deployment.enablePodSecurityContext=true"),
+					Entry("7-gateway-proxy-deployment", "gateway-proxy", "gatewayProxies.gatewayProxy.podTemplate.podSecurityContext", true, "gatewayProxies.gatewayProxy.podTemplate.enablePodSecurityContext=true"),
+				)
+
+				DescribeTable("applies default restricted container security contexts", func(seccompType string) {
+					helmArgs := append(
+						helmRenderEverythingValues(),
+						"global.podSecurityStandards.container.enableRestrictedContainerDefaults=true",
+					)
+
+					if seccompType != "" {
+						helmArgs = append([]string{
+							"global.podSecurityStandards.container.defaultSeccompProfileType=" + seccompType,
+						}, helmArgs...)
+					}
+
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: helmArgs,
+					})
+
+					securitycontext.ValidateSecurityContexts(
+						testManifest,
+						func(container corev1.Container, resourceName string) {
+							// Uncomment this to print the enumerated list of containers
+							// fmt.Printf("%s, %s, %s\n", resource.GetKind(), resource.GetName(), container.Name)
+							updateDefaults := securitycontext.ApplyNilSecurityDefaults
+							updatePodDefaults, ok := securitycontext.DefaultOverrides[resourceName]
+							if ok {
+								updateContainerDefaults, ok2 := updatePodDefaults[container.Name]
+								if ok2 {
+									updateDefaults = updateContainerDefaults
+								}
+							}
+
+							expectedDefaults := securitycontext.GetDefaultRestrictedContainerSecurityContext(seccompType, updateDefaults)
+							securityContext := container.SecurityContext
+							Expect(securityContext).To(Equal(expectedDefaults), "resource: %s, container: %s, seccompTypeValue: %s", resourceName, container.Name, seccompType)
+						},
+						Equal(securitycontext.ExpectedContainers),
+					)
+				},
+					Entry("null/default", ""),
+					Entry("RuntimeDefault", "RuntimeDefault"),
+					Entry("Localhost", "Localhost"),
+				)
+
+				// Most of the containers are covered in the test above which loops over the entire deployment, but we can't
+				// render all possible charts at the same time because some templates render when
+				// .Values.settings.integrations.knative.version >= 0.8.0 and others render when < 0.8.0
+				DescribeTable("(applies default restricted container security contexts (one-offs)", func(resourceName string, containerName string, resourceType string, applyDefaults securitycontext.ApplyContainerSecurityDefaults, extraArgs ...string) {
+					for _, seccompTypeValue := range []string{"RuntimeDefault", "Localhost", ""} {
+						helmArgs := extraArgs
+						if seccompTypeValue != "" {
+							helmArgs = append([]string{
+								"global.podSecurityStandards.container.defaultSeccompProfileType=" + seccompTypeValue,
+							}, helmArgs...)
+						}
+						expectedDefaults := securitycontext.GetDefaultRestrictedContainerSecurityContext(seccompTypeValue, applyDefaults)
+
+						helmArgs = append([]string{
+							"global.podSecurityStandards.container.enableRestrictedContainerDefaults=true",
+						}, helmArgs...)
+
+						prepareMakefile(namespace, glootestutils.HelmValues{
+							ValuesArgs: helmArgs,
+						})
+
+						container := getContainer(testManifest, resourceType, resourceName, containerName)
+						securityContext := container.SecurityContext
+						Expect(securityContext).To(Equal(expectedDefaults), "seccompTypeValue: %s", seccompTypeValue)
+					}
+				},
+					Entry("14-clusteringress-proxy-deployment.yaml", "clusteringress-proxy", "clusteringress-proxy", "Deployment", securitycontext.ApplyClusterIngressSecurityDefaults, "settings.integrations.knative.version=0.1.0", "settings.integrations.knative.enabled=true"),
+				)
+
+				DescribeTable("overrides resources for pod security contexts", func(resourceName string, securityRoot string, extraArgs ...string) {
+					helmValuesA := podSecurityContextFieldsStripeGroupA(securityRoot, extraArgs...)
+
+					// 2nd group of fields to test. Switch up the default 'no-merge' to the explict version
+					extraArgs = append([]string{
+						securityRoot + ".mergePolicy=no-merge",
+					}, extraArgs...)
+					helmValuesB := podSecurityContextFieldsStripeGroupB(securityRoot, extraArgs...)
+
+					prepareMakefile(namespace, helmValuesA)
+					structuredDeployment := getStructuredDeployment(testManifest, resourceName)
+
+					fsGroupChangePolicy := corev1.PodFSGroupChangePolicy("fsGroupChangePolicyValue")
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext).To(Equal(
+						&corev1.PodSecurityContext{
+							FSGroup:             pointer.Int64(int64(101010)),
+							FSGroupChangePolicy: &fsGroupChangePolicy,
+							RunAsGroup:          pointer.Int64(int64(202020)),
+							RunAsNonRoot:        pointer.Bool(true),
+							RunAsUser:           pointer.Int64(int64(303030)),
+							SupplementalGroups:  []int64{int64(11), int64(22), int64(33)},
+							SELinuxOptions: &corev1.SELinuxOptions{
+								Level: "seLevel",
+								Role:  "seRole",
+								Type:  "seType",
+								User:  "seUser",
+							},
+						},
+					))
+
+					prepareMakefile(namespace, helmValuesB)
+					structuredDeployment = getStructuredDeployment(testManifest, resourceName)
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext).To(Equal(
+						&corev1.PodSecurityContext{
+							SeccompProfile: &corev1.SeccompProfile{
+								LocalhostProfile: pointer.String("seccompLHP"),
+								Type:             "seccompType",
+							},
+							WindowsOptions: &corev1.WindowsSecurityContextOptions{
+								GMSACredentialSpecName: pointer.String("winGmsaCredSpecName"),
+								GMSACredentialSpec:     pointer.String("winGmsaCredSpec"),
+								RunAsUserName:          pointer.String("winUser"),
+								HostProcess:            pointer.Bool(true),
+							},
+							Sysctls: []corev1.Sysctl{
+								{
+									Name:  "sysctlName",
+									Value: "sysctlValue",
+								},
+							},
+						},
+					))
+				},
+					Entry("1-gloo-deployment", "gloo", "gloo.deployment.podSecurityContext"),
+					// "3-discovery-deployment" uses the template but is excluded from this test because it does not have a configurable podSecurityContext
+					Entry("7-gateway-proxy-deployment", "gateway-proxy", "gatewayProxies.gatewayProxy.podTemplate.podSecurityContext", "gatewayProxies.gatewayProxy.podTemplate.enablePodSecurityContext=true"),
+				)
+
+				DescribeTable("merges resources for pod security contexts", func(resourceName string, securityRoot string, extraArgs ...string) {
+					// First run with no extra helm security context values
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: extraArgs,
+					})
+
+					structuredDeployment := getStructuredDeployment(testManifest, resourceName)
+
+					initialSecurityContext := structuredDeployment.Spec.Template.Spec.SecurityContext
+					if initialSecurityContext == nil {
+						initialSecurityContext = &corev1.PodSecurityContext{}
+					}
+
+					var initialSecurityContextClean *corev1.PodSecurityContext
+					deepCopy(&initialSecurityContext, &initialSecurityContextClean)
+
+					extraArgs = append([]string{
+						securityRoot + ".mergePolicy=helm-merge",
+					}, extraArgs...)
+
+					fsGroupChangePolicy := corev1.PodFSGroupChangePolicy("fsGroupChangePolicyValue")
+					// Test every field, so split it up so each is set in one test and not in the other
+					helmValuesA := podSecurityContextFieldsStripeGroupA(securityRoot, extraArgs...)
+					helmValuesB := podSecurityContextFieldsStripeGroupB(securityRoot, extraArgs...)
+
+					//
+					// Stripe group A
+					//
+					prepareMakefile(namespace, helmValuesA)
+					structuredDeployment = getStructuredDeployment(testManifest, resourceName)
+					// Find the relevant resource and test that its values were updated
+					// Apply the new values to the initial security context and compare. They should be the same
+
+					// Check the fields individually:
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.FSGroup).To(Equal(pointer.Int64(int64(101010))))
+					initialSecurityContext.FSGroup = pointer.Int64(int64(101010))
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.FSGroupChangePolicy).To(Equal(&fsGroupChangePolicy))
+					initialSecurityContext.FSGroupChangePolicy = &fsGroupChangePolicy
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.RunAsGroup).To(Equal(pointer.Int64(int64(202020))))
+					initialSecurityContext.RunAsGroup = pointer.Int64(int64(202020))
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.RunAsNonRoot).To(Equal(pointer.Bool(true)))
+					initialSecurityContext.RunAsNonRoot = pointer.Bool(true)
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.RunAsUser).To(Equal(pointer.Int64(int64(303030))))
+					initialSecurityContext.RunAsUser = pointer.Int64(int64(303030))
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.SupplementalGroups).To(Equal(
+						[]int64{11, 22, 33}))
+					initialSecurityContext.SupplementalGroups = []int64{11, 22, 33}
+
+					expectedSELinuxOptions := &corev1.SELinuxOptions{
+						Level: "seLevel",
+						Role:  "seRole",
+						Type:  "seType",
+						User:  "seUser",
+					}
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.SELinuxOptions).To(Equal(expectedSELinuxOptions))
+					initialSecurityContext.SELinuxOptions = expectedSELinuxOptions
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext).To(Equal(initialSecurityContext))
+
+					//
+					// Stripe Group B
+					//
+					initialSecurityContext = &corev1.PodSecurityContext{}
+					deepCopy(&initialSecurityContextClean, &initialSecurityContext)
+					prepareMakefile(namespace, helmValuesB)
+
+					// Find the relevant resource and test that its values were updated
+					// Apply the new values to the initial security context and compare. They should be the same
+					structuredDeployment = getStructuredDeployment(testManifest, resourceName)
+
+					// Check the fields individually:
+					expectedSeccompProfile := &corev1.SeccompProfile{
+						LocalhostProfile: pointer.String("seccompLHP"),
+						Type:             "seccompType",
+					}
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.SeccompProfile).To(Equal(expectedSeccompProfile))
+					initialSecurityContext.SeccompProfile = expectedSeccompProfile
+
+					expectedWindowsOptions := &corev1.WindowsSecurityContextOptions{
+						GMSACredentialSpec:     pointer.String("winGmsaCredSpec"),
+						GMSACredentialSpecName: pointer.String("winGmsaCredSpecName"),
+						HostProcess:            pointer.Bool(true),
+						RunAsUserName:          pointer.String("winUser"),
+					}
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.WindowsOptions).To(Equal(expectedWindowsOptions))
+					initialSecurityContext.WindowsOptions = expectedWindowsOptions
+
+					expectedSysctls := []corev1.Sysctl{
+						{
+							Name:  "sysctlName",
+							Value: "sysctlValue",
+						},
+					}
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.Sysctls).To(Equal(expectedSysctls))
+					initialSecurityContext.Sysctls = expectedSysctls
+
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext).To(Equal(initialSecurityContext))
+				},
+					Entry("1-gloo-deployment", "gloo", "gloo.deployment.podSecurityContext"),
+					// "3-discovery-deployment" uses the template but is excluded from this test because it does not have a configurable podSecurityContext
+					Entry("7-gateway-proxy-deployment", "gateway-proxy", "gatewayProxies.gatewayProxy.podTemplate.podSecurityContext", "gatewayProxies.gatewayProxy.podTemplate.enablePodSecurityContext=true"),
+				)
+
+				DescribeTable("floatingUserId is properly applied (container)", func(resourceName string, containerName string, fpuidRoot string, securityRoot string, extraArgs ...string) {
+					// Pass 1 - get with no changes
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append([]string{
+							fpuidRoot + ".floatingUserId=false",
+							securityRoot + ".runAsUser=30303",
+						}, extraArgs...),
+					})
+
+					container := getContainer(testManifest, "Deployment", resourceName, containerName)
+					Expect(container.SecurityContext.RunAsUser).To(Equal(pointer.Int64(int64(30303))))
+
+					// Pass 2: floatingUserId=true
+					// runAsUser should not be defined
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append([]string{
+							fpuidRoot + ".floatingUserId=true",
+						}, extraArgs...),
+					})
+
+					container = getContainer(testManifest, "Deployment", resourceName, containerName)
+					Expect(container.SecurityContext.RunAsUser).To(BeNil())
+
+					// Pass 3: floatingUserId=true
+					// BUT also pass in an override for the runAsUser
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append([]string{
+							fpuidRoot + ".floatingUserId=true",
+							securityRoot + ".runAsUser=20202",
+							securityRoot + ".mergePolicy=helm-merge",
+						}, extraArgs...),
+					})
+
+					container = getContainer(testManifest, "Deployment", resourceName, containerName)
+					Expect(container.SecurityContext.RunAsUser).To(Equal(pointer.Int64(int64(20202))))
+				},
+					Entry("1-gloo-deployment-envoy-sidecar", "gloo", "envoy-sidecar", "gloo.deployment", "global.glooMtls.envoy.securityContext", "global.glooMtls.enabled=true"),
+					Entry("1-gloo-deployment-sds", "gloo", "sds", "gloo.deployment", "global.glooMtls.sds.securityContext", "global.glooMtls.enabled=true"),
+					Entry("7-gateway-proxy-deployment-gateway-proxy", "gateway-proxy", "gateway-proxy", "gatewayProxies.gatewayProxy.podTemplate", "gatewayProxies.gatewayProxy.podTemplate.glooContainerSecurityContext"),
+				)
+
+				DescribeTable("floatingUserId is properly applied (pod)", func(resourceName string, fpuidRoot string, securityRoot string, extraArgs ...string) {
+					// Pass 1: floatingUserId=false
+					// Also set the runAsUser to something other than the default
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append([]string{
+							fpuidRoot + ".floatingUserId=false",
+							securityRoot + ".runAsUser=30303",
+						}, extraArgs...),
+					})
+
+					// The chart uses the passed user id
+					structuredDeployment := getStructuredDeployment(testManifest, resourceName)
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.RunAsUser).To(Equal(pointer.Int64(int64(30303))))
+
+					// Pass 2: floatingUserId=true
+					// The chart uses the default user id
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append([]string{
+							fpuidRoot + ".floatingUserId=true",
+						}, extraArgs...),
+					})
+
+					structuredDeployment = getStructuredDeployment(testManifest, resourceName)
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.RunAsUser).To(BeNil())
+
+					// // Pass 3: floatingUserId=true
+					// // BUT also pass in an override for the runAsUser
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append([]string{
+							fpuidRoot + ".floatingUserId=true",
+							securityRoot + ".runAsUser=20202",
+							securityRoot + ".mergePolicy=helm-merge",
+						}, extraArgs...),
+					})
+
+					structuredDeployment = getStructuredDeployment(testManifest, resourceName)
+					Expect(structuredDeployment.Spec.Template.Spec.SecurityContext.RunAsUser).To(Equal(pointer.Int64(int64(20202))))
+				},
+					Entry("7-gateway-proxy-deployment", "gateway-proxy", "gatewayProxies.gatewayProxy.podTemplate", "gatewayProxies.gatewayProxy.podTemplate.podSecurityContext"),
+				)
+
+				It("should error on an invalid mergePolicy", func() {
+					values := glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gatewayProxies.gatewayProxy.podTemplate.podSecurityContext.mergePolicy=invalid",
+						},
+					}
+					_, err := rendererTestCase.renderer.RenderManifest(namespace, values)
+					Expect(err).To(HaveOccurred(), "should error on an invalid mergePolicy")
+				})
+			})
+
+			Context("Kube resource overrides", func() {
+				DescribeTable("overrides Yaml in generated resources", func(overrideProperty string, extraArgs ...string) {
+					// Override property should be the path to `kubeResourceOverride`, like gloo.deployment.kubeResourceOverride
+					valueArg := fmt.Sprintf("%s.metadata.labels.overriddenLabel=label", overrideProperty)
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append(extraArgs, valueArg),
+					})
+					// We are overriding the generated yaml by adding our own label to the metadata
+					resources := testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetLabels()["overriddenLabel"] == "label" && resource.GetKind() != ""
+					})
+					Expect(resources.NumResources()).To(Equal(1))
+				},
+					Entry("1-gloo-deployment", "gloo.deployment.kubeResourceOverride"),
+					Entry("2-gloo-service", "gloo.service.kubeResourceOverride"),
+					Entry("2-gloo-service-account", "gloo.serviceAccount.kubeResourceOverride"),
+					Entry("3-discovery-deployment", "discovery.deployment.kubeResourceOverride"),
+					Entry("3-discovery-service-account", "discovery.serviceAccount.kubeResourceOverride"),
+					Entry("5-gateway-validation-webhook-configuration", "gateway.validation.webhook.kubeResourceOverride"),
+					Entry("6-access-logger-deployment", "accessLogger.deployment.kubeResourceOverride", "accessLogger.enabled=true"),
+					Entry("6-access-logger-service", "accessLogger.service.kubeResourceOverride", "accessLogger.enabled=true"),
+					Entry("6.5-gateway-certgen-job", "gateway.certGenJob.kubeResourceOverride"),
+					Entry("6.5-gateway-certgen-cronjob", "gateway.certGenJob.cron.validationWebhookKubeResourceOverride", "gateway.enabled=true", "gateway.validation.enabled=true", "gateway.validation.webhook.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("8-gateway-proxy-service-account", "gateway.proxyServiceAccount.kubeResourceOverride"),
+					Entry("10-ingress-deployment", "ingress.deployment.kubeResourceOverride", "ingress.enabled=true"),
+					Entry("11-ingress-proxy-deployment", "ingressProxy.deployment.kubeResourceOverride", "ingress.enabled=true"),
+					Entry("12-ingress-proxy-configmap", "ingressProxy.configMap.kubeResourceOverride", "ingress.enabled=true"),
+					Entry("13-ingress-proxy-service", "ingressProxy.service.kubeResourceOverride", "ingress.enabled=true"),
+					Entry("14-clusteringress-proxy-deployment", "settings.integrations.knative.proxy.deployment.kubeResourceOverride", "settings.integrations.knative.version=0.1.0", "settings.integrations.knative.enabled=true"),
+					Entry("15-clusteringress-proxy-configmap", "settings.integrations.knative.proxy.configMap.kubeResourceOverride", "settings.integrations.knative.version=0.1.0", "settings.integrations.knative.enabled=true"),
+					Entry("16-clusteringress-proxy-service", "settings.integrations.knative.proxy.service.kubeResourceOverride", "settings.integrations.knative.version=0.1.0", "settings.integrations.knative.enabled=true"),
+					Entry("18-settings", "settings.kubeResourceOverride"),
+					Entry("19-gloo-mtls-certgen-job", "gateway.certGenJob.mtlsKubeResourceOverride", "global.glooMtls.enabled=true"),
+					Entry("19-gloo-mtls-certgen-cronjob", "gateway.certGenJob.cron.mtlsKubeResourceOverride", "global.glooMtls.enabled=true", "gateway.certGenJob.cron.enabled=true"),
+					Entry("26-knative-external-proxy-deployment", "settings.integrations.knative.proxy.deployment.kubeResourceOverride", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("27-knative-external-proxy-configmap", "settings.integrations.knative.proxy.configMap.kubeResourceOverride", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("28-knative-external-proxy-service", "settings.integrations.knative.proxy.service.kubeResourceOverride", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("29-knative-internal-proxy-deployment", "settings.integrations.knative.proxy.internal.deployment.kubeResourceOverride", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("30-knative-internal-proxy-configmap", "settings.integrations.knative.proxy.internal.configMap.kubeResourceOverride", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					Entry("31-knative-internal-proxy-service", "settings.integrations.knative.proxy.internal.service.kubeResourceOverride", "settings.integrations.knative.version=0.8.0", "settings.integrations.knative.enabled=true"),
+					// todo: implement overrides for these if need arises
+					// A named helm template will have to be created for each of the resources
+					// generated in the following files.
+					// Entry("19-gloo-mtls-configmap", ),
+					// Entry("20-namespace-clusterrole-gateway", ""),
+					// Entry("21-namespace-clusterrole-ingress", ""),
+					// Entry("22-namespace-clusterrole-knative", ""),
+					// Entry("23-namespace-clusterrolebinding-gateway", ""),
+					// Entry("24-namespace-clusterrolebinding-ingress", ""),
+					// Entry("25-namespace-clusterrolebinding-knative", ""),
+				)
+
+				DescribeTable("overrides Yaml in resources for each gateway proxy", func(proxyOverrideProperty string, argsPerProxy []string) {
+					// Override property should be the path to `kubeResourceOverride`, like gloo.deployment.kubeResourceOverride
+					proxies := []string{"gatewayProxy", "anotherProxy", "proxyThree"}
+					var args []string
+					var extraArgs []string
+					for _, proxy := range proxies {
+						args = append(args, fmt.Sprintf("gatewayProxies.%s.%s.metadata.labels.overriddenLabel=label", proxy, proxyOverrideProperty))
+						for _, arg := range argsPerProxy {
+							args = append(args, fmt.Sprintf("gatewayProxies.%s.%s", proxy, arg))
+						}
+					}
+
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: append(args, extraArgs...),
+					})
+
+					// We are overriding the generated yaml by adding our own label to the metadata
+					resources := testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetLabels()["overriddenLabel"] == "label" && resource.GetKind() != ""
+					})
+					countFromResources := resources.NumResources()
+
+					// gloo custom resources are stored as yaml in a configmap so they don't appear in the resources count.
+					configMap := getConfigMap(testManifest, namespace, customResourceConfigMapName)
+					Expect(configMap.Data).ToNot(BeNil())
+					Expect(configMap.Data["custom-resources"]).NotTo(BeEmpty())
+					countFromConfigMap := strings.Count(configMap.Data["custom-resources"], "overriddenLabel: label")
+
+					Expect(countFromResources + countFromConfigMap).To(Equal(len(proxies)))
+				},
+					Entry("7-gateway-proxy-deployment", "kubeResourceOverride", nil),
+					Entry("8-default-gateways httpGateway", "gatewaySettings.httpGatewayKubeOverride", nil),
+					Entry("8-default-gateways httpsGateway", "gatewaySettings.httpsGatewayKubeOverride", nil),
+					Entry("8-default-gateways failoverGateway", "failover.kubeResourceOverride", []string{"failover.enabled=true"}),
+					Entry("8-gateway-proxy-horizontal-pod-autoscaler", "horizontalPodAutoscaler.kubeResourceOverride", []string{"kind.deployment.replicas=2", "horizontalPodAutoscaler.apiVersion=v2"}),
+					Entry("8-gateway-proxy-pod-disruption-budget", "podDisruptionBudget.kubeResourceOverride", []string{"kind.deployment.replicas=2"}),
+					Entry("8-gateway-proxy-service service", "service.kubeResourceOverride", nil),
+					Entry("8-gateway-proxy-service config-dump-service", "service.configDumpService.kubeResourceOverride", []string{"readConfig=true", "readConfigMulticluster=true"}),
+					Entry("9-gateway-proxy-configmap", "configMap.kubeResourceOverride", nil),
+				)
+			})
+
+			Context("Kube GatewayKube overrides", func() {
+				It("can override values on default Gateways", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gatewayProxies.gatewayProxy.gatewaySettings.httpGatewayKubeOverride.spec.bindPort=1234",
+							"gatewayProxies.gatewayProxy.gatewaySettings.httpsGatewayKubeOverride.spec.ssl=false",
+							"gatewayProxies.gatewayProxy.failover.enabled=true",
+							"gatewayProxies.gatewayProxy.failover.kubeResourceOverride.spec.bindPort=5678",
+						},
+					})
+					// expected gateways
+					gw := makeUnstructuredGateway(namespace, defaults.GatewayProxyName, false)
+					unstructured.SetNestedField(gw.Object,
+						int64(1234),
+						"spec", "bindPort")
+					gwSsl := makeUnstructuredGateway(namespace, defaults.GatewayProxyName, true)
+					unstructured.SetNestedField(gwSsl.Object,
+						false,
+						"spec", "ssl")
+					gwFailover := makeUnstructuredFailoverGateway(namespace, defaults.GatewayProxyName)
+					unstructured.SetNestedField(gwFailover.Object,
+						int64(5678),
+						"spec", "bindPort")
+
+					assertCustomResourceManifest(map[string]types.GomegaMatcher{
+						defaults.GatewayProxyName:                         BeEquivalentTo(gw),
+						getSslGatewayName(defaults.GatewayProxyName):      BeEquivalentTo(gwSsl),
+						getFailoverGatewayName(defaults.GatewayProxyName): BeEquivalentTo(gwFailover),
+					})
+				})
+
+				It("can override values on custom Gateways", func() {
+					prepareMakefile(namespace, glootestutils.HelmValues{
+						ValuesArgs: []string{
+							"gatewayProxies.gatewayProxy.disabled=true",
+							"gatewayProxies.anotherProxy.gatewaySettings.httpGatewayKubeOverride.spec.bindAddress=something",
+							"gatewayProxies.anotherProxy.gatewaySettings.httpsGatewayKubeOverride.spec.proxyNames[0]=new-proxy",
+							"gatewayProxies.anotherProxy.failover.enabled=true",
+							"gatewayProxies.anotherProxy.failover.kubeResourceOverride.spec.bindPort=5678",
+						},
+					})
+					// expected gateways
+					anotherGw := makeUnstructuredGateway(namespace, "another-proxy", false)
+					unstructured.SetNestedField(anotherGw.Object,
+						"something",
+						"spec", "bindAddress")
+					anotherGwSsl := makeUnstructuredGateway(namespace, "another-proxy", true)
+					unstructured.SetNestedStringSlice(anotherGwSsl.Object,
+						[]string{"new-proxy"},
+						"spec", "proxyNames")
+					anotherGwFailover := makeUnstructuredFailoverGateway(namespace, "another-proxy")
+					unstructured.SetNestedField(anotherGwFailover.Object,
+						int64(5678),
+						"spec", "bindPort")
+
+					assertCustomResourceManifest(map[string]types.GomegaMatcher{
+						"another-proxy":                         BeEquivalentTo(anotherGw),
+						getSslGatewayName("another-proxy"):      BeEquivalentTo(anotherGwSsl),
+						getFailoverGatewayName("another-proxy"): BeEquivalentTo(anotherGwFailover),
+					})
+				})
+			})
+
+			It("test devMode", func() {
+				prepareMakefile(namespace, glootestutils.HelmValues{
+					ValuesArgs: append([]string{"settings.devMode=true"}),
+				})
+
+				resources := testManifest.SelectResources(func(u *unstructured.Unstructured) bool {
+					// Check the gloo deployment container
+					if u.GetKind() == "Deployment" && u.GetName() == "gloo" {
+						deploymentObject, err := kuberesource.ConvertUnstructured(u)
+						ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to render manifest")
+						structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+						Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", u))
+
+						containers := structuredDeployment.Spec.Template.Spec.Containers
+						// a := getFieldFromUnstructured(u, []string{"spec", "template", "spec", "containers"}...)
+						Expect(containers).ToNot(BeNil())
+						Expect(containers).To(HaveLen(1), "should have exactly 1 container")
+						ports := containers[0].Ports
+
+						foundDevModePort := false
+						for _, port := range ports {
+							if port.Name == "dev-admin" && port.ContainerPort == 10010 {
+								foundDevModePort = true
+							}
+						}
+
+						Expect(foundDevModePort).To(BeTrue(), "should have found the dev mode port")
+						return foundDevModePort
+					}
+					// Check the Settigns
+					if u.GetKind() == "Settings" && u.GetName() == "default" {
+						devMode := getFieldFromUnstructured(u, []string{"spec", "devMode"}...)
+						devModeBool, ok := devMode.(bool)
+						Expect(ok).To(BeTrue(), "devMode should be a bool")
+						Expect(devModeBool).To(BeTrue(), "should have found the dev mode port")
+						if devMode == true {
+							return true
+						}
+					}
+
+					return false
+				})
+
+				Expect(resources.NumResources()).To(Equal(2))
+			})
+
+			It("should add the additional labels to all resources", func() {
+				prepareMakefile(namespace, glootestutils.HelmValues{
+					ValuesArgs: append(helmRenderEverythingValues(),
+						"global.additionalLabels.this=that",
+						"global.additionalLabels.the=other",
+					),
+				})
+
+				testManifest.ExpectAll(func(resource *unstructured.Unstructured) {
+					labelsObj := getFieldFromUnstructured(resource, "metadata", "labels")
+					Expect(labelsObj).To(BeAssignableToTypeOf(map[string]interface{}{}))
+					labels := labelsObj.(map[string]interface{})
+					Expect(labels["app"]).To(Equal("gloo"))
+					Expect(labels["this"]).To(Equal("that"))
+					Expect(labels["the"]).To(Equal("other"))
+				})
+			})
+		})
+
+		Context("Reflection", func() {
+			// Values which, for whatever reason, are excluded from pointer-checking, all of which should
+			// include an explanation here for why they're present.
+			//  - 3 of the image values are used in our helm generate code, which doesn't like pointers.
+			//    We're not changing them for this test, since that code is likely to be removed/changed soon.
+			//  - The one exception is the Repository value, which is instead needed by value during codegen.
+
+			pointerExceptions := map[string]interface{}{}
+
+			It("All non-embedded fields in values.go have the omitempty tag", func() {
+				// The following code iterates over each struct in values.go,
+				// then iterates over each struct's fields and checks that they either contain the
+				// omitempty tag, or don't have tags at all. It also ensures that a variety of primitive types (and strings)
+				// are pointers to said types instead of direct values.
+				// These changes are necessary to make value deduplication possible between gloo-OS and gloo-E's charts.
+				// Without the omitempty tag and pointers, a bunch of problems can crop up. See the slab doc
+				// https://soloio.slab.com/posts/helm-chart-merging-issues-r7r2617z for more info.
+
+				// keep track of missing values for final error check
+				var missingVals []string
+
+				// All of the structs in values.go form a tree, with the HelmConfig struct as the root.
+				structQueue := []reflect.Type{reflect.TypeOf(values.HelmConfig{})}
+
+				// recursively iterate over every child struct of HelmConfig.
+				for len(structQueue) > 0 {
+					var inspectedStruct reflect.Type
+					inspectedStruct, structQueue = structQueue[0], structQueue[1:]
+					// for some reason, strings and interfaces slip past my earlier checks (including this same condition
+					// in the helper function).
+					structName := inspectedStruct.Name()
+					if structName == "" || structName == "string" {
+						continue
+					}
+					// iterate over struct fields
+					for i := range inspectedStruct.NumField() {
+						structField := inspectedStruct.Field(i)
+						// Check that the field contains a json tag, and if so, that it includes the omitempty tag.
+						// Values without any tags are assumed to be embedded structs, and are ignored.
+						tagStr, ok := structField.Tag.Lookup("json")
+						if ok && !strings.Contains(strings.ToLower(tagStr), "omitempty") {
+							fmt.Sprintf("Missing omitempty in %s.%s", inspectedStruct.Name(), structField.Name)
+							missingVals = append(missingVals, fmt.Sprintf("{ no omitempty - %s.%s }", inspectedStruct.Name(), structField.Name))
+						}
+
+						// Extract the field type, and add it to the structs-to-check queue.
+						// The structs can't be cyclic, so don't both with keeping track of what we've seen
+						// It's not worth the code clutter to do so for a test.
+						fieldType := structField.Type.Kind()
+						if fieldType == reflect.Ptr {
+							structQueue = appendIfNilPath(structQueue, structField.Type.Elem())
+						} else if fieldType == reflect.Array {
+							structQueue = appendIfNilPath(structQueue, structField.Type.Elem())
+						} else if fieldType == reflect.Map {
+							structQueue = append(structQueue, structField.Type.Elem()) // map keys are exclusively strings, this gets the item type
+						} else if fieldType == reflect.Struct {
+							structQueue = appendIfNilPath(structQueue, structField.Type)
+						} else if fieldType == reflect.String ||
+							fieldType == reflect.Bool ||
+							fieldType == reflect.Int ||
+							fieldType == reflect.Int8 ||
+							fieldType == reflect.Int32 ||
+							fieldType == reflect.Int64 ||
+							fieldType == reflect.Uint ||
+							fieldType == reflect.Uint32 ||
+							fieldType == reflect.Float64 {
+							_, found := pointerExceptions[fmt.Sprintf("%s.%s", inspectedStruct.Name(), structField.Name)]
+							if !found {
+								missingVals = append(missingVals, fmt.Sprintf("{ primitive or simple value not pointer-ed - %s.%s }", inspectedStruct.Name(), structField.Name))
+							}
+						}
+					}
+				}
+				Expect(fmt.Sprintf("%v", missingVals)).To(Equal("[]")) // this makes the failure message simply be a list of what we're missing
+			})
+		})
+
+		// Lines ending with whitespace causes malformatted config map (https://github.com/kgateway-dev/kgateway/issues/4645)
+		It("should not contain trailing whitespace", func() {
+			out, err := exec.Command("helm", "template", "../helm/gloo").Output()
+			Expect(err).NotTo(HaveOccurred(), "Helm template Generation error")
+
+			lines := strings.Split(string(out), "\n")
+			// more descriptive fail message that prints out the manifest that includes the trailing whitespace
+			manifestStartingLine := 0
+			skip := false
+			for idx, line := range lines {
+				if strings.Contains(line, "---") {
+					manifestStartingLine = idx
+					continue
+				}
+				// skip all the content within the custom resource configmap since there is extra whitespace
+				// that can't be removed
+				if strings.Contains(line, "custom-resources: |") {
+					skip = true
+					continue
+				}
+				if strings.Contains(line, "has-custom-resources:") {
+					skip = false
+				}
+				if !skip && strings.TrimRightFunc(line, unicode.IsSpace) != line {
+					Fail(strings.Join(lines[manifestStartingLine:idx+1], "\n") + "\n last line has whitespace")
+				}
+			}
+		})
+	}
+
+	runTests(allTests)
+})
+
+// Helper function that adds a reflected type to a queue if it is a struct from the generate package.
+func appendIfNilPath(queue []reflect.Type, newVal reflect.Type) []reflect.Type {
+	if newVal.Kind() == reflect.Struct {
+		pkgName := newVal.PkgPath()
+		if pkgName == "github.com/kgateway-dev/kgateway/v2/install/helm/gloo/generate" {
+			return append(queue, newVal)
+		}
+	}
+	return queue
+}
+
+func cloneMap(input map[string]string) map[string]string {
+	ret := map[string]string{}
+	for k, v := range input {
+		ret[k] = v
+	}
+
+	return ret
+}
+
+func constructResourceID(resource *unstructured.Unstructured) string {
+	// technically vulnerable to resources that have commas in their names, but that's not a big concern
+	return fmt.Sprintf("%s,%s,%s", resource.GetNamespace(), resource.GetName(), resource.GroupVersionKind().String())
+}
+
+// gets value of field nested within an Unstructured struct.
+// fieldPath is the path to the value, so the value foo.bar.baz would be passed in as "foo", "bar, "baz"
+func getFieldFromUnstructured(uns *unstructured.Unstructured, fieldPath ...string) interface{} {
+	if len(fieldPath) < 1 {
+		return nil
+	}
+	obj := uns.Object[fieldPath[0]]
+	for _, field := range fieldPath[1:] {
+		obj = obj.(map[string]interface{})[field]
+	}
+	return obj
+}
+
+// deepCopy deepcopies a to b using json marshaling
+// https://stackoverflow.com/questions/46790190/quicker-way-to-deepCopy-objects-in-golang-json-vs-gob
+func deepCopy(a, b interface{}) {
+	byt, _ := json.Marshal(a)
+	json.Unmarshal(byt, b)
+}
+
+/*
+podSecurityContextFieldsStripeGroupA/B are used to generate the values.yaml for the podSecurityContext tests.
+
+	We use the stripe groups so that with two tests we can cover all the fields in the podSecurityContext struct both with and without
+	overriding the default values. We do this in 2 places, to test the merge and the overwrite, so we'll just define them once here
+*/
+func podSecurityContextFieldsStripeGroupA(securityRoot string, extraArgs ...string) glootestutils.HelmValues {
+	return glootestutils.HelmValues{
+		ValuesArgs: append([]string{
+			securityRoot + ".fsGroup=101010",
+			securityRoot + ".fsGroupChangePolicy=fsGroupChangePolicyValue",
+			securityRoot + ".runAsGroup=202020",
+			securityRoot + ".runAsNonRoot=true",
+			securityRoot + ".runAsUser=303030",
+			securityRoot + ".supplementalGroups={11,22,33}",
+			securityRoot + ".seLinuxOptions.level=seLevel",
+			securityRoot + ".seLinuxOptions.role=seRole",
+			securityRoot + ".seLinuxOptions.type=seType",
+			securityRoot + ".seLinuxOptions.user=seUser",
+		}, extraArgs...),
+	}
+}
+
+func podSecurityContextFieldsStripeGroupB(securityRoot string, extraArgs ...string) glootestutils.HelmValues {
+	return glootestutils.HelmValues{
+		ValuesArgs: append([]string{
+			securityRoot + ".seccompProfile.localhostProfile=seccompLHP",
+			securityRoot + ".seccompProfile.type=seccompType",
+			securityRoot + ".windowsOptions.gmsaCredentialSpec=winGmsaCredSpec",
+			securityRoot + ".windowsOptions.gmsaCredentialSpecName=winGmsaCredSpecName",
+			securityRoot + ".windowsOptions.hostProcess=true",
+			securityRoot + ".windowsOptions.runAsUserName=winUser",
+			securityRoot + ".sysctls[0].name=sysctlName",
+			securityRoot + ".sysctls[0].value=sysctlValue",
+		}, extraArgs...),
+	}
+}
+
+func securityContextFieldsStripeGroupA(securityRoot string, extraArgs ...string) glootestutils.HelmValues {
+	return glootestutils.HelmValues{
+		ValuesArgs: append([]string{
+			securityRoot + ".runAsNonRoot=true",
+			securityRoot + ".runAsUser=1234",
+			securityRoot + ".allowPrivilegeEscalation=true",
+			securityRoot + ".readOnlyRootFilesystem=true",
+			securityRoot + ".seLinuxOptions.level=seLevel",
+			securityRoot + ".seLinuxOptions.role=seRole",
+			securityRoot + ".seLinuxOptions.type=seType",
+			securityRoot + ".seLinuxOptions.user=seUser",
+		}, extraArgs...),
+	}
+}
+
+func securityContextFieldsStripeGroupB(securityRoot string, extraArgs ...string) glootestutils.HelmValues {
+	return glootestutils.HelmValues{
+		ValuesArgs: append([]string{
+			securityRoot + ".capabilities.add={ADD}",
+			securityRoot + ".capabilities.drop={DROP}",
+			securityRoot + ".seccompProfile.localhostProfile=seccompLHP",
+			securityRoot + ".seccompProfile.type=seccompType",
+			securityRoot + ".windowsOptions.gmsaCredentialSpec=winGmsaCredSpec",
+			securityRoot + ".windowsOptions.gmsaCredentialSpecName=winGmsaCredSpecName",
+			securityRoot + ".windowsOptions.hostProcess=true",
+			securityRoot + ".windowsOptions.runAsUserName=winUser",
+		}, extraArgs...),
+	}
+}
+
+func getContainer(t TestManifest, kind string, resourceName string, containerName string) *corev1.Container {
+	resources := t.SelectResources(func(u *unstructured.Unstructured) bool {
+		if u.GetKind() == kind && u.GetName() == resourceName {
+			return true
+		}
+		return false
+	})
+
+	Expect(resources.NumResources()).To(Equal(1))
+
+	var foundContainer corev1.Container
+	resources.ExpectAll(func(deployment *unstructured.Unstructured) {
+		foundExpected := false
+		deploymentObject, err := kuberesource.ConvertUnstructured(deployment)
+		ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to render manifest")
+
+		var containers []corev1.Container
+
+		switch kind {
+		case "Deployment":
+			structuredDeployment, ok := deploymentObject.(*appsv1.Deployment)
+			Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", structuredDeployment))
+			containers = structuredDeployment.Spec.Template.Spec.Containers
+		case "Job":
+			structuredJob, ok := deploymentObject.(*batchv1.Job)
+			Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured job", structuredJob))
+			containers = structuredJob.Spec.Template.Spec.Containers
+		case "CronJob":
+			structuredCronJob, ok := deploymentObject.(*batchv1.CronJob)
+			Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured cronjob", structuredCronJob))
+			containers = structuredCronJob.Spec.JobTemplate.Spec.Template.Spec.Containers
+		default:
+			Fail("Unsupported kind:" + kind)
+		}
+
+		for _, container := range containers {
+			if container.Name == containerName {
+				foundExpected = true
+				foundContainer = container
+			}
+		}
+
+		Expect(foundExpected).To(BeTrue())
+	})
+
+	return &foundContainer
+}
+
+func getStructuredDeployment(t TestManifest, resourceName string) *appsv1.Deployment {
+	structuredDeployment := &appsv1.Deployment{}
+
+	resources := t.SelectResources(func(u *unstructured.Unstructured) bool {
+		if u.GetKind() == "Deployment" && u.GetName() == resourceName {
+			deploymentObject, err := kuberesource.ConvertUnstructured(u)
+			ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to render manifest")
+			var ok bool
+			structuredDeployment, ok = deploymentObject.(*appsv1.Deployment)
+			Expect(ok).To(BeTrue(), fmt.Sprintf("Deployment %+v should be able to cast to a structured deployment", u))
+			return true
+		}
+		return false
+	})
+	Expect(resources.NumResources()).To(Equal(1))
+
+	return structuredDeployment
+}
+
+//nolint:unparam // namespace always receives "gloo-system"
+func makeUnstructuredGateway(namespace string, name string, ssl bool) *unstructured.Unstructured {
+	port := "8080"
+	gwName := name
+	if ssl {
+		port = "8443"
+		gwName = getSslGatewayName(name)
+	}
+
+	return makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  labels:
+    app: gloo
+  name: ` + gwName + `
+  namespace: ` + namespace + `
+spec:
+  bindAddress: '::'
+  bindPort: ` + port + `
+  httpGateway: {}
+  proxyNames:
+  - ` + name + `
+  ssl: ` + strconv.FormatBool(ssl) + `
+  useProxyProto: false
+`)
+}
+
+func makeUnstructuredFailoverGateway(namespace string, proxyName string) *unstructured.Unstructured {
+	return makeUnstructured(`
+apiVersion: gateway.solo.io/v1
+kind: Gateway
+metadata:
+  labels:
+    app: gloo
+  name: ` + getFailoverGatewayName(proxyName) + `
+  namespace: ` + namespace + `
+spec:
+  bindAddress: '::'
+  bindPort: 15443
+  proxyNames:
+  - ` + proxyName + `
+  tcpGateway:
+    tcpHosts:
+    - destination:
+        forwardSniClusterName: {}
+      name: failover
+      sslConfig:
+        secretRef:
+          name: failover-downstream
+          namespace: ` + namespace + `
+`)
+}
+
+func getSslGatewayName(name string) string {
+	return name + "-ssl"
+}
+
+func getFailoverGatewayName(name string) string {
+	return name + "-failover"
+}
+
+// Does not render **everything** as some templates render when .Values.settings.integrations.knative.version >= 0.8.0 and others render when < 0.8.0
+// These arguments use the default from values-template, which is "0.10.0"
+// Also does not set kubeGateway.enabled=true - leave that to the individual tests
+func helmRenderEverythingValues() []string {
+	return []string{
+		"accessLogger.enabled=true",
+		"discovery.deployment.enablePodSecurityContext=true",
+		"gateway.certGenJob.cron.enabled=true",
+		"gateway.enabled=true",
+		"gateway.validation.enabled=true",
+		"gateway.validation.webhook.enabled=true",
+		"gatewayProxies.gatewayProxy.podTemplate.enablePodSecurityContext=true",
+		"global.glooMtls.enabled=true",
+		"global.istioIntegration.enabled=true",
+		"ingress.enabled=true",
+		"settings.integrations.knative.enabled=true",
+	}
+}
diff --git a/install/test/k8sgateway_test.go b/install/test/k8sgateway_test.go
new file mode 100644
index 000000000..79079ef14
--- /dev/null
+++ b/install/test/k8sgateway_test.go
@@ -0,0 +1,518 @@
+//go:build ignore
+
+package test
+
+import (
+	"fmt"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/resource"
+	"k8s.io/apimachinery/pkg/util/intstr"
+	"k8s.io/utils/pointer"
+
+	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	"github.com/kgateway-dev/kgateway/v2/install/utils/kuberesource"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
+	"github.com/kgateway-dev/kgateway/v2/test/helpers"
+	glootestutils "github.com/kgateway-dev/kgateway/v2/test/testutils"
+)
+
+var _ = Describe("Kubernetes Gateway API integration", func() {
+	allTests := func(rendererTestCase renderTestCase) {
+		var (
+			testManifest TestManifest
+			valuesArgs   []string
+		)
+		prepareHelmManifest := func(namespace string, values glootestutils.HelmValues) {
+			tm, err := rendererTestCase.renderer.RenderManifest(namespace, values)
+			ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to render manifest")
+			testManifest = tm
+		}
+
+		BeforeEach(func() {
+			valuesArgs = []string{}
+		})
+
+		JustBeforeEach(func() {
+			prepareHelmManifest(namespace, glootestutils.HelmValues{ValuesArgs: valuesArgs})
+		})
+		When("kube gateway integration is enabled", func() {
+			BeforeEach(func() {
+				valuesArgs = append(valuesArgs, "kubeGateway.enabled=true")
+			})
+
+			It("relevant resources are rendered", func() {
+				deployment := getDeployment(testManifest, namespace, helpers.DefaultKgatewayDeploymentName)
+				Expect(deployment.Spec.Template.Spec.Containers).To(HaveLen(1), "should have exactly 1 container")
+
+				// make sure the GatewayClass and RBAC resources exist (note, since they are all cluster-scoped, they do not have a namespace)
+				testManifest.ExpectUnstructured("GatewayClass", "", wellknown.GatewayClassName).NotTo(BeNil())
+
+				testManifest.ExpectUnstructured("GatewayParameters", namespace, wellknown.DefaultGatewayParametersName).NotTo(BeNil())
+
+				controlPlaneRbacName := fmt.Sprintf("glood-%s.%s", releaseName, namespace)
+				testManifest.Expect("ClusterRole", "", controlPlaneRbacName).NotTo(BeNil())
+				testManifest.Expect("ClusterRoleBinding", "", controlPlaneRbacName+"-binding").NotTo(BeNil())
+
+				deployerRbacName := fmt.Sprintf("glood-%s-deploy.%s", releaseName, namespace)
+				testManifest.Expect("ClusterRole", "", deployerRbacName).NotTo(BeNil())
+				testManifest.Expect("ClusterRoleBinding", "", deployerRbacName+"-binding").NotTo(BeNil())
+			})
+			It("renders default GatewayParameters", func() {
+				gwp := getDefaultGatewayParameters(testManifest)
+
+				gwpKube := gwp.Spec.Kube
+				Expect(gwpKube).ToNot(BeNil())
+
+				Expect(*gwpKube.Deployment.Replicas).To(Equal(uint32(1)))
+
+				Expect(*gwpKube.GetEnvoyContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullIfNotPresent))
+				Expect(*gwpKube.GetEnvoyContainer().GetImage().GetRegistry()).To(Equal("quay.io/solo-io"))
+				Expect(*gwpKube.GetEnvoyContainer().GetImage().GetRepository()).To(Equal("gloo-envoy-wrapper"))
+				Expect(*gwpKube.GetEnvoyContainer().GetImage().GetTag()).To(Equal(version))
+				Expect(*gwpKube.GetEnvoyContainer().GetSecurityContext().AllowPrivilegeEscalation).To(BeFalse())
+				Expect(*gwpKube.GetEnvoyContainer().GetSecurityContext().ReadOnlyRootFilesystem).To(BeTrue())
+				Expect(*gwpKube.GetEnvoyContainer().GetSecurityContext().RunAsNonRoot).To(BeTrue())
+				Expect(*gwpKube.GetEnvoyContainer().GetSecurityContext().RunAsUser).To(Equal(int64(10101)))
+				Expect(gwpKube.GetEnvoyContainer().GetSecurityContext().Capabilities.Drop).To(ContainElement(corev1.Capability("ALL")))
+				Expect(gwpKube.GetEnvoyContainer().GetSecurityContext().Capabilities.Add).To(ContainElement(corev1.Capability("NET_BIND_SERVICE")))
+				Expect(gwpKube.GetEnvoyContainer().GetResources()).To(BeNil())
+
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullIfNotPresent))
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetRegistry()).To(Equal("docker.io/istio"))
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetRepository()).To(Equal("proxyv2"))
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetTag()).To(Equal("1.22.0"))
+				Expect(gwpKube.GetIstio().GetIstioProxyContainer().GetSecurityContext()).To(BeNil())
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetLogLevel()).To(Equal("warning"))
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetIstioDiscoveryAddress()).To(Equal("istiod.istio-system.svc:15012"))
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetIstioMetaMeshId()).To(Equal("cluster.local"))
+				Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetIstioMetaClusterId()).To(Equal("Kubernetes"))
+
+				Expect(gwpKube.GetPodTemplate().GetExtraLabels()).To(matchers.ContainMapElements(map[string]string{"gloo": "kube-gateway"}))
+
+				Expect(*gwpKube.GetSdsContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullIfNotPresent))
+				Expect(*gwpKube.GetSdsContainer().GetImage().GetRegistry()).To(Equal("quay.io/solo-io"))
+				Expect(*gwpKube.GetSdsContainer().GetImage().GetRepository()).To(Equal("sds"))
+				Expect(*gwpKube.GetSdsContainer().GetImage().GetTag()).To(Equal(version))
+				Expect(gwpKube.GetSdsContainer().GetSecurityContext()).To(BeNil())
+				Expect(*gwpKube.GetSdsContainer().GetBootstrap().GetLogLevel()).To(Equal("info"))
+				Expect(gwpKube.GetSdsContainer().GetResources()).To(BeNil())
+
+				Expect(*gwpKube.GetService().GetType()).To(Equal(corev1.ServiceTypeLoadBalancer))
+
+				Expect(gwpKube.GetServiceAccount()).To(BeNil())
+
+				Expect(*gwpKube.GetStats().GetEnabled()).To(BeTrue())
+				Expect(*gwpKube.GetStats().GetRoutePrefixRewrite()).To(Equal("/stats/prometheus?usedonly"))
+				Expect(*gwpKube.GetStats().GetEnableStatsRoute()).To(BeTrue())
+				Expect(*gwpKube.GetStats().GetStatsRoutePrefixRewrite()).To(Equal("/stats"))
+
+				Expect(*gwpKube.GetAiExtension().GetEnabled()).To(BeFalse())
+				Expect(*gwpKube.GetAiExtension().GetImage().GetPullPolicy()).To(Equal(corev1.PullIfNotPresent))
+				Expect(*gwpKube.GetAiExtension().GetImage().GetRegistry()).To(Equal("ghcr.io/kgateway-dev"))
+				Expect(*gwpKube.GetAiExtension().GetImage().GetRepository()).To(Equal("kgateway-ai-extension"))
+				Expect(*gwpKube.GetAiExtension().GetImage().GetTag()).To(Equal(version))
+				Expect(gwpKube.GetAiExtension().GetSecurityContext()).To(BeNil())
+				Expect(gwpKube.GetAiExtension().GetResources()).To(BeNil())
+				Expect(gwpKube.GetAiExtension().GetPorts()).To(BeEmpty())
+
+				Expect(*gwpKube.GetFloatingUserId()).To(BeFalse())
+			})
+
+			When("overrides are set", func() {
+				var (
+					sdsRequests   = corev1.ResourceList{"memory": resource.MustParse("101Mi"), "cpu": resource.MustParse("201m")}
+					sdsLimits     = corev1.ResourceList{"memory": resource.MustParse("301Mi"), "cpu": resource.MustParse("401m")}
+					envoyRequests = corev1.ResourceList{"memory": resource.MustParse("102Mi"), "cpu": resource.MustParse("202m")}
+					envoyLimits   = corev1.ResourceList{"memory": resource.MustParse("302Mi"), "cpu": resource.MustParse("402m")}
+				)
+				BeforeEach(func() {
+					extraValuesArgs := []string{
+						"global.image.variant=standard",
+						"global.image.tag=global-override-tag",
+						"global.image.registry=global-override-registry",
+						"global.image.repository=global-override-repository",
+						"global.image.pullPolicy=Never",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.tag=envoy-override-tag",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.registry=envoy-override-registry",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.repository=envoy-override-repository",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.pullPolicy=Always",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.securityContext.runAsNonRoot=null",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.securityContext.runAsUser=777",
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.envoyContainer.resources.requests.memory=%s", envoyRequests["memory"].ToUnstructured()),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.envoyContainer.resources.requests.cpu=%s", envoyRequests["cpu"].ToUnstructured()),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.envoyContainer.resources.limits.memory=%s", envoyLimits["memory"].ToUnstructured()),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.envoyContainer.resources.limits.cpu=%s", envoyLimits["cpu"].ToUnstructured()),
+						"kubeGateway.gatewayParameters.glooGateway.proxyDeployment.replicas=5",
+						"kubeGateway.gatewayParameters.glooGateway.service.type=ClusterIP",
+						"kubeGateway.gatewayParameters.glooGateway.service.extraLabels.svclabel1=x",
+						"kubeGateway.gatewayParameters.glooGateway.service.extraAnnotations.svcanno1=y",
+						"kubeGateway.gatewayParameters.glooGateway.serviceAccount.extraLabels.label1=a",
+						"kubeGateway.gatewayParameters.glooGateway.serviceAccount.extraAnnotations.anno1=b",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.tag=sds-override-tag",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.registry=sds-override-registry",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.repository=sds-override-repository",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.pullPolicy=Never",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.logLevel=debug",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.securityContext.runAsNonRoot=null",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.securityContext.runAsUser=999",
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.requests.memory=%s", sdsRequests["memory"].ToUnstructured()),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.requests.cpu=%s", sdsRequests["cpu"].ToUnstructured()),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.limits.memory=%s", sdsLimits["memory"].ToUnstructured()),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.limits.cpu=%s", sdsLimits["cpu"].ToUnstructured()),
+						"kubeGateway.gatewayParameters.glooGateway.istio.istioProxyContainer.image.tag=istio-override-tag",
+						"kubeGateway.gatewayParameters.glooGateway.istio.istioProxyContainer.image.registry=istio-override-registry",
+						"kubeGateway.gatewayParameters.glooGateway.istio.istioProxyContainer.image.repository=istio-override-repository",
+						"kubeGateway.gatewayParameters.glooGateway.istio.istioProxyContainer.image.pullPolicy=Never",
+						"kubeGateway.gatewayParameters.glooGateway.istio.istioProxyContainer.logLevel=debug",
+						"kubeGateway.gatewayParameters.glooGateway.istio.istioProxyContainer.securityContext.runAsNonRoot=null",
+						"kubeGateway.gatewayParameters.glooGateway.istio.istioProxyContainer.securityContext.runAsUser=888",
+						"kubeGateway.gatewayParameters.glooGateway.stats.enabled=false",
+						"kubeGateway.gatewayParameters.glooGateway.stats.routePrefixRewrite=/foo/bar",
+						"kubeGateway.gatewayParameters.glooGateway.stats.enableStatsRoute=false",
+						"kubeGateway.gatewayParameters.glooGateway.stats.statsRoutePrefixRewrite=/scooby/doo",
+						"kubeGateway.gatewayParameters.glooGateway.aiExtension.image.tag=sds-override-tag",
+						"kubeGateway.gatewayParameters.glooGateway.aiExtension.image.registry=sds-override-registry",
+						"kubeGateway.gatewayParameters.glooGateway.aiExtension.image.repository=sds-override-repository",
+						"kubeGateway.gatewayParameters.glooGateway.aiExtension.image.pullPolicy=Never",
+						"kubeGateway.gatewayParameters.glooGateway.aiExtension.ports[0].name=port1",
+						"kubeGateway.gatewayParameters.glooGateway.aiExtension.ports[0].containerPort=80",
+						"global.istioIntegration.enabled=true",
+					}
+					valuesArgs = append(valuesArgs, extraValuesArgs...)
+				})
+				It("passes overrides to default GatewayParameters with Istio container", func() {
+					gwp := getDefaultGatewayParameters(testManifest)
+
+					gwpKube := gwp.Spec.Kube
+					Expect(gwpKube).ToNot(BeNil())
+
+					Expect(*gwpKube.GetDeployment().GetReplicas()).To(Equal(uint32(5)))
+
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullAlways))
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetRegistry()).To(Equal("envoy-override-registry"))
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetRepository()).To(Equal("envoy-override-repository"))
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetTag()).To(Equal("envoy-override-tag"))
+					// We specified non-null override for runAsUser and null override for runAsNonRoot. We expect runAsUser to be overridden,
+					// runAsNonRoot to be missing (nil) and the rest to be rendered from defaults.
+					Expect(*gwpKube.GetEnvoyContainer().GetSecurityContext().AllowPrivilegeEscalation).To(BeFalse())
+					Expect(*gwpKube.GetEnvoyContainer().GetSecurityContext().ReadOnlyRootFilesystem).To(BeTrue())
+					Expect(gwpKube.GetEnvoyContainer().GetSecurityContext().RunAsNonRoot).To(BeNil()) // Not using getter here as it masks nil as false
+					Expect(*gwpKube.GetEnvoyContainer().GetSecurityContext().RunAsUser).To(Equal(int64(777)))
+					Expect(gwpKube.GetEnvoyContainer().GetSecurityContext().Capabilities.Drop).To(ContainElement(corev1.Capability("ALL")))
+					Expect(gwpKube.GetEnvoyContainer().GetSecurityContext().Capabilities.Add).To(ContainElement(corev1.Capability("NET_BIND_SERVICE")))
+					Expect(gwpKube.GetEnvoyContainer().GetResources().Requests).To(matchers.ContainMapElements(envoyRequests))
+					Expect(gwpKube.GetEnvoyContainer().GetResources().Limits).To(matchers.ContainMapElements(envoyLimits))
+
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullNever))
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetRegistry()).To(Equal("istio-override-registry"))
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetRepository()).To(Equal("istio-override-repository"))
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetImage().GetTag()).To(Equal("istio-override-tag"))
+					// We specified non-null override for runAsUser and null override for runAsNonRoot. We expect runAsUser to be overridden,
+					// runAsNonRoot to be missing (nil) and the rest to be nil since there are no defaults.
+					Expect(gwpKube.GetIstio().GetIstioProxyContainer().GetSecurityContext().AllowPrivilegeEscalation).To(BeNil()) // Not using getter here as it masks nil as false
+					Expect(gwpKube.GetIstio().GetIstioProxyContainer().GetSecurityContext().ReadOnlyRootFilesystem).To(BeNil())   // Not using getter here as it masks nil as false
+					Expect(gwpKube.GetIstio().GetIstioProxyContainer().GetSecurityContext().RunAsNonRoot).To(BeNil())             // Not using getter here as it masks nil as false
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetSecurityContext().RunAsUser).To(Equal(int64(888)))
+					Expect(gwpKube.GetIstio().GetIstioProxyContainer().GetSecurityContext().Capabilities).To(BeNil())
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetLogLevel()).To(Equal("debug"))
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetIstioDiscoveryAddress()).To(Equal("istiod.istio-system.svc:15012"))
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetIstioMetaMeshId()).To(Equal("cluster.local"))
+					Expect(*gwpKube.GetIstio().GetIstioProxyContainer().GetIstioMetaClusterId()).To(Equal("Kubernetes"))
+
+					Expect(gwpKube.GetPodTemplate().GetExtraLabels()).To(matchers.ContainMapElements(map[string]string{"gloo": "kube-gateway"}))
+
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullNever))
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetRegistry()).To(Equal("sds-override-registry"))
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetRepository()).To(Equal("sds-override-repository"))
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetTag()).To(Equal("sds-override-tag"))
+					// We specified non-null override for runAsUser and null override for runAsNonRoot. We expect runAsUser to be overridden,
+					// runAsNonRoot to be missing (nil) and the rest to be nil since there are no defaults.
+					Expect(gwpKube.GetSdsContainer().GetSecurityContext().AllowPrivilegeEscalation).To(BeNil()) // Not using getter here as it masks nil as false
+					Expect(gwpKube.GetSdsContainer().GetSecurityContext().ReadOnlyRootFilesystem).To(BeNil())   // Not using getter here as it masks nil as false
+					Expect(gwpKube.GetSdsContainer().GetSecurityContext().RunAsNonRoot).To(BeNil())             // Not using getter here as it masks nil as false
+					Expect(*gwpKube.GetSdsContainer().GetSecurityContext().RunAsUser).To(Equal(int64(999)))
+					Expect(gwpKube.GetSdsContainer().GetSecurityContext().Capabilities).To(BeNil())
+					Expect(*gwpKube.GetSdsContainer().GetBootstrap().GetLogLevel()).To(Equal("debug"))
+					Expect(gwpKube.GetSdsContainer().GetResources().Requests).To(matchers.ContainMapElements(sdsRequests))
+					Expect(gwpKube.GetSdsContainer().GetResources().Limits).To(matchers.ContainMapElements(sdsLimits))
+
+					Expect(*gwpKube.GetService().GetType()).To(Equal(corev1.ServiceTypeClusterIP))
+					Expect(gwpKube.GetService().GetExtraLabels()).To(matchers.ContainMapElements(map[string]string{"svclabel1": "x"}))
+					Expect(gwpKube.GetService().GetExtraAnnotations()).To(matchers.ContainMapElements(map[string]string{"svcanno1": "y"}))
+
+					Expect(gwpKube.GetServiceAccount().GetExtraLabels()).To(matchers.ContainMapElements(map[string]string{"label1": "a"}))
+					Expect(gwpKube.GetServiceAccount().GetExtraAnnotations()).To(matchers.ContainMapElements(map[string]string{"anno1": "b"}))
+
+					Expect(*gwpKube.GetStats().GetEnabled()).To(BeFalse())
+					Expect(*gwpKube.GetStats().GetRoutePrefixRewrite()).To(Equal("/foo/bar"))
+					Expect(*gwpKube.GetStats().GetEnableStatsRoute()).To(BeFalse())
+					Expect(*gwpKube.GetStats().GetStatsRoutePrefixRewrite()).To(Equal("/scooby/doo"))
+
+					Expect(*gwpKube.GetAiExtension().GetImage().GetPullPolicy()).To(Equal(corev1.PullNever))
+					Expect(*gwpKube.GetAiExtension().GetImage().GetRegistry()).To(Equal("sds-override-registry"))
+					Expect(*gwpKube.GetAiExtension().GetImage().GetRepository()).To(Equal("sds-override-repository"))
+					Expect(*gwpKube.GetAiExtension().GetImage().GetTag()).To(Equal("sds-override-tag"))
+					Expect(gwpKube.GetAiExtension().GetPorts()).To(HaveLen(1))
+					Expect(gwpKube.GetAiExtension().GetPorts()[0].Name).To(Equal("port1"))
+					Expect(gwpKube.GetAiExtension().GetPorts()[0].ContainerPort).To(BeEquivalentTo(80))
+				})
+			})
+
+			When("custom sidecars overrides are set", func() {
+				BeforeEach(func() {
+					sdsVals := []string{"101Mi", "201m", "301Mi", "401m"}
+					extraValuesArgs := []string{
+						"global.image.variant=standard",
+						"global.image.tag=global-override-tag",
+						"global.image.registry=global-override-registry",
+						"global.image.repository=global-override-repository",
+						"global.image.pullPolicy=Never",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.tag=envoy-override-tag",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.registry=envoy-override-registry",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.repository=envoy-override-repository",
+						"kubeGateway.gatewayParameters.glooGateway.envoyContainer.image.pullPolicy=Always",
+						"kubeGateway.gatewayParameters.glooGateway.proxyDeployment.replicas=5",
+						"kubeGateway.gatewayParameters.glooGateway.service.type=ClusterIP",
+						"kubeGateway.gatewayParameters.glooGateway.service.extraLabels.svclabel1=a",
+						"kubeGateway.gatewayParameters.glooGateway.service.extraAnnotations.svcanno1=b",
+						"kubeGateway.gatewayParameters.glooGateway.serviceAccount.extraLabels.label1=a",
+						"kubeGateway.gatewayParameters.glooGateway.serviceAccount.extraAnnotations.anno1=b",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.tag=sds-override-tag",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.registry=sds-override-registry",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.repository=sds-override-repository",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.image.pullPolicy=Never",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.logLevel=debug",
+						"kubeGateway.gatewayParameters.glooGateway.sdsContainer.securityContext.runAsUser=999",
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.requests.memory=%s", sdsVals[0]),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.requests.cpu=%s", sdsVals[1]),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.limits.memory=%s", sdsVals[2]),
+						fmt.Sprintf("kubeGateway.gatewayParameters.glooGateway.sdsContainer.sdsResources.limits.cpu=%s", sdsVals[3]),
+						"kubeGateway.gatewayParameters.glooGateway.istio.customSidecars[0].name=custom-sidecar",
+						"global.istioIntegration.enabled=true",
+					}
+					valuesArgs = append(valuesArgs, extraValuesArgs...)
+				})
+				It("passes overrides to default GatewayParameters with custom sidecar", func() {
+					gwp := getDefaultGatewayParameters(testManifest)
+
+					gwpKube := gwp.Spec.Kube
+					Expect(gwpKube).ToNot(BeNil())
+
+					Expect(*gwpKube.GetDeployment().GetReplicas()).To(Equal(uint32(5)))
+
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullAlways))
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetRegistry()).To(Equal("envoy-override-registry"))
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetRepository()).To(Equal("envoy-override-repository"))
+					Expect(*gwpKube.GetEnvoyContainer().GetImage().GetTag()).To(Equal("envoy-override-tag"))
+
+					Expect(gwpKube.GetIstio().GetCustomSidecars()[0].Name).To(Equal("custom-sidecar"))
+					Expect(gwpKube.GetPodTemplate().GetExtraLabels()).To(matchers.ContainMapElements(map[string]string{"gloo": "kube-gateway"}))
+
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetPullPolicy()).To(Equal(corev1.PullNever))
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetRegistry()).To(Equal("sds-override-registry"))
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetRepository()).To(Equal("sds-override-repository"))
+					Expect(*gwpKube.GetSdsContainer().GetImage().GetTag()).To(Equal("sds-override-tag"))
+					Expect(*gwpKube.GetSdsContainer().GetBootstrap().GetLogLevel()).To(Equal("debug"))
+
+					Expect(*gwpKube.GetService().GetType()).To(Equal(corev1.ServiceTypeClusterIP))
+					Expect(gwpKube.GetService().GetExtraLabels()).To(matchers.ContainMapElements(map[string]string{"svclabel1": "a"}))
+					Expect(gwpKube.GetService().GetExtraAnnotations()).To(matchers.ContainMapElements(map[string]string{"svcanno1": "b"}))
+
+					Expect(gwpKube.GetServiceAccount().GetExtraLabels()).To(matchers.ContainMapElements(map[string]string{"label1": "a"}))
+					Expect(gwpKube.GetServiceAccount().GetExtraAnnotations()).To(matchers.ContainMapElements(map[string]string{"anno1": "b"}))
+				})
+			})
+
+			When("floatingUserId is set", func() {
+
+				DescribeTable("sets the floatingUserId field", func(expectedValue bool, extraValueArgs ...string) {
+					valuesArgs = append(valuesArgs, extraValueArgs...)
+					// Updated values so need to re-render
+					prepareHelmManifest(namespace, glootestutils.HelmValues{ValuesArgs: valuesArgs})
+
+					gwp := getDefaultGatewayParameters(testManifest)
+
+					gwpKube := gwp.Spec.Kube
+					Expect(gwpKube).ToNot(BeNil())
+
+					Expect(*gwpKube.GetFloatingUserId()).To(Equal(expectedValue))
+				},
+					Entry("locally true, globally true", true, "kubeGateway.gatewayParameters.glooGateway.floatingUserId=true", "global.securitySettings.floatingUserId=true"),
+					Entry("locally true, globally false", false, "kubeGateway.gatewayParameters.glooGateway.floatingUserId=true", "global.securitySettings.floatingUserId=false"),
+					Entry("locally true, globally undefined", true, "kubeGateway.gatewayParameters.glooGateway.floatingUserId=true"),
+					Entry("locally false, globally true", true, "kubeGateway.gatewayParameters.glooGateway.floatingUserId=false", "global.securitySettings.floatingUserId=true"),
+					Entry("locally false, globally false", false, "kubeGateway.gatewayParameters.glooGateway.floatingUserId=false", "global.securitySettings.floatingUserId=false"),
+					Entry("locally false, globally undefined", false, "kubeGateway.gatewayParameters.glooGateway.floatingUserId=false"),
+					Entry("locally undefined, globally true", true, "global.securitySettings.floatingUserId=true"),
+					Entry("locally undefined, globally false", false, "global.securitySettings.floatingUserId=false"),
+					Entry("locally undefined, globally undefined", false),
+				)
+			})
+
+			Context("probes and graceful shutdown", func() {
+				When("nothing is specified", func() {
+					It("does not render probes and graceful shutdown", func() {
+						gwp := getDefaultGatewayParameters(testManifest)
+
+						gwpPT := gwp.Spec.Kube.PodTemplate
+						Expect(gwpPT).ToNot(BeNil())
+
+						Expect(gwpPT.LivenessProbe).To(BeNil())
+						Expect(gwpPT.ReadinessProbe).To(BeNil())
+						Expect(gwpPT.GracefulShutdown).To(BeNil())
+						Expect(gwpPT.TerminationGracePeriodSeconds).To(BeNil())
+					})
+				})
+
+				When("probes are enabled", func() {
+					BeforeEach(func() {
+						extraValuesArgs := []string{
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.probes=true",
+						}
+
+						valuesArgs = append(valuesArgs, extraValuesArgs...)
+					})
+
+					It("sets the default values of the probes", func() {
+						gwp := getDefaultGatewayParameters(testManifest)
+						gwpPT := gwp.Spec.Kube.PodTemplate
+						Expect(*gwpPT.ReadinessProbe).To(BeEquivalentTo(corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								HTTPGet: &corev1.HTTPGetAction{
+									Scheme: "HTTP",
+									Port: intstr.IntOrString{
+										IntVal: 8082,
+									},
+									Path: "/envoy-hc",
+								},
+							},
+							InitialDelaySeconds: 5,
+							PeriodSeconds:       5,
+							FailureThreshold:    2,
+						}))
+						// There is no default liveness probe
+						Expect(gwpPT.LivenessProbe).To(BeNil())
+					})
+				})
+
+				When("custom probes are defined", func() {
+					BeforeEach(func() {
+						extraValuesArgs := []string{
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.probes=true",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customReadinessProbe.httpGet.scheme=HTTP",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customReadinessProbe.httpGet.port=9090",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customReadinessProbe.httpGet.path=/custom-readiness",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customReadinessProbe.failureThreshold=1",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customReadinessProbe.initialDelaySeconds=2",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customReadinessProbe.periodSeconds=3",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customLivenessProbe.exec.command[0]=wget",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customLivenessProbe.exec.command[1]=-O",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customLivenessProbe.exec.command[2]=/dev/null",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customLivenessProbe.exec.command[3]=127.0.0.1:9090/custom-liveness",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customLivenessProbe.failureThreshold=4",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customLivenessProbe.initialDelaySeconds=5",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.customLivenessProbe.periodSeconds=6",
+						}
+
+						valuesArgs = append(valuesArgs, extraValuesArgs...)
+					})
+
+					It("sets the custom values of the probes", func() {
+						gwp := getDefaultGatewayParameters(testManifest)
+						gwpPT := gwp.Spec.Kube.PodTemplate
+						Expect(*gwpPT.ReadinessProbe).To(BeEquivalentTo(corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								HTTPGet: &corev1.HTTPGetAction{
+									Scheme: "HTTP",
+									Port: intstr.IntOrString{
+										IntVal: 9090,
+									},
+									Path: "/custom-readiness",
+								},
+							},
+							FailureThreshold:    1,
+							InitialDelaySeconds: 2,
+							PeriodSeconds:       3,
+						}))
+						Expect(*gwpPT.LivenessProbe).To(BeEquivalentTo(corev1.Probe{
+							ProbeHandler: corev1.ProbeHandler{
+								Exec: &corev1.ExecAction{
+									Command: []string{
+										"wget",
+										"-O",
+										"/dev/null",
+										"127.0.0.1:9090/custom-liveness",
+									},
+								},
+							},
+							FailureThreshold:    4,
+							InitialDelaySeconds: 5,
+							PeriodSeconds:       6,
+						}))
+					})
+				})
+
+				When("gracefulShutdown and terminationGracePeriod is enabled", func() {
+					BeforeEach(func() {
+						extraValuesArgs := []string{
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.terminationGracePeriodSeconds=7",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.gracefulShutdown.enabled=true",
+							"kubeGateway.gatewayParameters.glooGateway.podTemplate.gracefulShutdown.sleepTimeSeconds=5",
+						}
+
+						valuesArgs = append(valuesArgs, extraValuesArgs...)
+					})
+
+					It("sets the custom values", func() {
+						gwp := getDefaultGatewayParameters(testManifest)
+						gwpPT := gwp.Spec.Kube.PodTemplate
+						Expect(*gwpPT.TerminationGracePeriodSeconds).To(Equal(7))
+						Expect(*gwpPT.GracefulShutdown).To(BeEquivalentTo(v1alpha1.GracefulShutdownSpec{
+							Enabled:          pointer.Bool(true),
+							SleepTimeSeconds: pointer.Int(5),
+						}))
+					})
+				})
+			})
+		})
+
+		When("kube gateway integration is disabled (default)", func() {
+			BeforeEach(func() {
+				valuesArgs = append(valuesArgs, "kubeGateway.enabled=false")
+			})
+
+			It("relevant resources are not rendered", func() {
+				deployment := getDeployment(testManifest, namespace, helpers.DefaultKgatewayDeploymentName)
+				Expect(deployment.Spec.Template.Spec.Containers).To(HaveLen(1), "should have exactly 1 container")
+
+				// the RBAC resources should not be rendered
+				testManifest.ExpectUnstructured("GatewayClass", "", wellknown.GatewayClassName).To(BeNil())
+
+				testManifest.ExpectUnstructured("GatewayParameters", namespace, wellknown.DefaultGatewayParametersName).To(BeNil())
+
+				controlPlaneRbacName := fmt.Sprintf("glood-%s.%s", releaseName, namespace)
+				testManifest.Expect("ClusterRole", "", controlPlaneRbacName).To(BeNil())
+				testManifest.Expect("ClusterRoleBinding", "", controlPlaneRbacName+"-binding").To(BeNil())
+
+				deployerRbacName := fmt.Sprintf("glood-%s-deploy.%s", releaseName, namespace)
+				testManifest.Expect("ClusterRole", "", deployerRbacName).To(BeNil())
+				testManifest.Expect("ClusterRoleBinding", "", deployerRbacName+"-binding").To(BeNil())
+			})
+		})
+	}
+	runTests(allTests)
+})
+
+func getDefaultGatewayParameters(t TestManifest) *v1alpha1.GatewayParameters {
+	gwpUnstructured := t.ExpectCustomResource("GatewayParameters", namespace, wellknown.DefaultGatewayParametersName)
+	obj, err := kuberesource.ConvertUnstructured(gwpUnstructured)
+	Expect(err).NotTo(HaveOccurred())
+
+	gwp, ok := obj.(*v1alpha1.GatewayParameters)
+	Expect(ok).To(BeTrue())
+	return gwp
+}
diff --git a/install/test/kube_utils.go b/install/test/kube_utils.go
new file mode 100644
index 000000000..5ea62df35
--- /dev/null
+++ b/install/test/kube_utils.go
@@ -0,0 +1,70 @@
+//go:build ignore
+
+package test
+
+import (
+	"fmt"
+
+	. "github.com/onsi/gomega"
+	"github.com/solo-io/k8s-utils/installutils/kuberesource"
+	. "github.com/solo-io/k8s-utils/manifesttestutils"
+	appsv1 "k8s.io/api/apps/v1"
+	batchv1 "k8s.io/api/batch/v1"
+	corev1 "k8s.io/api/core/v1"
+)
+
+//nolint:unparam // svcNamespace always receives "gloo-system"
+func getService(testManifest TestManifest, svcNamespace string, svcName string) *corev1.Service {
+	svcUns := testManifest.ExpectCustomResource("Service", svcNamespace, svcName)
+	svcObj, err := kuberesource.ConvertUnstructured(svcUns)
+	Expect(err).NotTo(HaveOccurred())
+	Expect(svcObj).To(BeAssignableToTypeOf(&corev1.Service{}))
+	return svcObj.(*corev1.Service)
+}
+
+//nolint:unparam // deploymentNamespace always receives "gloo-system"
+func getDeployment(testManifest TestManifest, deploymentNamespace string, deploymentName string) *appsv1.Deployment {
+	deployUns := testManifest.ExpectCustomResource("Deployment", deploymentNamespace, deploymentName)
+	deployObj, err := kuberesource.ConvertUnstructured(deployUns)
+	Expect(err).NotTo(HaveOccurred())
+	Expect(deployObj).To(BeAssignableToTypeOf(&appsv1.Deployment{}))
+	return deployObj.(*appsv1.Deployment)
+}
+
+//nolint:unparam // jobNamespace always receives "gloo-system"
+func getJob(testManifest TestManifest, jobNamespace string, jobName string) *batchv1.Job {
+	jobUns := testManifest.ExpectCustomResource("Job", jobNamespace, jobName)
+	jobObj, err := kuberesource.ConvertUnstructured(jobUns)
+	Expect(err).NotTo(HaveOccurred())
+	Expect(jobObj).To(BeAssignableToTypeOf(&batchv1.Job{}))
+	return jobObj.(*batchv1.Job)
+}
+
+//nolint:unparam // jobNamespace always receives "gloo-system"
+func getConfigMap(testManifest TestManifest, namespace string, name string) *corev1.ConfigMap {
+	configMapUns := testManifest.ExpectCustomResource("ConfigMap", namespace, name)
+	configMapObj, err := kuberesource.ConvertUnstructured(configMapUns)
+	Expect(err).NotTo(HaveOccurred())
+	Expect(configMapObj).To(BeAssignableToTypeOf(&corev1.ConfigMap{}))
+	return configMapObj.(*corev1.ConfigMap)
+}
+
+// verifies that the container contains the expected environment variable
+func expectEnvVarExists(container corev1.Container, expectedEnvVar corev1.EnvVar) {
+	foundName := false
+	for _, envVar := range container.Env {
+		if envVar.Name == expectedEnvVar.Name {
+			Expect(envVar).To(Equal(expectedEnvVar), fmt.Sprintf("expected env var %s to have value %v, but actual value was %v", envVar.Name, expectedEnvVar, envVar))
+			foundName = true
+			break
+		}
+	}
+	Expect(foundName).To(BeTrue(), fmt.Sprintf("env var with name %s should exist", expectedEnvVar.Name))
+}
+
+// verifies that the container does not contain an env var with the given name
+func expectEnvVarDoesNotExist(container corev1.Container, name string) {
+	for _, envVar := range container.Env {
+		Expect(envVar.Name).NotTo(Equal(name), fmt.Sprintf("env var with name %s should not exist", name))
+	}
+}
diff --git a/install/test/merge_ingress_values.yaml b/install/test/merge_ingress_values.yaml
new file mode 100644
index 000000000..f172de793
--- /dev/null
+++ b/install/test/merge_ingress_values.yaml
@@ -0,0 +1,39 @@
+discovery:
+  fdsMode: WHITELIST
+gateway:
+  enabled: false
+ingress:
+  deployment:
+    runAsUser: 10101
+    image:
+      # This is where we override the ingress image
+      registry: docker.io/ilackarms
+      repository: ingress
+      tag: test-ilackarms
+      pullPolicy: Always
+    replicas: 1
+    stats: false
+  enabled: false
+k8s:
+  clusterName: cluster.local
+namespace:
+  create: true
+global:
+  glooRbac:
+    create: true
+settings:
+  create: true
+  integrations:
+    knative:
+      enabled: true
+      version: 0.8.0
+      proxy:
+        httpPort: 80
+        httpsPort: 443
+        image:
+          pullPolicy: Always
+          registry: quay.io/solo-io
+          repository: gloo-envoy-wrapper
+          tag: 0.18.9
+        replicas: 1
+        stats: true
\ No newline at end of file
diff --git a/install/test/rbac_test.go b/install/test/rbac_test.go
new file mode 100644
index 000000000..2503cbc4a
--- /dev/null
+++ b/install/test/rbac_test.go
@@ -0,0 +1,948 @@
+//go:build ignore
+
+package test
+
+import (
+	"fmt"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	glootestutils "github.com/kgateway-dev/kgateway/v2/test/testutils"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/onsi/gomega/format"
+	. "github.com/solo-io/k8s-utils/manifesttestutils"
+	rbacv1 "k8s.io/api/rbac/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+)
+
+var _ = Describe("RBAC Test", func() {
+	format.MaxLength = 10000000
+	allTests := func(testCase renderTestCase) {
+		Describe(testCase.rendererName, func() {
+			var (
+				testManifest    TestManifest
+				resourceBuilder ResourceBuilder
+			)
+
+			prepareMakefile := func(helmFlags ...string) {
+				tm, err := testCase.renderer.RenderManifest(namespace, glootestutils.HelmValues{
+					// TODO: re-enable once our k8s gw integration supports namespaced rbac
+					ValuesArgs: append([]string{"kubeGateway.enabled=false"}, helmFlags...),
+				})
+				Expect(err).NotTo(HaveOccurred(), "Should be able to render the manifest in the RBAC unit test")
+				testManifest = tm
+			}
+
+			ExpectDiscoveryNotInRoleBindingSubjects := func(roleBindingName string) {
+				selectedResources := testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+					return resource.GetKind() == "RoleBinding" && resource.GetName() == roleBindingName
+				})
+				Expect(selectedResources.NumResources()).ToNot(BeZero(), fmt.Sprintf("could not find expected role binding: %s", roleBindingName))
+				selectedResources.ExpectAll(func(resource *unstructured.Unstructured) {
+					roleBinding := makeRoleBindingFromUnstructured(resource)
+					for _, subject := range roleBinding.Subjects {
+						Expect(subject.Name).To(Not(Equal("discovery")), "disabled discovery service should not be bound in %s", roleBinding.Name)
+					}
+				})
+			}
+
+			ExpectDiscoveryNotInClusterRoleBindingSubjects := func(clusterRoleBindingName string) {
+				selectedResources := testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+					return resource.GetKind() == "ClusterRoleBinding" && resource.GetName() == clusterRoleBindingName
+				})
+				Expect(selectedResources.NumResources()).ToNot(BeZero(), fmt.Sprintf("could not find expected cluster role binding: %s", clusterRoleBindingName))
+				selectedResources.ExpectAll(func(resource *unstructured.Unstructured) {
+					clusterRoleBinding := makeClusterRoleBindingFromUnstructured(resource)
+					for _, subject := range clusterRoleBinding.Subjects {
+						Expect(subject.Name).To(Not(Equal("discovery")), "disabled discovery service should not be bound in %s", clusterRoleBinding.Name)
+					}
+				})
+			}
+
+			Context("implementation-agnostic permissions", func() {
+				BeforeEach(func() {
+					format.MaxLength = 0
+				})
+				It("correctly assigns permissions for single-namespace gloo", func() {
+					prepareMakefile("namespace.create=true", "global.glooRbac.namespaced=true")
+					permissions := GetServiceAccountPermissions("gloo-system")
+					testManifest.ExpectPermissions(permissions)
+				})
+
+				It("correctly assigns permissions for cluster-scoped gloo", func() {
+					prepareMakefile("namespace.create=true", "global.glooRbac.namespaced=false")
+					permissions := GetServiceAccountPermissions("")
+					testManifest.ExpectPermissions(permissions)
+				})
+
+				It("creates no permissions when rbac is disabled", func() {
+					prepareMakefile("global.glooRbac.create=false")
+					testManifest.ExpectAll(func(resource *unstructured.Unstructured) {
+						Expect(resource.GetAPIVersion()).NotTo(ContainSubstring("rbac.authorization.k8s.io"), "Should not contain the RBAC API group")
+					})
+				})
+			})
+
+			Context("all cluster-scoped RBAC resources", func() {
+				checkSuffix := func(suffix string) {
+					rbacResources := testManifest.SelectResources(func(resource *unstructured.Unstructured) bool {
+						return resource.GetKind() == "ClusterRole" || resource.GetKind() == "ClusterRoleBinding"
+					})
+
+					Expect(rbacResources.NumResources()).NotTo(BeZero())
+
+					rbacResources.ExpectAll(func(resource *unstructured.Unstructured) {
+						Expect(resource.GetName()).To(HaveSuffix("-" + suffix))
+					})
+				}
+
+				It("is all named appropriately when a custom suffix is specified", func() {
+					suffix := "test-suffix"
+					prepareMakefile("global.glooRbac.nameSuffix=" + suffix)
+					checkSuffix(suffix)
+				})
+
+				It("is all named appropriately in a non-namespaced install", func() {
+					// be sure to pass these flags here so that all RBAC resources are rendered in the template
+					prepareMakefile("ingress.enabled=true", "settings.integrations.knative.enabled=true")
+					checkSuffix(namespace)
+				})
+			})
+
+			Context("kube-resource-watcher", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "kube-resource-watcher",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{""},
+								Resources: []string{"pods", "services", "secrets", "endpoints", "configmaps", "namespaces"},
+								Verbs:     []string{"get", "list", "watch"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "kube-resource-watcher",
+						},
+						Subjects: []rbacv1.Subject{{
+							Kind:      "ServiceAccount",
+							Name:      "gloo",
+							Namespace: namespace,
+						}, {
+							Kind:      "ServiceAccount",
+							Name:      "discovery",
+							Namespace: namespace,
+						}},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from cluster role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false", "discovery.enabled=false")
+						ExpectDiscoveryNotInClusterRoleBindingSubjects(resourceBuilder.GetClusterRoleBinding().GetName())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true", "discovery.enabled=false")
+						ExpectDiscoveryNotInRoleBindingSubjects(resourceBuilder.GetRoleBinding().GetName())
+					})
+				})
+			})
+
+			Context("gloo-upstream-mutator", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "gloo-upstream-mutator",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{"gloo.solo.io"},
+								Resources: []string{"upstreams"},
+								Verbs:     []string{"get", "list", "watch", "create", "update", "patch", "delete"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "gloo-upstream-mutator",
+						},
+						Subjects: []rbacv1.Subject{{
+							Kind:      "ServiceAccount",
+							Name:      "discovery",
+							Namespace: namespace,
+						}},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from cluster role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false", "discovery.enabled=false")
+						ExpectDiscoveryNotInClusterRoleBindingSubjects(resourceBuilder.GetClusterRoleBinding().GetName())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true", "discovery.enabled=false")
+						ExpectDiscoveryNotInRoleBindingSubjects(resourceBuilder.GetRoleBinding().GetName())
+					})
+				})
+			})
+
+			Context("gloo-resource-reader", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "gloo-resource-reader",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{"gloo.solo.io"},
+								Resources: []string{"upstreams", "upstreamgroups", "proxies"},
+								Verbs:     []string{"get", "list", "watch", "patch"},
+							},
+							{
+								APIGroups: []string{"enterprise.gloo.solo.io"},
+								Resources: []string{"authconfigs"},
+								Verbs:     []string{"get", "list", "watch", "patch"},
+							},
+							{
+								APIGroups: []string{"ratelimit.solo.io"},
+								Resources: []string{"ratelimitconfigs", "ratelimitconfigs/status"},
+								Verbs:     []string{"get", "list", "watch", "patch", "update"},
+							},
+							{
+								APIGroups: []string{"graphql.gloo.solo.io"},
+								Resources: []string{"graphqlapis", "graphqlapis/status"},
+								Verbs:     []string{"get", "list", "watch", "patch", "update"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "gloo-resource-reader",
+						},
+						Subjects: []rbacv1.Subject{{
+							Kind:      "ServiceAccount",
+							Name:      "gloo",
+							Namespace: namespace,
+						}},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+				})
+			})
+
+			Context("kube-leader-election", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "kube-leader-election",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{"coordination.k8s.io"},
+								Resources: []string{"leases"},
+								Verbs:     []string{"*"},
+							},
+							{
+								APIGroups: []string{""},
+								Resources: []string{"configmaps"},
+								Verbs:     []string{"*"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "kube-leader-election",
+						},
+						Subjects: []rbacv1.Subject{
+							{
+								Kind:      "ServiceAccount",
+								Name:      "gloo",
+								Namespace: namespace,
+							},
+							{
+								Kind:      "ServiceAccount",
+								Name:      "discovery",
+								Namespace: namespace,
+							},
+						},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+				})
+			})
+
+			Context("gloo-graphqlapi-mutator", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "gloo-graphqlapi-mutator",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{"graphql.gloo.solo.io"},
+								Resources: []string{"graphqlapis", "graphqlapis/status"},
+								Verbs:     []string{"get", "list", "watch", "update", "patch", "create"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "gloo-graphqlapi-mutator",
+						},
+						Subjects: []rbacv1.Subject{{
+							Kind:      "ServiceAccount",
+							Name:      "discovery",
+							Namespace: namespace,
+						}},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from cluster role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false", "discovery.enabled=false")
+						ExpectDiscoveryNotInClusterRoleBindingSubjects(resourceBuilder.GetClusterRoleBinding().GetName())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true", "discovery.enabled=false")
+						ExpectDiscoveryNotInRoleBindingSubjects(resourceBuilder.GetRoleBinding().GetName())
+					})
+				})
+			})
+
+			Context("settings-user", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "settings-user",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{"gloo.solo.io"},
+								Resources: []string{"settings"},
+								Verbs:     []string{"get", "list", "watch"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "settings-user",
+						},
+						Subjects: []rbacv1.Subject{{
+							Kind:      "ServiceAccount",
+							Name:      "gloo",
+							Namespace: namespace,
+						}, {
+							Kind:      "ServiceAccount",
+							Name:      "gateway",
+							Namespace: namespace,
+						}, {
+							Kind:      "ServiceAccount",
+							Name:      "discovery",
+							Namespace: namespace,
+						}},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from cluster role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false", "discovery.enabled=false")
+						ExpectDiscoveryNotInClusterRoleBindingSubjects(resourceBuilder.GetClusterRoleBinding().GetName())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+
+					It("disabling discovery removes its service account from role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true", "discovery.enabled=false")
+						ExpectDiscoveryNotInRoleBindingSubjects(resourceBuilder.GetRoleBinding().GetName())
+					})
+				})
+			})
+
+			Context("certgen job", func() {
+				It("Cluster scope", func() {
+					prepareMakefile("global.glooRbac.namespaced=false")
+					By("roles", func() {
+						testManifest.ExpectRole(&rbacv1.
+							Role{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "Role",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name:      "gloo-gateway-secret-create-gloo-system",
+								Namespace: "gloo-system",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Rules: []rbacv1.PolicyRule{
+								{
+									Verbs:           []string{"create", "get", "update"},
+									APIGroups:       []string{""},
+									Resources:       []string{"secrets"},
+									ResourceNames:   nil,
+									NonResourceURLs: nil,
+								},
+							},
+						})
+						testManifest.ExpectClusterRole(&rbacv1.ClusterRole{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "ClusterRole",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name: "gloo-gateway-vwc-update-gloo-system",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Rules: []rbacv1.PolicyRule{
+								{
+									Verbs:           []string{"get", "update"},
+									APIGroups:       []string{"admissionregistration.k8s.io"},
+									Resources:       []string{"validatingwebhookconfigurations"},
+									ResourceNames:   nil,
+									NonResourceURLs: nil,
+								},
+							},
+							AggregationRule: nil,
+						})
+					})
+					By("role bindings", func() {
+						testManifest.ExpectRoleBinding(&rbacv1.RoleBinding{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "RoleBinding",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name:      "gloo-gateway-secret-create-gloo-system",
+								Namespace: "gloo-system",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Subjects: []rbacv1.Subject{{
+								Kind:      "ServiceAccount",
+								APIGroup:  "",
+								Name:      "certgen",
+								Namespace: "gloo-system",
+							}},
+							RoleRef: rbacv1.RoleRef{
+								APIGroup: "rbac.authorization.k8s.io",
+								Kind:     "Role",
+								Name:     "gloo-gateway-secret-create-gloo-system",
+							},
+						})
+						testManifest.ExpectClusterRoleBinding(&rbacv1.ClusterRoleBinding{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "ClusterRoleBinding",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name: "gloo-gateway-vwc-update-gloo-system",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Subjects: []rbacv1.Subject{{
+								Kind:      "ServiceAccount",
+								APIGroup:  "",
+								Name:      "certgen",
+								Namespace: "gloo-system",
+							}},
+							RoleRef: rbacv1.RoleRef{
+								APIGroup: "rbac.authorization.k8s.io",
+								Kind:     "ClusterRole",
+								Name:     "gloo-gateway-vwc-update-gloo-system",
+							},
+						})
+					})
+				})
+				It("Namespace scope", func() {
+					prepareMakefile("global.glooRbac.namespaced=true")
+					By("roles", func() {
+						testManifest.ExpectRole(&rbacv1.Role{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "Role",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name:      "gloo-gateway-secret-create",
+								Namespace: "gloo-system",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Rules: []rbacv1.PolicyRule{{
+								Verbs:           []string{"create", "get", "update"},
+								APIGroups:       []string{""},
+								Resources:       []string{"secrets"},
+								ResourceNames:   nil,
+								NonResourceURLs: nil,
+							}},
+						})
+						testManifest.ExpectClusterRole(&rbacv1.ClusterRole{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "ClusterRole",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name: "gloo-gateway-vwc-update",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Rules: []rbacv1.PolicyRule{
+								{
+									Verbs:           []string{"get", "update"},
+									APIGroups:       []string{"admissionregistration.k8s.io"},
+									Resources:       []string{"validatingwebhookconfigurations"},
+									ResourceNames:   nil,
+									NonResourceURLs: nil,
+								},
+							},
+							AggregationRule: nil,
+						})
+					})
+					By("role bindings", func() {
+						testManifest.ExpectRoleBinding(&rbacv1.RoleBinding{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "RoleBinding",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name:      "gloo-gateway-secret-create",
+								Namespace: "gloo-system",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Subjects: []rbacv1.Subject{{
+								Kind:      "ServiceAccount",
+								APIGroup:  "",
+								Name:      "certgen",
+								Namespace: "gloo-system",
+							}},
+							RoleRef: rbacv1.RoleRef{
+								APIGroup: "rbac.authorization.k8s.io",
+								Kind:     "Role",
+								Name:     "gloo-gateway-secret-create",
+							},
+						})
+						testManifest.ExpectClusterRoleBinding(&rbacv1.ClusterRoleBinding{
+							TypeMeta: metav1.TypeMeta{
+								Kind:       "ClusterRoleBinding",
+								APIVersion: "rbac.authorization.k8s.io/v1",
+							},
+							ObjectMeta: metav1.ObjectMeta{
+								Name: "gloo-gateway-vwc-update",
+								Labels: map[string]string{
+									"app":                    "gloo",
+									"gloo":                   "rbac",
+									"gloo.solo.io/component": "certgen",
+								},
+								Annotations: map[string]string{
+									"helm.sh/hook-weight": "5",
+									"helm.sh/hook":        "pre-install,pre-upgrade",
+								},
+							},
+							Subjects: []rbacv1.Subject{{
+								Kind:      "ServiceAccount",
+								APIGroup:  "",
+								Name:      "certgen",
+								Namespace: "gloo-system",
+							}},
+							RoleRef: rbacv1.RoleRef{
+								APIGroup: "rbac.authorization.k8s.io",
+								Kind:     "ClusterRole",
+								Name:     "gloo-gateway-vwc-update",
+							},
+						})
+					})
+				})
+			})
+
+			Context("gloo-resource-mutator", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "gloo-resource-mutator",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{"gloo.solo.io"},
+								Resources: []string{"proxies"},
+								Verbs:     []string{"get", "list", "watch", "create", "update", "patch", "delete"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "gloo-resource-mutator",
+						},
+						Subjects: []rbacv1.Subject{
+							{
+								Kind:      "ServiceAccount",
+								Name:      "gateway",
+								Namespace: namespace,
+							},
+							{
+								Kind:      "ServiceAccount",
+								Name:      "gloo",
+								Namespace: namespace,
+							},
+						},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+				})
+			})
+
+			Context("gateway-resource-reader", func() {
+				BeforeEach(func() {
+					resourceBuilder = ResourceBuilder{
+						Name: "gateway-resource-reader",
+						Labels: map[string]string{
+							"app":  "gloo",
+							"gloo": "rbac",
+						},
+						Rules: []rbacv1.PolicyRule{
+							{
+								APIGroups: []string{"gateway.solo.io"},
+								Resources: []string{"gateways", "httpgateways", "tcpgateways", "virtualservices", "routetables", "virtualhostoptions", "routeoptions"},
+								Verbs:     []string{"get", "list", "watch", "patch"},
+							},
+						},
+						RoleRef: rbacv1.RoleRef{
+							APIGroup: "rbac.authorization.k8s.io",
+							Kind:     "ClusterRole",
+							Name:     "gateway-resource-reader",
+						},
+						Subjects: []rbacv1.Subject{
+							{
+								Kind:      "ServiceAccount",
+								Name:      "gateway",
+								Namespace: namespace,
+							},
+							{
+								Kind:      "ServiceAccount",
+								Name:      "gloo",
+								Namespace: namespace,
+							},
+						},
+					}
+				})
+				Context("cluster scope", func() {
+					It("role", func() {
+						resourceBuilder.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRole(resourceBuilder.GetClusterRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding-" + namespace
+						resourceBuilder.RoleRef.Name += "-" + namespace
+						prepareMakefile("global.glooRbac.namespaced=false")
+						testManifest.ExpectClusterRoleBinding(resourceBuilder.GetClusterRoleBinding())
+					})
+				})
+				Context("namespace scope", func() {
+					BeforeEach(func() {
+						resourceBuilder.RoleRef.Kind = "Role"
+						resourceBuilder.Namespace = namespace
+					})
+
+					It("role", func() {
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRole(resourceBuilder.GetRole())
+					})
+
+					It("role binding", func() {
+						resourceBuilder.Name += "-binding"
+						prepareMakefile("global.glooRbac.namespaced=true")
+						testManifest.ExpectRoleBinding(resourceBuilder.GetRoleBinding())
+					})
+				})
+			})
+		})
+	}
+
+	runTests(allTests)
+})
diff --git a/install/test/rbac_utils.go b/install/test/rbac_utils.go
new file mode 100644
index 000000000..d2feb13ce
--- /dev/null
+++ b/install/test/rbac_utils.go
@@ -0,0 +1,114 @@
+//go:build ignore
+
+package test
+
+import "github.com/solo-io/k8s-utils/manifesttestutils"
+
+func GetServiceAccountPermissions(namespace string) *manifesttestutils.ServiceAccountPermissions {
+	permissions := &manifesttestutils.ServiceAccountPermissions{}
+
+	// Gloo
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{""},
+		[]string{"pods", "services", "configmaps", "namespaces", "secrets", "endpoints"},
+		[]string{"get", "list", "watch"})
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{""},
+		[]string{"configmaps"},
+		[]string{"*"},
+	)
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"coordination.k8s.io"},
+		[]string{"leases"},
+		[]string{"*"},
+	)
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"gloo.solo.io"},
+		[]string{"upstreams", "upstreamgroups", "proxies"},
+		[]string{"get", "list", "watch", "patch"})
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"gateway.solo.io"},
+		[]string{"gateways", "httpgateways", "tcpgateways", "virtualservices", "routetables", "virtualhostoptions", "routeoptions"},
+		[]string{"get", "list", "watch", "patch"})
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"gloo.solo.io"},
+		[]string{"proxies"},
+		[]string{"get", "list", "watch", "update", "patch", "create", "delete"})
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"gloo.solo.io"},
+		[]string{"settings"},
+		[]string{"get", "list", "watch"})
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"enterprise.gloo.solo.io"},
+		[]string{"authconfigs"},
+		[]string{"get", "list", "watch", "patch"})
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"ratelimit.solo.io"},
+		[]string{"ratelimitconfigs", "ratelimitconfigs/status"},
+		[]string{"get", "list", "watch", "patch", "update"})
+	permissions.AddExpectedPermission(
+		"gloo-system.gloo",
+		namespace,
+		[]string{"graphql.gloo.solo.io"},
+		[]string{"graphqlapis", "graphqlapis/status"},
+		[]string{"get", "list", "watch", "patch", "update"})
+
+	// Discovery
+	permissions.AddExpectedPermission(
+		"gloo-system.discovery",
+		namespace,
+		[]string{""},
+		[]string{"pods", "services", "configmaps", "namespaces", "secrets", "endpoints"},
+		[]string{"get", "list", "watch"})
+	permissions.AddExpectedPermission(
+		"gloo-system.discovery",
+		namespace,
+		[]string{""},
+		[]string{"configmaps"},
+		[]string{"*"},
+	)
+	permissions.AddExpectedPermission(
+		"gloo-system.discovery",
+		namespace,
+		[]string{"coordination.k8s.io"},
+		[]string{"leases"},
+		[]string{"*"},
+	)
+	permissions.AddExpectedPermission(
+		"gloo-system.discovery",
+		namespace,
+		[]string{"gloo.solo.io"},
+		[]string{"settings"},
+		[]string{"get", "list", "watch"})
+	permissions.AddExpectedPermission(
+		"gloo-system.discovery",
+		namespace,
+		[]string{"gloo.solo.io"},
+		[]string{"upstreams"},
+		[]string{"get", "list", "watch", "create", "update", "patch", "delete"})
+	permissions.AddExpectedPermission(
+		"gloo-system.discovery",
+		namespace,
+		[]string{"graphql.gloo.solo.io"},
+		[]string{"graphqlapis", "graphqlapis/status"},
+		[]string{"get", "list", "watch", "update", "patch", "create"})
+	return permissions
+}
diff --git a/install/test/securitycontext/utils.go b/install/test/securitycontext/utils.go
new file mode 100644
index 000000000..d350afd74
--- /dev/null
+++ b/install/test/securitycontext/utils.go
@@ -0,0 +1,203 @@
+//go:build ignore
+
+package securitycontext
+
+import (
+	"fmt"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+	"github.com/solo-io/k8s-utils/installutils/kuberesource"
+	. "github.com/solo-io/k8s-utils/manifesttestutils"
+	appsv1 "k8s.io/api/apps/v1"
+	batchv1 "k8s.io/api/batch/v1"
+	corev1 "k8s.io/api/core/v1"
+
+	"github.com/onsi/gomega/types"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/utils/ptr"
+)
+
+const (
+	defaultRunAsUser = 10101 // from values-template.yaml
+)
+
+// ApplyContainerSecurityDefaults describes a function that modifies a SecurityContext
+// These functions are used in testing to modify the default "expected" security context of a container to match the template-specific defaults
+type ApplyContainerSecurityDefaults func(*corev1.SecurityContext)
+
+// ApplyNilSecurityDefaults is a function that does nothing and can be used as a default value for ApplyContainerSecurityDefaults
+var ApplyNilSecurityDefaults = ApplyContainerSecurityDefaults(func(securityContext *corev1.SecurityContext) {})
+
+// ApplyDiscoverySecurityDefaults will update the security context to match the defaults for the discovery container
+var ApplyDiscoverySecurityDefaults = ApplyContainerSecurityDefaults(func(securityContext *corev1.SecurityContext) {
+	securityContext.ReadOnlyRootFilesystem = ptr.To(true)
+	securityContext.RunAsUser = ptr.To(int64(defaultRunAsUser))
+})
+
+// ApplyRunAsUserSecurityDefaults will update the runAsUser fields of the security context to the default value
+var ApplyRunAsUserSecurityDefaults = ApplyContainerSecurityDefaults(func(securityContext *corev1.SecurityContext) {
+	securityContext.RunAsUser = ptr.To(int64(defaultRunAsUser))
+})
+
+// ApplyKnativeSecurityDefaults updates the security context to match the defaults for Knative services
+var ApplyKnativeSecurityDefaults = ApplyContainerSecurityDefaults(func(securityContext *corev1.SecurityContext) {
+	securityContext.RunAsUser = ptr.To(int64(defaultRunAsUser))
+	securityContext.ReadOnlyRootFilesystem = ptr.To(true)
+	securityContext.Capabilities = &corev1.Capabilities{
+		Drop: []corev1.Capability{"ALL"},
+		Add:  []corev1.Capability{"NET_BIND_SERVICE"},
+	}
+})
+
+// ApplyClusterIngressSecurityDefaults updates the security context to match the defaults for the ClusterIngress service
+var ApplyClusterIngressSecurityDefaults = ApplyContainerSecurityDefaults(func(securityContext *corev1.SecurityContext) {
+	securityContext.Capabilities = &corev1.Capabilities{
+		Drop: []corev1.Capability{"ALL"},
+		Add:  []corev1.Capability{"NET_BIND_SERVICE"},
+	}
+	securityContext.ReadOnlyRootFilesystem = ptr.To(true)
+})
+
+// GetDefaultRestrictedContainerSecurityContext applies the `applyContainerDefaults` function to the default restricted container security context
+// and sets the SeccompProfile to the provided `seccompType.
+var GetDefaultRestrictedContainerSecurityContext = func(seccompType string, applyContainerDefaults ApplyContainerSecurityDefaults) *corev1.SecurityContext {
+	// Use default value if not set
+	if seccompType == "" {
+		seccompType = "RuntimeDefault"
+	}
+
+	defaultRestrictedContainerSecurityContext := &corev1.SecurityContext{
+		RunAsNonRoot:             ptr.To(true),
+		AllowPrivilegeEscalation: ptr.To(false),
+		Capabilities: &corev1.Capabilities{
+			Drop: []corev1.Capability{"ALL"},
+		},
+		SeccompProfile: &corev1.SeccompProfile{
+			Type: corev1.SeccompProfileType(seccompType),
+		},
+	}
+	applyContainerDefaults(defaultRestrictedContainerSecurityContext)
+	return defaultRestrictedContainerSecurityContext
+}
+
+// DefaultOverrides is a map of resource names to a map of container names to ApplyContainerSecurityDefaults functions
+// Used to generated expected security contexts for specific containers in specific jobs and deployments
+var DefaultOverrides = map[string]map[string]ApplyContainerSecurityDefaults{
+	"gloo": {
+		"gloo":          ApplyDiscoverySecurityDefaults,
+		"envoy-sidecar": ApplyRunAsUserSecurityDefaults,
+		"sds":           ApplyRunAsUserSecurityDefaults,
+	},
+	"discovery":                     {"discovery": ApplyDiscoverySecurityDefaults},
+	"gateway-proxy":                 {"gateway-proxy": ApplyDiscoverySecurityDefaults},
+	"gloo-mtls-certgen":             {"certgen": ApplyRunAsUserSecurityDefaults},
+	"gloo-resource-cleanup":         {"kubectl": ApplyRunAsUserSecurityDefaults},
+	"gloo-resource-migration":       {"kubectl": ApplyRunAsUserSecurityDefaults},
+	"gloo-resource-rollout-check":   {"kubectl": ApplyRunAsUserSecurityDefaults},
+	"gloo-resource-rollout-cleanup": {"kubectl": ApplyRunAsUserSecurityDefaults},
+	"gloo-resource-rollout":         {"kubectl": ApplyRunAsUserSecurityDefaults},
+	"prometheus-server-migration":   {"prometheus-server-migration": ApplyRunAsUserSecurityDefaults},
+	"gateway-certgen":               {"certgen": ApplyRunAsUserSecurityDefaults},
+	"ingress-proxy":                 {"ingress-proxy": ApplyKnativeSecurityDefaults},
+	"clusteringress-proxy":          {"clusteringress-proxy": ApplyClusterIngressSecurityDefaults},
+	"knative-external-proxy":        {"knative-external-proxy": ApplyKnativeSecurityDefaults},
+	"knative-internal-proxy":        {"knative-internal-proxy": ApplyKnativeSecurityDefaults},
+	"gloo-mtls-certgen-cronjob":     {"certgen": ApplyRunAsUserSecurityDefaults},
+	"gateway-certgen-cronjob":       {"certgen": ApplyRunAsUserSecurityDefaults},
+}
+
+// FilterAndValidateSecurityContexts will filter the resources in the TestManifest using the provided filter function
+// and apply the passed validateContainer function to each container in the filtered resources. Returns the number of non-filtered containers found.
+func FilterAndValidateSecurityContexts(
+	testManifest TestManifest,
+	validateContainer func(container corev1.Container, resourceName string),
+	containerMatcher types.GomegaMatcher,
+	filter func(resource *unstructured.Unstructured) bool,
+) {
+	foundContainers := 0
+
+	testManifest.SelectResources(filter).ExpectAll(func(resource *unstructured.Unstructured) {
+
+		if resource.GetKind() != "Deployment" && resource.GetKind() != "Job" && resource.GetKind() != "CronJob" {
+			// It's not a resource we care about, and it might throw and error if we try to cast it
+			return
+		}
+		// Get the pods and validate their security context
+		var containers []corev1.Container
+		resourceUncast, err := kuberesource.ConvertUnstructured(resource)
+		Expect(err).NotTo(HaveOccurred())
+
+		switch resource.GetKind() {
+		case "Deployment":
+			deployment := resourceUncast.(*appsv1.Deployment)
+			containers = deployment.Spec.Template.Spec.Containers
+		case "Job":
+			job := resourceUncast.(*batchv1.Job)
+			containers = job.Spec.Template.Spec.Containers
+		case "CronJob":
+			job := resourceUncast.(*batchv1.CronJob)
+			containers = job.Spec.JobTemplate.Spec.Template.Spec.Containers
+		default:
+			// We should never get here as we've checked the resource kind above
+			Fail(fmt.Sprintf("Unexpected resource kind: %s", resource.GetKind()))
+		}
+
+		for _, container := range containers {
+			// Uncomment this to print the enumerated list of containers
+			// fmt.Printf("%s, %s, %s\n", resource.GetKind(), resource.GetName(), container.Name)
+			foundContainers += 1
+			validateContainer(container, resource.GetName())
+		}
+	})
+
+	containerMatcher.Match(foundContainers)
+}
+
+// ValidateSecurityContexts passes through the TestManifest and validateContainer function to FilterAndValidateSecurityContexts and
+// creates a filter used to select Deployment, Job, and CronJob resources for validation.
+func ValidateSecurityContexts(testManifest TestManifest, validateContainer func(container corev1.Container, resourceName string), containerMatcher types.GomegaMatcher) {
+	FilterAndValidateSecurityContexts(testManifest, validateContainer, containerMatcher, func(resource *unstructured.Unstructured) bool {
+		return true
+	})
+}
+
+// ExpectedContainers is the number of expected containers found when ValidateSecurityContexts is called on a TestManifest
+const ExpectedContainers = 21
+
+// Deployment, gloo, envoy-sidecar
+// Deployment, gloo, sds
+// Deployment, gloo, gloo
+// Deployment, ingress, ingress
+// Deployment, ingress-proxy, ingress-proxy
+// Deployment, knative-external-proxy, knative-external-proxy
+// Deployment, knative-internal-proxy, knative-internal-proxy
+// Deployment, discovery, discovery
+// Deployment, gateway-proxy-access-logger, access-logger
+// Deployment, gateway-proxy, gateway-proxy
+// Deployment, gateway-proxy, sds
+// Deployment, gateway-proxy, istio-proxy
+// Job, gloo-resource-rollout, kubectl
+// CronJob, gloo-mtls-certgen-cronjob, certgen
+// CronJob, gateway-certgen-cronjob, certgen
+// Job, gloo-mtls-certgen, certgen
+// Job, gloo-resource-cleanup, kubectl
+// Job, gloo-resource-migration, kubectl
+// Job, gloo-resource-rollout-check, kubectl
+// Job, gloo-resource-rollout-cleanup, kubectl
+// Job, gateway-certgen, certgen
+
+// ContainerSecurityContextRoots is a list of paths to the root of the container security context in the Helm charts
+var ContainerSecurityContextRoots = []string{
+	"accessLogger.accessLoggerContainerSecurityContext",
+	"discovery.deployment.discoveryContainerSecurityContext",
+	"gateway.certGenJob.containerSecurityContext",
+	"gatewayProxies.gatewayProxy.podTemplate.glooContainerSecurityContext",
+	"global.glooMtls.envoy.securityContext",
+	"global.glooMtls.istioProxy.securityContext",
+	"global.glooMtls.sds.securityContext",
+	"gloo.deployment.glooContainerSecurityContext",
+	"ingress.deployment.ingressContainerSecurityContext",
+	"ingressProxy.deployment.ingressProxyContainerSecurityContext",
+	"settings.integrations.knative.proxy.containerSecurityContext",
+}
diff --git a/install/test/svc_accnt_test.go b/install/test/svc_accnt_test.go
new file mode 100644
index 000000000..1d099ec83
--- /dev/null
+++ b/install/test/svc_accnt_test.go
@@ -0,0 +1,69 @@
+//go:build ignore
+
+package test
+
+import (
+	. "github.com/onsi/ginkgo/v2"
+
+	glootestutils "github.com/kgateway-dev/kgateway/v2/test/testutils"
+
+	. "github.com/onsi/gomega"
+	. "github.com/solo-io/k8s-utils/manifesttestutils"
+)
+
+var _ = Describe("SVC Accnt Test", func() {
+	var allTests = func(testCase renderTestCase) {
+		Describe(testCase.rendererName, func() {
+			var (
+				testManifest    TestManifest
+				resourceBuilder ResourceBuilder
+			)
+
+			prepareMakefile := func(name string, helmFlags []string) {
+				resourceBuilder.Name = name
+				resourceBuilder.Labels["gloo"] = name
+
+				tm, err := testCase.renderer.RenderManifest(namespace, glootestutils.HelmValues{
+					ValuesArgs: helmFlags,
+				})
+				Expect(err).NotTo(HaveOccurred(), "Should be able to render the manifest in the service account unit test")
+				testManifest = tm
+			}
+
+			BeforeEach(func() {
+				resourceBuilder = ResourceBuilder{
+					Namespace: namespace,
+					Labels: map[string]string{
+						"app": "gloo",
+					},
+				}
+			})
+
+			It("gloo", func() {
+				prepareMakefile("gloo", []string{"global.glooRbac.namespaced=false"})
+				testManifest.ExpectServiceAccount(resourceBuilder.GetServiceAccount())
+			})
+
+			It("discovery", func() {
+				prepareMakefile("discovery", []string{"global.glooRbac.namespaced=false"})
+				testManifest.ExpectServiceAccount(resourceBuilder.GetServiceAccount())
+			})
+
+			It("gateway-proxy", func() {
+				prepareMakefile("gateway-proxy", []string{"global.glooRbac.namespaced=false"})
+				svcAccount := resourceBuilder.GetServiceAccount()
+				testManifest.ExpectServiceAccount(svcAccount)
+			})
+
+			It("gateway-proxy disables svc account", func() {
+				prepareMakefile("gateway-proxy", []string{"global.glooRbac.namespaced=false", "gateway.proxyServiceAccount.disableAutomount=true"})
+				svcAccount := resourceBuilder.GetServiceAccount()
+				falze := false
+				svcAccount.AutomountServiceAccountToken = &falze
+				testManifest.ExpectServiceAccount(svcAccount)
+			})
+		})
+	}
+
+	runTests(allTests)
+})
diff --git a/install/test/values/val_access_logger.yaml b/install/test/values/val_access_logger.yaml
new file mode 100644
index 000000000..26c32b3b8
--- /dev/null
+++ b/install/test/values/val_access_logger.yaml
@@ -0,0 +1,2 @@
+accessLogger:
+  enabled: true
\ No newline at end of file
diff --git a/install/test/values/val_consul_discovery_test_inputs.yaml b/install/test/values/val_consul_discovery_test_inputs.yaml
new file mode 100644
index 000000000..afb62b0f6
--- /dev/null
+++ b/install/test/values/val_consul_discovery_test_inputs.yaml
@@ -0,0 +1,9 @@
+settings:
+  integrations:
+    consulUpstreamDiscovery:
+      useTlsTagging: true
+      tlsTagName: tag
+      splitTlsServices: true
+      rootCa:
+        name: testName
+        namespace: testNamespace
\ No newline at end of file
diff --git a/install/test/values/val_consul_test_inputs.yaml b/install/test/values/val_consul_test_inputs.yaml
new file mode 100644
index 000000000..eb4a5a5d3
--- /dev/null
+++ b/install/test/values/val_consul_test_inputs.yaml
@@ -0,0 +1,20 @@
+settings:
+  integrations:
+    consul:
+      datacenter: datacenter
+      username: user
+      password: password
+      token: aToken
+      caFile: testCaFile
+      caPath: testCaPath
+      certFile: testCertFile
+      keyFile: testKeyFile
+      insecureSkipVerify: true
+      waitTime: 12s
+      serviceDiscovery:
+        dataCenters:
+          - dc1
+          - dc2
+      httpAddress: 1.2.3.4
+      dnsAddress: 5.6.7.8
+      dnsPollingInterval: 5s
\ No newline at end of file
diff --git a/install/test/values/val_custom_bootstrap_extensions.yaml b/install/test/values/val_custom_bootstrap_extensions.yaml
new file mode 100644
index 000000000..fe49913ae
--- /dev/null
+++ b/install/test/values/val_custom_bootstrap_extensions.yaml
@@ -0,0 +1,14 @@
+gatewayProxies:
+  gatewayProxy:
+    envoyBootstrapExtensions:
+    - name: envoy.wasm_service
+      typed_config:
+        "@type": type.googleapis.com/envoy.extensions.wasm.v3.WasmService
+        config:
+          name: "my_plugin"
+          vm_config:
+            runtime: "envoy.wasm.runtime.v8"
+            code:
+              local:
+                filename: "/etc/envoy_filter_http_wasm_example.wasm"
+        singleton: true
\ No newline at end of file
diff --git a/install/test/values/val_custom_gateways.yaml b/install/test/values/val_custom_gateways.yaml
new file mode 100644
index 000000000..774332edd
--- /dev/null
+++ b/install/test/values/val_custom_gateways.yaml
@@ -0,0 +1,48 @@
+gatewayProxies:
+  gatewayProxy:
+    gatewaySettings:
+      useProxyProto: true
+      customHttpGateway:
+        virtualServices:
+        - name: one
+          namespace: one
+      customHttpsGateway:
+        virtualServices:
+        - name: one
+          namespace: one
+  testName:
+    gatewaySettings:
+      useProxyProto: true
+      customHttpGateway:
+        virtualServices:
+        - name: one
+          namespace: one
+      customHttpsGateway:
+        virtualServices:
+        - name: one
+          namespace: one
+    kind:
+      deployment:
+        replicas: 1
+    podTemplate:
+      disableNetBind: false
+      floatingUserId: false
+      httpPort: 8081
+      httpsPort: 8444
+      image:
+        pullPolicy: Always
+        repository: gloo-envoy-wrapper
+        tag: dev
+      probes: false
+      runAsUser: 10101
+      runUnprivileged: false
+      tolerations: null
+    readConfig: false
+    service:
+      httpPort: 80
+      httpsPort: 443
+      type: LoadBalancer
+    stats:
+      enabled: true
+    configMap:
+      data: null
diff --git a/install/test/values/val_custom_istio_sidecar.yaml b/install/test/values/val_custom_istio_sidecar.yaml
new file mode 100644
index 000000000..5e871ab2f
--- /dev/null
+++ b/install/test/values/val_custom_istio_sidecar.yaml
@@ -0,0 +1,108 @@
+global:
+  istioSDS:
+    enabled: true
+    customSidecars:
+      - name: istio-proxy
+        image: docker.io/istio/proxyv2:1.6.6
+        args:
+        - proxy
+        - sidecar
+        - --domain
+        - $(POD_NAMESPACE).svc.cluster.local
+        - --configPath
+        - /etc/istio/proxy
+        - --binaryPath
+        - /usr/local/bin/envoy
+        - --serviceCluster
+        - istio-proxy-prometheus
+        - --drainDuration
+        - 45s
+        - --parentShutdownDuration
+        - 1m0s
+        - --proxyLogLevel=warning
+        - --proxyComponentLogLevel=misc:error
+        - --connectTimeout
+        - 10s
+        - --proxyAdminPort
+        - "15000"
+        - --controlPlaneAuthPolicy
+        - NONE
+        - --dnsRefreshRate
+        - 300s
+        - --statusPort
+        - "15021"
+        - --controlPlaneBootstrap=false
+        env:
+          - name: OUTPUT_CERTS
+            value: "/etc/istio-certs"
+          - name: JWT_POLICY
+            value: third-party-jwt
+          - name: PILOT_CERT_PROVIDER
+            value: istiod
+          - name: CA_ADDR
+            value: istiod.istio-system.svc:15012
+          - name: ISTIO_META_MESH_ID
+            value: cluster.local
+          - name: PROXY_CONFIG
+            value: |
+              {"discoveryAddress": "istiod.istio-system.svc:15012"}
+          - name: POD_NAME
+            valueFrom:
+              fieldRef:
+                fieldPath: metadata.name
+          - name: POD_NAMESPACE
+            valueFrom:
+              fieldRef:
+                fieldPath: metadata.namespace
+          - name: INSTANCE_IP
+            valueFrom:
+              fieldRef:
+                fieldPath: status.podIP
+          - name: SERVICE_ACCOUNT
+            valueFrom:
+              fieldRef:
+                fieldPath: spec.serviceAccountName
+          - name: HOST_IP
+            valueFrom:
+              fieldRef:
+                fieldPath: status.hostIP
+          - name: ISTIO_META_POD_NAME
+            valueFrom:
+              fieldRef:
+                apiVersion: v1
+                fieldPath: metadata.name
+          - name: ISTIO_META_CONFIG_NAMESPACE
+            valueFrom:
+              fieldRef:
+                apiVersion: v1
+                fieldPath: metadata.namespace
+        imagePullPolicy: IfNotPresent
+        readinessProbe:
+          failureThreshold: 3
+          httpGet:
+            path: /healthz/ready
+            port: 15021
+            scheme: HTTP
+          initialDelaySeconds: 3
+          periodSeconds: 10
+          successThreshold: 1
+          timeoutSeconds: 1
+        livenessProbe:
+            failureThreshold: 3
+            httpGet:
+              path: /healthz/live
+              port: 15021
+              scheme: HTTP
+            initialDelaySeconds: 3
+            periodSeconds: 3
+            successThreshold: 1
+            timeoutSeconds: 1
+        volumeMounts:
+        - mountPath: /var/run/secrets/istio
+          name: istiod-ca-cert
+        - mountPath: /etc/istio/proxy
+          name: istio-envoy
+        - mountPath: /etc/istio-certs/
+          name: istio-certs
+        - mountPath: /var/run/secrets/tokens
+          name: istio-token 
diff --git a/install/test/values/val_custom_static_bootstrap.yaml b/install/test/values/val_custom_static_bootstrap.yaml
new file mode 100644
index 000000000..ab2a6ff41
--- /dev/null
+++ b/install/test/values/val_custom_static_bootstrap.yaml
@@ -0,0 +1,5 @@
+gatewayProxies:
+  gatewayProxy:
+    customStaticLayer:
+      envoy.reloadable_features.strict_1xx_and_204_response_headers: false
+      envoy.reloadable_features.disable_tls_inspector_injection: false
\ No newline at end of file
diff --git a/install/test/values/val_default_gateway_access_logging_service.yaml b/install/test/values/val_default_gateway_access_logging_service.yaml
new file mode 100644
index 000000000..c37ec28ae
--- /dev/null
+++ b/install/test/values/val_default_gateway_access_logging_service.yaml
@@ -0,0 +1,8 @@
+gatewayProxies:
+  gatewayProxy:
+    gatewaySettings:
+      accessLoggingService:
+        accessLog:
+        - fileSink:
+            path: /dev/stdout
+            stringFormat: ""
diff --git a/install/test/values/val_gwp_affinity.yaml b/install/test/values/val_gwp_affinity.yaml
new file mode 100644
index 000000000..9877c5509
--- /dev/null
+++ b/install/test/values/val_gwp_affinity.yaml
@@ -0,0 +1,12 @@
+gatewayProxies:
+  gatewayProxy:
+    affinity:
+      nodeAffinity:
+        requiredDuringSchedulingIgnoredDuringExecution:
+          nodeSelectorTerms:
+          - matchExpressions:
+            - key: kubernetes.io/e2e-az-name
+              operator: In
+              values:
+              - e2e-az1
+              - e2e-az2
\ No newline at end of file
diff --git a/install/test/values/val_gwp_hpa_v2.yaml b/install/test/values/val_gwp_hpa_v2.yaml
new file mode 100644
index 000000000..895e696fc
--- /dev/null
+++ b/install/test/values/val_gwp_hpa_v2.yaml
@@ -0,0 +1,30 @@
+gatewayProxies:
+  gatewayProxy:
+    horizontalPodAutoscaler:
+      apiVersion: autoscaling/v2
+      minReplicas: 1
+      maxReplicas: 2
+      metrics:
+        - type: Resource
+          resource:
+            name: cpu
+            target:
+              type: Utilization
+              averageUtilization: 75
+      behavior:
+        scaleDown:
+          stabilizationWindowSeconds: 300
+          policies:
+          - type: Percent
+            value: 100
+            periodSeconds: 15
+        scaleUp:
+          stabilizationWindowSeconds: 0
+          policies:
+          - type: Percent
+            value: 100
+            periodSeconds: 15
+          - type: Pods
+            value: 4
+            periodSeconds: 15
+          selectPolicy: Max
diff --git a/install/test/values/val_gwp_hpa_v2beta2.yaml b/install/test/values/val_gwp_hpa_v2beta2.yaml
new file mode 100644
index 000000000..20173df53
--- /dev/null
+++ b/install/test/values/val_gwp_hpa_v2beta2.yaml
@@ -0,0 +1,22 @@
+gatewayProxies:
+  gatewayProxy:
+    horizontalPodAutoscaler:
+      apiVersion: autoscaling/v2beta2
+      minReplicas: 1
+      maxReplicas: 2
+      metrics:
+        - type: Resource
+          resource:
+            name: cpu
+            target:
+              type: Utilization
+              averageUtilization: 50
+      behavior:
+        scaleDown:
+          policies:
+            - type: Pods
+              value: 4
+              periodSeconds: 60
+            - type: Percent
+              value: 10
+              periodSeconds: 60
diff --git a/install/test/values/val_gwp_http_hybrid_gateway.yaml b/install/test/values/val_gwp_http_hybrid_gateway.yaml
new file mode 100644
index 000000000..c8e1fe357
--- /dev/null
+++ b/install/test/values/val_gwp_http_hybrid_gateway.yaml
@@ -0,0 +1,19 @@
+gatewayProxies:
+  gatewayProxy:
+    gatewaySettings:
+      httpHybridGateway:
+        hybridGateway:
+          matchedGateways:
+            - httpGateway:
+                virtualServices:
+                  - name: default
+                    namespace: gloo-system
+              matcher:
+                sourcePrefixRanges:
+                  - addressPrefix: 0.0.0.0
+                    prefixLen: 1
+            - httpGateway:
+                virtualServices:
+                  - name: client-ip-reject
+                    namespace: gloo-system
+              matcher: {}
diff --git a/install/test/values/val_gwp_https_hybrid_gateway.yaml b/install/test/values/val_gwp_https_hybrid_gateway.yaml
new file mode 100644
index 000000000..33316130a
--- /dev/null
+++ b/install/test/values/val_gwp_https_hybrid_gateway.yaml
@@ -0,0 +1,27 @@
+gatewayProxies:
+  gatewayProxy:
+    gatewaySettings:
+      httpsHybridGateway:
+        hybridGateway:
+          matchedGateways:
+            - httpGateway:
+                virtualServices:
+                  - name: default
+                    namespace: gloo-system
+              matcher:
+                sourcePrefixRanges:
+                  - addressPrefix: 0.0.0.0
+                    prefixLen: 1
+                sslConfig:
+                  secretRef:
+                    name: gloo-cert
+                    namespace: gloo-system
+            - httpGateway:
+                virtualServices:
+                  - name: client-ip-reject
+                    namespace: gloo-system
+              matcher:
+                sslConfig:
+                  secretRef:
+                    name: gloo-cert
+                    namespace: gloo-system
diff --git a/install/test/values/val_gwp_topologyspreadconstraints.yaml b/install/test/values/val_gwp_topologyspreadconstraints.yaml
new file mode 100644
index 000000000..6c96a3046
--- /dev/null
+++ b/install/test/values/val_gwp_topologyspreadconstraints.yaml
@@ -0,0 +1,9 @@
+gatewayProxies:
+  gatewayProxy:
+    topologySpreadConstraints:
+    - maxSkew: 1
+      topologyKey: zone
+      whenUnsatisfiable: ScheduleAnyway
+      labelSelector:
+        matchLabels:
+          gloo: gateway-proxy
diff --git a/install/test/values/val_lb_external_ips.yaml b/install/test/values/val_lb_external_ips.yaml
new file mode 100644
index 000000000..f920abf26
--- /dev/null
+++ b/install/test/values/val_lb_external_ips.yaml
@@ -0,0 +1,7 @@
+gatewayProxies:
+  gatewayProxy:
+    service:
+      type: LoadBalancer
+      externalIPs:
+        - 130.211.204.1
+        - 130.211.204.2
\ No newline at end of file
diff --git a/install/test/values/val_lb_source_ranges.yaml b/install/test/values/val_lb_source_ranges.yaml
new file mode 100644
index 000000000..8cca8cfed
--- /dev/null
+++ b/install/test/values/val_lb_source_ranges.yaml
@@ -0,0 +1,7 @@
+gatewayProxies:
+  gatewayProxy:
+    service:
+      type: LoadBalancer
+      loadBalancerSourceRanges:
+        - 130.211.204.1/32
+        - 130.211.204.2/32
\ No newline at end of file
diff --git a/install/test/values/val_static_clusters.yaml b/install/test/values/val_static_clusters.yaml
new file mode 100644
index 000000000..dc044addb
--- /dev/null
+++ b/install/test/values/val_static_clusters.yaml
@@ -0,0 +1,16 @@
+gatewayProxies:
+  gatewayProxy:
+    envoyStaticClusters:
+    - name: test_cluster
+      connect_timeout: 5.000s
+      type: STATIC
+      lb_policy: ROUND_ROBIN
+      load_assignment:
+        cluster_name: test_cluster
+        endpoints:
+        - lb_endpoints:
+          - endpoint:
+              address:
+                socket_address:
+                  address: 127.0.0.1
+                  port_value: 8080
\ No newline at end of file
diff --git a/install/test/values/val_tracing_provider_cluster.yaml b/install/test/values/val_tracing_provider_cluster.yaml
new file mode 100644
index 000000000..e66c87697
--- /dev/null
+++ b/install/test/values/val_tracing_provider_cluster.yaml
@@ -0,0 +1,22 @@
+gatewayProxies:
+  gatewayProxy:
+    tracing:
+      provider:
+        zipkinConfig:
+          collector_cluster: zipkin
+          collector_endpoint: /api/v2/spans
+      cluster:
+      - name: zipkin
+        connect_timeout: 1s
+        type: STRICT_DNS
+        respect_dns_ttl: true
+        lb_policy: ROUND_ROBIN
+        load_assignment:
+          cluster_name: zipkin
+          endpoints:
+          - lb_endpoints:
+            - endpoint:
+                address:
+                  socket_address:
+                    address: zipkin
+                    port_value: 1234
diff --git a/internal/kgateway/agentgatewaysyncer/README.md b/internal/kgateway/agentgatewaysyncer/README.md
index 34de8ac44..d7d0d77ba 100644
--- a/internal/kgateway/agentgatewaysyncer/README.md
+++ b/internal/kgateway/agentgatewaysyncer/README.md
@@ -2,10 +2,63 @@
 
 This syncer configures xds updates for the [agentgateway](https://agentgateway.dev/) data plane. 
 
+To use the agentgateway control plane with kgateway, you need to enable the integration in the helm chart:
+```yaml
+agentGateway:
+  enabled: true # set this to true
+```
+
+You can configure the agentgateway Gateway class to use a specific image by setting the image field on the 
+GatewayClass:
+```yaml
+kind: GatewayParameters
+apiVersion: gateway.kgateway.dev/v1alpha1
+metadata:
+  name: kgateway
+spec:
+  kube:
+    agentGateway:
+      enabled: true
+      logLevel: debug
+      image:
+        tag: bc92714
+---
+kind: GatewayClass
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: agentgateway
+spec:
+  controllerName: kgateway.dev/kgateway
+  parametersRef:
+    group: gateway.kgateway.dev
+    kind: GatewayParameters
+    name: kgateway
+    namespace: default
+---
+kind: Gateway
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: agent-gateway
+spec:
+  gatewayClassName: agentgateway
+  listeners:
+    - protocol: HTTP
+      port: 8080
+      name: http
+      allowedRoutes:
+        namespaces:
+          from: All
+```
+
 ### APIs
 
 The syncer uses the following APIs:
 
-- [a2a](https://github.com/agentgateway/agentgateway/tree/main/go/api/a2a/a2a)
-- [mcp](https://github.com/agentgateway/agentgateway/tree/main/go/api/mcp/mcp)
-- [listener](https://github.com/agentgateway/agentgateway/tree/main/go/api/listener)
+- [workload](https://github.com/agentgateway/agentgateway/tree/main/go/api/workload.pb.go)
+- [resource](https://github.com/agentgateway/agentgateway/tree/main/go/api/resource.pb.go)
+
+### Conformance tests
+
+```
+make run HELM_ADDITIONAL_VALUES=test/kubernetes/e2e/tests/manifests/agent-gateway-integration.yaml; CONFORMANCE_GATEWAY_CLASS=agentgateway make conformance 
+```
\ No newline at end of file
diff --git a/internal/kgateway/agentgatewaysyncer/adp.go b/internal/kgateway/agentgatewaysyncer/adp.go
new file mode 100644
index 000000000..e5eca1a0d
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/adp.go
@@ -0,0 +1,280 @@
+package agentgatewaysyncer
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"istio.io/istio/pkg/slices"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
+)
+
+func createADPMethodMatch(match gwv1.HTTPRouteMatch) (*api.MethodMatch, *reporter.RouteCondition) {
+	if match.Method == nil {
+		return nil, nil
+	}
+	return &api.MethodMatch{
+		Exact: string(*match.Method),
+	}, nil
+}
+
+func createADPQueryMatch(match gwv1.HTTPRouteMatch) ([]*api.QueryMatch, *reporter.RouteCondition) {
+	res := []*api.QueryMatch{}
+	for _, header := range match.QueryParams {
+		tp := gwv1.QueryParamMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case gwv1.QueryParamMatchExact:
+			res = append(res, &api.QueryMatch{
+				Name:  string(header.Name),
+				Value: &api.QueryMatch_Exact{Exact: header.Value},
+			})
+		case gwv1.QueryParamMatchRegularExpression:
+			res = append(res, &api.QueryMatch{
+				Name:  string(header.Name),
+				Value: &api.QueryMatch_Regex{Regex: header.Value},
+			})
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported QueryMatch type", tp)}
+		}
+	}
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createADPPathMatch(match gwv1.HTTPRouteMatch) (*api.PathMatch, *reporter.RouteCondition) {
+	tp := gwv1.PathMatchPathPrefix
+	if match.Path.Type != nil {
+		tp = *match.Path.Type
+	}
+	dest := "/"
+	if match.Path.Value != nil {
+		dest = *match.Path.Value
+	}
+	switch tp {
+	case gwv1.PathMatchPathPrefix:
+		// "When specified, a trailing `/` is ignored."
+		if dest != "/" {
+			dest = strings.TrimSuffix(dest, "/")
+		}
+		return &api.PathMatch{Kind: &api.PathMatch_PathPrefix{
+			PathPrefix: dest,
+		}}, nil
+	case gwv1.PathMatchExact:
+		return &api.PathMatch{Kind: &api.PathMatch_Exact{
+			Exact: dest,
+		}}, nil
+	case gwv1.PathMatchRegularExpression:
+		return &api.PathMatch{Kind: &api.PathMatch_Regex{
+			Regex: dest,
+		}}, nil
+	default:
+		// Should never happen, unless a new field is added
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+	}
+}
+
+func createADPHeadersMatch(match gwv1.HTTPRouteMatch) ([]*api.HeaderMatch, *reporter.RouteCondition) {
+	res := []*api.HeaderMatch{}
+	for _, header := range match.Headers {
+		tp := gwv1.HeaderMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case gwv1.HeaderMatchExact:
+			res = append(res, &api.HeaderMatch{
+				Name:  string(header.Name),
+				Value: &api.HeaderMatch_Exact{Exact: header.Value},
+			})
+		case gwv1.HeaderMatchRegularExpression:
+			res = append(res, &api.HeaderMatch{
+				Name:  string(header.Name),
+				Value: &api.HeaderMatch_Regex{Regex: header.Value},
+			})
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createADPHeadersFilter(filter *gwv1.HTTPHeaderFilter) *api.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_RequestHeaderModifier{
+			RequestHeaderModifier: &api.HeaderModifier{
+				Add:    headerListToADP(filter.Add),
+				Set:    headerListToADP(filter.Set),
+				Remove: filter.Remove,
+			},
+		},
+	}
+}
+
+func createADPResponseHeadersFilter(filter *gwv1.HTTPHeaderFilter) *api.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_ResponseHeaderModifier{
+			ResponseHeaderModifier: &api.HeaderModifier{
+				Add:    headerListToADP(filter.Add),
+				Set:    headerListToADP(filter.Set),
+				Remove: filter.Remove,
+			},
+		},
+	}
+}
+
+func createADPRewriteFilter(filter *gwv1.HTTPURLRewriteFilter) *api.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+
+	var hostname string
+	if filter.Hostname != nil {
+		hostname = string(*filter.Hostname)
+	}
+	ff := &api.UrlRewrite{
+		Host: hostname,
+	}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case gwv1.PrefixMatchHTTPPathModifier:
+			ff.Path = &api.UrlRewrite_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
+		case gwv1.FullPathHTTPPathModifier:
+			ff.Path = &api.UrlRewrite_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
+		}
+	}
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_UrlRewrite{
+			UrlRewrite: ff,
+		},
+	}
+}
+
+func createADPMirrorFilter(
+	ctx RouteContext,
+	filter *gwv1.HTTPRequestMirrorFilter,
+	ns string,
+	k schema.GroupVersionKind,
+) (*api.RouteFilter, *reporter.RouteCondition) {
+	if filter == nil {
+		return nil, nil
+	}
+	var weightOne int32 = 1
+	dst, err := buildADPDestination(ctx, gwv1.HTTPBackendRef{
+		BackendRef: gwv1.BackendRef{
+			BackendObjectReference: filter.BackendRef,
+			Weight:                 &weightOne,
+		},
+	}, ns, k)
+	if err != nil {
+		return nil, err
+	}
+	var percent float64
+	if f := filter.Fraction; f != nil {
+		denominator := float64(100)
+		if f.Denominator != nil {
+			denominator = float64(*f.Denominator)
+		}
+		percent = (100 * float64(f.Numerator)) / denominator
+	} else if p := filter.Percent; p != nil {
+		percent = float64(*p)
+	} else {
+		percent = 100
+	}
+	if percent == 0 {
+		return nil, nil
+	}
+	rm := &api.RequestMirror{
+		Kind:       nil,
+		Percentage: percent,
+		Port:       dst.GetPort(),
+	}
+	switch dk := dst.GetKind().(type) {
+	case *api.RouteBackend_Service:
+		rm.Kind = &api.RequestMirror_Service{
+			Service: dk.Service,
+		}
+	}
+	return &api.RouteFilter{Kind: &api.RouteFilter_RequestMirror{RequestMirror: rm}}, nil
+}
+
+func createADPRedirectFilter(filter *gwv1.HTTPRequestRedirectFilter) *api.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+	var scheme, host string
+	var port, statusCode uint32
+	if filter.Scheme != nil {
+		scheme = *filter.Scheme
+	}
+	if filter.Hostname != nil {
+		host = string(*filter.Hostname)
+	}
+	if filter.Port != nil {
+		port = uint32(*filter.Port)
+	}
+	if filter.StatusCode != nil {
+		statusCode = uint32(*filter.StatusCode)
+	}
+
+	ff := &api.RequestRedirect{
+		Scheme: scheme,
+		Host:   host,
+		Port:   port,
+		Status: statusCode,
+	}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case gwv1.PrefixMatchHTTPPathModifier:
+			ff.Path = &api.RequestRedirect_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
+		case gwv1.FullPathHTTPPathModifier:
+			ff.Path = &api.RequestRedirect_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
+		}
+	}
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_RequestRedirect{
+			RequestRedirect: ff,
+		},
+	}
+}
+
+func headerListToADP(hl []gwv1.HTTPHeader) []*api.Header {
+	return slices.Map(hl, func(hl gwv1.HTTPHeader) *api.Header {
+		return &api.Header{
+			Name:  string(hl.Name),
+			Value: hl.Value,
+		}
+	})
+}
diff --git a/internal/kgateway/agentgatewaysyncer/conditions.go b/internal/kgateway/agentgatewaysyncer/conditions.go
new file mode 100644
index 000000000..828e03e21
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/conditions.go
@@ -0,0 +1,174 @@
+package agentgatewaysyncer
+
+import (
+	"istio.io/istio/pilot/pkg/model/kstatus"
+	"istio.io/istio/pkg/maps"
+	"istio.io/istio/pkg/slices"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+)
+
+type ParentErrorReason string
+
+const (
+	ParentErrorNotAccepted       = ParentErrorReason(gwv1.RouteReasonNoMatchingParent)
+	ParentErrorNotAllowed        = ParentErrorReason(gwv1.RouteReasonNotAllowedByListeners)
+	ParentErrorNoHostname        = ParentErrorReason(gwv1.RouteReasonNoMatchingListenerHostname)
+	ParentErrorParentRefConflict = ParentErrorReason("ParentRefConflict")
+	ParentNoError                = ParentErrorReason("")
+)
+
+type ConfigErrorReason = string
+
+const (
+	// InvalidDestination indicates an issue with the destination
+	InvalidDestination ConfigErrorReason = "InvalidDestination"
+	InvalidAddress     ConfigErrorReason = ConfigErrorReason(gwv1.GatewayReasonUnsupportedAddress)
+	// InvalidDestinationPermit indicates a destination was not permitted
+	InvalidDestinationPermit ConfigErrorReason = ConfigErrorReason(gwv1.RouteReasonRefNotPermitted)
+	// InvalidDestinationKind indicates an issue with the destination kind
+	InvalidDestinationKind ConfigErrorReason = ConfigErrorReason(gwv1.RouteReasonInvalidKind)
+	// InvalidDestinationNotFound indicates a destination does not exist
+	InvalidDestinationNotFound ConfigErrorReason = ConfigErrorReason(gwv1.RouteReasonBackendNotFound)
+	// InvalidFilter indicates an issue with the filters
+	InvalidFilter ConfigErrorReason = "InvalidFilter"
+	// InvalidTLS indicates an issue with TLS settings
+	InvalidTLS ConfigErrorReason = ConfigErrorReason(gwv1.ListenerReasonInvalidCertificateRef)
+	// InvalidListenerRefNotPermitted indicates a listener reference was not permitted
+	InvalidListenerRefNotPermitted ConfigErrorReason = ConfigErrorReason(gwv1.ListenerReasonRefNotPermitted)
+	// InvalidConfiguration indicates a generic error for all other invalid configurations
+	InvalidConfiguration ConfigErrorReason = "InvalidConfiguration"
+	DeprecateFieldUsage  ConfigErrorReason = "DeprecatedField"
+)
+
+// ParentError represents that a parent could not be referenced
+type ParentError struct {
+	Reason  ParentErrorReason
+	Message string
+}
+
+// ConfigError represents an invalid configuration that will be reported back to the user.
+type ConfigError struct {
+	Reason  ConfigErrorReason
+	Message string
+}
+
+type condition struct {
+	// reason defines the reason to report on success. Ignored if error is set
+	reason string
+	// message defines the message to report on success. Ignored if error is set
+	message string
+	// status defines the status to report on success. The inverse will be set if error is set
+	// If not set, will default to StatusTrue
+	status metav1.ConditionStatus
+	// error defines an error state; the reason and message will be replaced with that of the error and
+	// the status inverted
+	error *ConfigError
+	// setOnce, if enabled, will only set the condition if it is not yet present or set to this reason
+	setOnce string
+}
+
+// setConditions sets the existingConditions with the new conditions
+func setConditions(generation int64, existingConditions []metav1.Condition, conditions map[string]*condition) []metav1.Condition {
+	// Sort keys for deterministic ordering
+	for _, k := range slices.Sort(maps.Keys(conditions)) {
+		cond := conditions[k]
+		setter := kstatus.UpdateConditionIfChanged
+		if cond.setOnce != "" {
+			setter = func(conditions []metav1.Condition, condition metav1.Condition) []metav1.Condition {
+				return kstatus.CreateCondition(conditions, condition, cond.setOnce)
+			}
+		}
+		// A condition can be "negative polarity" (ex: ListenerInvalid) or "positive polarity" (ex:
+		// ListenerValid), so in order to determine the status we should set each `condition` defines its
+		// default positive status. When there is an error, we will invert that. Example: If we have
+		// condition ListenerInvalid, the status will be set to StatusFalse. If an error is reported, it
+		// will be inverted to StatusTrue to indicate listeners are invalid. See
+		// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
+		// for more information
+		if cond.error != nil {
+			existingConditions = setter(existingConditions, metav1.Condition{
+				Type:               k,
+				Status:             kstatus.InvertStatus(cond.status),
+				ObservedGeneration: generation,
+				LastTransitionTime: metav1.Now(),
+				Reason:             cond.error.Reason,
+				Message:            cond.error.Message,
+			})
+		} else {
+			status := cond.status
+			if status == "" {
+				status = kstatus.StatusTrue
+			}
+			existingConditions = setter(existingConditions, metav1.Condition{
+				Type:               k,
+				Status:             status,
+				ObservedGeneration: generation,
+				LastTransitionTime: metav1.Now(),
+				Reason:             cond.reason,
+				Message:            cond.message,
+			})
+		}
+	}
+	return existingConditions
+}
+
+func reportListenerCondition(index int, l gwv1.Listener, obj *gwv1.Gateway,
+	gs *gwv1.GatewayStatus, conditions map[string]*condition,
+) {
+	for index >= len(gs.Listeners) {
+		gs.Listeners = append(gs.Listeners, gwv1.ListenerStatus{})
+	}
+	cond := gs.Listeners[index].Conditions
+	supported, valid := generateSupportedKinds(l)
+	if !valid {
+		conditions[string(gwv1.ListenerConditionResolvedRefs)] = &condition{
+			reason:  string(gwv1.ListenerReasonInvalidRouteKinds),
+			status:  metav1.ConditionFalse,
+			message: "Invalid route kinds",
+		}
+	}
+	gs.Listeners[index] = gwv1.ListenerStatus{
+		Name:           l.Name,
+		AttachedRoutes: 0, // this will be reported later
+		SupportedKinds: supported,
+		Conditions:     setConditions(obj.Generation, cond, conditions),
+	}
+}
+
+func generateSupportedKinds(l gwv1.Listener) ([]gwv1.RouteGroupKind, bool) {
+	var supported []gwv1.RouteGroupKind
+	switch l.Protocol {
+	case gwv1.HTTPProtocolType, gwv1.HTTPSProtocolType:
+		// Only terminate allowed, so its always HTTP
+		supported = []gwv1.RouteGroupKind{
+			toRouteKind(wellknown.HTTPRouteGVK),
+			toRouteKind(wellknown.GRPCRouteGVK),
+		}
+	case gwv1.TCPProtocolType:
+		supported = []gwv1.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
+	case gwv1.TLSProtocolType:
+		if l.TLS != nil && l.TLS.Mode != nil && *l.TLS.Mode == gwv1.TLSModePassthrough {
+			supported = []gwv1.RouteGroupKind{toRouteKind(wellknown.TLSRouteGVK)}
+		} else {
+			supported = []gwv1.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
+		}
+		// UDP route not support
+	}
+	if l.AllowedRoutes != nil && len(l.AllowedRoutes.Kinds) > 0 {
+		// We need to filter down to only ones we actually support
+		var intersection []gwv1.RouteGroupKind
+		for _, s := range supported {
+			for _, kind := range l.AllowedRoutes.Kinds {
+				if routeGroupKindEqual(s, kind) {
+					intersection = append(intersection, s)
+					break
+				}
+			}
+		}
+		return intersection, len(intersection) == len(l.AllowedRoutes.Kinds)
+	}
+	return supported, true
+}
diff --git a/internal/kgateway/agentgatewaysyncer/const.go b/internal/kgateway/agentgatewaysyncer/const.go
index 48365f1c5..30605e493 100644
--- a/internal/kgateway/agentgatewaysyncer/const.go
+++ b/internal/kgateway/agentgatewaysyncer/const.go
@@ -1,16 +1,7 @@
 package agentgatewaysyncer
 
 const (
-	TargetTypeA2AUrl      = "type.googleapis.com/agentgateway.dev.a2a.target.Target"
-	TargetTypeMcpUrl      = "type.googleapis.com/agentgateway.dev.mcp.target.Target"
-	TargetTypeListenerUrl = "type.googleapis.com/agentgateway.dev.listener.Listener"
-
-	MCPProtocol = "kgateway.dev/mcp"
-	A2AProtocol = "kgateway.dev/a2a"
-
-	MCPPathAnnotation = "kgateway.dev/mcp-path"
-	A2APathAnnotation = "kgateway.dev/a2a-path"
-
-	// Needs to match agentgateway role configured here: https://github.com/agentgateway/agentgateway/blob/main/crates/agentgateway/src/xds/client.rs#L293
-	OwnerNodeId = "agentgateway-api"
+	TargetTypeResourceUrl = "type.googleapis.com/agentgateway.dev.resource.Resource"
+	TargetTypeAddressUrl  = "type.googleapis.com/agentgateway.dev.workload.Address"
+	AgentgatewayName      = "agentgateway-autogenerated-k8s-gateway"
 )
diff --git a/internal/kgateway/agentgatewaysyncer/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
new file mode 100644
index 000000000..8951b21eb
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -0,0 +1,1801 @@
+package agentgatewaysyncer
+
+import (
+	"crypto/tls"
+	"fmt"
+	"log"
+	"sort"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"google.golang.org/protobuf/types/known/durationpb"
+	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
+	"istio.io/api/annotation"
+	istio "istio.io/api/networking/v1alpha3"
+	kubecreds "istio.io/istio/pilot/pkg/credentials/kube"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	creds "istio.io/istio/pilot/pkg/model/credentials"
+	"istio.io/istio/pilot/pkg/model/kstatus"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/sets"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	klabels "k8s.io/apimachinery/pkg/labels"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gwv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+)
+
+const (
+	gatewayTLSTerminateModeKey = "gateway.agentgateway.io/tls-terminate-mode"
+)
+
+func convertHTTPRouteToADP(ctx RouteContext, r gwv1.HTTPRouteRule,
+	obj *gwv1.HTTPRoute, pos int, matchPos int,
+) (*api.Route, *reporter.RouteCondition) {
+	res := &api.Route{
+		Key:         obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) + "." + strconv.Itoa(matchPos),
+		RouteName:   obj.Namespace + "/" + obj.Name,
+		ListenerKey: "",
+		RuleName:    defaultString(r.Name, ""),
+	}
+
+	for _, match := range r.Matches {
+		path, err := createADPPathMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		headers, err := createADPHeadersMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		method, err := createADPMethodMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		query, err := createADPQueryMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		res.Matches = append(res.GetMatches(), &api.RouteMatch{
+			Path:        path,
+			Headers:     headers,
+			Method:      method,
+			QueryParams: query,
+		})
+	}
+	filters, err := buildADPFilters(ctx, obj.Namespace, r.Filters)
+	if err != nil {
+		return nil, err
+	}
+	res.Filters = filters
+
+	if r.Timeouts != nil {
+		res.TrafficPolicy = &api.TrafficPolicy{}
+		if r.Timeouts.Request != nil {
+			request, _ := time.ParseDuration(string(*r.Timeouts.Request))
+			if request > 0 {
+				res.GetTrafficPolicy().RequestTimeout = durationpb.New(request)
+			}
+		}
+		if r.Timeouts.BackendRequest != nil {
+			request, _ := time.ParseDuration(string(*r.Timeouts.BackendRequest))
+			if request > 0 {
+				res.GetTrafficPolicy().RequestTimeout = durationpb.New(request)
+			}
+		}
+	}
+
+	// Retry: todo
+	route, backendErr, err := buildADPHTTPDestination(ctx, r.BackendRefs, obj.Namespace)
+	if err != nil {
+		return nil, err
+	}
+	res.Backends = route
+	res.Hostnames = slices.Map(obj.Spec.Hostnames, func(e gwv1.Hostname) string {
+		return string(e)
+	})
+	return res, backendErr
+}
+
+func buildADPFilters(
+	ctx RouteContext,
+	ns string,
+	inputFilters []gwv1.HTTPRouteFilter,
+) ([]*api.RouteFilter, *reporter.RouteCondition) {
+	var filters []*api.RouteFilter
+	var mirrorBackendErr *reporter.RouteCondition
+	for _, filter := range inputFilters {
+		switch filter.Type {
+		case gwv1.HTTPRouteFilterRequestHeaderModifier:
+			h := createADPHeadersFilter(filter.RequestHeaderModifier)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case gwv1.HTTPRouteFilterResponseHeaderModifier:
+			h := createADPResponseHeadersFilter(filter.ResponseHeaderModifier)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case gwv1.HTTPRouteFilterRequestRedirect:
+			h := createADPRedirectFilter(filter.RequestRedirect)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case gwv1.HTTPRouteFilterRequestMirror:
+			h, err := createADPMirrorFilter(ctx, filter.RequestMirror, ns, wellknown.HTTPRouteGVK)
+			if err != nil {
+				mirrorBackendErr = err
+			} else {
+				filters = append(filters, h)
+			}
+		case gwv1.HTTPRouteFilterURLRewrite:
+			h := createADPRewriteFilter(filter.URLRewrite)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case gwv1.HTTPRouteFilterCORS:
+			//return nil, &reporter.RouteCondition{
+			//	Reason:  InvalidFilter,
+			//	Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
+			//}
+		default:
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonIncompatibleFilters,
+				Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
+			}
+		}
+	}
+	return filters, mirrorBackendErr
+}
+
+func buildADPHTTPDestination(
+	ctx RouteContext,
+	forwardTo []gwv1.HTTPBackendRef,
+	ns string,
+) ([]*api.RouteBackend, *reporter.RouteCondition, *reporter.RouteCondition) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+
+	var invalidBackendErr *reporter.RouteCondition
+	var res []*api.RouteBackend
+	for _, fwd := range forwardTo {
+		dst, err := buildADPDestination(ctx, fwd, ns, wellknown.HTTPRouteGVK)
+		if err != nil {
+			logger.Error("erroring building agent gateway destination", "error", err)
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		if dst != nil {
+			filters, err := buildADPFilters(ctx, ns, fwd.Filters)
+			if err != nil {
+				return nil, nil, err
+			}
+			dst.Filters = filters
+		}
+		res = append(res, dst)
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildADPDestination(
+	ctx RouteContext,
+	to gwv1.HTTPBackendRef,
+	ns string,
+	k schema.GroupVersionKind,
+) (*api.RouteBackend, *reporter.RouteCondition) {
+	// check if the reference is allowed
+	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
+		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonRefNotPermitted,
+				Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
+			}
+		}
+	}
+
+	namespace := ns // use default
+	if to.Namespace != nil {
+		namespace = string(*to.Namespace)
+	}
+	var invalidBackendErr *reporter.RouteCondition
+	var hostname string
+	weight := int32(1) // default
+	if to.Weight != nil {
+		weight = *to.Weight
+	}
+	rb := &api.RouteBackend{
+		Weight: weight,
+	}
+	var port *gwv1.PortNumber
+	ref := normalizeReference(to.Group, to.Kind, wellknown.ServiceGVK)
+	switch ref.GroupKind() {
+	case wellknown.InferencePoolGVK.GroupKind():
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+		logger.Debug("Found pull pool for service", "svc", svc, "key", key)
+		if svc == nil {
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		} else {
+			port = ptr.Of(gwv1.PortNumber(svc.Spec.TargetPortNumber))
+		}
+		rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
+	case wellknown.ServiceGVK.GroupKind():
+		port = to.Port
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+		rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
+	default:
+		port = to.Port
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionResolvedRefs,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonInvalidKind,
+			Message: fmt.Sprintf("referencing unsupported backendRef: group %q kind %q", ptr.OrEmpty(to.Group), ptr.OrEmpty(to.Kind)),
+		}
+	}
+	// All types currently require a Port, so we do this for everything; consider making this per-type if we have future types
+	// that do not require port.
+	if port == nil {
+		// "Port is required when the referent is a Kubernetes Service."
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: "port is required in backendRef"}
+	}
+	rb.Port = int32(*port)
+	return rb, invalidBackendErr
+}
+
+func parentMeta(obj controllers.Object, sectionName *gwv1.SectionName) map[string]string {
+	kind := obj.GetObjectKind().GroupVersionKind().Kind
+	name := fmt.Sprintf("%s/%s.%s", kind, obj.GetName(), obj.GetNamespace())
+	if sectionName != nil {
+		name = fmt.Sprintf("%s/%s/%s.%s", kind, obj.GetName(), *sectionName, obj.GetNamespace())
+	}
+	return map[string]string{
+		constants.InternalParentNames: name,
+	}
+}
+
+var allowedParentReferences = sets.New(
+	wellknown.GatewayGVK,
+	wellknown.ServiceGVK,
+	wellknown.ServiceEntryGVK,
+)
+
+// normalizeReference normalizes group and kind references to a standard GVK format.
+// If group or kind are nil/empty, it uses the default GVK's group/kind.
+// Empty group is treated as "core" API group.
+func normalizeReference(group *gwv1.Group, kind *gwv1.Kind, defaultGVK schema.GroupVersionKind) schema.GroupVersionKind {
+	result := defaultGVK
+
+	if kind != nil && *kind != "" {
+		result.Kind = string(*kind)
+	}
+
+	if group != nil {
+		groupStr := string(*group)
+		if groupStr == "" {
+			// Empty group means "core" API group
+			result.Group = ""
+		} else {
+			result.Group = groupStr
+		}
+	}
+
+	return result
+}
+
+func toInternalParentReference(p gwv1.ParentReference, localNamespace string) (parentKey, error) {
+	ref := normalizeReference(p.Group, p.Kind, wellknown.GatewayGVK)
+	if !allowedParentReferences.Contains(wellknown.GatewayGVK) {
+		return parentKey{}, fmt.Errorf("unsupported parent: %v/%v", p.Group, p.Kind)
+	}
+	return parentKey{
+		Kind: ref,
+		Name: string(p.Name),
+		// Unset namespace means "same namespace"
+		Namespace: defaultString(p.Namespace, localNamespace),
+	}, nil
+}
+
+func referenceAllowed(
+	ctx RouteContext,
+	parent *parentInfo,
+	routeKind schema.GroupVersionKind,
+	parentRef parentReference,
+	hostnames []gwv1.Hostname,
+	localNamespace string,
+) *ParentError {
+	if parentRef.Kind == wellknown.ServiceGVK {
+
+		key := parentRef.Namespace + "/" + parentRef.Name
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+
+		// check that the referenced svc exists
+		if svc == nil {
+			return &ParentError{
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("parent service: %q not found", parentRef.Name),
+			}
+		}
+	} else if parentRef.Kind == wellknown.ServiceEntryGVK {
+		// check that the referenced svc entry exists
+		key := parentRef.Namespace + "/" + parentRef.Name
+		svcEntry := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(key)))
+		if svcEntry == nil {
+			return &ParentError{
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("parent service entry: %q not found", parentRef.Name),
+			}
+		}
+	} else {
+		// First, check section and port apply. This must come first
+		if parentRef.Port != 0 && parentRef.Port != parent.Port {
+			return &ParentError{
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("port %v not found", parentRef.Port),
+			}
+		}
+		if len(parentRef.SectionName) > 0 && parentRef.SectionName != parent.SectionName {
+			return &ParentError{
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("sectionName %q not found", parentRef.SectionName),
+			}
+		}
+
+		// Next check the hostnames are a match. This is a bi-directional wildcard match. Only one route
+		// hostname must match for it to be allowed (but the others will be filtered at runtime)
+		// If either is empty its treated as a wildcard which always matches
+
+		if len(hostnames) == 0 {
+			hostnames = []gwv1.Hostname{"*"}
+		}
+		if len(parent.Hostnames) > 0 {
+			// TODO: the spec actually has a label match, not a string match. That is, *.com does not match *.apple.com
+			// We are doing a string match here
+			matched := false
+			hostMatched := false
+		out:
+			for _, routeHostname := range hostnames {
+				for _, parentHostNamespace := range parent.Hostnames {
+					var parentNamespace, parentHostname string
+					// When parentHostNamespace lacks a '/', it was likely sanitized from '*/host' to 'host'
+					// by sanitizeServerHostNamespace. Set parentNamespace to '*' to reflect the wildcard namespace
+					// and parentHostname to the sanitized host to prevent an index out of range panic.
+					if strings.Contains(parentHostNamespace, "/") {
+						spl := strings.Split(parentHostNamespace, "/")
+						parentNamespace, parentHostname = spl[0], spl[1]
+					} else {
+						parentNamespace, parentHostname = "*", parentHostNamespace
+					}
+
+					hostnameMatch := host.Name(parentHostname).Matches(host.Name(routeHostname))
+					namespaceMatch := parentNamespace == "*" || parentNamespace == localNamespace
+					hostMatched = hostMatched || hostnameMatch
+					if hostnameMatch && namespaceMatch {
+						matched = true
+						break out
+					}
+				}
+			}
+			if !matched {
+				if hostMatched {
+					return &ParentError{
+						Reason: ParentErrorNotAllowed,
+						Message: fmt.Sprintf(
+							"hostnames matched parent hostname %q, but namespace %q is not allowed by the parent",
+							parent.OriginalHostname, localNamespace,
+						),
+					}
+				}
+				return &ParentError{
+					Reason: ParentErrorNoHostname,
+					Message: fmt.Sprintf(
+						"no hostnames matched parent hostname %q",
+						parent.OriginalHostname,
+					),
+				}
+			}
+		}
+	}
+	// Also make sure this route kind is allowed
+	matched := false
+	for _, ak := range parent.AllowedKinds {
+		if string(ak.Kind) == routeKind.Kind && ptr.OrDefault((*string)(ak.Group), gvk.GatewayClass.Group) == routeKind.Group {
+			matched = true
+			break
+		}
+	}
+	if !matched {
+		return &ParentError{
+			Reason:  ParentErrorNotAllowed,
+			Message: fmt.Sprintf("kind %v is not allowed", routeKind),
+		}
+	}
+	return nil
+}
+
+func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj controllers.Object) []routeParentReference {
+	routeRefs, hostnames, kind := GetCommonRouteInfo(obj)
+	localNamespace := obj.GetNamespace()
+	var parentRefs []routeParentReference
+	for _, ref := range routeRefs {
+		ir, err := toInternalParentReference(ref, localNamespace)
+		if err != nil {
+			// Cannot handle the reference. Maybe it is for another controller, so we just ignore it
+			continue
+		}
+		pk := parentReference{
+			parentKey:   ir,
+			SectionName: ptr.OrEmpty(ref.SectionName),
+			Port:        ptr.OrEmpty(ref.Port),
+		}
+		gk := ir
+		currentParents := parents.fetch(ctx.Krt, gk)
+		appendParent := func(pr *parentInfo, pk parentReference) {
+			bannedHostnames := sets.New[string]()
+			for _, gw := range currentParents {
+				if gw == pr {
+					continue // do not ban ourself
+				}
+				if gw.Port != pr.Port {
+					// We only care about listeners on the same port
+					continue
+				}
+				if gw.Protocol != pr.Protocol {
+					// We only care about listeners on the same protocol
+					continue
+				}
+				bannedHostnames.Insert(gw.OriginalHostname)
+			}
+			deniedReason := referenceAllowed(ctx, pr, kind, pk, hostnames, localNamespace)
+			rpi := routeParentReference{
+				InternalName:      pr.InternalName,
+				InternalKind:      ir.Kind,
+				Hostname:          pr.OriginalHostname,
+				DeniedReason:      deniedReason,
+				OriginalReference: ref,
+				BannedHostnames:   bannedHostnames.Copy().Delete(pr.OriginalHostname),
+				ParentKey:         ir,
+				ParentSection:     pr.SectionName,
+			}
+			parentRefs = append(parentRefs, rpi)
+		}
+		for _, gw := range currentParents {
+			// Append all matches. Note we may be adding mismatch section or ports; this is handled later
+			appendParent(gw, pk)
+		}
+	}
+	// Ensure stable order
+	slices.SortBy(parentRefs, func(a routeParentReference) string {
+		return parentRefString(a.OriginalReference)
+	})
+	return parentRefs
+}
+
+func convertTCPRoute(ctx RouteContext, r gwv1alpha2.TCPRouteRule, obj *gwv1alpha2.TCPRoute) (*istio.TCPRoute, *reporter.RouteCondition) {
+	if tcpWeightSum(r.BackendRefs) == 0 {
+		// The spec requires us to reject connections when there are no >0 weight backends
+		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
+		return &istio.TCPRoute{
+			Route: []*istio.RouteDestination{{
+				Destination: &istio.Destination{
+					Host:   "internal.cluster.local",
+					Subset: "zero-weight",
+					Port:   &istio.PortSelector{Number: 65535},
+				},
+				Weight: 0,
+			}},
+		}, nil
+	}
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, wellknown.TCPRouteGVK)
+	if err != nil {
+		return nil, err
+	}
+	return &istio.TCPRoute{
+		Route: dest,
+	}, backendErr
+}
+
+func convertTLSRoute(ctx RouteContext, r gwv1alpha2.TLSRouteRule, obj *gwv1alpha2.TLSRoute) (*istio.TLSRoute, *reporter.RouteCondition) {
+	if tcpWeightSum(r.BackendRefs) == 0 {
+		// The spec requires us to reject connections when there are no >0 weight backends
+		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
+		return &istio.TLSRoute{
+			Route: []*istio.RouteDestination{{
+				Destination: &istio.Destination{
+					Host:   "internal.cluster.local",
+					Subset: "zero-weight",
+					Port:   &istio.PortSelector{Number: 65535},
+				},
+				Weight: 0,
+			}},
+		}, nil
+	}
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, wellknown.TLSRouteGVK)
+	if err != nil {
+		return nil, err
+	}
+	return &istio.TLSRoute{
+		Match: buildTLSMatch(obj.Spec.Hostnames),
+		Route: dest,
+	}, backendErr
+}
+
+func buildTCPDestination(
+	ctx RouteContext,
+	forwardTo []gwv1.BackendRef,
+	ns string,
+	k schema.GroupVersionKind,
+) ([]*istio.RouteDestination, *reporter.RouteCondition, *reporter.RouteCondition) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+
+	weights := []int{}
+	var action []gwv1.BackendRef
+	for _, w := range forwardTo {
+		wt := int(ptr.OrDefault(w.Weight, 1))
+		if wt == 0 {
+			continue
+		}
+		action = append(action, w)
+		weights = append(weights, wt)
+	}
+	if len(weights) == 1 {
+		weights = []int{0}
+	}
+
+	var invalidBackendErr *reporter.RouteCondition
+	var res []*istio.RouteDestination
+	for i, fwd := range action {
+		dst, err := buildDestination(ctx, fwd, ns, k)
+		if err != nil {
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		res = append(res, &istio.RouteDestination{
+			Destination: dst,
+			Weight:      int32(weights[i]),
+		})
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildTLSMatch(hostnames []gwv1.Hostname) []*istio.TLSMatchAttributes {
+	// Currently, the spec only supports extensions beyond hostname, which are not currently implemented by Istio.
+	return []*istio.TLSMatchAttributes{{
+		SniHosts: hostnamesToStringListWithWildcard(hostnames),
+	}}
+}
+
+func hostnamesToStringListWithWildcard(h []gwv1.Hostname) []string {
+	if len(h) == 0 {
+		return []string{"*"}
+	}
+	res := make([]string, 0, len(h))
+	for _, i := range h {
+		res = append(res, string(i))
+	}
+	return res
+}
+
+func weightSum(forwardTo []gwv1.HTTPBackendRef) int {
+	sum := int32(0)
+	for _, w := range forwardTo {
+		sum += ptr.OrDefault(w.Weight, 1)
+	}
+	return int(sum)
+}
+
+func grpcWeightSum(forwardTo []gwv1.GRPCBackendRef) int {
+	sum := int32(0)
+	for _, w := range forwardTo {
+		sum += ptr.OrDefault(w.Weight, 1)
+	}
+	return int(sum)
+}
+
+func tcpWeightSum(forwardTo []gwv1.BackendRef) int {
+	sum := int32(0)
+	for _, w := range forwardTo {
+		sum += ptr.OrDefault(w.Weight, 1)
+	}
+	return int(sum)
+}
+
+func buildHTTPDestination(
+	ctx RouteContext,
+	forwardTo []gwv1.HTTPBackendRef,
+	ns string,
+) ([]*istio.HTTPRouteDestination, *reporter.RouteCondition, *reporter.RouteCondition) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+	weights := []int{}
+	action := []gwv1.HTTPBackendRef{}
+	for _, w := range forwardTo {
+		wt := int(ptr.OrDefault(w.Weight, 1))
+		if wt == 0 {
+			continue
+		}
+		action = append(action, w)
+		weights = append(weights, wt)
+	}
+	if len(weights) == 1 {
+		weights = []int{0}
+	}
+
+	var invalidBackendErr *reporter.RouteCondition
+	res := []*istio.HTTPRouteDestination{}
+	for i, fwd := range action {
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, wellknown.HTTPRouteGVK)
+		if err != nil {
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		rd := &istio.HTTPRouteDestination{
+			Destination: dst,
+			Weight:      int32(weights[i]),
+		}
+		for _, filter := range fwd.Filters {
+			switch filter.Type {
+			case gwv1.HTTPRouteFilterRequestHeaderModifier:
+				h := createHeadersFilter(filter.RequestHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.GetHeaders() == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.GetHeaders().Request = h
+			case gwv1.HTTPRouteFilterResponseHeaderModifier:
+				h := createHeadersFilter(filter.ResponseHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.GetHeaders() == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.GetHeaders().Response = h
+			default:
+				return nil, nil, &reporter.RouteCondition{
+					Type:    gwv1.RouteConditionAccepted,
+					Status:  metav1.ConditionFalse,
+					Reason:  gwv1.RouteReasonIncompatibleFilters,
+					Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
+			}
+		}
+		res = append(res, rd)
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildGRPCDestination(
+	ctx RouteContext,
+	forwardTo []gwv1.GRPCBackendRef,
+	ns string,
+) ([]*istio.HTTPRouteDestination, *reporter.RouteCondition, *reporter.RouteCondition) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+	weights := []int{}
+	action := []gwv1.GRPCBackendRef{}
+	for _, w := range forwardTo {
+		wt := int(ptr.OrDefault(w.Weight, 1))
+		if wt == 0 {
+			continue
+		}
+		action = append(action, w)
+		weights = append(weights, wt)
+	}
+	if len(weights) == 1 {
+		weights = []int{0}
+	}
+
+	var invalidBackendErr *reporter.RouteCondition
+	var res []*istio.HTTPRouteDestination
+	for i, fwd := range action {
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, wellknown.GRPCRouteGVK)
+		if err != nil {
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		rd := &istio.HTTPRouteDestination{
+			Destination: dst,
+			Weight:      int32(weights[i]),
+		}
+		for _, filter := range fwd.Filters {
+			switch filter.Type {
+			case gwv1.GRPCRouteFilterRequestHeaderModifier:
+				h := createHeadersFilter(filter.RequestHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.GetHeaders() == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.GetHeaders().Request = h
+			case gwv1.GRPCRouteFilterResponseHeaderModifier:
+				h := createHeadersFilter(filter.ResponseHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.GetHeaders() == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.GetHeaders().Response = h
+			default:
+				return nil, nil, &reporter.RouteCondition{
+					Type:    gwv1.RouteConditionAccepted,
+					Status:  metav1.ConditionFalse,
+					Reason:  gwv1.RouteReasonIncompatibleFilters,
+					Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
+			}
+		}
+		res = append(res, rd)
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildDestination(ctx RouteContext, to gwv1.BackendRef, ns string, k schema.GroupVersionKind) (*istio.Destination, *reporter.RouteCondition) {
+	// check if the reference is allowed
+	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
+		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
+			return &istio.Destination{}, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonRefNotPermitted,
+				Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
+			}
+		}
+	}
+
+	namespace := ptr.OrDefault((*string)(to.Namespace), ns)
+	var invalidBackendErr *reporter.RouteCondition
+	var hostname string
+	ref := normalizeReference(to.Group, to.Kind, wellknown.ServiceGVK)
+	switch ref {
+	case wellknown.InferencePoolGVK: // TODO: add validation
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+	case wellknown.ServiceGVK:
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+	case schema.GroupVersionKind{Group: wellknown.ServiceEntryGVK.Group, Kind: "Hostname"}:
+		if to.Namespace != nil {
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "namespace may not be set with Hostname type"}
+		}
+		hostname = string(to.Name)
+		// TODO: check hostname is valid
+	case schema.GroupVersionKind{Group: features.MCSAPIGroup, Kind: "ServiceImport"}:
+		hostname = fmt.Sprintf("%s.%s.svc.clusterset.local", to.Name, namespace)
+		if !features.EnableMCSHost {
+			// They asked for ServiceImport, but actually don't have full support enabled...
+			// No problem, we can just treat it as Service, which is already cross-cluster in this mode anyways
+			hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
+		}
+		// TODO: currently we are always looking for Service. We should be looking for ServiceImport when features.EnableMCSHost
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+	default:
+		return &istio.Destination{}, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionResolvedRefs,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonInvalidKind,
+			Message: fmt.Sprintf("referencing unsupported backendRef: group %q kind %q", ptr.OrEmpty(to.Group), ptr.OrEmpty(to.Kind)),
+		}
+	}
+	// All types currently require a Port, so we do this for everything; consider making this per-type if we have future types
+	// that do not require port.
+	if to.Port == nil {
+		// "Port is required when the referent is a Kubernetes Service."
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: "port is required in backendRef"}
+	}
+	return &istio.Destination{
+		Host: hostname,
+		Port: &istio.PortSelector{Number: uint32(*to.Port)},
+	}, invalidBackendErr
+}
+
+// https://github.com/kubernetes-sigs/gateway-api/blob/cea484e38e078a2c1997d8c7a62f410a1540f519/apis/v1beta1/httproute_types.go#L207-L212
+func isInvalidBackend(err *reporter.RouteCondition) bool {
+	return err.Reason == gwv1.RouteReasonRefNotPermitted ||
+		err.Reason == gwv1.RouteReasonBackendNotFound ||
+		err.Reason == gwv1.RouteReasonInvalidKind
+}
+
+func headerListToMap(hl []gwv1.HTTPHeader) map[string]string {
+	if len(hl) == 0 {
+		return nil
+	}
+	res := map[string]string{}
+	for _, e := range hl {
+		k := strings.ToLower(string(e.Name))
+		if _, f := res[k]; f {
+			// "Subsequent entries with an equivalent header name MUST be ignored"
+			continue
+		}
+		res[k] = e.Value
+	}
+	return res
+}
+
+func createMirrorFilter(ctx RouteContext, filter *gwv1.HTTPRequestMirrorFilter, ns string,
+	k schema.GroupVersionKind,
+) (*istio.HTTPMirrorPolicy, *reporter.RouteCondition) {
+	if filter == nil {
+		return nil, nil
+	}
+	var weightOne int32 = 1
+	dst, err := buildDestination(ctx, gwv1.BackendRef{
+		BackendObjectReference: filter.BackendRef,
+		Weight:                 &weightOne,
+	}, ns, k)
+	if err != nil {
+		return nil, err
+	}
+	var percent *istio.Percent
+	if f := filter.Fraction; f != nil {
+		percent = &istio.Percent{Value: (100 * float64(f.Numerator)) / float64(ptr.OrDefault(f.Denominator, int32(100)))}
+	} else if p := filter.Percent; p != nil {
+		percent = &istio.Percent{Value: float64(*p)}
+	}
+	return &istio.HTTPMirrorPolicy{Destination: dst, Percentage: percent}, nil
+}
+
+func createRewriteFilter(filter *gwv1.HTTPURLRewriteFilter) *istio.HTTPRewrite {
+	if filter == nil {
+		return nil
+	}
+	rewrite := &istio.HTTPRewrite{}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case gwv1.PrefixMatchHTTPPathModifier:
+			rewrite.Uri = strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")
+			if rewrite.GetUri() == "" {
+				// `/` means removing the prefix
+				rewrite.Uri = "/"
+			}
+		case gwv1.FullPathHTTPPathModifier:
+			rewrite.UriRegexRewrite = &istio.RegexRewrite{
+				Match:   "/.*",
+				Rewrite: *filter.Path.ReplaceFullPath,
+			}
+		}
+	}
+	if filter.Hostname != nil {
+		rewrite.Authority = string(*filter.Hostname)
+	}
+	// Nothing done
+	if rewrite.GetUri() == "" && rewrite.GetUriRegexRewrite() == nil && rewrite.GetAuthority() == "" {
+		return nil
+	}
+	return rewrite
+}
+
+func createCorsFilter(filter *gwv1.HTTPCORSFilter) *istio.CorsPolicy {
+	if filter == nil {
+		return nil
+	}
+	res := &istio.CorsPolicy{}
+	for _, r := range filter.AllowOrigins {
+		rs := string(r)
+		if len(rs) == 0 {
+			continue // Not valid anyways, but double check
+		}
+
+		// TODO: support wildcards (https://github.com/kubernetes-sigs/gateway-api/issues/3648)
+		res.AllowOrigins = append(res.GetAllowOrigins(), &istio.StringMatch{
+			MatchType: &istio.StringMatch_Exact{Exact: string(r)},
+		})
+	}
+	if filter.AllowCredentials {
+		res.AllowCredentials = wrappers.Bool(true)
+	}
+	for _, r := range filter.AllowMethods {
+		res.AllowMethods = append(res.GetAllowMethods(), string(r))
+	}
+	for _, r := range filter.AllowHeaders {
+		res.AllowHeaders = append(res.GetAllowHeaders(), string(r))
+	}
+	for _, r := range filter.ExposeHeaders {
+		res.ExposeHeaders = append(res.GetExposeHeaders(), string(r))
+	}
+	if filter.MaxAge > 0 {
+		res.MaxAge = durationpb.New(time.Duration(filter.MaxAge) * time.Second)
+	}
+
+	return res
+}
+
+func createRedirectFilter(filter *gwv1.HTTPRequestRedirectFilter) *istio.HTTPRedirect {
+	if filter == nil {
+		return nil
+	}
+	resp := &istio.HTTPRedirect{}
+	if filter.StatusCode != nil {
+		// Istio allows 301, 302, 303, 307, 308.
+		// Gateway allows only 301 and 302.
+		resp.RedirectCode = uint32(*filter.StatusCode)
+	}
+	if filter.Hostname != nil {
+		resp.Authority = string(*filter.Hostname)
+	}
+	if filter.Scheme != nil {
+		// Both allow http and https
+		resp.Scheme = *filter.Scheme
+	}
+	if filter.Port != nil {
+		resp.RedirectPort = &istio.HTTPRedirect_Port{Port: uint32(*filter.Port)}
+	} else {
+		// "When empty, port (if specified) of the request is used."
+		// this differs from Istio default
+		if filter.Scheme != nil {
+			resp.RedirectPort = &istio.HTTPRedirect_DerivePort{DerivePort: istio.HTTPRedirect_FROM_PROTOCOL_DEFAULT}
+		} else {
+			resp.RedirectPort = &istio.HTTPRedirect_DerivePort{DerivePort: istio.HTTPRedirect_FROM_REQUEST_PORT}
+		}
+	}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case gwv1.FullPathHTTPPathModifier:
+			resp.Uri = *filter.Path.ReplaceFullPath
+		case gwv1.PrefixMatchHTTPPathModifier:
+			resp.Uri = fmt.Sprintf("%%PREFIX()%%%s", *filter.Path.ReplacePrefixMatch)
+		}
+	}
+	return resp
+}
+
+func createHeadersFilter(filter *gwv1.HTTPHeaderFilter) *istio.Headers_HeaderOperations {
+	if filter == nil {
+		return nil
+	}
+	return &istio.Headers_HeaderOperations{
+		Add:    headerListToMap(filter.Add),
+		Remove: filter.Remove,
+		Set:    headerListToMap(filter.Set),
+	}
+}
+
+// nolint: unparam
+func createMethodMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *reporter.RouteCondition) {
+	if match.Method == nil {
+		return nil, nil
+	}
+	return &istio.StringMatch{
+		MatchType: &istio.StringMatch_Exact{Exact: string(*match.Method)},
+	}, nil
+}
+
+func createQueryParamsMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *reporter.RouteCondition) {
+	res := map[string]*istio.StringMatch{}
+	for _, qp := range match.QueryParams {
+		tp := gwv1.QueryParamMatchExact
+		if qp.Type != nil {
+			tp = *qp.Type
+		}
+		switch tp {
+		case gwv1.QueryParamMatchExact:
+			res[string(qp.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Exact{Exact: qp.Value},
+			}
+		case gwv1.QueryParamMatchRegularExpression:
+			res[string(qp.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: qp.Value},
+			}
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported QueryParams type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createHeadersMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *reporter.RouteCondition) {
+	res := map[string]*istio.StringMatch{}
+	for _, header := range match.Headers {
+		tp := gwv1.HeaderMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case gwv1.HeaderMatchExact:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Exact{Exact: header.Value},
+			}
+		case gwv1.HeaderMatchRegularExpression:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: header.Value},
+			}
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createGRPCHeadersMatch(match gwv1.GRPCRouteMatch) (map[string]*istio.StringMatch, *reporter.RouteCondition) {
+	res := map[string]*istio.StringMatch{}
+	for _, header := range match.Headers {
+		tp := gwv1.GRPCHeaderMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case gwv1.GRPCHeaderMatchExact:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Exact{Exact: header.Value},
+			}
+		case gwv1.GRPCHeaderMatchRegularExpression:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: header.Value},
+			}
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createURIMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *reporter.RouteCondition) {
+	tp := gwv1.PathMatchPathPrefix
+	if match.Path.Type != nil {
+		tp = *match.Path.Type
+	}
+	dest := "/"
+	if match.Path.Value != nil {
+		dest = *match.Path.Value
+	}
+	switch tp {
+	case gwv1.PathMatchPathPrefix:
+		// "When specified, a trailing `/` is ignored."
+		if dest != "/" {
+			dest = strings.TrimSuffix(dest, "/")
+		}
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Prefix{Prefix: dest},
+		}, nil
+	case gwv1.PathMatchExact:
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Exact{Exact: dest},
+		}, nil
+	case gwv1.PathMatchRegularExpression:
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Regex{Regex: dest},
+		}, nil
+	default:
+		// Should never happen, unless a new field is added
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+	}
+}
+
+func createGRPCURIMatch(match gwv1.GRPCRouteMatch) (*istio.StringMatch, *reporter.RouteCondition) {
+	m := match.Method
+	if m == nil {
+		return nil, nil
+	}
+	tp := gwv1.GRPCMethodMatchExact
+	if m.Type != nil {
+		tp = *m.Type
+	}
+	if m.Method == nil && m.Service == nil {
+		// Should never happen, invalid per spec
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: "gRPC match must have method or service defined"}
+	}
+	// gRPC format is /<Service>/<Method>. Since we don't natively understand this, convert to various string matches
+	switch tp {
+	case gwv1.GRPCMethodMatchExact:
+		if m.Method == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Prefix{Prefix: fmt.Sprintf("/%s/", *m.Service)},
+			}, nil
+		}
+		if m.Service == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/[^/]+/%s", *m.Method)},
+			}, nil
+		}
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Exact{Exact: fmt.Sprintf("/%s/%s", *m.Service, *m.Method)},
+		}, nil
+	case gwv1.GRPCMethodMatchRegularExpression:
+		if m.Method == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/%s/.+", *m.Service)},
+			}, nil
+		}
+		if m.Service == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/[^/]+/%s", *m.Method)},
+			}, nil
+		}
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/%s/%s", *m.Service, *m.Method)},
+		}, nil
+	default:
+		// Should never happen, unless a new field is added
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+	}
+}
+
+// parentKey holds info about a parentRef (eg route binding to a Gateway). This is a mirror of
+// gwv1.ParentReference in a form that can be stored in a map
+type parentKey struct {
+	Kind schema.GroupVersionKind
+	// Name is the original name of the resource (eg Kubernetes Gateway name)
+	Name string
+	// Namespace is the namespace of the resource
+	Namespace string
+}
+
+func (p parentKey) String() string {
+	return p.Kind.String() + "/" + p.Namespace + "/" + p.Name
+}
+
+type parentReference struct {
+	parentKey
+
+	SectionName gwv1.SectionName
+	Port        gwv1.PortNumber
+}
+
+func (p parentReference) String() string {
+	return p.parentKey.String() + "/" + string(p.SectionName) + "/" + fmt.Sprint(p.Port)
+}
+
+// parentInfo holds info about a "parent" - something that can be referenced as a ParentRef in the API.
+// Today, this is just Gateway
+type parentInfo struct {
+	// InternalName refers to the internal name we can reference it by. For example "my-ns/my-gateway"
+	InternalName string
+	// AllowedKinds indicates which kinds can be admitted by this parent
+	AllowedKinds []gwv1.RouteGroupKind
+	// Hostnames is the hostnames that must be match to reference to the parent. For gateway this is listener hostname
+	// Format is ns/hostname
+	Hostnames []string
+	// OriginalHostname is the unprocessed form of Hostnames; how it appeared in users' config
+	OriginalHostname string
+
+	SectionName gwv1.SectionName
+	Port        gwv1.PortNumber
+	Protocol    gwv1.ProtocolType
+}
+
+// routeParentReference holds information about a route's parent reference
+type routeParentReference struct {
+	// InternalName refers to the internal name of the parent we can reference it by. For example "my-ns/my-gateway"
+	InternalName string
+	// InternalKind is the Group/Kind of the parent
+	InternalKind schema.GroupVersionKind
+	// DeniedReason, if present, indicates why the reference was not valid
+	DeniedReason *ParentError
+	// OriginalReference contains the original reference
+	OriginalReference gwv1.ParentReference
+	// Hostname is the hostname match of the parent, if any
+	Hostname        string
+	BannedHostnames sets.Set[string]
+	ParentKey       parentKey
+	ParentSection   gwv1.SectionName
+}
+
+func (r routeParentReference) hostnameAllowedByIsolation(rawRouteHost string) bool {
+	routeHost := host.Name(rawRouteHost)
+	ourListener := host.Name(r.Hostname)
+	if len(ourListener) > 0 && !ourListener.IsWildCarded() {
+		// Short circuit: this logic only applies to wildcards
+		// Not required for correctness, just an optimization
+		return true
+	}
+	if len(ourListener) > 0 && !routeHost.Matches(ourListener) {
+		return false
+	}
+	for checkListener := range r.BannedHostnames {
+		// We have 3 hostnames here:
+		// * routeHost, the hostname in the route entry
+		// * ourListener, the hostname of the listener the route is bound to
+		// * checkListener, the hostname of the other listener we are comparing to
+		// We want to return false if checkListener would match the routeHost and it would be a more exact match
+		if len(ourListener) > len(checkListener) {
+			// If our hostname is longer, it must be more exact than the check
+			continue
+		}
+		// Ours is shorter. If it matches the checkListener, then it should ONLY match that one
+		// Note protocol, port, etc are already considered when we construct bannedHostnames
+		if routeHost.SubsetOf(host.Name(checkListener)) {
+			return false
+		}
+	}
+	return true
+}
+
+func filteredReferences(parents []routeParentReference) []routeParentReference {
+	ret := make([]routeParentReference, 0, len(parents))
+	for _, p := range parents {
+		if p.DeniedReason != nil {
+			// We should filter this out
+			continue
+		}
+		ret = append(ret, p)
+	}
+	// To ensure deterministic order, sort them
+	sort.Slice(ret, func(i, j int) bool {
+		return ret[i].InternalName < ret[j].InternalName
+	})
+	return ret
+}
+
+func getDefaultName(name string, kgw *gwv1.GatewaySpec) string {
+	return fmt.Sprintf("%v-%v", name, kgw.GatewayClassName)
+}
+
+// IsManaged checks if a Gateway is managed (ie we create the Deployment and Service) or unmanaged.
+// This is based on the address field of the spec. If address is set with a Hostname type, it should point to an existing
+// Service that handles the gateway traffic. If it is not set, or refers to only a single IP, we will consider it managed and provision the Service.
+// If there is an IP, we will set the `loadBalancerIP` type.
+// While there is no defined standard for this in the API yet, it is tracked in https://github.com/kubernetes-sigs/gateway-api/issues/892.
+// So far, this mirrors how out of clusters work (address set means to use existing IP, unset means to provision one),
+// and there has been growing consensus on this model for in cluster deployments.
+//
+// Currently, the supported options are:
+// * 1 Hostname value. This can be short Service name ingress, or FQDN ingress.ns.svc.cluster.local, example.com. If its a non-k8s FQDN it is a ServiceEntry.
+// * 1 IP address. This is managed, with IP explicit
+// * Nothing. This is managed, with IP auto assigned
+//
+// Not supported:
+// Multiple hostname/IP - It is feasible but preference is to create multiple Gateways. This would also break the 1:1 mapping of GW:Service
+// Mixed hostname and IP - doesn't make sense; user should define the IP in service
+// NamedAddress - Service has no concept of named address. For cloud's that have named addresses they can be configured by annotations,
+//
+//	which users can add to the Gateway.
+//
+// If manual deployments are disabled, IsManaged() always returns true.
+func IsManaged(gw *gwv1.GatewaySpec) bool {
+	//if !features.EnableGatewayAPIManualDeployment {
+	//	return true
+	//}
+	if len(gw.Addresses) == 0 {
+		return true
+	}
+	if len(gw.Addresses) > 1 {
+		return false
+	}
+	if t := gw.Addresses[0].Type; t == nil || *t == gwv1.IPAddressType {
+		return true
+	}
+	return false
+}
+
+func extractGatewayServices(domainSuffix string, kgw *gwv1.Gateway) ([]string, *reporter.RouteCondition) {
+	if IsManaged(&kgw.Spec) {
+		name := model.GetOrDefault(kgw.Annotations[annotation.GatewayNameOverride.Name], getDefaultName(kgw.Name, &kgw.Spec))
+		return []string{fmt.Sprintf("%s.%s.svc.%v", name, kgw.Namespace, domainSuffix)}, nil
+	}
+	gatewayServices := []string{}
+	skippedAddresses := []string{}
+	for _, addr := range kgw.Spec.Addresses {
+		if addr.Type != nil && *addr.Type != gwv1.HostnameAddressType {
+			// We only support HostnameAddressType. Keep track of invalid ones so we can report in status.
+			skippedAddresses = append(skippedAddresses, addr.Value)
+			continue
+		}
+		// TODO: For now we are using Addresses. There has been some discussion of allowing inline
+		// parameters on the class field like a URL, in which case we will probably just use that. See
+		// https://github.com/kubernetes-sigs/gateway-api/pull/614
+		fqdn := addr.Value
+		if !strings.Contains(fqdn, ".") {
+			// Short name, expand it
+			fqdn = fmt.Sprintf("%s.%s.svc.%s", fqdn, kgw.Namespace, domainSuffix)
+		}
+		gatewayServices = append(gatewayServices, fqdn)
+	}
+	if len(skippedAddresses) > 0 {
+		// Give error but return services, this is a soft failure
+		return gatewayServices, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("only Hostname is supported, ignoring %v", skippedAddresses),
+		}
+	}
+	if _, f := kgw.Annotations[annotation.NetworkingServiceType.Name]; f {
+		// Give error but return services, this is a soft failure
+		// Remove entirely in 1.20
+		return gatewayServices, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("annotation %v is deprecated, use Spec.Infrastructure.Routeability", annotation.NetworkingServiceType.Name),
+		}
+	}
+	return gatewayServices, nil
+}
+
+func buildListener(
+	ctx krt.HandlerContext,
+	secrets krt.Collection[*corev1.Secret],
+	grants ReferenceGrants,
+	namespaces krt.Collection[*corev1.Namespace],
+	obj *gwv1.Gateway,
+	status *gwv1.GatewayStatus,
+	l gwv1.Listener,
+	listenerIndex int,
+	controllerName gwv1.GatewayController,
+) (*istio.Server, *TLSInfo, bool) {
+	listenerConditions := map[string]*condition{
+		string(gwv1.ListenerConditionAccepted): {
+			reason:  string(gwv1.ListenerReasonAccepted),
+			message: "No errors found",
+		},
+		string(gwv1.ListenerConditionProgrammed): {
+			reason:  string(gwv1.ListenerReasonProgrammed),
+			message: "No errors found",
+		},
+		string(gwv1.ListenerConditionConflicted): {
+			reason:  string(gwv1.ListenerReasonNoConflicts),
+			message: "No errors found",
+			status:  kstatus.StatusFalse,
+		},
+		string(gwv1.ListenerConditionResolvedRefs): {
+			reason:  string(gwv1.ListenerReasonResolvedRefs),
+			message: "No errors found",
+		},
+	}
+
+	ok := true
+	tls, tlsInfo, err := buildTLS(ctx, secrets, grants, l.TLS, obj, kube.IsAutoPassthrough(obj.Labels, l))
+	if err != nil {
+		listenerConditions[string(gwv1.ListenerConditionResolvedRefs)].error = err
+		listenerConditions[string(gwv1.GatewayConditionProgrammed)].error = &ConfigError{
+			Reason:  string(gwv1.GatewayReasonInvalid),
+			Message: "Bad TLS configuration",
+		}
+		ok = false
+	}
+
+	hostnames := buildHostnameMatch(ctx, obj.Namespace, namespaces, l)
+	protocol, perr := listenerProtocolToAgentgateway(controllerName, l.Protocol)
+	if perr != nil {
+		listenerConditions[string(gwv1.ListenerConditionAccepted)].error = &ConfigError{
+			Reason:  string(gwv1.ListenerReasonUnsupportedProtocol),
+			Message: perr.Error(),
+		}
+		ok = false
+	}
+	server := &istio.Server{
+		Port: &istio.Port{
+			// Name is required. We only have one server per Gateway, so we can just name them all the same
+			Name:     "default",
+			Number:   uint32(l.Port),
+			Protocol: protocol,
+		},
+		Hosts: hostnames,
+		Tls:   tls,
+	}
+
+	reportListenerCondition(listenerIndex, l, obj, status, listenerConditions)
+	return server, tlsInfo, ok
+}
+
+var supportedProtocols = sets.New(
+	gwv1.HTTPProtocolType,
+	gwv1.HTTPSProtocolType,
+	gwv1.TLSProtocolType,
+	gwv1.TCPProtocolType,
+	gwv1.ProtocolType(protocol.HBONE))
+
+func listenerProtocolToAgentgateway(name gwv1.GatewayController, p gwv1.ProtocolType) (string, error) {
+	switch p {
+	// Standard protocol types
+	case gwv1.HTTPProtocolType:
+		return string(p), nil
+	case gwv1.HTTPSProtocolType:
+		return string(p), nil
+	case gwv1.TLSProtocolType, gwv1.TCPProtocolType:
+		if !features.EnableAlphaGatewayAPI {
+			return "", fmt.Errorf("protocol %q is supported, but only when %v=true is configured", p, features.EnableAlphaGatewayAPIName)
+		}
+		return string(p), nil
+	}
+	up := gwv1.ProtocolType(strings.ToUpper(string(p)))
+	if supportedProtocols.Contains(up) {
+		return "", fmt.Errorf("protocol %q is unsupported. hint: %q (uppercase) may be supported", p, up)
+	}
+	// Note: the k8s.UDPProtocolType is explicitly left to hit this path
+	return "", fmt.Errorf("protocol %q is unsupported", p)
+}
+
+func buildTLS(
+	ctx krt.HandlerContext,
+	secrets krt.Collection[*corev1.Secret],
+	grants ReferenceGrants,
+	tls *gwv1.GatewayTLSConfig,
+	gw *gwv1.Gateway,
+	isAutoPassthrough bool,
+) (*istio.ServerTLSSettings, *TLSInfo, *ConfigError) {
+	if tls == nil {
+		return nil, nil, nil
+	}
+	// Explicitly not supported: file mounted
+	// Not yet implemented: TLS mode, https redirect, max protocol version, SANs, CipherSuites, VerifyCertificate
+	out := &istio.ServerTLSSettings{
+		HttpsRedirect: false,
+	}
+	mode := gwv1.TLSModeTerminate
+	if tls.Mode != nil {
+		mode = *tls.Mode
+	}
+	namespace := gw.Namespace
+	switch mode {
+	case gwv1.TLSModeTerminate:
+		out.Mode = istio.ServerTLSSettings_SIMPLE
+		if tls.Options != nil {
+			switch tls.Options[gatewayTLSTerminateModeKey] {
+			case "MUTUAL":
+				out.Mode = istio.ServerTLSSettings_MUTUAL
+			case "ISTIO_MUTUAL":
+				out.Mode = istio.ServerTLSSettings_ISTIO_MUTUAL
+				return out, nil, nil
+			}
+		}
+		if len(tls.CertificateRefs) != 1 {
+			// This is required in the API, should be rejected in validation
+			return out, nil, &ConfigError{Reason: InvalidTLS, Message: "exactly 1 certificateRefs should be present for TLS termination"}
+		}
+		cred, tlsInfo, err := buildSecretReference(ctx, tls.CertificateRefs[0], gw, secrets)
+		if err != nil {
+			return out, nil, err
+		}
+		credNs := ptr.OrDefault((*string)(tls.CertificateRefs[0].Namespace), namespace)
+		sameNamespace := credNs == namespace
+		if !sameNamespace && !grants.SecretAllowed(ctx, creds.ToResourceName(cred), namespace) {
+			return out, nil, &ConfigError{
+				Reason: InvalidListenerRefNotPermitted,
+				Message: fmt.Sprintf(
+					"certificateRef %v/%v not accessible to a Gateway in namespace %q (missing a ReferenceGrant?)",
+					tls.CertificateRefs[0].Name, credNs, namespace,
+				),
+			}
+		}
+		out.CredentialName = cred
+		return out, &tlsInfo, nil
+	case gwv1.TLSModePassthrough:
+		out.Mode = istio.ServerTLSSettings_PASSTHROUGH
+		if isAutoPassthrough {
+			out.Mode = istio.ServerTLSSettings_AUTO_PASSTHROUGH
+		}
+	}
+	return out, nil, nil
+}
+
+func buildSecretReference(
+	ctx krt.HandlerContext,
+	ref gwv1.SecretObjectReference,
+	gw *gwv1.Gateway,
+	secrets krt.Collection[*corev1.Secret],
+) (string, TLSInfo, *ConfigError) {
+	if normalizeReference(ref.Group, ref.Kind, wellknown.SecretGVK) != wellknown.SecretGVK {
+		return "", TLSInfo{}, &ConfigError{Reason: InvalidTLS, Message: fmt.Sprintf("invalid certificate reference %v, only secret is allowed", objectReferenceString(ref))}
+	}
+
+	secret := ConfigKey{
+		Kind:      kind.Secret,
+		Name:      string(ref.Name),
+		Namespace: ptr.OrDefault((*string)(ref.Namespace), gw.Namespace),
+	}
+
+	key := secret.Namespace + "/" + secret.Name
+	scrt := ptr.Flatten(krt.FetchOne(ctx, secrets, krt.FilterKey(key)))
+	if scrt == nil {
+		return "", TLSInfo{}, &ConfigError{
+			Reason:  InvalidTLS,
+			Message: fmt.Sprintf("invalid certificate reference %v, secret %v not found", objectReferenceString(ref), key),
+		}
+	}
+	certInfo, err := kubecreds.ExtractCertInfo(scrt)
+	if err != nil {
+		return "", TLSInfo{}, &ConfigError{
+			Reason:  InvalidTLS,
+			Message: fmt.Sprintf("invalid certificate reference %v, %v", objectReferenceString(ref), err),
+		}
+	}
+	if _, err = tls.X509KeyPair(certInfo.Cert, certInfo.Key); err != nil {
+		return "", TLSInfo{}, &ConfigError{
+			Reason:  InvalidTLS,
+			Message: fmt.Sprintf("invalid certificate reference %v, the certificate is malformed: %v", objectReferenceString(ref), err),
+		}
+	}
+	return creds.ToKubernetesGatewayResource(secret.Namespace, secret.Name), TLSInfo{
+		Cert: certInfo.Cert,
+		Key:  certInfo.Key,
+	}, nil
+}
+
+func objectReferenceString(ref gwv1.SecretObjectReference) string {
+	return fmt.Sprintf("%s/%s/%s.%s",
+		ptr.OrEmpty(ref.Group),
+		ptr.OrEmpty(ref.Kind),
+		ref.Name,
+		ptr.OrEmpty(ref.Namespace))
+}
+
+func parentRefString(ref gwv1.ParentReference) string {
+	return fmt.Sprintf("%s/%s/%s/%s/%d.%s",
+		ptr.OrEmpty(ref.Group),
+		ptr.OrEmpty(ref.Kind),
+		ref.Name,
+		ptr.OrEmpty(ref.SectionName),
+		ptr.OrEmpty(ref.Port),
+		ptr.OrEmpty(ref.Namespace))
+}
+
+// buildHostnameMatch generates a Gateway.spec.servers.hosts section from a listener
+func buildHostnameMatch(ctx krt.HandlerContext, localNamespace string, namespaces krt.Collection[*corev1.Namespace], l gwv1.Listener) []string {
+	// We may allow all hostnames or a specific one
+	hostname := "*"
+	if l.Hostname != nil {
+		hostname = string(*l.Hostname)
+	}
+
+	resp := []string{}
+	for _, ns := range namespacesFromSelector(ctx, localNamespace, namespaces, l.AllowedRoutes) {
+		// This check is necessary to prevent adding a hostname with an invalid empty namespace
+		if len(ns) > 0 {
+			resp = append(resp, fmt.Sprintf("%s/%s", ns, hostname))
+		}
+	}
+
+	// If nothing matched use ~ namespace (match nothing). We need this since its illegal to have an
+	// empty hostname list, but we still need the Gateway provisioned to ensure status is properly set and
+	// SNI matches are established; we just don't want to actually match any routing rules (yet).
+	if len(resp) == 0 {
+		return []string{"~/" + hostname}
+	}
+	return resp
+}
+
+// namespacesFromSelector determines a list of allowed namespaces for a given AllowedRoutes
+func namespacesFromSelector(ctx krt.HandlerContext, localNamespace string, namespaceCol krt.Collection[*corev1.Namespace], lr *gwv1.AllowedRoutes) []string {
+	// Default is to allow only the same namespace
+	if lr == nil || lr.Namespaces == nil || lr.Namespaces.From == nil || *lr.Namespaces.From == gwv1.NamespacesFromSame {
+		return []string{localNamespace}
+	}
+	if *lr.Namespaces.From == gwv1.NamespacesFromAll {
+		return []string{"*"}
+	}
+
+	if lr.Namespaces.Selector == nil {
+		// Should never happen, invalid config
+		return []string{"*"}
+	}
+
+	// gateway-api has selectors, but Istio Gateway just has a list of names. We will run the selector
+	// against all namespaces and get a list of matching namespaces that can be converted into a list
+	// Istio can handle.
+	ls, err := metav1.LabelSelectorAsSelector(lr.Namespaces.Selector)
+	if err != nil {
+		return nil
+	}
+	namespaces := []string{}
+	namespaceObjects := krt.Fetch(ctx, namespaceCol)
+	for _, ns := range namespaceObjects {
+		if ls.Matches(toNamespaceSet(ns.Name, ns.Labels)) {
+			namespaces = append(namespaces, ns.Name)
+		}
+	}
+	// Ensure stable order
+	sort.Strings(namespaces)
+	return namespaces
+}
+
+// NamespaceNameLabel represents that label added automatically to namespaces is newer Kubernetes clusters
+const NamespaceNameLabel = "kubernetes.io/metadata.name"
+
+// toNamespaceSet converts a set of namespace labels to a Set that can be used to select against.
+func toNamespaceSet(name string, labels map[string]string) klabels.Set {
+	// If namespace label is not set, implicitly insert it to support older Kubernetes versions
+	if labels[NamespaceNameLabel] == name {
+		// Already set, avoid copies
+		return labels
+	}
+	// First we need a copy to not modify the underlying object
+	ret := make(map[string]string, len(labels)+1)
+	for k, v := range labels {
+		ret[k] = v
+	}
+	ret[NamespaceNameLabel] = name
+	return ret
+}
+
+func GetCommonRouteInfo(spec any) ([]gwv1.ParentReference, []gwv1.Hostname, schema.GroupVersionKind) {
+	switch t := spec.(type) {
+	case *gwv1alpha2.TCPRoute:
+		return t.Spec.ParentRefs, nil, wellknown.TCPRouteGVK
+	case *gwv1alpha2.TLSRoute:
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.TLSRouteGVK
+	case *gwv1.HTTPRoute:
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.HTTPRouteGVK
+	case *gwv1beta1.HTTPRoute: // TODO: support both v1 and v1beta1?
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.HTTPRouteGVK
+	case *gwv1.GRPCRoute:
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.GRPCRouteGVK
+	default:
+		log.Fatalf("unknown type %T", t)
+		return nil, nil, schema.GroupVersionKind{}
+	}
+}
+
+func defaultString[T ~string](s *T, def string) string {
+	if s == nil {
+		return def
+	}
+	return string(*s)
+}
+
+func toRouteKind(g schema.GroupVersionKind) gwv1.RouteGroupKind {
+	return gwv1.RouteGroupKind{Group: (*gwv1.Group)(&g.Group), Kind: gwv1.Kind(g.Kind)}
+}
+
+func routeGroupKindEqual(rgk1, rgk2 gwv1.RouteGroupKind) bool {
+	return rgk1.Kind == rgk2.Kind && getGroup(rgk1) == getGroup(rgk2)
+}
+
+func getGroup(rgk gwv1.RouteGroupKind) gwv1.Group {
+	return ptr.OrDefault(rgk.Group, wellknown.GatewayGroup)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
new file mode 100644
index 000000000..311f813c1
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
@@ -0,0 +1,268 @@
+package agentgatewaysyncer
+
+import (
+	"fmt"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	istio "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
+)
+
+func toResourcep(gw types.NamespacedName, t any) *ADPResource {
+	res := toResource(gw, t)
+	return &res
+}
+
+func toResourcepWithReports(gw types.NamespacedName, t any, reportMap reports.ReportMap) *ADPResource {
+	res := toResourceWithReports(gw, t, reportMap)
+	return &res
+}
+
+func toResource(gw types.NamespacedName, t any) ADPResource {
+	return toResourceWithReports(gw, t, reports.NewReportMap())
+}
+
+func toResourceWithReports(gw types.NamespacedName, t any, reportMap reports.ReportMap) ADPResource {
+	switch tt := t.(type) {
+	case Bind:
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Bind{tt.Bind}}, Gateway: gw, reports: reportMap}
+	case ADPListener:
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Listener{tt.Listener}}, Gateway: gw, reports: reportMap}
+	case ADPRoute:
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Route{tt.Route}}, Gateway: gw, reports: reportMap}
+	}
+	panic("unknown resource kind")
+}
+
+// TODO: we need some way to associate this to a specific instance of the proxy!!
+type Bind struct {
+	*api.Bind
+}
+
+func (g Bind) ResourceName() string {
+	return g.Key
+}
+
+func (g Bind) Equals(other Bind) bool {
+	return protoconv.Equals(g, other)
+}
+
+type ADPListener struct {
+	*api.Listener
+}
+
+func (g ADPListener) ResourceName() string {
+	return g.Key
+}
+
+func (g ADPListener) Equals(other ADPListener) bool {
+	return protoconv.Equals(g, other)
+}
+
+type ADPRoute struct {
+	*api.Route
+}
+
+func (g ADPRoute) ResourceName() string {
+	return g.Key
+}
+
+func (g ADPRoute) Equals(other ADPRoute) bool {
+	return protoconv.Equals(g, other)
+}
+
+type TLSInfo struct {
+	Cert []byte
+	Key  []byte `json:"-"`
+}
+
+type PortBindings struct {
+	Gateway
+	Port string
+}
+
+func (g PortBindings) ResourceName() string {
+	return g.Gateway.Name
+}
+
+func (g PortBindings) Equals(other PortBindings) bool {
+	return g.Gateway.Equals(other.Gateway) &&
+		g.Port == other.Port
+}
+
+type Gateway struct {
+	*Config
+	parent     parentKey
+	parentInfo parentInfo
+	TLSInfo    *TLSInfo
+	Valid      bool
+}
+
+func (g Gateway) ResourceName() string {
+	return g.Config.Name
+}
+
+func (g Gateway) Equals(other Gateway) bool {
+	// TODO: ok to ignore parent/parentInfo?
+	return g.Config.Equals(other.Config) &&
+		g.Valid == other.Valid
+}
+
+func GatewayCollection(
+	agentGatewayClassName string,
+	gateways krt.Collection[*gwv1.Gateway],
+	gatewayClasses krt.Collection[GatewayClass],
+	namespaces krt.Collection[*corev1.Namespace],
+	grants ReferenceGrants,
+	secrets krt.Collection[*corev1.Secret],
+	domainSuffix string,
+	krtopts krtutil.KrtOptions,
+	statusReporter reporter.Reporter,
+) krt.Collection[Gateway] {
+	gw := krt.NewManyCollection(gateways, func(ctx krt.HandlerContext, obj *gwv1.Gateway) []Gateway {
+		gwReporter := statusReporter.Gateway(obj)
+		logger.Debug("translating Gateway", "gw_name", obj.GetName(), "resource_version", obj.GetResourceVersion())
+
+		if string(obj.Spec.GatewayClassName) != agentGatewayClassName {
+			return nil // ignore non agentgateway gws
+		}
+
+		var result []Gateway
+		kgw := obj.Spec
+		status := obj.Status.DeepCopy()
+		class := fetchClass(ctx, gatewayClasses, kgw.GatewayClassName)
+		if class == nil {
+			return nil
+		}
+		controllerName := class.Controller
+		var servers []*istio.Server
+
+		// Extract the addresses. A gwv1 will bind to a specific Service
+		gatewayServices, err := extractGatewayServices(domainSuffix, obj)
+		if len(gatewayServices) == 0 && err != nil {
+			// Short circuit if its a hard failure
+			logger.Error("failed to translate gwv1", "name", obj.GetName(), "namespace", obj.GetNamespace(), "err", err.Message)
+			gwReporter.SetCondition(reporter.GatewayCondition{
+				Type:    gwv1.GatewayConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.GatewayReasonInvalid, // TODO: check reason
+				Message: err.Message,
+			})
+			return nil
+		}
+
+		for i, l := range kgw.Listeners {
+			server, tlsInfo, programmed := buildListener(ctx, secrets, grants, namespaces, obj, status, l, i, controllerName)
+			lstatus := status.Listeners[i]
+
+			// Generate supported kinds for the listener
+			allowed, _ := generateSupportedKinds(l)
+
+			// Set all listener conditions from the actual status
+			for _, condition := range lstatus.Conditions {
+				gwReporter.Listener(&l).SetCondition(reporter.ListenerCondition{
+					Type:    gwv1.ListenerConditionType(condition.Type),
+					Status:  condition.Status,
+					Reason:  gwv1.ListenerConditionReason(condition.Reason),
+					Message: condition.Message,
+				})
+			}
+
+			// Set supported kinds for the listener
+			gwReporter.Listener(&l).SetSupportedKinds(allowed)
+
+			servers = append(servers, server)
+			meta := parentMeta(obj, &l.Name)
+			// Each listener generates a Gateway with a single Server. This allows binding to a specific listener.
+			gatewayConfig := Config{
+				Meta: Meta{
+					CreationTimestamp: obj.CreationTimestamp.Time,
+					GroupVersionKind:  schema.GroupVersionKind{Group: wellknown.GatewayGroup, Kind: wellknown.GatewayKind},
+					Name:              InternalGatewayName(obj.Name, string(l.Name)),
+					Annotations:       meta,
+					Namespace:         obj.Namespace,
+					Domain:            domainSuffix,
+				},
+				// TODO: clean up and move away from istio gwv1 ir
+				Spec: &istio.Gateway{
+					Servers: []*istio.Server{server},
+				},
+			}
+			ref := parentKey{
+				Kind:      wellknown.GatewayGVK,
+				Name:      obj.Name,
+				Namespace: obj.Namespace,
+			}
+			pri := parentInfo{
+				InternalName:     obj.Namespace + "/" + gatewayConfig.Name,
+				AllowedKinds:     allowed,
+				Hostnames:        server.GetHosts(),
+				OriginalHostname: string(ptr.OrEmpty(l.Hostname)),
+				SectionName:      l.Name,
+				Port:             l.Port,
+				Protocol:         l.Protocol,
+			}
+
+			res := Gateway{
+				Config:     &gatewayConfig,
+				Valid:      programmed,
+				TLSInfo:    tlsInfo,
+				parent:     ref,
+				parentInfo: pri,
+			}
+			result = append(result, res)
+		}
+
+		gwReporter.SetCondition(reporter.GatewayCondition{
+			Type:   gwv1.GatewayConditionAccepted,
+			Status: metav1.ConditionTrue,
+			Reason: gwv1.GatewayReasonAccepted,
+		})
+		return result
+	}, krtopts.ToOptions("KubernetesGateway")...)
+
+	return gw
+}
+
+// RouteParents holds information about things routes can reference as parents.
+type RouteParents struct {
+	gateways     krt.Collection[Gateway]
+	gatewayIndex krt.Index[parentKey, Gateway]
+}
+
+func (p RouteParents) fetch(ctx krt.HandlerContext, pk parentKey) []*parentInfo {
+	return slices.Map(krt.Fetch(ctx, p.gateways, krt.FilterIndex(p.gatewayIndex, pk)), func(gw Gateway) *parentInfo {
+		return &gw.parentInfo
+	})
+}
+
+func BuildRouteParents(
+	gateways krt.Collection[Gateway],
+) RouteParents {
+	idx := krt.NewIndex(gateways, func(o Gateway) []parentKey {
+		return []parentKey{o.parent}
+	})
+	return RouteParents{
+		gateways:     gateways,
+		gatewayIndex: idx,
+	}
+}
+
+// InternalGatewayName returns the name of the internal Istio Gateway corresponding to the
+// specified gwv1-api gwv1 and listener.
+func InternalGatewayName(gwName, lName string) string {
+	return fmt.Sprintf("%s-%s-%s", gwName, AgentgatewayName, lName)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
new file mode 100644
index 000000000..2570a2e84
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
@@ -0,0 +1,41 @@
+package agentgatewaysyncer
+
+import (
+	"istio.io/istio/pkg/kube/krt"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+)
+
+type GatewayClass struct {
+	Name       string
+	Controller gwv1.GatewayController
+}
+
+func (g GatewayClass) ResourceName() string {
+	return g.Name
+}
+
+func GatewayClassesCollection(
+	gatewayClasses krt.Collection[*gwv1.GatewayClass],
+	krtopts krtutil.KrtOptions,
+) krt.Collection[GatewayClass] {
+	return krt.NewCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gwv1.GatewayClass) *GatewayClass {
+		return &GatewayClass{
+			Name:       obj.Name,
+			Controller: obj.Spec.ControllerName,
+		}
+	}, krtopts.ToOptions("GatewayClasses")...)
+}
+
+func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayClass], gc gwv1.ObjectName) *GatewayClass {
+	class := krt.FetchOne(ctx, gatewayClasses, krt.FilterKey(string(gc)))
+	if class == nil {
+		return &GatewayClass{
+			Name:       string(gc),
+			Controller: wellknown.DefaultGatewayControllerName, // TODO: make this configurable
+		}
+	}
+	return class
+}
diff --git a/internal/kgateway/agentgatewaysyncer/model.go b/internal/kgateway/agentgatewaysyncer/model.go
new file mode 100644
index 000000000..852354393
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/model.go
@@ -0,0 +1,344 @@
+package agentgatewaysyncer
+
+import (
+	"fmt"
+	"maps"
+	"reflect"
+	"slices"
+	"time"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	udpa "github.com/cncf/xds/go/udpa/type/v1"
+	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/reflect/protoreflect"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/util/hash"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/utils/ptr"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+)
+
+// Statically link protobuf descriptors from UDPA
+var _ = udpa.TypedStruct{}
+
+type ConfigHash uint64
+
+// ConfigKey describe a specific config item.
+// In most cases, the name is the config's name. However, for ServiceEntry it is service's FQDN.
+type ConfigKey struct {
+	Kind      kind.Kind
+	Name      string
+	Namespace string
+}
+
+func (key ConfigKey) HashCode() ConfigHash {
+	h := hash.New()
+	h.Write([]byte{byte(key.Kind)})
+	// Add separator / to avoid collision.
+	h.WriteString("/")
+	h.WriteString(key.Namespace)
+	h.WriteString("/")
+	h.WriteString(key.Name)
+	return ConfigHash(h.Sum64())
+}
+
+func (key ConfigKey) String() string {
+	return key.Kind.String() + "/" + key.Namespace + "/" + key.Name
+}
+
+type ADPCacheResource struct {
+	Gateway types.NamespacedName `json:"gateway"`
+	reports reports.ReportMap
+
+	Resources envoycache.Resources
+
+	VersionMap map[string]map[string]string
+}
+
+func (r ADPCacheResource) ResourceName() string {
+	return fmt.Sprintf("%s~%s", r.Gateway.Namespace, r.Gateway.Name)
+}
+
+func (r ADPCacheResource) Equals(in ADPCacheResource) bool {
+	return r.Gateway == in.Gateway &&
+		report{r.reports}.Equals(report{in.reports}) &&
+		r.Resources.Version == in.Resources.Version
+}
+
+type ADPCacheAddress struct {
+	NamespacedName types.NamespacedName
+
+	Address             proto.Message
+	AddressResourceName string
+	AddressVersion      uint64
+
+	reports    reports.ReportMap
+	VersionMap map[string]map[string]string
+}
+
+func (r ADPCacheAddress) ResourceName() string {
+	return r.NamespacedName.String()
+}
+
+func (r ADPCacheAddress) Equals(in ADPCacheAddress) bool {
+	return report{r.reports}.Equals(report{in.reports}) &&
+		r.NamespacedName.Name == in.NamespacedName.Name && r.NamespacedName.Namespace == in.NamespacedName.Namespace &&
+		proto.Equal(r.Address, in.Address) &&
+		r.AddressVersion == in.AddressVersion &&
+		r.AddressResourceName == in.AddressResourceName
+}
+
+type ADPResource struct {
+	Resource *api.Resource        `json:"resource"`
+	Gateway  types.NamespacedName `json:"gateway"`
+
+	reports reports.ReportMap
+}
+
+func (g ADPResource) ResourceName() string {
+	switch t := g.Resource.GetKind().(type) {
+	case *api.Resource_Bind:
+		return "bind/" + t.Bind.GetKey()
+	case *api.Resource_Listener:
+		return "listener/" + t.Listener.GetKey()
+	case *api.Resource_Route:
+		return "route/" + t.Route.GetKey()
+	}
+	panic("unknown resource kind")
+}
+
+func (g ADPResource) Equals(other ADPResource) bool {
+	return proto.Equal(g.Resource, other.Resource) && g.Gateway == other.Gateway &&
+		report{g.reports}.Equals(report{other.reports})
+}
+
+// Meta is metadata attached to each configuration unit.
+// The revision is optional, and if provided, identifies the
+// last update operation on the object.
+type Meta struct {
+	// GroupVersionKind is a short configuration name that matches the content message type
+	// (e.g. "route-rule")
+	GroupVersionKind schema.GroupVersionKind `json:"type,omitempty"`
+
+	// UID
+	UID string `json:"uid,omitempty"`
+
+	// Name is a unique immutable identifier in a namespace
+	Name string `json:"name,omitempty"`
+
+	// Namespace defines the space for names (optional for some types),
+	// applications may choose to use namespaces for a variety of purposes
+	// (security domains, fault domains, organizational domains)
+	Namespace string `json:"namespace,omitempty"`
+
+	// Domain defines the suffix of the fully qualified name past the namespace.
+	// Domain is not a part of the unique key unlike name and namespace.
+	Domain string `json:"domain,omitempty"`
+
+	// Map of string keys and values that can be used to organize and categorize
+	// (scope and select) objects.
+	Labels map[string]string `json:"labels,omitempty"`
+
+	// Annotations is an unstructured key value map stored with a resource that may be
+	// set by external tools to store and retrieve arbitrary metadata. They are not
+	// queryable and should be preserved when modifying objects.
+	Annotations map[string]string `json:"annotations,omitempty"`
+
+	// ResourceVersion is an opaque identifier for tracking updates to the config registry.
+	// The implementation may use a change index or a commit log for the revision.
+	// The config client should not make any assumptions about revisions and rely only on
+	// exact equality to implement optimistic concurrency of read-write operations.
+	//
+	// The lifetime of an object of a particular revision depends on the underlying data store.
+	// The data store may compactify old revisions in the interest of storage optimization.
+	//
+	// An empty revision carries a special meaning that the associated object has
+	// not been stored and assigned a revision.
+	ResourceVersion string `json:"resourceVersion,omitempty"`
+
+	// CreationTimestamp records the creation time
+	CreationTimestamp time.Time `json:"creationTimestamp,omitempty"`
+
+	// OwnerReferences allows specifying in-namespace owning objects.
+	OwnerReferences []metav1.OwnerReference `json:"ownerReferences,omitempty"`
+
+	// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
+	Generation int64 `json:"generation,omitempty"`
+}
+
+// Config is a configuration unit consisting of the type of configuration, the
+// key identifier that is unique per type, and the content represented as a
+// protobuf message.
+type Config struct {
+	Meta
+
+	// Spec holds the configuration object as a gogo protobuf message
+	Spec Spec
+
+	// Status holds long-running status.
+	Status Status
+}
+
+type TypedResource struct {
+	Kind schema.GroupVersionKind
+	Name types.NamespacedName
+}
+
+// Spec defines the spec for the  In order to use below helper methods,
+// this must be one of:
+// * golang/protobuf Message
+// * gogo/protobuf Message
+// * Able to marshal/unmarshal using json
+type Spec any
+
+func (c *Config) Equals(other *Config) bool {
+	am, bm := c.Meta, other.Meta
+	if am.GroupVersionKind != bm.GroupVersionKind {
+		return false
+	}
+	if am.UID != bm.UID {
+		return false
+	}
+	if am.Name != bm.Name {
+		return false
+	}
+	if am.Namespace != bm.Namespace {
+		return false
+	}
+	if am.Domain != bm.Domain {
+		return false
+	}
+	if !maps.Equal(am.Labels, bm.Labels) {
+		return false
+	}
+	if !maps.Equal(am.Annotations, bm.Annotations) {
+		return false
+	}
+	if am.ResourceVersion != bm.ResourceVersion {
+		return false
+	}
+	if am.CreationTimestamp != bm.CreationTimestamp {
+		return false
+	}
+	if !slices.EqualFunc(am.OwnerReferences, bm.OwnerReferences, func(a metav1.OwnerReference, b metav1.OwnerReference) bool {
+		if a.APIVersion != b.APIVersion {
+			return false
+		}
+		if a.Kind != b.Kind {
+			return false
+		}
+		if a.Name != b.Name {
+			return false
+		}
+		if a.UID != b.UID {
+			return false
+		}
+		if !ptr.Equal(a.Controller, b.Controller) {
+			return false
+		}
+		if !ptr.Equal(a.BlockOwnerDeletion, b.BlockOwnerDeletion) {
+			return false
+		}
+		return true
+	}) {
+		return false
+	}
+	if am.Generation != bm.Generation {
+		return false
+	}
+
+	if !equals(c.Spec, other.Spec) {
+		return false
+	}
+	if !equals(c.Status, other.Status) {
+		return false
+	}
+	return true
+}
+
+func equals(a any, b any) bool {
+	if _, ok := a.(protoreflect.ProtoMessage); ok {
+		if pb, ok := a.(proto.Message); ok {
+			return proto.Equal(pb, b.(proto.Message))
+		}
+	}
+	// We do NOT do gogo here. The reason is Kubernetes has hacked up almost-gogo types that do not allow Equals() calls
+
+	return reflect.DeepEqual(a, b)
+}
+
+type Status any
+
+// Key function for the configuration objects
+func Key(grp, ver, typ, name, namespace string) string {
+	return grp + "/" + ver + "/" + typ + "/" + namespace + "/" + name // Format: %s/%s/%s/%s/%s
+}
+
+// Key is the unique identifier for a configuration object
+func (meta *Meta) Key() string {
+	return Key(
+		meta.GroupVersionKind.Group, meta.GroupVersionKind.Version, meta.GroupVersionKind.Kind,
+		meta.Name, meta.Namespace)
+}
+
+func (meta *Meta) ToObjectMeta() metav1.ObjectMeta {
+	return metav1.ObjectMeta{
+		Name:              meta.Name,
+		Namespace:         meta.Namespace,
+		UID:               types.UID(meta.UID),
+		ResourceVersion:   meta.ResourceVersion,
+		Generation:        meta.Generation,
+		CreationTimestamp: metav1.NewTime(meta.CreationTimestamp),
+		Labels:            meta.Labels,
+		Annotations:       meta.Annotations,
+		OwnerReferences:   meta.OwnerReferences,
+	}
+}
+
+func (c *Config) GetName() string {
+	return c.Name
+}
+
+func (c *Config) GetNamespace() string {
+	return c.Namespace
+}
+
+func (c *Config) GetCreationTimestamp() time.Time {
+	return c.CreationTimestamp
+}
+
+func (c *Config) NamespacedName() types.NamespacedName {
+	return types.NamespacedName{
+		Namespace: c.Namespace,
+		Name:      c.Name,
+	}
+}
+
+type Index[K comparable, O any] interface {
+	Lookup(k K) []O
+	// AsCollection(opts ...CollectionOption) Collection[IndexObject[K, O]]
+	objectHasKey(obj O, k K) bool
+	extractKeys(o O) []K
+	LookupCount(k K) int
+}
+
+type IndexObject[K comparable, O any] struct {
+	Key     K
+	Objects []O
+}
+
+func (i IndexObject[K, O]) ResourceName() string {
+	return toString(i.Key)
+}
+
+func toString(rk any) string {
+	tk, ok := rk.(string)
+	if !ok {
+		return rk.(fmt.Stringer).String()
+	}
+	return tk
+}
diff --git a/internal/kgateway/agentgatewaysyncer/references_collection.go b/internal/kgateway/agentgatewaysyncer/references_collection.go
new file mode 100644
index 000000000..2fb25189e
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/references_collection.go
@@ -0,0 +1,152 @@
+package agentgatewaysyncer
+
+import (
+	"fmt"
+
+	creds "istio.io/istio/pilot/pkg/model/credentials"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/kube/krt"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+)
+
+// Reference stores a reference to a namespaced GVK, as used by ReferencePolicy
+type Reference struct {
+	Kind      schema.GroupVersionKind
+	Namespace gwv1beta1.Namespace
+}
+
+func (refs Reference) String() string {
+	return refs.Kind.String() + "/" + string(refs.Namespace)
+}
+
+type ReferencePair struct {
+	To, From Reference
+}
+
+func (r ReferencePair) String() string {
+	return fmt.Sprintf("%s->%s", r.To, r.From)
+}
+
+type ReferenceGrants struct {
+	collection krt.Collection[ReferenceGrant]
+	index      krt.Index[ReferencePair, ReferenceGrant]
+}
+
+func ReferenceGrantsCollection(referenceGrants krt.Collection[*gwv1beta1.ReferenceGrant], krtopts krtutil.KrtOptions) krt.Collection[ReferenceGrant] {
+	return krt.NewManyCollection(referenceGrants, func(ctx krt.HandlerContext, obj *gwv1beta1.ReferenceGrant) []ReferenceGrant {
+		rp := obj.Spec
+		results := make([]ReferenceGrant, 0, len(rp.From)*len(rp.To))
+		for _, from := range rp.From {
+			fromKey := Reference{
+				Namespace: from.Namespace,
+			}
+			if string(from.Group) == wellknown.GatewayGVK.Group && string(from.Kind) == wellknown.GatewayKind {
+				fromKey.Kind = wellknown.GatewayGVK
+			} else if string(from.Group) == wellknown.HTTPRouteGVK.Group && string(from.Kind) == wellknown.HTTPRouteKind {
+				fromKey.Kind = wellknown.HTTPRouteGVK
+			} else if string(from.Group) == wellknown.GRPCRouteGVK.Group && string(from.Kind) == wellknown.GRPCRouteKind {
+				fromKey.Kind = wellknown.GRPCRouteGVK
+			} else if string(from.Group) == wellknown.TLSRouteGVK.Group && string(from.Kind) == wellknown.TLSRouteKind {
+				fromKey.Kind = wellknown.TLSRouteGVK
+			} else if string(from.Group) == wellknown.TCPRouteGVK.Group && string(from.Kind) == wellknown.TCPRouteKind {
+				fromKey.Kind = wellknown.TCPRouteGVK
+			} else {
+				// Not supported type. Not an error; may be for another controller
+				continue
+			}
+			for _, to := range rp.To {
+				toKey := Reference{
+					Namespace: gwv1beta1.Namespace(obj.Namespace),
+				}
+				if to.Group == "" && string(to.Kind) == wellknown.SecretGVK.Kind {
+					toKey.Kind = wellknown.SecretGVK
+				} else if to.Group == "" && string(to.Kind) == wellknown.ServiceKind {
+					toKey.Kind = wellknown.ServiceGVK
+				} else {
+					// Not supported type. Not an error; may be for another controller
+					continue
+				}
+				rg := ReferenceGrant{
+					Source:      config.NamespacedName(obj),
+					From:        fromKey,
+					To:          toKey,
+					AllowAll:    false,
+					AllowedName: "",
+				}
+				if to.Name != nil {
+					rg.AllowedName = string(*to.Name)
+				} else {
+					rg.AllowAll = true
+				}
+				results = append(results, rg)
+			}
+		}
+		return results
+	}, krtopts.ToOptions("ReferenceGrants")...)
+}
+
+func BuildReferenceGrants(collection krt.Collection[ReferenceGrant]) ReferenceGrants {
+	idx := krt.NewIndex(collection, func(o ReferenceGrant) []ReferencePair {
+		return []ReferencePair{{
+			To:   o.To,
+			From: o.From,
+		}}
+	})
+	return ReferenceGrants{
+		collection: collection,
+		index:      idx,
+	}
+}
+
+type ReferenceGrant struct {
+	Source      types.NamespacedName
+	From        Reference
+	To          Reference
+	AllowAll    bool
+	AllowedName string
+}
+
+func (g ReferenceGrant) ResourceName() string {
+	return g.Source.String() + "/" + g.From.String() + "/" + g.To.String()
+}
+
+func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName string, namespace string) bool {
+	p, err := creds.ParseResourceName(resourceName, "", "", "")
+	if err != nil {
+		logger.Warn("failed to parse resource name", "resourceName", resourceName, "error", err)
+		return false
+	}
+	from := Reference{Kind: wellknown.GatewayGVK, Namespace: gwv1beta1.Namespace(namespace)}
+	to := Reference{Kind: wellknown.SecretGVK, Namespace: gwv1beta1.Namespace(p.Namespace)}
+	pair := ReferencePair{From: from, To: to}
+	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
+	for _, g := range grants {
+		if g.AllowAll || g.AllowedName == p.Name {
+			return true
+		}
+	}
+	return false
+}
+
+func (refs ReferenceGrants) BackendAllowed(ctx krt.HandlerContext,
+	k schema.GroupVersionKind,
+	backendName gwv1beta1.ObjectName,
+	backendNamespace gwv1beta1.Namespace,
+	routeNamespace string,
+) bool {
+	from := Reference{Kind: k, Namespace: gwv1beta1.Namespace(routeNamespace)}
+	to := Reference{Kind: wellknown.SecretGVK, Namespace: backendNamespace}
+	pair := ReferencePair{From: from, To: to}
+	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
+	for _, g := range grants {
+		if g.AllowAll || g.AllowedName == string(backendName) {
+			return true
+		}
+	}
+	return false
+}
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
new file mode 100644
index 000000000..edab6364e
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -0,0 +1,172 @@
+package agentgatewaysyncer
+
+import (
+	"iter"
+	"strings"
+
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/protomarshal"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/types"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
+)
+
+// TODO: support other route collections (TCP, TLS, etc.)
+func ADPRouteCollection(
+	httpRoutes krt.Collection[*gwv1.HTTPRoute],
+	inputs RouteContextInputs,
+	krtopts krtutil.KrtOptions,
+	rm reports.ReportMap,
+	rep reporter.Reporter,
+) krt.Collection[ADPResource] {
+	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gwv1.HTTPRoute) []ADPResource {
+		logger.Debug("translating HTTPRoute", "route_name", obj.GetName(), "resource_version", obj.GetResourceVersion())
+
+		ctx := inputs.WithCtx(krtctx)
+		routeReporter := rep.Route(obj)
+		route := obj.Spec
+		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gwv1.HTTPRoute) iter.Seq2[ADPRoute, *reporter.RouteCondition] {
+			return func(yield func(ADPRoute, *reporter.RouteCondition) bool) {
+				for n, r := range route.Rules {
+					// split the rule to make sure each rule has up to one match
+					matches := slices.Reference(r.Matches)
+					if len(matches) == 0 {
+						matches = append(matches, nil)
+					}
+					for idx, m := range matches {
+						if m != nil {
+							r.Matches = []gwv1.HTTPRouteMatch{*m}
+						}
+						res, err := convertHTTPRouteToADP(ctx, r, obj, n, idx)
+						if !yield(ADPRoute{Route: res}, err) {
+							return
+						}
+					}
+				}
+			}
+		})
+
+		var res []ADPResource
+		for _, parent := range filteredReferences(parentRefs) {
+			// Always create a route reporter entry for the parent ref
+			parentRefReporter := routeReporter.ParentRef(&parent.OriginalReference)
+
+			// for gwv1beta1 routes, build one VS per gwv1beta1+host
+			routes := gwResult.routes
+			if len(routes) == 0 {
+				logger.Debug("no routes for parent", "route_name", obj.GetName(), "parent", parent.ParentKey)
+				continue
+			}
+			if gwResult.error != nil {
+				parentRefReporter.SetCondition(*gwResult.error)
+			}
+
+			gw := types.NamespacedName{
+				Namespace: parent.ParentKey.Namespace,
+				Name:      parent.ParentKey.Name,
+			}
+			res = append(res, slices.Map(routes, func(e ADPRoute) ADPResource {
+				inner := protomarshal.Clone(e.Route)
+				_, name, _ := strings.Cut(parent.InternalName, "/")
+				inner.ListenerKey = name
+				inner.Key = inner.GetKey() + "." + string(parent.ParentSection)
+				return toResourceWithReports(gw, ADPRoute{Route: inner}, rm)
+			})...)
+		}
+		return res
+	}, krtopts.ToOptions("ADPRoutes")...)
+
+	return routes
+}
+
+type conversionResult[O any] struct {
+	error  *reporter.RouteCondition
+	routes []O
+}
+
+// IsNil works around comparing generic types
+func IsNil[O comparable](o O) bool {
+	var t O
+	return o == t
+}
+
+// computeRoute holds the common route building logic shared amongst all types
+func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, translator func(
+	obj T,
+) iter.Seq2[O, *reporter.RouteCondition],
+) ([]routeParentReference, conversionResult[O]) {
+	parentRefs := extractParentReferenceInfo(ctx, ctx.RouteParents, obj)
+
+	convertRules := func() conversionResult[O] {
+		res := conversionResult[O]{}
+		for vs, err := range translator(obj) {
+			// This was a hard error
+			if IsNil(vs) {
+				res.error = err
+				return conversionResult[O]{error: err}
+			}
+			// Got an error but also routes
+			if err != nil {
+				res.error = err
+			}
+			res.routes = append(res.routes, vs)
+		}
+		return res
+	}
+	gwResult := buildGatewayRoutes(parentRefs, convertRules)
+
+	return parentRefs, gwResult
+}
+
+// RouteContext defines a common set of inputs to a route collection. This should be built once per route translation and
+// not shared outside of that.
+// The embedded RouteContextInputs is typically based into a collection, then translated to a RouteContext with RouteContextInputs.WithCtx().
+type RouteContext struct {
+	Krt krt.HandlerContext
+	RouteContextInputs
+}
+
+type RouteContextInputs struct {
+	Grants         ReferenceGrants
+	RouteParents   RouteParents
+	DomainSuffix   string
+	Services       krt.Collection[*corev1.Service]
+	InferencePools krt.Collection[*inf.InferencePool]
+	Namespaces     krt.Collection[*corev1.Namespace]
+	ServiceEntries krt.Collection[*networkingclient.ServiceEntry]
+}
+
+func (i RouteContextInputs) WithCtx(krtctx krt.HandlerContext) RouteContext {
+	return RouteContext{
+		Krt:                krtctx,
+		RouteContextInputs: i,
+	}
+}
+
+type RouteWithKey struct {
+	*Config
+	Key string
+}
+
+func (r RouteWithKey) ResourceName() string {
+	return config.NamespacedName(r.Config).String()
+}
+
+func (r RouteWithKey) Equals(o RouteWithKey) bool {
+	return r.Config.Equals(o.Config)
+}
+
+// buildGatewayRoutes contains common logic to build a set of routes with gwv1beta1 semantics
+func buildGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func() T) T {
+	return convertRules()
+}
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections_test.go b/internal/kgateway/agentgatewaysyncer/route_collections_test.go
new file mode 100644
index 000000000..ca96d031b
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/route_collections_test.go
@@ -0,0 +1,1065 @@
+package agentgatewaysyncer
+
+import (
+	"context"
+	"testing"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pkg/kube/krt/krttest"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/utils/ptr"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+)
+
+var (
+	groupName = gwv1.Group(gwv1.GroupName)
+)
+
+func TestADPRouteCollection(t *testing.T) {
+	testCases := []struct {
+		name           string
+		httpRoutes     []*gwv1.HTTPRoute
+		services       []*corev1.Service
+		namespaces     []*corev1.Namespace
+		gateways       []Gateway
+		refGrants      []ReferenceGrant
+		expectedCount  int
+		expectedRoutes []*api.Route
+	}{
+		{
+			name: "Simple HTTP route with single rule",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/api"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 1,
+			expectedRoutes: []*api.Route{
+				{
+					Key:       "default.test-route.0.0.http",
+					RouteName: "default/test-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/api",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "HTTP route with multiple rules",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "multi-rule-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/api"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/admin"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "admin-service",
+												Port: ptr.To(gwv1.PortNumber(8080)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "admin-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 8080,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 2,
+			expectedRoutes: []*api.Route{ // TODO: consistent ordering of routes?
+				{
+					Key:       "default.multi-rule-route.0.0.http",
+					RouteName: "default/multi-rule-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/api",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+				{
+					Key:       "default.multi-rule-route.1.0.http",
+					RouteName: "default/multi-rule-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/admin",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/admin-service.default.svc.cluster.local",
+							},
+							Port: 8080,
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "HTTP route with exact path match",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "exact-match-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"api.example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchExact),
+											Value: ptr.To("/exact"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 1,
+			expectedRoutes: []*api.Route{
+				{
+					Key:       "default.exact-match-route.0.0.http",
+					RouteName: "default/exact-match-route",
+					Hostnames: []string{"api.example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_Exact{
+									Exact: "/exact",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "HTTP route with header match",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "header-match-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/api"),
+										},
+										Headers: []gwv1.HTTPHeaderMatch{
+											{
+												Type:  ptr.To(gwv1.HeaderMatchExact),
+												Name:  "X-API-Version",
+												Value: "v1",
+											},
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 1,
+			expectedRoutes: []*api.Route{
+				{
+					Key:       "default.header-match-route.0.0.http",
+					RouteName: "default/header-match-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/api",
+								},
+							},
+							Headers: []*api.HeaderMatch{
+								{
+									Name: "X-API-Version",
+									Value: &api.HeaderMatch_Exact{
+										Exact: "v1",
+									},
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+			},
+		},
+		{
+			name:           "No HTTP routes",
+			httpRoutes:     []*gwv1.HTTPRoute{},
+			services:       []*corev1.Service{},
+			namespaces:     []*corev1.Namespace{},
+			gateways:       []Gateway{},
+			refGrants:      []ReferenceGrant{},
+			expectedCount:  0,
+			expectedRoutes: []*api.Route{},
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			// Prepare inputs
+			var inputs []any
+			for _, route := range tc.httpRoutes {
+				inputs = append(inputs, route)
+			}
+			for _, svc := range tc.services {
+				inputs = append(inputs, svc)
+			}
+			for _, ns := range tc.namespaces {
+				inputs = append(inputs, ns)
+			}
+			for _, gw := range tc.gateways {
+				inputs = append(inputs, gw)
+			}
+			for _, gw := range tc.refGrants {
+				inputs = append(inputs, gw)
+			}
+
+			// Create mock collections
+			mock := krttest.NewMock(t, inputs)
+			gateways := krttest.GetMockCollection[Gateway](mock)
+			httpRoutes := krttest.GetMockCollection[*gwv1.HTTPRoute](mock)
+			refGrantsCollection := krttest.GetMockCollection[ReferenceGrant](mock)
+			services := krttest.GetMockCollection[*corev1.Service](mock)
+			namespaces := krttest.GetMockCollection[*corev1.Namespace](mock)
+			serviceEntries := krttest.GetMockCollection[*networkingclient.ServiceEntry](mock)
+			inferencePools := krttest.GetMockCollection[*inf.InferencePool](mock)
+
+			// Wait for collections to sync
+			gateways.WaitUntilSynced(context.Background().Done())
+			httpRoutes.WaitUntilSynced(context.Background().Done())
+			refGrantsCollection.WaitUntilSynced(context.Background().Done())
+			services.WaitUntilSynced(context.Background().Done())
+			namespaces.WaitUntilSynced(context.Background().Done())
+
+			routeParents := BuildRouteParents(gateways)
+			refGrants := BuildReferenceGrants(refGrantsCollection)
+			// Create route context inputs
+			routeInputs := RouteContextInputs{
+				Grants:         refGrants,
+				RouteParents:   routeParents,
+				DomainSuffix:   "cluster.local",
+				Services:       services,
+				Namespaces:     namespaces,
+				ServiceEntries: serviceEntries,
+				InferencePools: inferencePools,
+			}
+
+			// Create KRT options
+			krtopts := krtutil.KrtOptions{}
+
+			// Call ADPRouteCollection
+			rm := reports.NewReportMap()
+			rep := reports.NewReporter(&rm)
+			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts, rm, rep)
+
+			// Wait for the collection to process
+			adpRoutes.WaitUntilSynced(context.Background().Done())
+
+			// Get results
+			results := adpRoutes.List()
+
+			// Verify expected count
+			assert.Equal(t, tc.expectedCount, len(results), "Expected %d routes but got %d", tc.expectedCount, len(results))
+
+			// Create a map of actual routes by key for easy lookup
+			actualRoutes := make(map[string]*api.Route)
+			for _, result := range results {
+				require.NotNil(t, result.Resource, "Resource should not be nil")
+				routeResource := result.Resource.GetRoute()
+				require.NotNil(t, routeResource, "Route resource should not be nil")
+				actualRoutes[routeResource.GetKey()] = routeResource
+			}
+
+			// Verify each expected route exists in the actual results
+			for _, expectedRoute := range tc.expectedRoutes {
+				expected := expectedRoute
+				routeResource, found := actualRoutes[expected.GetKey()]
+				require.True(t, found, "Expected route with key %s not found", expected.GetKey())
+
+				// Verify route properties using the expected api.Route
+				assert.Equal(t, expected.GetKey(), routeResource.GetKey(), "Route key mismatch")
+				assert.Equal(t, expected.GetRouteName(), routeResource.GetRouteName(), "Route name mismatch")
+				assert.Equal(t, expected.GetHostnames(), routeResource.GetHostnames(), "Hostnames mismatch")
+
+				// Verify matches
+				require.Equal(t, len(expected.GetMatches()), len(routeResource.GetMatches()), "Matches count mismatch")
+				for j, expectedMatch := range expected.GetMatches() {
+					actualMatch := routeResource.GetMatches()[j]
+
+					// Verify path match
+					if expectedMatch.GetPath() != nil {
+						require.NotNil(t, actualMatch.GetPath(), "Path match should not be nil")
+						switch expectedPath := expectedMatch.GetPath().GetKind().(type) {
+						case *api.PathMatch_PathPrefix:
+							actualPath, ok := actualMatch.GetPath().GetKind().(*api.PathMatch_PathPrefix)
+							require.True(t, ok, "Expected PathPrefix match")
+							assert.Equal(t, expectedPath.PathPrefix, actualPath.PathPrefix, "PathPrefix mismatch")
+						case *api.PathMatch_Exact:
+							actualPath, ok := actualMatch.GetPath().GetKind().(*api.PathMatch_Exact)
+							require.True(t, ok, "Expected Exact match")
+							assert.Equal(t, expectedPath.Exact, actualPath.Exact, "Exact path mismatch")
+						}
+					}
+
+					// Verify header matches
+					require.Equal(t, len(expectedMatch.GetHeaders()), len(actualMatch.GetHeaders()), "Header matches count mismatch")
+					for k, expectedHeader := range expectedMatch.GetHeaders() {
+						actualHeader := actualMatch.GetHeaders()[k]
+						assert.Equal(t, expectedHeader.GetName(), actualHeader.GetName(), "Header name mismatch")
+						switch expectedValue := expectedHeader.GetValue().(type) {
+						case *api.HeaderMatch_Exact:
+							actualValue, ok := actualHeader.GetValue().(*api.HeaderMatch_Exact)
+							require.True(t, ok, "Expected exact header match")
+							assert.Equal(t, expectedValue.Exact, actualValue.Exact, "Header exact value mismatch")
+						}
+					}
+				}
+
+				// Verify backends
+				require.Equal(t, len(expected.GetBackends()), len(routeResource.GetBackends()), "Backends count mismatch")
+				for j, expectedBackend := range expected.GetBackends() {
+					actualBackend := routeResource.GetBackends()[j]
+					assert.Equal(t, expectedBackend.GetPort(), actualBackend.GetPort(), "Backend port mismatch")
+
+					// Verify service backend
+					switch expectedKind := expectedBackend.GetKind().(type) {
+					case *api.RouteBackend_Service:
+						actualKind, ok := actualBackend.GetKind().(*api.RouteBackend_Service)
+						require.True(t, ok, "Expected service backend")
+						assert.Equal(t, expectedKind.Service, actualKind.Service, "Service mismatch")
+					}
+				}
+			}
+		})
+	}
+}
+
+func TestADPRouteCollectionWithFilters(t *testing.T) {
+	testCases := []struct {
+		name           string
+		httpRoute      *gwv1.HTTPRoute
+		expectedFilter *api.RouteFilter
+	}{
+		{
+			name: "Route with request header modifier",
+			httpRoute: &gwv1.HTTPRoute{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "header-route",
+					Namespace: "default",
+				},
+				Spec: gwv1.HTTPRouteSpec{
+					CommonRouteSpec: gwv1.CommonRouteSpec{
+						ParentRefs: []gwv1.ParentReference{
+							{
+								Name: "test-gateway",
+							},
+						},
+					},
+					Rules: []gwv1.HTTPRouteRule{
+						{
+							Filters: []gwv1.HTTPRouteFilter{
+								{
+									Type: gwv1.HTTPRouteFilterRequestHeaderModifier,
+									RequestHeaderModifier: &gwv1.HTTPHeaderFilter{
+										Set: []gwv1.HTTPHeader{
+											{
+												Name:  "X-Test-Header",
+												Value: "test-value",
+											},
+										},
+									},
+								},
+							},
+							BackendRefs: []gwv1.HTTPBackendRef{
+								{
+									BackendRef: gwv1.BackendRef{
+										BackendObjectReference: gwv1.BackendObjectReference{
+											Name: "test-service",
+											Port: ptr.To(gwv1.PortNumber(80)),
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedFilter: &api.RouteFilter{
+				Kind: &api.RouteFilter_RequestHeaderModifier{
+					RequestHeaderModifier: &api.HeaderModifier{
+						Set: []*api.Header{
+							{
+								Name:  "X-Test-Header",
+								Value: "test-value",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Route with redirect filter",
+			httpRoute: &gwv1.HTTPRoute{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "redirect-route",
+					Namespace: "default",
+				},
+				Spec: gwv1.HTTPRouteSpec{
+					CommonRouteSpec: gwv1.CommonRouteSpec{
+						ParentRefs: []gwv1.ParentReference{
+							{
+								Name: "test-gateway",
+							},
+						},
+					},
+					Rules: []gwv1.HTTPRouteRule{
+						{
+							Filters: []gwv1.HTTPRouteFilter{
+								{
+									Type: gwv1.HTTPRouteFilterRequestRedirect,
+									RequestRedirect: &gwv1.HTTPRequestRedirectFilter{
+										Scheme:     ptr.To("https"),
+										StatusCode: ptr.To(301),
+									},
+								},
+							},
+							BackendRefs: []gwv1.HTTPBackendRef{
+								{
+									BackendRef: gwv1.BackendRef{
+										BackendObjectReference: gwv1.BackendObjectReference{
+											Name: "test-service",
+											Port: ptr.To(gwv1.PortNumber(80)),
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedFilter: &api.RouteFilter{
+				Kind: &api.RouteFilter_RequestRedirect{
+					RequestRedirect: &api.RequestRedirect{
+						Scheme: "https",
+						Status: 301,
+					},
+				},
+			},
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			// Prepare inputs
+			service := &corev1.Service{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-service",
+					Namespace: "default",
+				},
+				Spec: corev1.ServiceSpec{
+					Ports: []corev1.ServicePort{
+						{
+							Port: 80,
+						},
+					},
+				},
+			}
+
+			namespace := &corev1.Namespace{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "default",
+				},
+			}
+
+			gateway := Gateway{
+				Config: &Config{
+					Meta: Meta{
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+				},
+				parent: parentKey{
+					Kind:      wellknown.GatewayGVK,
+					Name:      "test-gateway",
+					Namespace: "default",
+				},
+				parentInfo: parentInfo{
+					InternalName: "default/test-gateway",
+					Protocol:     gwv1.HTTPProtocolType,
+					Port:         80,
+					SectionName:  "http",
+					AllowedKinds: []gwv1.RouteGroupKind{
+						{
+							Group: &groupName,
+							Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+						},
+					},
+				},
+				Valid: true,
+			}
+
+			refGrant := ReferenceGrant{}
+
+			inputs := []any{tc.httpRoute, service, namespace, gateway, refGrant}
+
+			// Create mock collections
+			mock := krttest.NewMock(t, inputs)
+			gateways := krttest.GetMockCollection[Gateway](mock)
+			httpRoutes := krttest.GetMockCollection[*gwv1.HTTPRoute](mock)
+			refGrantsCollection := krttest.GetMockCollection[ReferenceGrant](mock)
+			services := krttest.GetMockCollection[*corev1.Service](mock)
+			namespaces := krttest.GetMockCollection[*corev1.Namespace](mock)
+			serviceEntries := krttest.GetMockCollection[*networkingclient.ServiceEntry](mock)
+			inferencePools := krttest.GetMockCollection[*inf.InferencePool](mock)
+
+			// Wait for collections to sync
+			gateways.WaitUntilSynced(context.Background().Done())
+			httpRoutes.WaitUntilSynced(context.Background().Done())
+			refGrantsCollection.WaitUntilSynced(context.Background().Done())
+			services.WaitUntilSynced(context.Background().Done())
+			namespaces.WaitUntilSynced(context.Background().Done())
+
+			routeParents := BuildRouteParents(gateways)
+			refGrants := BuildReferenceGrants(refGrantsCollection)
+			// Create route context inputs
+			routeInputs := RouteContextInputs{
+				Grants:         refGrants,
+				RouteParents:   routeParents,
+				DomainSuffix:   "cluster.local",
+				Services:       services,
+				Namespaces:     namespaces,
+				ServiceEntries: serviceEntries,
+				InferencePools: inferencePools,
+			}
+
+			// Create KRT options
+			krtopts := krtutil.KrtOptions{}
+
+			// Call ADPRouteCollection
+			rm := reports.NewReportMap()
+			rep := reports.NewReporter(&rm)
+			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts, rm, rep)
+
+			// Wait for the collection to process
+			adpRoutes.WaitUntilSynced(context.Background().Done())
+
+			// Get results
+			results := adpRoutes.List()
+
+			// Verify we got a result
+			require.Len(t, results, 1, "Expected exactly one route")
+
+			result := results[0]
+			require.NotNil(t, result.Resource, "Resource should not be nil")
+
+			routeResource := result.Resource.GetRoute()
+			require.NotNil(t, routeResource, "Route resource should not be nil")
+
+			// Verify filters
+			require.Len(t, routeResource.GetFilters(), 1, "Expected exactly one filter")
+			actualFilter := routeResource.GetFilters()[0]
+
+			// Verify filter type and content
+			switch expectedKind := tc.expectedFilter.GetKind().(type) {
+			case *api.RouteFilter_RequestHeaderModifier:
+				actualKind, ok := actualFilter.GetKind().(*api.RouteFilter_RequestHeaderModifier)
+				require.True(t, ok, "Expected RequestHeaderModifier filter")
+
+				expectedMod := expectedKind.RequestHeaderModifier
+				actualMod := actualKind.RequestHeaderModifier
+
+				require.Equal(t, len(expectedMod.GetSet()), len(actualMod.GetSet()), "Set headers count mismatch")
+				for i, expectedHeader := range expectedMod.GetSet() {
+					actualHeader := actualMod.GetSet()[i]
+					assert.Equal(t, expectedHeader.GetName(), actualHeader.GetName(), "Header name mismatch")
+					assert.Equal(t, expectedHeader.GetValue(), actualHeader.GetValue(), "Header value mismatch")
+				}
+
+			case *api.RouteFilter_RequestRedirect:
+				actualKind, ok := actualFilter.GetKind().(*api.RouteFilter_RequestRedirect)
+				require.True(t, ok, "Expected RequestRedirect filter")
+
+				expectedRedirect := expectedKind.RequestRedirect
+				actualRedirect := actualKind.RequestRedirect
+
+				assert.Equal(t, expectedRedirect.GetScheme(), actualRedirect.GetScheme(), "Redirect scheme mismatch")
+				assert.Equal(t, expectedRedirect.GetStatus(), actualRedirect.GetStatus(), "Redirect status mismatch")
+			}
+		})
+	}
+}
+
+func TestADPRouteCollectionResourceName(t *testing.T) {
+	// Test that ADPResource implements ResourceName correctly
+	adpResource := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: &api.Route{
+					Key: "test-key",
+				},
+			},
+		},
+		Gateway: types.NamespacedName{
+			Name:      "test-gateway",
+			Namespace: "default",
+		},
+	}
+
+	expectedName := "route/test-key"
+	actualName := adpResource.ResourceName()
+	assert.Equal(t, expectedName, actualName, "Resource name should match expected format")
+}
+
+func TestADPRouteCollectionEquals(t *testing.T) {
+	// Test that ADPResource implements Equals correctly
+	route1 := &api.Route{
+		Key:       "test-key",
+		RouteName: "test-route",
+	}
+
+	route2 := &api.Route{
+		Key:       "test-key",
+		RouteName: "test-route",
+	}
+
+	route3 := &api.Route{
+		Key:       "different-key",
+		RouteName: "test-route",
+	}
+
+	gateway := types.NamespacedName{
+		Name:      "test-gateway",
+		Namespace: "default",
+	}
+
+	adpResource1 := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: route1,
+			},
+		},
+		Gateway: gateway,
+	}
+
+	adpResource2 := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: route2,
+			},
+		},
+		Gateway: gateway,
+	}
+
+	adpResource3 := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: route3,
+			},
+		},
+		Gateway: gateway,
+	}
+
+	assert.True(t, adpResource1.Equals(adpResource2), "Equal resources should return true")
+	assert.False(t, adpResource1.Equals(adpResource3), "Different resources should return false")
+}
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
new file mode 100644
index 000000000..38a127bca
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -0,0 +1,1090 @@
+package agentgatewaysyncer
+
+import (
+	"bytes"
+	"fmt"
+	"net/netip"
+	"strings"
+	"sync"
+	"time"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/types/known/anypb"
+	apiannotation "istio.io/api/annotation"
+	"istio.io/api/label"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube"
+	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/host"
+	kubeutil "istio.io/istio/pkg/config/kube"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/maps"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
+	v1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/types"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+)
+
+func (a *index) ServicesCollection(
+	services krt.Collection[*v1.Service],
+	serviceEntries krt.Collection[*networkingclient.ServiceEntry],
+	inferencePools krt.Collection[*inf.InferencePool],
+	namespaces krt.Collection[*v1.Namespace],
+	krtopts krtutil.KrtOptions,
+) krt.Collection[ServiceInfo] {
+	servicesInfo := krt.NewCollection(services, a.serviceServiceBuilder(namespaces),
+		krtopts.ToOptions("ServicesInfo")...)
+	//ServiceEntriesInfo := krt.NewManyCollection(serviceEntries, a.serviceEntryServiceBuilder(namespaces),
+	//	krtopts.ToOptions("ServiceEntriesInfo")...)
+	inferencePoolsInfo := krt.NewCollection(inferencePools, a.inferencePoolBuilder(namespaces),
+		krtopts.ToOptions("InferencePools")...)
+	//WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{ServicesInfo, ServiceEntriesInfo}, krtopts.ToOptions("WorkloadService")...)
+
+	WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{servicesInfo, inferencePoolsInfo}, krtopts.ToOptions("WorkloadService")...)
+	return WorkloadServices
+}
+
+func (a *index) serviceServiceBuilder(
+	namespaces krt.Collection[*v1.Namespace],
+) krt.TransformationSingle[*v1.Service, ServiceInfo] {
+	return func(ctx krt.HandlerContext, s *v1.Service) *ServiceInfo {
+		if s.Spec.Type == v1.ServiceTypeExternalName {
+			// ExternalName services are not implemented by ambient (but will still work).
+			// The DNS requests will forward to the upstream DNS server, then Ztunnel can handle the request based on the target
+			// hostname.
+			// In theory we could add support for native 'DNS alias' into Ztunnel's DNS proxy. This would give the same behavior
+			// but let the DNS proxy handle it instead of forwarding upstream. However, at this time we do not do so.
+			return nil
+		}
+		portNames := map[int32]ServicePortName{}
+		for _, p := range s.Spec.Ports {
+			portNames[p.Port] = ServicePortName{
+				PortName:       p.Name,
+				TargetPortName: p.TargetPort.StrVal,
+			}
+		}
+
+		svc := a.constructService(ctx, s)
+		return precomputeServicePtr(&ServiceInfo{
+			Service:       svc,
+			PortNames:     portNames,
+			LabelSelector: NewSelector(s.Spec.Selector),
+			Source:        MakeSource(s),
+		})
+	}
+}
+
+// ServiceHostname produces FQDN for a k8s service
+func InferenceHostname(name, namespace, domainSuffix string) host.Name {
+	return host.Name(name + "." + namespace + "." + "inference" + "." + domainSuffix) // Format: "%s.%s.svc.%s"
+}
+
+func (a *index) inferencePoolBuilder(
+	namespaces krt.Collection[*v1.Namespace],
+) krt.TransformationSingle[*inf.InferencePool, ServiceInfo] {
+	return func(ctx krt.HandlerContext, s *inf.InferencePool) *ServiceInfo {
+		portNames := map[int32]ServicePortName{}
+		ports := []*api.Port{{
+			ServicePort: uint32(s.Spec.TargetPortNumber),
+			TargetPort:  uint32(s.Spec.TargetPortNumber),
+			AppProtocol: api.AppProtocol_HTTP11,
+		}}
+
+		// TODO this is only checking one controller - we may be missing service vips for instances in another cluster
+		svc := &api.Service{
+			Name:      s.Name,
+			Namespace: s.Namespace,
+			Hostname:  string(InferenceHostname(s.Name, s.Namespace, a.DomainSuffix)),
+			Ports:     ports,
+		}
+
+		selector := make(map[string]string, len(s.Spec.Selector))
+		for k, v := range s.Spec.Selector {
+			selector[string(k)] = string(v)
+		}
+		return precomputeServicePtr(&ServiceInfo{
+			Service:       svc,
+			PortNames:     portNames,
+			LabelSelector: NewSelector(selector),
+			Source: TypedObject{
+				NamespacedName: types.NamespacedName{
+					Namespace: s.Namespace,
+					Name:      s.Name,
+				},
+				Kind: "InferencePool", // TODO: get wellknown kind
+			},
+		})
+	}
+}
+
+func (a *index) serviceEntryServiceBuilder(
+	namespaces krt.Collection[*v1.Namespace],
+) krt.TransformationMulti[*networkingclient.ServiceEntry, ServiceInfo] {
+	return func(ctx krt.HandlerContext, s *networkingclient.ServiceEntry) []ServiceInfo {
+		return a.serviceEntriesInfo(ctx, s)
+	}
+}
+
+func toAppProtocolFromKube(p v1.ServicePort) api.AppProtocol {
+	return toAppProtocolFromProtocol(string(kubeutil.ConvertProtocol(p.Port, p.Name, p.Protocol, p.AppProtocol)))
+}
+
+func (a *index) constructService(ctx krt.HandlerContext, svc *v1.Service) *api.Service {
+	ports := make([]*api.Port, 0, len(svc.Spec.Ports))
+	for _, p := range svc.Spec.Ports {
+		ports = append(ports, &api.Port{
+			ServicePort: uint32(p.Port),
+			TargetPort:  uint32(p.TargetPort.IntVal),
+			AppProtocol: toAppProtocolFromKube(p),
+		})
+	}
+
+	addresses, err := slices.MapErr(getVIPs(svc), func(e string) (*api.NetworkAddress, error) {
+		return a.toNetworkAddress(ctx, e)
+	})
+	if err != nil {
+		logger.Warn("fail to parse service", "svc", config.NamespacedName(svc), "error", err)
+		return nil
+	}
+
+	var lb *api.LoadBalancing
+
+	// The TrafficDistribution field is quite new, so we allow a legacy annotation option as well
+	preferClose := strings.EqualFold(svc.Annotations[apiannotation.NetworkingTrafficDistribution.Name], v1.ServiceTrafficDistributionPreferClose)
+	if svc.Spec.TrafficDistribution != nil {
+		preferClose = *svc.Spec.TrafficDistribution == v1.ServiceTrafficDistributionPreferClose
+	}
+	if preferClose {
+		lb = preferCloseLoadBalancer
+	}
+	if itp := svc.Spec.InternalTrafficPolicy; itp != nil && *itp == v1.ServiceInternalTrafficPolicyLocal {
+		lb = &api.LoadBalancing{
+			// Only allow endpoints on the same node.
+			RoutingPreference: []api.LoadBalancing_Scope{
+				api.LoadBalancing_NODE,
+			},
+			Mode: api.LoadBalancing_STRICT,
+		}
+	}
+	if svc.Spec.PublishNotReadyAddresses {
+		if lb == nil {
+			lb = &api.LoadBalancing{}
+		}
+		lb.HealthPolicy = api.LoadBalancing_ALLOW_ALL
+	}
+
+	ipFamily := api.IPFamilies_AUTOMATIC
+	if len(svc.Spec.IPFamilies) == 2 {
+		ipFamily = api.IPFamilies_DUAL
+	} else if len(svc.Spec.IPFamilies) == 1 {
+		family := svc.Spec.IPFamilies[0]
+		if family == v1.IPv4Protocol {
+			ipFamily = api.IPFamilies_IPV4_ONLY
+		} else {
+			ipFamily = api.IPFamilies_IPV6_ONLY
+		}
+	}
+	// TODO this is only checking one controller - we may be missing service vips for instances in another cluster
+	return &api.Service{
+		Name:          svc.Name,
+		Namespace:     svc.Namespace,
+		Hostname:      string(kube.ServiceHostname(svc.Name, svc.Namespace, a.DomainSuffix)),
+		Addresses:     addresses,
+		Ports:         ports,
+		LoadBalancing: lb,
+		IpFamilies:    ipFamily,
+	}
+}
+
+var preferCloseLoadBalancer = &api.LoadBalancing{
+	// Prefer endpoints in close zones, but allow spilling over to further endpoints where required.
+	RoutingPreference: []api.LoadBalancing_Scope{
+		api.LoadBalancing_NETWORK,
+		api.LoadBalancing_REGION,
+		api.LoadBalancing_ZONE,
+		api.LoadBalancing_SUBZONE,
+	},
+	Mode: api.LoadBalancing_FAILOVER,
+}
+
+func getVIPs(svc *v1.Service) []string {
+	res := []string{}
+	cips := svc.Spec.ClusterIPs
+	if len(cips) == 0 {
+		cips = []string{svc.Spec.ClusterIP}
+	}
+	for _, cip := range cips {
+		if cip != "" && cip != v1.ClusterIPNone {
+			res = append(res, cip)
+		}
+	}
+	return res
+}
+
+// Service describes an Istio service (e.g., catalog.mystore.com:8080)
+// Each service has a fully qualified domain name (FQDN) and one or more
+// ports where the service is listening for connections. *Optionally*, a
+// service can have a single load balancer/virtual IP address associated
+// with it, such that the DNS queries for the FQDN resolves to the virtual
+// IP address (a load balancer IP).
+//
+// E.g., in kubernetes, a service foo is associated with
+// foo.default.svc.cluster.local hostname, has a virtual IP of 10.0.1.1 and
+// listens on ports 80, 8080
+type Service struct {
+	// Attributes contains additional attributes associated with the service
+	// used mostly by RBAC for policy enforcement purposes.
+	Attributes ServiceAttributes
+
+	// Ports is the set of network ports where the service is listening for
+	// connections
+	Ports PortList `json:"ports,omitempty"`
+
+	// ServiceAccounts specifies the service accounts that run the service.
+	ServiceAccounts []string `json:"serviceAccounts,omitempty"`
+
+	// CreationTime records the time this service was created, if available.
+	CreationTime time.Time `json:"creationTime,omitempty"`
+
+	// Name of the service, e.g. "catalog.mystore.com"
+	Hostname host.Name `json:"hostname"`
+
+	// ClusterVIPs specifies the service address of the load balancer
+	// in each of the clusters where the service resides
+	ClusterVIPs AddressMap `json:"clusterVIPs,omitempty"`
+
+	// DefaultAddress specifies the default service IP of the load balancer.
+	// Do not access directly. Use GetAddressForProxy
+	DefaultAddress string `json:"defaultAddress,omitempty"`
+
+	// AutoAllocatedIPv4Address and AutoAllocatedIPv6Address specifies
+	// the automatically allocated IPv4/IPv6 address out of the reserved
+	// Class E subnet (240.240.0.0/16) or reserved Benchmarking IP range
+	// (2001:2::/48) in RFC5180.for service entries with non-wildcard
+	// hostnames. The IPs assigned to services are not
+	// synchronized across istiod replicas as the DNS resolution
+	// for these service entries happens completely inside a pod
+	// whose proxy is managed by one istiod. That said, the algorithm
+	// to allocate IPs is pretty deterministic that at stable state, two
+	// istiods will allocate the exact same set of IPs for a given set of
+	// service entries.
+	AutoAllocatedIPv4Address string `json:"autoAllocatedIPv4Address,omitempty"`
+	AutoAllocatedIPv6Address string `json:"autoAllocatedIPv6Address,omitempty"`
+
+	// Resolution indicates how the service instances need to be resolved before routing
+	// traffic. Most services in the service registry will use static load balancing wherein
+	// the proxy will decide the service instance that will receive the traffic. Service entries
+	// could either use DNS load balancing (i.e. proxy will query DNS server for the IP of the service)
+	// or use the passthrough model (i.e. proxy will forward the traffic to the network endpoint requested
+	// by the caller)
+	Resolution Resolution
+
+	// ResourceVersion represents the internal version of this object.
+	ResourceVersion string
+}
+
+func (s *Service) NamespacedName() types.NamespacedName {
+	return types.NamespacedName{Name: s.Attributes.Name, Namespace: s.Attributes.Namespace}
+}
+
+func (s *Service) Key() string {
+	if s == nil {
+		return ""
+	}
+
+	return s.Attributes.Namespace + "/" + string(s.Hostname)
+}
+
+var serviceCmpOpts = []cmp.Option{cmpopts.IgnoreFields(AddressMap{}, "mutex")}
+
+func (s *Service) CmpOpts() []cmp.Option {
+	return serviceCmpOpts
+}
+
+func (s *Service) SupportsDrainingEndpoints() bool {
+	return (features.PersistentSessionLabel != "" && s.Attributes.Labels[features.PersistentSessionLabel] != "") ||
+		(features.PersistentSessionHeaderLabel != "" && s.Attributes.Labels[features.PersistentSessionHeaderLabel] != "")
+}
+
+// SupportsUnhealthyEndpoints marks if this service should send unhealthy endpoints
+func (s *Service) SupportsUnhealthyEndpoints() bool {
+	if features.GlobalSendUnhealthyEndpoints.Load() {
+		// Enable process-wide
+		return true
+	}
+	if s != nil && s.Attributes.TrafficDistribution != TrafficDistributionAny {
+		// When we are doing location aware routing, we need some way to indicate if endpoints are healthy, otherwise we don't
+		// know when to spill over to other zones.
+		// For the older DestinationRule localityLB, we do this by requiring outlier detection.
+		// If they use the newer Kubernetes-native TrafficDistribution we don't want to require an Istio-specific outlier rule,
+		// and instead will use endpoint health which requires sending unhealthy endpoints.
+		return true
+	}
+	return false
+}
+
+// Resolution indicates how the service instances need to be resolved before routing traffic.
+type Resolution int
+
+const (
+	// ClientSideLB implies that the proxy will decide the endpoint from its local lb pool
+	ClientSideLB Resolution = iota
+	// DNSLB implies that the proxy will resolve a DNS address and forward to the resolved address
+	DNSLB
+	// Passthrough implies that the proxy should forward traffic to the destination IP requested by the caller
+	Passthrough
+	// DNSRoundRobinLB implies that the proxy will resolve a DNS address and forward to the resolved address
+	DNSRoundRobinLB
+	// Alias defines a Service that is an alias for another.
+	Alias
+)
+
+// String converts Resolution in to String.
+func (resolution Resolution) String() string {
+	switch resolution {
+	case ClientSideLB:
+		return "ClientSide"
+	case DNSLB:
+		return "DNS"
+	case DNSRoundRobinLB:
+		return "DNSRoundRobin"
+	case Passthrough:
+		return "Passthrough"
+	default:
+		return fmt.Sprintf("%d", int(resolution))
+	}
+}
+
+const (
+	// TunnelLabel defines the label workloads describe to indicate that they support tunneling.
+	// Values are expected to be a CSV list, sorted by preference, of protocols supported.
+	// Currently supported values:
+	// * "http": indicates tunneling over HTTP over TCP. HTTP/2 vs HTTP/1.1 may be supported by ALPN negotiation.
+	// Planned future values:
+	// * "http3": indicates tunneling over HTTP over QUIC. This is distinct from "http", since we cannot do ALPN
+	//   negotiation for QUIC vs TCP.
+	// Users should appropriately parse the full list rather than doing a string literal check to
+	// ensure future-proofing against new protocols being added.
+	TunnelLabel = "networking.agentgateway.io/tunnel"
+	// TunnelLabelShortName is a short name for TunnelLabel to be used in optimized scenarios.
+	TunnelLabelShortName = "tunnel"
+	// TunnelHTTP indicates tunneling over HTTP over TCP. HTTP/2 vs HTTP/1.1 may be supported by ALPN
+	// negotiation. Note: ALPN negotiation is not currently implemented; HTTP/2 will always be used.
+	// This is future-proofed, however, because only the `h2` ALPN is exposed.
+	TunnelHTTP = "http"
+)
+
+const (
+	// DisabledTLSModeLabel implies that this endpoint should receive traffic as is (mostly plaintext)
+	DisabledTLSModeLabel = "disabled"
+
+	// MutualTLSModeLabel implies that the endpoint is ready to receive agent mTLS connections.
+	MutualTLSModeLabel = "mtls"
+)
+
+func SupportsTunnel(labels map[string]string, tunnelType string) bool {
+	tl, f := labels[TunnelLabel]
+	if !f {
+		return false
+	}
+	if tl == tunnelType {
+		// Fast-path the case where we have only one label
+		return true
+	}
+	// Else check everything. Tunnel label is a comma-separated list.
+	return sets.New(strings.Split(tl, ",")...).Contains(tunnelType)
+}
+
+// Port represents a network port where a service is listening for
+// connections. The port should be annotated with the type of protocol
+// used by the port.
+type Port struct {
+	// Name ascribes a human-readable name for the port object. When a
+	// service has multiple ports, the name field is mandatory
+	Name string `json:"name,omitempty"`
+
+	// Port number where the service can be reached. Does not necessarily
+	// map to the corresponding port numbers for the instances behind the
+	// service.
+	Port int `json:"port"`
+
+	// Protocol to be used for the port.
+	Protocol protocol.Instance `json:"protocol,omitempty"`
+}
+
+func (p Port) String() string {
+	return fmt.Sprintf("Name:%s Port:%d Protocol:%v", p.Name, p.Port, p.Protocol)
+}
+
+// PortList is a set of ports
+type PortList []*Port
+
+// ServiceTarget includes a Service object, along with a specific service port
+// and target port. This is basically a smaller version of ServiceInstance,
+// intended to avoid the need to have the full object when only port information
+// is needed.
+type ServiceTarget struct {
+	Service *Service
+	Port    ServiceInstancePort
+}
+
+type (
+	ServicePort = *Port
+	// ServiceInstancePort defines a port that has both a port and targetPort (which distinguishes it from Port)
+	// Note: ServiceInstancePort only makes sense in the context of a specific ServiceInstance, because TargetPort depends on a specific instance.
+	ServiceInstancePort struct {
+		ServicePort
+		TargetPort uint32
+	}
+)
+
+type workloadKind int
+
+const (
+	// PodKind indicates the workload is from pod
+	PodKind workloadKind = iota
+	// WorkloadEntryKind indicates the workload is from workloadentry
+	WorkloadEntryKind
+)
+
+func (k workloadKind) String() string {
+	if k == PodKind {
+		return "Pod"
+	}
+
+	if k == WorkloadEntryKind {
+		return "WorkloadEntry"
+	}
+	return ""
+}
+
+// ServiceAttributes represents a group of custom attributes of the service.
+type ServiceAttributes struct {
+	// ServiceRegistry indicates the backing service registry system where this service
+	// was sourced from.
+	// TODO: move the ServiceRegistry type from platform.go to model
+	ServiceRegistry provider.ID
+	// Name is "destination.service.name" attribute
+	Name string
+	// Namespace is "destination.service.namespace" attribute
+	Namespace string
+	// Labels applied to the service
+	Labels map[string]string
+	// ExportTo defines the visibility of Service in
+	// a namespace when the namespace is imported.
+	ExportTo sets.Set[visibility.Instance]
+
+	// LabelSelectors are the labels used by the service to select workloads.
+	// Applicable to both Kubernetes and ServiceEntries.
+	LabelSelectors map[string]string
+
+	// Aliases is the resolved set of aliases for this service. This is computed based on a global view of all Service's `AliasFor`
+	// fields.
+	// For example, if I had two Services with `externalName: foo`, "a" and "b", then the "foo" service would have Aliases=[a,b].
+	Aliases []NamespacedHostname
+
+	// For Kubernetes platform
+
+	// ClusterExternalAddresses is a mapping between a cluster name and the external
+	// address(es) to access the service from outside the cluster.
+	// Used by the aggregator to aggregate the Attributes.ClusterExternalAddresses
+	// for clusters where the service resides
+	ClusterExternalAddresses *AddressMap
+
+	// ClusterExternalPorts is a mapping between a cluster name and the service port
+	// to node port mappings for a given service. When accessing the service via
+	// node port IPs, we need to use the kubernetes assigned node ports of the service
+	ClusterExternalPorts map[cluster.ID]map[uint32]uint32
+
+	PassthroughTargetPorts map[uint32]uint32
+
+	K8sAttributes
+}
+
+type NamespacedHostname struct {
+	Hostname  host.Name
+	Namespace string
+}
+
+type K8sAttributes struct {
+	// Type holds the value of the corev1.Type of the Kubernetes service
+	// spec.Type
+	Type string
+
+	// spec.ExternalName
+	ExternalName string
+
+	// NodeLocal means the proxy will only forward traffic to node local endpoints
+	// spec.InternalTrafficPolicy == Local
+	NodeLocal bool
+
+	// TrafficDistribution determines the service-level traffic distribution.
+	// This may be overridden by locality load balancing settings.
+	TrafficDistribution TrafficDistribution
+
+	// ObjectName is the object name of the underlying object. This may differ from the Service.Attributes.Name for legacy semantics.
+	ObjectName string
+
+	// spec.PublishNotReadyAddresses
+	PublishNotReadyAddresses bool
+}
+
+type TrafficDistribution int
+
+const (
+	// TrafficDistributionAny allows any destination
+	TrafficDistributionAny TrafficDistribution = iota
+	// TrafficDistributionPreferClose prefers traffic in same region/zone/network if possible, with failover allowed.
+	TrafficDistributionPreferClose TrafficDistribution = iota
+)
+
+// DeepCopy creates a deep copy of ServiceAttributes, but skips internal mutexes.
+func (s *ServiceAttributes) DeepCopy() ServiceAttributes {
+	// AddressMap contains a mutex, which is safe to copy in this case.
+	// nolint: govet
+	out := *s
+
+	out.Labels = maps.Clone(s.Labels)
+	if s.ExportTo != nil {
+		out.ExportTo = s.ExportTo.Copy()
+	}
+
+	out.LabelSelectors = maps.Clone(s.LabelSelectors)
+	out.ClusterExternalAddresses = s.ClusterExternalAddresses.DeepCopy()
+
+	if s.ClusterExternalPorts != nil {
+		out.ClusterExternalPorts = make(map[cluster.ID]map[uint32]uint32, len(s.ClusterExternalPorts))
+		for k, m := range s.ClusterExternalPorts {
+			out.ClusterExternalPorts[k] = maps.Clone(m)
+		}
+	}
+
+	out.Aliases = slices.Clone(s.Aliases)
+	out.PassthroughTargetPorts = maps.Clone(out.PassthroughTargetPorts)
+
+	// AddressMap contains a mutex, which is safe to return a copy in this case.
+	// nolint: govet
+	return out
+}
+
+// Equals checks whether the attributes are equal from the passed in service.
+func (s *ServiceAttributes) Equals(other *ServiceAttributes) bool {
+	if s == nil {
+		return other == nil
+	}
+	if other == nil {
+		return s == nil
+	}
+
+	if !maps.Equal(s.Labels, other.Labels) {
+		return false
+	}
+
+	if !maps.Equal(s.LabelSelectors, other.LabelSelectors) {
+		return false
+	}
+
+	if !maps.Equal(s.ExportTo, other.ExportTo) {
+		return false
+	}
+
+	if !slices.Equal(s.Aliases, other.Aliases) {
+		return false
+	}
+
+	if s.ClusterExternalAddresses.Len() != other.ClusterExternalAddresses.Len() {
+		return false
+	}
+
+	for k, v1 := range s.ClusterExternalAddresses.GetAddresses() {
+		if v2, ok := other.ClusterExternalAddresses.Addresses[k]; !ok || !slices.Equal(v1, v2) {
+			return false
+		}
+	}
+
+	if len(s.ClusterExternalPorts) != len(other.ClusterExternalPorts) {
+		return false
+	}
+
+	for k, v1 := range s.ClusterExternalPorts {
+		if v2, ok := s.ClusterExternalPorts[k]; !ok || !maps.Equal(v1, v2) {
+			return false
+		}
+	}
+	return s.Name == other.Name && s.Namespace == other.Namespace &&
+		s.ServiceRegistry == other.ServiceRegistry && s.K8sAttributes == other.K8sAttributes
+}
+
+type AddressInfo struct {
+	*api.Address
+	Marshaled *anypb.Any
+}
+
+func (i AddressInfo) Equals(other AddressInfo) bool {
+	return protoconv.Equals(i.Address, other.Address)
+}
+
+func (i AddressInfo) Aliases() []string {
+	switch addr := i.Type.(type) {
+	case *api.Address_Workload:
+		aliases := make([]string, 0, len(addr.Workload.GetAddresses()))
+		network := addr.Workload.GetNetwork()
+		for _, workloadAddr := range addr.Workload.GetAddresses() {
+			ip, _ := netip.AddrFromSlice(workloadAddr)
+			aliases = append(aliases, network+"/"+ip.String())
+		}
+		return aliases
+	case *api.Address_Service:
+		aliases := make([]string, 0, len(addr.Service.GetAddresses()))
+		for _, networkAddr := range addr.Service.GetAddresses() {
+			ip, _ := netip.AddrFromSlice(networkAddr.GetAddress())
+			aliases = append(aliases, networkAddr.GetNetwork()+"/"+ip.String())
+		}
+		return aliases
+	}
+	return nil
+}
+
+func (i AddressInfo) ResourceName() string {
+	var name string
+	switch addr := i.Type.(type) {
+	case *api.Address_Workload:
+		name = workloadResourceName(addr.Workload)
+	case *api.Address_Service:
+		name = serviceResourceName(addr.Service)
+	}
+	return name
+}
+
+type TypedObject struct {
+	types.NamespacedName
+	Kind string
+}
+
+type ServicePortName struct {
+	PortName       string
+	TargetPortName string
+}
+
+type ServiceInfo struct {
+	Service *api.Service
+	// LabelSelectors for the Service. Note these are only used internally, not sent over XDS
+	LabelSelector LabelSelector
+	// PortNames provides a mapping of ServicePort -> port names. Note these are only used internally, not sent over XDS
+	PortNames map[int32]ServicePortName
+	// Source is the type that introduced this service.
+	Source TypedObject
+	// MarshaledAddress contains the pre-marshaled representation.
+	// Note: this is an Address -- not a Service.
+	MarshaledAddress *anypb.Any
+	// AsAddress contains a pre-created AddressInfo representation. This ensures we do not need repeated conversions on
+	// the hotpath
+	AsAddress AddressInfo
+}
+
+func (i ServiceInfo) GetLabelSelector() map[string]string {
+	return i.LabelSelector.Labels
+}
+
+func (i ServiceInfo) GetStatusTarget() TypedObject {
+	return i.Source
+}
+
+type StatusMessage struct {
+	Reason  string
+	Message string
+}
+
+func (i ServiceInfo) NamespacedName() types.NamespacedName {
+	return types.NamespacedName{Name: i.Service.GetName(), Namespace: i.Service.GetNamespace()}
+}
+
+func (i ServiceInfo) GetNamespace() string {
+	return i.Service.GetNamespace()
+}
+
+func (i ServiceInfo) Equals(other ServiceInfo) bool {
+	return equalUsingPremarshaled(i.Service, i.MarshaledAddress, other.Service, other.MarshaledAddress) &&
+		maps.Equal(i.LabelSelector.Labels, other.LabelSelector.Labels) &&
+		maps.Equal(i.PortNames, other.PortNames) &&
+		i.Source == other.Source
+}
+
+func (i ServiceInfo) ResourceName() string {
+	return serviceResourceName(i.Service)
+}
+
+func serviceResourceName(s *api.Service) string {
+	// TODO: check prepending svc
+	return s.GetNamespace() + "/" + s.GetHostname()
+}
+
+type WorkloadInfo struct {
+	Workload *api.Workload
+	// Labels for the workload. Note these are only used internally, not sent over XDS
+	Labels map[string]string
+	// Source is the type that introduced this workload.
+	Source kind.Kind
+	// CreationTime is the time when the workload was created. Note this is used internally only.
+	CreationTime time.Time
+	// MarshaledAddress contains the pre-marshaled representation.
+	// Note: this is an Address -- not a Workload.
+	MarshaledAddress *anypb.Any
+	// AsAddress contains a pre-created AddressInfo representation. This ensures we do not need repeated conversions on
+	// the hotpath
+	AsAddress AddressInfo
+}
+
+func (i WorkloadInfo) Equals(other WorkloadInfo) bool {
+	return equalUsingPremarshaled(i.Workload, i.MarshaledAddress, other.Workload, other.MarshaledAddress) &&
+		maps.Equal(i.Labels, other.Labels) &&
+		i.Source == other.Source &&
+		i.CreationTime == other.CreationTime
+}
+
+func workloadResourceName(w *api.Workload) string {
+	return w.GetUid()
+}
+
+func (i *WorkloadInfo) Clone() *WorkloadInfo {
+	return &WorkloadInfo{
+		Workload:     protomarshal.Clone(i.Workload),
+		Labels:       maps.Clone(i.Labels),
+		Source:       i.Source,
+		CreationTime: i.CreationTime,
+	}
+}
+
+func (i WorkloadInfo) ResourceName() string {
+	return workloadResourceName(i.Workload)
+}
+
+type LabelSelector struct {
+	Labels map[string]string
+}
+
+func NewSelector(l map[string]string) LabelSelector {
+	return LabelSelector{l}
+}
+
+func (l LabelSelector) GetLabelSelector() map[string]string {
+	return l.Labels
+}
+
+// MCSServiceInfo combines the name of a service with a particular Kubernetes cluster. This
+// is used for debug information regarding the state of Kubernetes Multi-Cluster Services (MCS).
+type MCSServiceInfo struct {
+	Cluster         cluster.ID
+	Name            string
+	Namespace       string
+	Exported        bool
+	Imported        bool
+	ClusterSetVIP   string
+	Discoverability map[host.Name]string
+}
+
+// GetNames returns port names
+func (ports PortList) GetNames() []string {
+	names := make([]string, 0, len(ports))
+	for _, port := range ports {
+		names = append(names, port.Name)
+	}
+	return names
+}
+
+// Get retrieves a port declaration by name
+func (ports PortList) Get(name string) (*Port, bool) {
+	for _, port := range ports {
+		if port.Name == name {
+			return port, true
+		}
+	}
+	return nil, false
+}
+
+// GetByPort retrieves a port declaration by port value
+func (ports PortList) GetByPort(num int) (*Port, bool) {
+	for _, port := range ports {
+		if port.Port == num && port.Protocol != protocol.UDP {
+			return port, true
+		}
+	}
+	return nil, false
+}
+
+func (p *Port) Equals(other *Port) bool {
+	if p == nil {
+		return other == nil
+	}
+	if other == nil {
+		return p == nil
+	}
+	return p.Name == other.Name && p.Port == other.Port && p.Protocol == other.Protocol
+}
+
+func (ports PortList) Equals(other PortList) bool {
+	return slices.EqualFunc(ports, other, func(a, b *Port) bool {
+		return a.Equals(b)
+	})
+}
+
+func (ports PortList) String() string {
+	sp := make([]string, 0, len(ports))
+	for _, p := range ports {
+		sp = append(sp, p.String())
+	}
+	return strings.Join(sp, ", ")
+}
+
+// HasAddressOrAssigned returns whether the service has an IP address.
+// This includes auto-allocated IP addresses. Note that not all proxies support auto-allocated IP addresses;
+// typically GetAllAddressesForProxy should be used which automatically filters addresses to account for that.
+func (s *Service) HasAddressOrAssigned(id cluster.ID) bool {
+	if id != "" {
+		if len(s.ClusterVIPs.GetAddressesFor(id)) > 0 {
+			return true
+		}
+	}
+	if s.DefaultAddress != constants.UnspecifiedIP {
+		return true
+	}
+	if s.AutoAllocatedIPv4Address != "" {
+		return true
+	}
+	if s.AutoAllocatedIPv6Address != "" {
+		return true
+	}
+	return false
+}
+
+// GetTLSModeFromEndpointLabels returns the value of the label
+// security.istio.io/tlsMode if set. Do not return Enums or constants
+// from this function as users could provide values other than istio/disabled
+// and apply custom transport socket matchers here.
+func GetTLSModeFromEndpointLabels(labels map[string]string) string {
+	if labels != nil {
+		if val, exists := labels[label.SecurityTlsMode.Name]; exists {
+			return val
+		}
+	}
+	return DisabledTLSModeLabel
+}
+
+// DeepCopy creates a clone of Service.
+func (s *Service) DeepCopy() *Service {
+	// nolint: govet
+	out := *s
+	out.Attributes = s.Attributes.DeepCopy()
+	if s.Ports != nil {
+		out.Ports = make(PortList, len(s.Ports))
+		for i, port := range s.Ports {
+			if port != nil {
+				out.Ports[i] = &Port{
+					Name:     port.Name,
+					Port:     port.Port,
+					Protocol: port.Protocol,
+				}
+			} else {
+				out.Ports[i] = nil
+			}
+		}
+	}
+
+	out.ServiceAccounts = slices.Clone(s.ServiceAccounts)
+	out.ClusterVIPs = *s.ClusterVIPs.DeepCopy()
+	return &out
+}
+
+// Equals compares two service objects.
+func (s *Service) Equals(other *Service) bool {
+	if s == nil {
+		return other == nil
+	}
+	if other == nil {
+		return s == nil
+	}
+
+	if !s.Attributes.Equals(&other.Attributes) {
+		return false
+	}
+
+	if !s.Ports.Equals(other.Ports) {
+		return false
+	}
+	if !slices.Equal(s.ServiceAccounts, other.ServiceAccounts) {
+		return false
+	}
+
+	if len(s.ClusterVIPs.Addresses) != len(other.ClusterVIPs.Addresses) {
+		return false
+	}
+	for k, v1 := range s.ClusterVIPs.Addresses {
+		if v2, ok := other.ClusterVIPs.Addresses[k]; !ok || !slices.Equal(v1, v2) {
+			return false
+		}
+	}
+
+	return s.DefaultAddress == other.DefaultAddress && s.AutoAllocatedIPv4Address == other.AutoAllocatedIPv4Address &&
+		s.AutoAllocatedIPv6Address == other.AutoAllocatedIPv6Address && s.Hostname == other.Hostname &&
+		s.Resolution == other.Resolution
+}
+
+func equalUsingPremarshaled[T proto.Message](a T, am *anypb.Any, b T, bm *anypb.Any) bool {
+	// If they are both pre-marshaled, use the marshaled representation. This is orders of magnitude faster
+	if am != nil && bm != nil {
+		return bytes.Equal(am.GetValue(), bm.GetValue())
+	}
+
+	// Fallback to equals
+	return protoconv.Equals(a, b)
+}
+
+// AddressMap provides a thread-safe mapping of addresses for each Kubernetes cluster.
+type AddressMap struct {
+	// Addresses hold the underlying map. Most code should only access this through the available methods.
+	// Should only be used by tests and construction/initialization logic, where there is no concern
+	// for race conditions.
+	Addresses map[cluster.ID][]string
+
+	// NOTE: The copystructure library is not able to copy unexported fields, so the mutex will not be copied.
+	mutex sync.RWMutex
+}
+
+func (m *AddressMap) Len() int {
+	if m == nil {
+		return 0
+	}
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	return len(m.Addresses)
+}
+
+func (m *AddressMap) DeepCopy() *AddressMap {
+	if m == nil {
+		return nil
+	}
+	return &AddressMap{
+		Addresses: m.GetAddresses(),
+	}
+}
+
+// GetAddresses returns the mapping of clusters to addresses.
+func (m *AddressMap) GetAddresses() map[cluster.ID][]string {
+	if m == nil {
+		return nil
+	}
+
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	if m.Addresses == nil {
+		return nil
+	}
+
+	out := make(map[cluster.ID][]string)
+	for k, v := range m.Addresses {
+		out[k] = slices.Clone(v)
+	}
+	return out
+}
+
+// SetAddresses sets the addresses per cluster.
+func (m *AddressMap) SetAddresses(addrs map[cluster.ID][]string) {
+	if len(addrs) == 0 {
+		addrs = nil
+	}
+
+	m.mutex.Lock()
+	m.Addresses = addrs
+	m.mutex.Unlock()
+}
+
+func (m *AddressMap) GetAddressesFor(c cluster.ID) []string {
+	if m == nil {
+		return nil
+	}
+
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	if m.Addresses == nil {
+		return nil
+	}
+
+	// Copy the Addresses array.
+	return append([]string{}, m.Addresses[c]...)
+}
+
+func (m *AddressMap) SetAddressesFor(c cluster.ID, addresses []string) *AddressMap {
+	m.mutex.Lock()
+	defer m.mutex.Unlock()
+
+	if len(addresses) == 0 {
+		// Setting an empty array for the cluster. Remove the entry for the cluster if it exists.
+		if m.Addresses != nil {
+			delete(m.Addresses, c)
+
+			// Delete the map if there's nothing left.
+			if len(m.Addresses) == 0 {
+				m.Addresses = nil
+			}
+		}
+	} else {
+		// Create the map if it doesn't already exist.
+		if m.Addresses == nil {
+			m.Addresses = make(map[cluster.ID][]string)
+		}
+		m.Addresses[c] = addresses
+	}
+	return m
+}
+
+func (m *AddressMap) AddAddressesFor(c cluster.ID, addresses []string) *AddressMap {
+	if len(addresses) == 0 {
+		return m
+	}
+
+	m.mutex.Lock()
+	defer m.mutex.Unlock()
+
+	// Create the map if nil.
+	if m.Addresses == nil {
+		m.Addresses = make(map[cluster.ID][]string)
+	}
+
+	m.Addresses[c] = append(m.Addresses[c], addresses...)
+	return m
+}
+
+func (m *AddressMap) ForEach(fn func(c cluster.ID, addresses []string)) {
+	if m == nil {
+		return
+	}
+
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	if m.Addresses == nil {
+		return
+	}
+
+	for c, addresses := range m.Addresses {
+		fn(c, addresses)
+	}
+}
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 88e848a24..57f0dfa09 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -3,58 +3,139 @@ package agentgatewaysyncer
 import (
 	"context"
 	"fmt"
+	"log/slog"
 	"maps"
-	"regexp"
-	"slices"
-	"strings"
+	"strconv"
+	"time"
 
-	agentgateway "github.com/agentgateway/agentgateway/go/api"
-	"github.com/agentgateway/agentgateway/go/api/a2a"
-	"github.com/agentgateway/agentgateway/go/api/mcp"
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/avast/retry-go/v4"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
 	"google.golang.org/protobuf/proto"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/config/schema/kubeclient"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/kclient"
 	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/kube/kubetypes"
 	corev1 "k8s.io/api/core/v1"
+	discoveryv1 "k8s.io/api/discovery/v1"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/sets"
+	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/tools/cache"
+	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/manager"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	"sigs.k8s.io/gateway-api-inference-extension/client-go/clientset/versioned"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gwv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
+	gwxv1a1 "sigs.k8s.io/gateway-api/apisx/v1alpha1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/xds"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 )
 
 var logger = logging.New("agentgateway/syncer")
 
+const (
+	// Retry configuration constants
+	maxRetryAttempts = 5
+	retryDelay       = 100 * time.Millisecond
+
+	// Resource name format strings
+	resourceNameFormat = "%s~%s"
+	bindKeyFormat      = "%s/%s"
+	gatewayNameFormat  = "%s/%s"
+
+	// Log message keys
+	logKeyControllerName = "controllername"
+	logKeyError          = "error"
+	logKeyGateway        = "gateway"
+	logKeyResourceRef    = "resource_ref"
+	logKeyRouteType      = "route_type"
+)
+
 // AgentGwSyncer synchronizes Kubernetes Gateway API resources with xDS for agentgateway proxies.
 // It watches Gateway resources with the agentgateway class and translates them to agentgateway configuration.
 type AgentGwSyncer struct {
-	commonCols            *common.CommonCollections
+	// Core collections and dependencies
+	commonCols *common.CommonCollections
+	mgr        manager.Manager
+	client     kube.Client
+
+	// Configuration
 	controllerName        string
 	agentGatewayClassName string
-	xDS                   krt.Collection[agentGwXdsResources]
-	xdsCache              envoycache.SnapshotCache
-	istioClient           kube.Client
+	domainSuffix          string
+	systemNamespace       string
+	clusterID             string
+
+	// XDS and caching
+	xDS                 krt.Collection[agentGwXdsResources]
+	xdsCache            envoycache.SnapshotCache
+	xdsSnapshotsMetrics krtcollections.CollectionMetricsRecorder
 
+	// Status reporting
+	statusReport krt.Singleton[report]
+	reportMap    *reports.ReportMap
+
+	// Synchronization
 	waitForSync []cache.InformerSynced
 }
 
+// agentGwXdsResources represents XDS resources for a single agent gateway
+type agentGwXdsResources struct {
+	types.NamespacedName
+
+	// Status reports for this gateway
+	reports reports.ReportMap
+
+	// Resources config for gateway (Bind, Listener, Route)
+	ResourceConfig envoycache.Resources
+
+	// Address config (Services, Workloads)
+	AddressConfig envoycache.Resources
+}
+
+// ResourceName needs to match agentgateway role configured in client.rs (https://github.com/agentgateway/agentgateway/blob/main/crates/agentgateway/src/xds/client.rs)
+func (r agentGwXdsResources) ResourceName() string {
+	return fmt.Sprintf(resourceNameFormat, r.Namespace, r.Name)
+}
+
+func (r agentGwXdsResources) Equals(in agentGwXdsResources) bool {
+	return r.NamespacedName == in.NamespacedName &&
+		report{r.reports}.Equals(report{in.reports}) &&
+		r.ResourceConfig.Version == in.ResourceConfig.Version &&
+		r.AddressConfig.Version == in.AddressConfig.Version
+}
+
 func NewAgentGwSyncer(
-	ctx context.Context,
 	controllerName string,
 	agentGatewayClassName string,
-	mgr manager.Manager,
 	client kube.Client,
+	mgr manager.Manager,
 	commonCols *common.CommonCollections,
 	xdsCache envoycache.SnapshotCache,
+	domainSuffix string,
+	systemNamespace string,
+	clusterID string,
 ) *AgentGwSyncer {
 	// TODO: register types (auth, policy, etc.) if necessary
 	return &AgentGwSyncer{
@@ -62,31 +143,15 @@ func NewAgentGwSyncer(
 		controllerName:        controllerName,
 		agentGatewayClassName: agentGatewayClassName,
 		xdsCache:              xdsCache,
-		// mgr:            mgr,
-		istioClient: client,
+		client:                client,
+		mgr:                   mgr,
+		domainSuffix:          domainSuffix,
+		systemNamespace:       systemNamespace,
+		clusterID:             clusterID,
+		xdsSnapshotsMetrics:   krtcollections.NewCollectionMetricsRecorder("AgentGatewayXDSSnapshots"),
 	}
 }
 
-type agentGwXdsResources struct {
-	types.NamespacedName
-
-	reports            reports.ReportMap
-	AgentGwA2AServices envoycache.Resources
-	AgentGwMcpServices envoycache.Resources
-	Listeners          envoycache.Resources
-}
-
-func (r agentGwXdsResources) ResourceName() string {
-	return xds.OwnerNamespaceNameID(OwnerNodeId, r.Namespace, r.Name)
-}
-
-func (r agentGwXdsResources) Equals(in agentGwXdsResources) bool {
-	return r.NamespacedName == in.NamespacedName &&
-		report{r.reports}.Equals(report{in.reports}) &&
-		r.AgentGwA2AServices.Version == in.AgentGwA2AServices.Version &&
-		r.AgentGwMcpServices.Version == in.AgentGwMcpServices.Version
-}
-
 type envoyResourceWithName struct {
 	inner   envoytypes.ResourceWithName
 	version uint64
@@ -120,20 +185,6 @@ func (r envoyResourceWithCustomName) Equals(in envoyResourceWithCustomName) bool
 
 var _ envoytypes.ResourceWithName = envoyResourceWithCustomName{}
 
-type agentGwService struct {
-	krt.Named
-	ip       string
-	port     int
-	path     string
-	protocol string // currently only A2A and MCP
-	// The listeners which are allowed to connect to the target.
-	allowedListeners []string
-}
-
-func (r agentGwService) Equals(in agentGwService) bool {
-	return r.ip == in.ip && r.port == in.port && r.path == in.path && r.protocol == in.protocol && slices.Equal(r.allowedListeners, in.allowedListeners)
-}
-
 type report struct {
 	// lower case so krt doesn't error in debug handler
 	reportMap reports.ReportMap
@@ -144,174 +195,422 @@ func (r report) ResourceName() string {
 }
 
 func (r report) Equals(in report) bool {
-	return maps.Equal(r.reportMap.Gateways, in.reportMap.Gateways) &&
-		maps.Equal(r.reportMap.HTTPRoutes, in.reportMap.HTTPRoutes) &&
-		maps.Equal(r.reportMap.TCPRoutes, in.reportMap.TCPRoutes)
+	if !maps.Equal(r.reportMap.Gateways, in.reportMap.Gateways) {
+		return false
+	}
+	if !maps.Equal(r.reportMap.HTTPRoutes, in.reportMap.HTTPRoutes) {
+		return false
+	}
+	return true
+}
+
+// Inputs holds all the input collections needed for the syncer
+type Inputs struct {
+	// Core Kubernetes resources
+	Namespaces krt.Collection[*corev1.Namespace]
+	Services   krt.Collection[*corev1.Service]
+	Secrets    krt.Collection[*corev1.Secret]
+
+	// Gateway API resources
+	GatewayClasses  krt.Collection[*gwv1.GatewayClass]
+	Gateways        krt.Collection[*gwv1.Gateway]
+	HTTPRoutes      krt.Collection[*gwv1.HTTPRoute]
+	GRPCRoutes      krt.Collection[*gwv1.GRPCRoute]
+	TCPRoutes       krt.Collection[*gwv1alpha2.TCPRoute]
+	TLSRoutes       krt.Collection[*gwv1alpha2.TLSRoute]
+	ReferenceGrants krt.Collection[*gwv1beta1.ReferenceGrant]
+
+	// Extended resources
+	ServiceEntries krt.Collection[*networkingclient.ServiceEntry]
+	InferencePools krt.Collection[*inf.InferencePool]
 }
 
 func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	logger.Debug("init agentgateway Syncer", "controllername", s.controllerName)
 
-	// TODO: convert auth to rbac json config for agentgateways
+	s.setupInferenceExtensionClient()
+	inputs := s.buildInputCollections(krtopts)
+	rm := reports.NewReportMap()
+	r := reports.NewReporter(&rm)
+	s.reportMap = &rm // Store the report map in the struct
+	s.buildResourceCollections(inputs, krtopts, r)
+}
 
-	gatewaysCol := krt.NewCollection(s.commonCols.GatewayIndex.Gateways, func(kctx krt.HandlerContext, gw ir.Gateway) *ir.Gateway {
-		if string(gw.Obj.Spec.GatewayClassName) != s.agentGatewayClassName {
-			return nil
+func (s *AgentGwSyncer) setupInferenceExtensionClient() {
+	// TODO: share this in a common spot with the inference extension plugin
+	// Create the inference extension clientset.
+	inferencePoolGVR := wellknown.InferencePoolGVK.GroupVersion().WithResource("inferencepools")
+	infCli, err := versioned.NewForConfig(s.commonCols.Client.RESTConfig())
+	if err != nil {
+		logger.Error("failed to create inference extension client", "error", err)
+	} else {
+		kubeclient.Register[*inf.InferencePool](
+			inferencePoolGVR,
+			wellknown.InferencePoolGVK,
+			func(c kubeclient.ClientGetter, namespace string, o metav1.ListOptions) (runtime.Object, error) {
+				return infCli.InferenceV1alpha2().InferencePools(namespace).List(context.Background(), o)
+			},
+			func(c kubeclient.ClientGetter, namespace string, o metav1.ListOptions) (watch.Interface, error) {
+				return infCli.InferenceV1alpha2().InferencePools(namespace).Watch(context.Background(), o)
+			},
+		)
+	}
+}
+
+func (s *AgentGwSyncer) buildInputCollections(krtopts krtutil.KrtOptions) Inputs {
+	inputs := Inputs{
+		Namespaces: krt.NewInformer[*corev1.Namespace](s.client),
+		Secrets: krt.WrapClient[*corev1.Secret](
+			kclient.NewFiltered[*corev1.Secret](s.client, kubetypes.Filter{
+				//FieldSelector: kubesecrets.SecretsFieldSelector,
+				ObjectFilter: s.client.ObjectFilter(),
+			}),
+		),
+		Services: krt.WrapClient[*corev1.Service](
+			kclient.NewFiltered[*corev1.Service](s.client, kubetypes.Filter{ObjectFilter: s.client.ObjectFilter()}),
+			krtopts.ToOptions("informer/Services")...),
+
+		GatewayClasses: krt.WrapClient(kclient.New[*gwv1.GatewayClass](s.client), krtopts.ToOptions("informer/GatewayClasses")...),
+		Gateways:       krt.WrapClient(kclient.New[*gwv1.Gateway](s.client), krtopts.ToOptions("informer/Gateways")...),
+		HTTPRoutes:     krt.WrapClient(kclient.New[*gwv1.HTTPRoute](s.client), krtopts.ToOptions("informer/HTTPRoutes")...),
+		GRPCRoutes:     krt.WrapClient(kclient.New[*gwv1.GRPCRoute](s.client), krtopts.ToOptions("informer/GRPCRoutes")...),
+
+		ReferenceGrants: krt.WrapClient(kclient.New[*gwv1beta1.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
+		//ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
+		InferencePools: krt.WrapClient(kclient.NewDelayedInformer[*inf.InferencePool](s.client, wellknown.InferencePoolGVK.GroupVersion().WithResource("inferencepools"), kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()}), krtopts.ToOptions("informer/InferencePools")...),
+	}
+
+	if features.EnableAlphaGatewayAPI {
+		inputs.TCPRoutes = krt.WrapClient(kclient.New[*gwv1alpha2.TCPRoute](s.client), krtopts.ToOptions("informer/TCPRoutes")...)
+		inputs.TLSRoutes = krt.WrapClient(kclient.New[*gwv1alpha2.TLSRoute](s.client), krtopts.ToOptions("informer/TLSRoutes")...)
+	} else {
+		// If disabled, still build a collection but make it always empty
+		inputs.TCPRoutes = krt.NewStaticCollection[*gwv1alpha2.TCPRoute](nil, krtopts.ToOptions("disable/TCPRoutes")...)
+		inputs.TLSRoutes = krt.NewStaticCollection[*gwv1alpha2.TLSRoute](nil, krtopts.ToOptions("disable/TLSRoutes")...)
+	}
+
+	return inputs
+}
+
+func (s *AgentGwSyncer) buildResourceCollections(inputs Inputs, krtopts krtutil.KrtOptions, reporter reporter.Reporter) {
+	// Build core collections
+	gatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, krtopts)
+	refGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, krtopts))
+	gateways := s.buildGatewayCollection(inputs, gatewayClasses, refGrants, krtopts, reporter)
+
+	// Build ADP resources
+	adpResources := s.buildADPResources(gateways, inputs, refGrants, krtopts, reporter)
+
+	// Build address collections
+	addresses := s.buildAddressCollections(inputs, krtopts)
+
+	// Build XDS collection
+	s.buildXDSCollection(adpResources, addresses, krtopts)
+
+	// Build status reporting
+	s.buildStatusReporting()
+
+	// Set up sync dependencies
+	s.setupSyncDependencies(gateways, adpResources, addresses, inputs)
+}
+
+func (s *AgentGwSyncer) buildGatewayCollection(
+	inputs Inputs,
+	gatewayClasses krt.Collection[GatewayClass],
+	refGrants ReferenceGrants,
+	krtopts krtutil.KrtOptions,
+	reporter reporter.Reporter,
+) krt.Collection[Gateway] {
+	return GatewayCollection(
+		s.agentGatewayClassName,
+		inputs.Gateways,
+		gatewayClasses,
+		inputs.Namespaces,
+		refGrants,
+		inputs.Secrets,
+		s.domainSuffix,
+		krtopts,
+		reporter,
+	)
+}
+
+func (s *AgentGwSyncer) buildADPResources(
+	gateways krt.Collection[Gateway],
+	inputs Inputs,
+	refGrants ReferenceGrants,
+	krtopts krtutil.KrtOptions,
+	rep reporter.Reporter,
+) krt.Collection[ADPResource] {
+	// Use the report map from the syncer - pass the original map, not a copy
+	reportMap := s.reportMap
+	if reportMap == nil {
+		newMap := reports.NewReportMap()
+		reportMap = &newMap
+	}
+
+	// Build ports and binds
+	ports := krt.NewCollection(gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
+		port := fmt.Sprint(obj.parentInfo.Port)
+		return &IndexObject[string, Gateway]{
+			Key:     port,
+			Objects: []Gateway{obj},
 		}
-		return &gw
-	}, krtopts.ToOptions("agentgateway")...)
-
-	// TODO(npolshak): optimize this in the future with an index
-	agentGwServices := krt.NewManyCollection(s.commonCols.Services, func(kctx krt.HandlerContext, s *corev1.Service) []agentGwService {
-		var allowedA2AListeners, allowedMCPListeners []string
-
-		gws := krt.Fetch(kctx, gatewaysCol)
-		for _, gw := range gws {
-			for _, listener := range gw.Listeners {
-				if listener.Protocol != A2AProtocol && listener.Protocol != MCPProtocol {
-					continue
-				}
-				logger.Debug("found agentgateway service", "namespace", s.Namespace, "name", s.Name)
-				if listener.AllowedRoutes == nil {
-					// only allow agent services in same namespace
-					if s.Namespace == gw.Obj.Namespace {
-						if listener.Protocol == A2AProtocol {
-							allowedA2AListeners = append(allowedA2AListeners, string(listener.Name))
-						} else {
-							allowedMCPListeners = append(allowedMCPListeners, string(listener.Name))
-						}
-					}
-				} else if listener.AllowedRoutes.Namespaces.From != nil {
-					switch *listener.AllowedRoutes.Namespaces.From {
-					case gwv1.NamespacesFromAll:
-						if listener.Protocol == A2AProtocol {
-							allowedA2AListeners = append(allowedA2AListeners, string(listener.Name))
-						} else {
-							allowedMCPListeners = append(allowedMCPListeners, string(listener.Name))
-						}
-					case gwv1.NamespacesFromSame:
-						// only allow agent services in same namespace
-						if s.Namespace == gw.Obj.Namespace {
-							if listener.Protocol == A2AProtocol {
-								allowedA2AListeners = append(allowedA2AListeners, string(listener.Name))
-							} else {
-								allowedMCPListeners = append(allowedMCPListeners, string(listener.Name))
-							}
-						}
-					case gwv1.NamespacesFromSelector:
-						// TODO: implement namespace selectors with gateway index
-						logger.Error("namespace selectors not supported for agentgateways")
-						continue
-					}
-				}
+	}, krtopts.ToOptions("ports")...)
+
+	binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object IndexObject[string, Gateway]) []ADPResource {
+		port, _ := strconv.Atoi(object.Key)
+		uniq := sets.New[types.NamespacedName]()
+		for _, gw := range object.Objects {
+			uniq.Insert(types.NamespacedName{
+				Namespace: gw.parent.Namespace,
+				Name:      gw.parent.Name,
+			})
+		}
+		var binds []ADPResource
+
+		for _, obj := range uniq.UnsortedList() {
+			bind := Bind{
+				Bind: &api.Bind{
+					Key:  object.Key + "/" + obj.String(),
+					Port: uint32(port),
+				},
 			}
+			binds = append(binds, toResourceWithReports(obj, bind, *reportMap))
 		}
-		return translateAgentService(s, allowedA2AListeners, allowedMCPListeners)
-	})
-	xdsA2AServices := krt.NewCollection(agentGwServices, func(kctx krt.HandlerContext, s agentGwService) *envoyResourceWithName {
-		if s.protocol != A2AProtocol {
-			return nil
+		return binds
+	}, krtopts.ToOptions("Binds")...)
+
+	// Build listeners
+	listeners := krt.NewCollection(gateways, s.buildListenerFromGateway, krtopts.ToOptions("Listeners")...)
+
+	// Build routes
+	routeParents := BuildRouteParents(gateways)
+	routeInputs := RouteContextInputs{
+		Grants:         refGrants,
+		RouteParents:   routeParents,
+		DomainSuffix:   s.domainSuffix,
+		Services:       inputs.Services,
+		Namespaces:     inputs.Namespaces,
+		InferencePools: inputs.InferencePools,
+	}
+	adpRoutes := ADPRouteCollection(inputs.HTTPRoutes, routeInputs, krtopts, *reportMap, rep)
+
+	return krt.JoinCollection([]krt.Collection[ADPResource]{binds, listeners, adpRoutes}, krtopts.ToOptions("ADPResources")...)
+}
+
+// buildListenerFromGateway creates a listener resource from a gateway
+func (s *AgentGwSyncer) buildListenerFromGateway(ctx krt.HandlerContext, obj Gateway) *ADPResource {
+	l := &api.Listener{
+		Key:         obj.ResourceName(),
+		Name:        string(obj.parentInfo.SectionName),
+		BindKey:     fmt.Sprint(obj.parentInfo.Port) + "/" + obj.parent.Namespace + "/" + obj.parent.Name,
+		GatewayName: obj.parent.Namespace + "/" + obj.parent.Name,
+		Hostname:    obj.parentInfo.OriginalHostname,
+	}
+
+	// Set protocol and TLS configuration
+	protocol, tlsConfig, ok := s.getProtocolAndTLSConfig(obj)
+	if !ok {
+		return nil // Unsupported protocol or missing TLS config
+	}
+
+	l.Protocol = protocol
+	l.Tls = tlsConfig
+
+	// Use the report map from the syncer
+	reportMap := s.reportMap
+	if reportMap == nil {
+		newMap := reports.NewReportMap()
+		reportMap = &newMap
+	}
+
+	return toResourcepWithReports(types.NamespacedName{
+		Namespace: obj.parent.Namespace,
+		Name:      obj.parent.Name,
+	}, ADPListener{l}, *reportMap)
+}
+
+// getProtocolAndTLSConfig extracts protocol and TLS configuration from a gateway
+func (s *AgentGwSyncer) getProtocolAndTLSConfig(obj Gateway) (api.Protocol, *api.TLSConfig, bool) {
+	var tlsConfig *api.TLSConfig
+
+	// Build TLS config if needed
+	if obj.TLSInfo != nil {
+		tlsConfig = &api.TLSConfig{
+			Cert:       obj.TLSInfo.Cert,
+			PrivateKey: obj.TLSInfo.Key,
 		}
-		t := &a2a.Target{
-			Name:      getTargetName(s.ResourceName()),
-			Host:      s.ip,
-			Port:      uint32(s.port),
-			Path:      s.path,
-			Listeners: s.allowedListeners,
+	}
+
+	switch obj.parentInfo.Protocol {
+	case gwv1.HTTPProtocolType:
+		return api.Protocol_HTTP, nil, true
+	case gwv1.HTTPSProtocolType:
+		if tlsConfig == nil {
+			return api.Protocol_HTTPS, nil, false // TLS required but not configured
 		}
-		return &envoyResourceWithName{inner: t, version: utils.HashProto(t)}
-	}, krtopts.ToOptions("a2a-target-xds")...)
-	xdsMcpServices := krt.NewCollection(agentGwServices, func(kctx krt.HandlerContext, s agentGwService) *envoyResourceWithName {
-		if s.protocol != MCPProtocol {
-			return nil
+		return api.Protocol_HTTPS, tlsConfig, true
+	case gwv1.TLSProtocolType:
+		if tlsConfig == nil {
+			return api.Protocol_TLS, nil, false // TLS required but not configured
 		}
-		t := &mcp.Target{
-			// Note: No slashes allowed here (must match ^[a-zA-Z0-9-]+$)
-			Name: getTargetName(s.ResourceName()),
-			Target: &mcp.Target_Sse{
-				Sse: &mcp.Target_SseTarget{
-					Host: s.ip,
-					Port: uint32(s.port),
-					Path: s.path,
-				},
-			},
-			Listeners: s.allowedListeners,
+		return api.Protocol_TLS, tlsConfig, true
+	case gwv1.TCPProtocolType:
+		return api.Protocol_TCP, nil, true
+	default:
+		return api.Protocol_HTTP, nil, false // Unsupported protocol
+	}
+}
+
+func (s *AgentGwSyncer) buildAddressCollections(inputs Inputs, krtopts krtutil.KrtOptions) krt.Collection[envoyResourceWithCustomName] {
+	// Build endpoint slices and namespaces
+	epSliceClient := kclient.NewFiltered[*discoveryv1.EndpointSlice](
+		s.commonCols.Client,
+		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
+	)
+	endpointSlices := krt.WrapClient(epSliceClient, s.commonCols.KrtOpts.ToOptions("informer/EndpointSlices")...)
+
+	nsClient := kclient.NewFiltered[*corev1.Namespace](
+		s.commonCols.Client,
+		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
+	)
+	namespaces := krt.WrapClient(nsClient, s.commonCols.KrtOpts.ToOptions("informer/Namespaces")...)
+
+	// Build workload index
+	workloadIndex := index{
+		namespaces:      s.commonCols.Namespaces,
+		SystemNamespace: s.systemNamespace,
+		ClusterID:       s.clusterID,
+		DomainSuffix:    s.domainSuffix,
+	}
+
+	// Build service and workload collections
+	workloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, inputs.InferencePools, namespaces, krtopts)
+	workloads := workloadIndex.WorkloadsCollection(
+		s.commonCols.WrappedPods,
+		workloadServices,
+		nil, // serviceEntries,
+		endpointSlices,
+		namespaces,
+		krtopts,
+	)
+
+	// Build address collections
+	svcAddresses := krt.NewCollection(workloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
+		addrMessage := obj.AsAddress.Address
+		resourceVersion := utils.HashProto(addrMessage)
+		result := &ADPCacheAddress{
+			NamespacedName:      types.NamespacedName{Name: obj.Service.GetName(), Namespace: obj.Service.GetNamespace()},
+			Address:             addrMessage,
+			AddressResourceName: obj.ResourceName(),
+			AddressVersion:      resourceVersion,
 		}
-		return &envoyResourceWithName{inner: t, version: utils.HashProto(t)}
-	}, krtopts.ToOptions("mcp-target-xds")...)
-
-	// translate gateways to xds
-	s.xDS = krt.NewCollection(gatewaysCol, func(kctx krt.HandlerContext, gw ir.Gateway) *agentGwXdsResources {
-		// listeners for the agentgateway
-		agwListeners := make([]envoytypes.Resource, 0, len(gw.Listeners))
-		var listenerVersion uint64
-		var listener *agentgateway.Listener
-		for _, gwListener := range gw.Listeners {
-			var protocol agentgateway.Listener_Protocol
-			switch string(gwListener.Protocol) {
-			case MCPProtocol:
-				protocol = agentgateway.Listener_MCP
-			case A2AProtocol:
-				protocol = agentgateway.Listener_A2A
-			default:
-				// Not a valid protocol for agentgateway
-				continue
-			}
+		logger.Debug("created XDS resources for svc address with ID", "addr", fmt.Sprintf("%s,%s", obj.Service.GetName(), obj.Service.GetNamespace()), "resourceid", result.ResourceName())
+		return result
+	})
 
-			listener = &agentgateway.Listener{
-				Name:     string(gwListener.Name),
-				Protocol: protocol,
-				// TODO: Add support for stdio listener
-				Listener: &agentgateway.Listener_Sse{
-					Sse: &agentgateway.SseListener{
-						Address: "[::]",
-						Port:    uint32(gwListener.Port),
-					},
-				},
-			}
+	workloadAddresses := krt.NewCollection(workloads, func(ctx krt.HandlerContext, obj WorkloadInfo) *ADPCacheAddress {
+		addrMessage := obj.AsAddress.Address
+		resourceVersion := utils.HashProto(addrMessage)
+		result := &ADPCacheAddress{
+			NamespacedName:      types.NamespacedName{Name: obj.Workload.GetName(), Namespace: obj.Workload.GetNamespace()},
+			Address:             addrMessage,
+			AddressVersion:      resourceVersion,
+			AddressResourceName: obj.ResourceName(),
+		}
+		logger.Debug("created XDS resources for workload address with ID", "addr", fmt.Sprintf("%s,%s", obj.Workload.GetName(), obj.Workload.GetNamespace()), "resourceid", result.ResourceName())
+		return result
+	})
+
+	adpAddresses := krt.JoinCollection([]krt.Collection[ADPCacheAddress]{svcAddresses, workloadAddresses}, krtopts.ToOptions("ADPAddresses")...)
+	return krt.NewCollection(adpAddresses, func(kctx krt.HandlerContext, obj ADPCacheAddress) *envoyResourceWithCustomName {
+		return &envoyResourceWithCustomName{
+			Message: obj.Address,
+			Name:    obj.AddressResourceName,
+			version: obj.AddressVersion,
+		}
+	}, krtopts.ToOptions("XDSAddresses")...)
+}
+
+func (s *AgentGwSyncer) buildXDSCollection(adpResources krt.Collection[ADPResource], xdsAddresses krt.Collection[envoyResourceWithCustomName], krtopts krtutil.KrtOptions) {
+	// Create an index on adpResources by Gateway to avoid fetching all resources
+	adpResourcesByGateway := krt.NewIndex(adpResources, func(resource ADPResource) []types.NamespacedName {
+		return []types.NamespacedName{resource.Gateway}
+	})
+
+	s.xDS = krt.NewCollection(adpResources, func(kctx krt.HandlerContext, obj ADPResource) *agentGwXdsResources {
+		gwNamespacedName := obj.Gateway
+
+		cacheAddresses := krt.Fetch(kctx, xdsAddresses)
+		envoytypesAddresses := make([]envoytypes.Resource, 0, len(cacheAddresses))
+		for _, addr := range cacheAddresses {
+			envoytypesAddresses = append(envoytypesAddresses, addr)
+		}
+
+		var cacheResources []envoytypes.Resource
+		// Use index to fetch only resources for this gateway instead of all resources
+		resourceList := krt.Fetch(kctx, adpResources, krt.FilterIndex(adpResourcesByGateway, gwNamespacedName))
 
-			// Update listenerVersion to be the result
-			listenerVersion ^= utils.HashProto(listener)
-			agwListeners = append(agwListeners, listener)
+		// Collect and merge reports from all resources for this gateway
+		mergedReports := reports.NewReportMap()
+		for _, resource := range resourceList {
+			cacheResources = append(cacheResources, &envoyResourceWithCustomName{
+				Message: resource.Resource,
+				Name:    resource.ResourceName(),
+				version: utils.HashProto(resource.Resource),
+			})
+
+			// Merge reports from this resource into the merged reports
+			maps.Copy(mergedReports.Gateways, resource.reports.Gateways)
+			maps.Copy(mergedReports.ListenerSets, resource.reports.ListenerSets)
+			mergeRouteReports(mergedReports.HTTPRoutes, resource.reports.HTTPRoutes)
+			mergeRouteReports(mergedReports.TCPRoutes, resource.reports.TCPRoutes)
+			mergeRouteReports(mergedReports.TLSRoutes, resource.reports.TLSRoutes)
+			mergeRouteReports(mergedReports.GRPCRoutes, resource.reports.GRPCRoutes)
 		}
 
-		// a2a services
-		a2aServiceResources := krt.Fetch(kctx, xdsA2AServices)
-		logger.Debug("found A2A resources for gateway", "total_services", len(a2aServiceResources), "resource_ref", gw.ResourceName())
-		a2aResources := make([]envoytypes.Resource, len(a2aServiceResources))
-		var a2aVersion uint64
-		for i, res := range a2aServiceResources {
-			a2aVersion ^= res.version
-			target := res.inner.(*a2a.Target)
-			a2aResources[i] = target
+		// Create the resource wrappers
+		var resourceVersion uint64
+		for _, res := range cacheResources {
+			resourceVersion ^= res.(*envoyResourceWithCustomName).version
 		}
-		// mcp services
-		mcpServiceResources := krt.Fetch(kctx, xdsMcpServices)
-		logger.Debug("found MCP resources for gateway", "total_services", len(mcpServiceResources), "resource_ref", gw.ResourceName())
-		mcpResources := make([]envoytypes.Resource, len(mcpServiceResources))
-		var mcpVersion uint64
-		for i, res := range mcpServiceResources {
-			mcpVersion ^= res.version
-			target := res.inner.(*mcp.Target)
-			mcpResources[i] = target
+		// Calculate address version
+		var addrVersion uint64
+		for _, res := range cacheAddresses {
+			addrVersion ^= res.version
 		}
+
 		result := &agentGwXdsResources{
-			NamespacedName:     types.NamespacedName{Namespace: gw.Namespace, Name: gw.Name},
-			AgentGwA2AServices: envoycache.NewResources(fmt.Sprintf("%d", a2aVersion), a2aResources),
-			AgentGwMcpServices: envoycache.NewResources(fmt.Sprintf("%d", mcpVersion), mcpResources),
-			Listeners:          envoycache.NewResources(fmt.Sprintf("%d", listenerVersion), agwListeners),
+			NamespacedName: gwNamespacedName,
+			reports:        mergedReports,
+			ResourceConfig: envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
+			AddressConfig:  envoycache.NewResources(fmt.Sprintf("%d", addrVersion), envoytypesAddresses),
 		}
-		logger.Debug("created XDS resources for with ID", "gwname", gw.Name, "resourceid", result.ResourceName())
+		logger.Debug("created XDS resources for gateway with ID", "gwname", fmt.Sprintf("%s,%s", gwNamespacedName.Name, gwNamespacedName.Namespace), "resourceid", result.ResourceName())
 		return result
-	}, krtopts.ToOptions("agentgateway-xds")...)
+	})
+}
 
+func (s *AgentGwSyncer) buildStatusReporting() {
+	// as proxies are created, they also contain a reportMap containing status for the Gateway and associated xRoutes (really parentRefs)
+	// here we will merge reports that are per-Proxy to a singleton Report used to persist to k8s on a timer
+	s.statusReport = krt.NewSingleton(func(kctx krt.HandlerContext) *report {
+		proxies := krt.Fetch(kctx, s.xDS)
+		merged := mergeProxyReports(proxies)
+		return &report{merged}
+	})
+}
+
+func (s *AgentGwSyncer) setupSyncDependencies(gateways krt.Collection[Gateway], adpResources krt.Collection[ADPResource], addresses krt.Collection[envoyResourceWithCustomName], inputs Inputs) {
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
-		xdsA2AServices.HasSynced,
-		xdsMcpServices.HasSynced,
-		gatewaysCol.HasSynced,
-		agentGwServices.HasSynced,
+		gateways.HasSynced,
+		// resources
+		adpResources.HasSynced,
 		s.xDS.HasSynced,
+		// addresses
+		addresses.HasSynced,
+		inputs.Namespaces.HasSynced,
 	}
 }
 
@@ -326,33 +625,58 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 
 	s.xDS.RegisterBatch(func(events []krt.Event[agentGwXdsResources], _ bool) {
 		for _, e := range events {
-			r := e.Latest()
+			snap := e.Latest()
 			if e.Event == controllers.EventDelete {
-				s.xdsCache.ClearSnapshot(r.ResourceName())
+				s.xdsCache.ClearSnapshot(snap.ResourceName())
 				continue
 			}
 			snapshot := &agentGwSnapshot{
-				AgentGwA2AServices: r.AgentGwA2AServices,
-				AgentGwMcpServices: r.AgentGwMcpServices,
-				Listeners:          r.Listeners,
+				Resources: snap.ResourceConfig,
+				Addresses: snap.AddressConfig,
 			}
-			logger.Debug("setting xds snapshot", "resourcename", r.ResourceName())
-			err := s.xdsCache.SetSnapshot(ctx, r.ResourceName(), snapshot)
+			logger.Debug("setting xds snapshot", "resourceName", snap.ResourceName())
+			logger.Debug("snapshot config", "resourceSnapshot", snapshot.Resources, "workloadSnapshot", snapshot.Addresses)
+			err := s.xdsCache.SetSnapshot(ctx, snap.ResourceName(), snapshot)
 			if err != nil {
-				logger.Error("failed to set xds snapshot", "resourcename", r.ResourceName(), "error", err.Error())
+				logger.Error("failed to set xds snapshot", "resourcename", snap.ResourceName(), "error", err.Error())
 				continue
 			}
 		}
 	}, true)
 
+	// latestReport will be constantly updated to contain the merged status report for Kube Gateway status
+	// when timer ticks, we will use the state of the mergedReports at that point in time to sync the status to k8s
+	latestReportQueue := utils.NewAsyncQueue[reports.ReportMap]()
+	s.statusReport.Register(func(o krt.Event[report]) {
+		if o.Event == controllers.EventDelete {
+			// TODO: handle garbage collection
+			return
+		}
+		latestReportQueue.Enqueue(o.Latest().reportMap)
+	})
+	routeStatusLogger := logger.With("subcomponent", "routeStatusSyncer")
+	listenerSetStatusLogger := logger.With("subcomponent", "listenerSetStatusSyncer")
+	gatewayStatusLogger := logger.With("subcomponent", "gatewayStatusSyncer")
+	go func() {
+		for {
+			latestReport, err := latestReportQueue.Dequeue(ctx)
+			if err != nil {
+				logger.Error("failed to dequeue latest report", "error", err)
+				return
+			}
+			s.syncGatewayStatus(ctx, gatewayStatusLogger, latestReport)
+			s.syncListenerSetStatus(ctx, listenerSetStatusLogger, latestReport)
+			s.syncRouteStatus(ctx, routeStatusLogger, latestReport)
+		}
+	}()
+
 	return nil
 }
 
 type agentGwSnapshot struct {
-	AgentGwA2AServices envoycache.Resources
-	AgentGwMcpServices envoycache.Resources
-	Listeners          envoycache.Resources
-	VersionMap         map[string]map[string]string
+	Resources  envoycache.Resources
+	Addresses  envoycache.Resources
+	VersionMap map[string]map[string]string
 }
 
 func (m *agentGwSnapshot) GetResources(typeURL string) map[string]envoytypes.Resource {
@@ -366,12 +690,10 @@ func (m *agentGwSnapshot) GetResources(typeURL string) map[string]envoytypes.Res
 
 func (m *agentGwSnapshot) GetResourcesAndTTL(typeURL string) map[string]envoytypes.ResourceWithTTL {
 	switch typeURL {
-	case TargetTypeA2AUrl:
-		return m.AgentGwA2AServices.Items
-	case TargetTypeMcpUrl:
-		return m.AgentGwMcpServices.Items
-	case TargetTypeListenerUrl:
-		return m.Listeners.Items
+	case TargetTypeResourceUrl:
+		return m.Resources.Items
+	case TargetTypeAddressUrl:
+		return m.Addresses.Items
 	default:
 		return nil
 	}
@@ -379,12 +701,10 @@ func (m *agentGwSnapshot) GetResourcesAndTTL(typeURL string) map[string]envoytyp
 
 func (m *agentGwSnapshot) GetVersion(typeURL string) string {
 	switch typeURL {
-	case TargetTypeA2AUrl:
-		return m.AgentGwA2AServices.Version
-	case TargetTypeMcpUrl:
-		return m.AgentGwMcpServices.Version
-	case TargetTypeListenerUrl:
-		return m.Listeners.Version
+	case TargetTypeResourceUrl:
+		return m.Resources.Version
+	case TargetTypeAddressUrl:
+		return m.Addresses.Version
 	default:
 		return ""
 	}
@@ -400,9 +720,8 @@ func (m *agentGwSnapshot) ConstructVersionMap() error {
 
 	m.VersionMap = make(map[string]map[string]string)
 	resources := map[string]map[string]envoytypes.ResourceWithTTL{
-		TargetTypeA2AUrl:      m.AgentGwA2AServices.Items,
-		TargetTypeMcpUrl:      m.AgentGwMcpServices.Items,
-		TargetTypeListenerUrl: m.Listeners.Items,
+		TargetTypeResourceUrl: m.Resources.Items,
+		TargetTypeAddressUrl:  m.Addresses.Items,
 	}
 
 	for typeUrl, items := range resources {
@@ -429,68 +748,308 @@ func (m *agentGwSnapshot) GetVersionMap(typeURL string) map[string]string {
 
 var _ envoycache.ResourceSnapshot = &agentGwSnapshot{}
 
-// getTargetName sanitizes the given resource name to ensure it matches the AgentGateway required pattern:
-// ^[a-zA-Z0-9-]+$ by replacing slashes and removing invalid characters.
-func getTargetName(resourceName string) string {
-	var (
-		invalidCharsRegex      = regexp.MustCompile(`[^a-zA-Z0-9-]+`)
-		consecutiveDashesRegex = regexp.MustCompile(`-+`)
-	)
+type clustersWithErrors struct {
+	clusters            envoycache.Resources
+	erroredClusters     []string
+	erroredClustersHash uint64
+	clustersHash        uint64
+	resourceName        string
+}
+
+type addressesWithUccName struct {
+	addresses    envoycache.Resources
+	resourceName string
+}
 
-	// Replace all invalid characters with dashes
-	sanitized := invalidCharsRegex.ReplaceAllString(resourceName, "-")
+func (c clustersWithErrors) ResourceName() string {
+	return c.resourceName
+}
+
+var _ krt.Equaler[clustersWithErrors] = new(clustersWithErrors)
 
-	// Remove leading/trailing dashes and collapse consecutive dashes
-	sanitized = strings.Trim(sanitized, "-")
-	sanitized = consecutiveDashesRegex.ReplaceAllString(sanitized, "-")
+func (c clustersWithErrors) Equals(k clustersWithErrors) bool {
+	return c.clustersHash == k.clustersHash && c.erroredClustersHash == k.erroredClustersHash
+}
 
-	return sanitized
+func (c addressesWithUccName) ResourceName() string {
+	return c.resourceName
 }
 
-func translateAgentService(svc *corev1.Service, allowedA2AListeners, allowedMCPListeners []string) []agentGwService {
-	var svcs []agentGwService
+var _ krt.Equaler[addressesWithUccName] = new(addressesWithUccName)
 
-	if svc.Spec.ClusterIP == "" && svc.Spec.ExternalName == "" {
-		// Return early if there's no valid IP or external name set on the service
-		return svcs
-	}
+func (c addressesWithUccName) Equals(k addressesWithUccName) bool {
+	return c.addresses.Version == k.addresses.Version
+}
+
+type UccWithAddress struct {
+	Client  ir.UniqlyConnectedClient
+	Address ADPCacheAddress
+}
+
+func (c UccWithAddress) ResourceName() string {
+	return fmt.Sprintf("%s/%s", c.Client.ResourceName(), c.Address.ResourceName())
+}
+
+func (c UccWithAddress) Equals(in UccWithAddress) bool {
+	return c.Client.Equals(in.Client) && c.Address.Equals(in.Address)
+}
 
-	addr := svc.Spec.ClusterIP
-	if addr == "" {
-		addr = svc.Spec.ExternalName
+type PerClientAddresses struct {
+	addresses krt.Collection[UccWithAddress]
+	index     krt.Index[string, UccWithAddress]
+}
+
+func (ie *PerClientAddresses) FetchEndpointsForClient(kctx krt.HandlerContext, ucc ir.UniqlyConnectedClient) []UccWithAddress {
+	return krt.Fetch(kctx, ie.addresses, krt.FilterIndex(ie.index, ucc.ResourceName()))
+}
+
+func (s *AgentGwSyncer) syncRouteStatus(ctx context.Context, logger *slog.Logger, rm reports.ReportMap) {
+	stopwatch := utils.NewTranslatorStopWatch("RouteStatusSyncer")
+	stopwatch.Start()
+	defer stopwatch.Stop(ctx)
+
+	// TODO: add routeStatusMetrics
+
+	// Helper function to sync route status with retry
+	syncStatusWithRetry := func(
+		routeType string,
+		routeKey client.ObjectKey,
+		getRouteFunc func() client.Object,
+		statusUpdater func(route client.Object) error,
+	) error {
+		return retry.Do(
+			func() error {
+				route := getRouteFunc()
+				err := s.mgr.GetClient().Get(ctx, routeKey, route)
+				if err != nil {
+					if apierrors.IsNotFound(err) {
+						// the route is not found, we can't report status on it
+						// if it's recreated, we'll retranslate it anyway
+						return nil
+					}
+					logger.Error("error getting route", logKeyError, err, logKeyResourceRef, routeKey, logKeyRouteType, routeType)
+					return err
+				}
+				if err := statusUpdater(route); err != nil {
+					logger.Debug("error updating status for route", logKeyError, err, logKeyResourceRef, routeKey, logKeyRouteType, routeType)
+					return err
+				}
+				return nil
+			},
+			retry.Attempts(maxRetryAttempts),
+			retry.Delay(retryDelay),
+			retry.DelayType(retry.BackOffDelay),
+		)
 	}
 
-	for _, port := range svc.Spec.Ports {
-		if port.AppProtocol == nil {
-			continue
-		}
-		appProtocol := *port.AppProtocol
-		var path string
-		var allowedListeners []string
-
-		switch appProtocol {
-		case A2AProtocol:
-			path = svc.Annotations[A2APathAnnotation]
-			allowedListeners = allowedA2AListeners
-		case MCPProtocol:
-			path = svc.Annotations[MCPPathAnnotation]
-			allowedListeners = allowedMCPListeners
+	// Helper function to build route status and update if needed
+	buildAndUpdateStatus := func(route client.Object, routeType string) error {
+		var status *gwv1.RouteStatus
+		switch r := route.(type) {
+		case *gwv1.HTTPRoute: // TODO: beta1?
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
+			}
+			r.Status.RouteStatus = *status
+		case *gwv1alpha2.TCPRoute:
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
+			}
+			r.Status.RouteStatus = *status
+		case *gwv1alpha2.TLSRoute:
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
+			}
+			r.Status.RouteStatus = *status
+		case *gwv1.GRPCRoute:
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
+			}
+			r.Status.RouteStatus = *status
 		default:
-			// Skip unsupported protocols
-			continue
+			logger.Warn("unsupported route type", logKeyRouteType, routeType, logKeyResourceRef, client.ObjectKeyFromObject(route))
+			return nil
 		}
 
-		svcs = append(svcs, agentGwService{
-			Named: krt.Named{
-				Name:      svc.Name,
-				Namespace: svc.Namespace,
+		// Update the status
+		return s.mgr.GetClient().Status().Update(ctx, route)
+	}
+
+	for rnn := range rm.HTTPRoutes {
+		err := syncStatusWithRetry(
+			wellknown.HTTPRouteKind,
+			rnn,
+			func() client.Object {
+				return new(gwv1.HTTPRoute)
 			},
-			ip:               addr,
-			port:             int(port.Port),
-			path:             path,
-			protocol:         appProtocol,
-			allowedListeners: allowedListeners,
-		})
+			func(route client.Object) error {
+				return buildAndUpdateStatus(route, wellknown.HTTPRouteKind)
+			},
+		)
+		if err != nil {
+			logger.Error("all attempts failed at updating HTTPRoute status", logKeyError, err, "route", rnn)
+		}
+	}
+}
+
+// syncGatewayStatus will build and update status for all Gateways in a reportMap
+func (s *AgentGwSyncer) syncGatewayStatus(ctx context.Context, logger *slog.Logger, rm reports.ReportMap) {
+	stopwatch := utils.NewTranslatorStopWatch("GatewayStatusSyncer")
+	stopwatch.Start()
+
+	// TODO: add gatewayStatusMetrics
+
+	// TODO: retry within loop per GW rather that as a full block
+	err := retry.Do(func() error {
+		for gwnn := range rm.Gateways {
+			gw := gwv1.Gateway{}
+			err := s.mgr.GetClient().Get(ctx, gwnn, &gw)
+			if err != nil {
+				logger.Info("error getting gw", logKeyError, err, logKeyGateway, gwnn.String())
+				return err
+			}
+
+			gwStatusWithoutAddress := gw.Status
+			gwStatusWithoutAddress.Addresses = nil
+			if status := rm.BuildGWStatus(ctx, gw); status != nil {
+				if !isGatewayStatusEqual(&gwStatusWithoutAddress, status) {
+					gw.Status = *status
+					if err := s.mgr.GetClient().Status().Patch(ctx, &gw, client.Merge); err != nil {
+						logger.Error("error patching gateway status", logKeyError, err, logKeyGateway, gwnn.String())
+						return err
+					}
+					logger.Info("patched gw status", logKeyGateway, gwnn.String())
+				} else {
+					logger.Info("skipping k8s gateway status update, status equal", logKeyGateway, gwnn.String())
+				}
+			}
+		}
+		return nil
+	},
+		retry.Attempts(maxRetryAttempts),
+		retry.Delay(retryDelay),
+		retry.DelayType(retry.BackOffDelay),
+	)
+	if err != nil {
+		logger.Error("all attempts failed at updating gateway statuses", logKeyError, err)
 	}
-	return svcs
+	duration := stopwatch.Stop(ctx)
+	logger.Debug("synced gw status for gateways", "count", len(rm.Gateways), "duration", duration)
+}
+
+// syncListenerSetStatus will build and update status for all Listener Sets in a reportMap
+func (s *AgentGwSyncer) syncListenerSetStatus(ctx context.Context, logger *slog.Logger, rm reports.ReportMap) {
+	stopwatch := utils.NewTranslatorStopWatch("ListenerSetStatusSyncer")
+	stopwatch.Start()
+
+	// TODO: add listenerStatusMetrics
+
+	// TODO: retry within loop per LS rathen that as a full block
+	err := retry.Do(func() error {
+		for lsnn := range rm.ListenerSets {
+			ls := gwxv1a1.XListenerSet{}
+			err := s.mgr.GetClient().Get(ctx, lsnn, &ls)
+			if err != nil {
+				logger.Info("error getting ls", "erro", err.Error())
+				return err
+			}
+			lsStatus := ls.Status
+			if status := rm.BuildListenerSetStatus(ctx, ls); status != nil {
+				if !isListenerSetStatusEqual(&lsStatus, status) {
+					ls.Status = *status
+					if err := s.mgr.GetClient().Status().Patch(ctx, &ls, client.Merge); err != nil {
+						logger.Error("error patching listener set status", logKeyError, err, logKeyGateway, lsnn.String())
+						return err
+					}
+					logger.Info("patched ls status", "listenerset", lsnn.String())
+				} else {
+					logger.Info("skipping k8s ls status update, status equal", "listenerset", lsnn.String())
+				}
+			}
+		}
+		return nil
+	},
+		retry.Attempts(maxRetryAttempts),
+		retry.Delay(retryDelay),
+		retry.DelayType(retry.BackOffDelay),
+	)
+	if err != nil {
+		logger.Error("all attempts failed at updating listener set statuses", logKeyError, err)
+	}
+	duration := stopwatch.Stop(ctx)
+	logger.Debug("synced listener sets status for listener set", "count", len(rm.ListenerSets), "duration", duration.String())
+}
+
+// TODO: refactor proxy_syncer status syncing to use the same logic as agentgateway syncer
+
+var opts = cmp.Options{
+	cmpopts.IgnoreFields(metav1.Condition{}, "LastTransitionTime"),
+	cmpopts.IgnoreMapEntries(func(k string, _ any) bool {
+		return k == "lastTransitionTime"
+	}),
+}
+
+// isRouteStatusEqual compares two RouteStatus objects directly
+func isRouteStatusEqual(objA, objB *gwv1.RouteStatus) bool {
+	return cmp.Equal(objA, objB, opts)
+}
+
+func isListenerSetStatusEqual(objA, objB *gwxv1a1.ListenerSetStatus) bool {
+	return cmp.Equal(objA, objB, opts)
+}
+
+func mergeProxyReports(proxies []agentGwXdsResources) reports.ReportMap {
+	merged := reports.NewReportMap()
+
+	for _, p := range proxies {
+		// 1. merge GW Reports for all Proxies' status reports
+		maps.Copy(merged.Gateways, p.reports.Gateways)
+
+		// 2. merge LS Reports for all Proxies' status reports
+		maps.Copy(merged.ListenerSets, p.reports.ListenerSets)
+
+		// 3. merge route parentRefs into RouteReports for all route types
+		mergeRouteReports(merged.HTTPRoutes, p.reports.HTTPRoutes)
+		mergeRouteReports(merged.TCPRoutes, p.reports.TCPRoutes)
+		mergeRouteReports(merged.TLSRoutes, p.reports.TLSRoutes)
+		mergeRouteReports(merged.GRPCRoutes, p.reports.GRPCRoutes)
+
+		// TODO: add back when policies are back
+		//for key, report := range p.reports.Policies {
+		//	// if we haven't encountered this policy, just copy it over completely
+		//	old := merged.Policies[key]
+		//	if old == nil {
+		//		merged.Policies[key] = report
+		//		continue
+		//	}
+		//	// else, let's merge our parentRefs into the existing map
+		//	// obsGen will stay as-is...
+		//	maps.Copy(merged.Policies[key].Ancestors, report.Ancestors)
+		//}
+	}
+
+	return merged
+}
+
+// mergeRouteReports is a helper function to merge route reports
+func mergeRouteReports(merged map[types.NamespacedName]*reports.RouteReport, source map[types.NamespacedName]*reports.RouteReport) {
+	for rnn, rr := range source {
+		// if we haven't encountered this route, just copy it over completely
+		old := merged[rnn]
+		if old == nil {
+			merged[rnn] = rr
+			continue
+		}
+		// else, this route has already been seen for a proxy, merge this proxy's parents
+		// into the merged report
+		maps.Copy(merged[rnn].Parents, rr.Parents)
+	}
+}
+
+func isGatewayStatusEqual(objA, objB *gwv1.GatewayStatus) bool {
+	return cmp.Equal(objA, objB, opts)
 }
diff --git a/internal/kgateway/agentgatewaysyncer/syncer_test.go b/internal/kgateway/agentgatewaysyncer/syncer_test.go
index b385c55ff..a41f4c864 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer_test.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer_test.go
@@ -1,246 +1,647 @@
 package agentgatewaysyncer
 
 import (
-	"context"
 	"testing"
 
-	agentgateway "github.com/agentgateway/agentgateway/go/api"
-	"github.com/agentgateway/agentgateway/go/api/a2a"
-	"github.com/agentgateway/agentgateway/go/api/mcp"
-	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
-	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"github.com/agentgateway/agentgateway/go/api"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/utils/ptr"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 )
 
-// dumpXDSCacheState is a helper function that dump the current state of the XDS cache for the agentgateway cache
-func dumpXDSCacheState(ctx context.Context, cache envoycache.SnapshotCache) {
-	logger.Info("current XDS cache state:")
-
-	// Get all snapshot IDs from cache
-	for _, nodeID := range cache.GetStatusKeys() {
-		logger.Info("snapshot has node", "node_id", nodeID)
-
-		snapshot, err := cache.GetSnapshot(nodeID)
-		if err != nil {
-			logger.Info("error getting snapshot", "error", err.Error())
-			continue
-		}
-
-		// Check for A2A targets
-		logger.Info("A2A targets version", "snapshot", snapshot.GetVersion(TargetTypeA2AUrl)) //nolint:sloglint // ignore msg-type
-		resources := snapshot.GetResources(TargetTypeA2AUrl)
-		for name := range resources {
-			logger.Info("snapshot has resources", "name", name)
-		}
-
-		// Check for MCP targets
-		logger.Info("MCP targets version", "snapshot", snapshot.GetVersion(TargetTypeMcpUrl))
-		resources = snapshot.GetResources(TargetTypeMcpUrl)
-		for name := range resources {
-			logger.Info("snapshot has resources", "name", name)
-		}
+func TestBuildADPFilters(t *testing.T) {
+	testCases := []struct {
+		name            string
+		inputFilters    []gwv1.HTTPRouteFilter
+		expectedFilters []*api.RouteFilter
+		expectedError   bool
+	}{
+		{
+			name: "Request header modifier filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterRequestHeaderModifier,
+					RequestHeaderModifier: &gwv1.HTTPHeaderFilter{
+						Set: []gwv1.HTTPHeader{
+							{Name: "X-Custom-Header", Value: "custom-value"},
+						},
+						Add: []gwv1.HTTPHeader{
+							{Name: "X-Added-Header", Value: "added-value"},
+						},
+						Remove: []string{"X-Remove-Header"},
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_RequestHeaderModifier{
+						RequestHeaderModifier: &api.HeaderModifier{
+							Set: []*api.Header{
+								{Name: "X-Custom-Header", Value: "custom-value"},
+							},
+							Add: []*api.Header{
+								{Name: "X-Added-Header", Value: "added-value"},
+							},
+							Remove: []string{"X-Remove-Header"},
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
+		{
+			name: "Response header modifier filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterResponseHeaderModifier,
+					ResponseHeaderModifier: &gwv1.HTTPHeaderFilter{
+						Set: []gwv1.HTTPHeader{
+							{Name: "X-Response-Header", Value: "response-value"},
+						},
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_ResponseHeaderModifier{
+						ResponseHeaderModifier: &api.HeaderModifier{
+							Set: []*api.Header{
+								{Name: "X-Response-Header", Value: "response-value"},
+							},
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
+		{
+			name: "Request redirect filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterRequestRedirect,
+					RequestRedirect: &gwv1.HTTPRequestRedirectFilter{
+						Scheme:     ptr.To("https"),
+						Hostname:   ptr.To(gwv1.PreciseHostname("secure.example.com")),
+						StatusCode: ptr.To(301),
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_RequestRedirect{
+						RequestRedirect: &api.RequestRedirect{
+							Scheme: "https",
+							Host:   "secure.example.com",
+							Status: 301,
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
+		{
+			name: "URL rewrite filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterURLRewrite,
+					URLRewrite: &gwv1.HTTPURLRewriteFilter{
+						Path: &gwv1.HTTPPathModifier{
+							Type:               gwv1.PrefixMatchHTTPPathModifier,
+							ReplacePrefixMatch: ptr.To("/new-prefix"),
+						},
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_UrlRewrite{
+						UrlRewrite: &api.UrlRewrite{
+							Path: &api.UrlRewrite_Prefix{
+								Prefix: "/new-prefix",
+							},
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
 	}
-}
 
-// TestXDSCacheState checks that the xds cache has targets and listeners properly set
-func TestXDSCacheState(t *testing.T) {
-	ctx := context.Background()
-	cache := envoycache.NewSnapshotCache(false, envoycache.IDHash{}, nil)
-
-	a2aTarget := &a2a.Target{
-		Name:      "test-a2a-service",
-		Host:      "10.0.0.1",
-		Port:      8080,
-		Path:      "/api",
-		Listeners: []string{"a2a-listener"},
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			ctx := RouteContext{
+				RouteContextInputs: RouteContextInputs{
+					Grants:       ReferenceGrants{},
+					RouteParents: RouteParents{},
+				},
+			}
+
+			result, err := buildADPFilters(ctx, "default", tc.inputFilters)
+
+			if tc.expectedError {
+				assert.NotNil(t, err)
+				return
+			}
+
+			assert.Nil(t, err)
+			require.Equal(t, len(tc.expectedFilters), len(result))
+
+			for i, expectedFilter := range tc.expectedFilters {
+				actualFilter := result[i]
+
+				// Compare filter types
+				switch expectedFilter.Kind.(type) {
+				case *api.RouteFilter_RequestHeaderModifier:
+					assert.IsType(t, &api.RouteFilter_RequestHeaderModifier{}, actualFilter.Kind)
+				case *api.RouteFilter_ResponseHeaderModifier:
+					assert.IsType(t, &api.RouteFilter_ResponseHeaderModifier{}, actualFilter.Kind)
+				case *api.RouteFilter_RequestRedirect:
+					assert.IsType(t, &api.RouteFilter_RequestRedirect{}, actualFilter.Kind)
+				case *api.RouteFilter_UrlRewrite:
+					assert.IsType(t, &api.RouteFilter_UrlRewrite{}, actualFilter.Kind)
+				}
+			}
+		})
 	}
-	mcpTarget := &mcp.Target{
-		Name: "test-mcp-service",
-		Target: &mcp.Target_Sse{
-			Sse: &mcp.Target_SseTarget{
-				Host: "10.0.0.2",
-				Port: 8081,
-				Path: "/events",
+}
+
+func TestGetProtocolAndTLSConfig(t *testing.T) {
+	testCases := []struct {
+		name          string
+		gateway       Gateway
+		expectedProto api.Protocol
+		expectedTLS   *api.TLSConfig
+		expectedOk    bool
+	}{
+		{
+			name: "HTTP protocol",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.HTTPProtocolType,
+				},
+				TLSInfo: nil,
 			},
+			expectedProto: api.Protocol_HTTP,
+			expectedTLS:   nil,
+			expectedOk:    true,
 		},
-		Listeners: []string{"mcp-listener"},
-	}
-	listener := &agentgateway.Listener{
-		Name:     "test-listener",
-		Protocol: agentgateway.Listener_A2A,
-		Listener: &agentgateway.Listener_Sse{
-			Sse: &agentgateway.SseListener{
-				Address: "[::]",
-				Port:    8080,
+		{
+			name: "HTTPS protocol with TLS",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.HTTPSProtocolType,
+				},
+				TLSInfo: &TLSInfo{
+					Cert: []byte("cert-data"),
+					Key:  []byte("key-data"),
+				},
 			},
+			expectedProto: api.Protocol_HTTPS,
+			expectedTLS: &api.TLSConfig{
+				Cert:       []byte("cert-data"),
+				PrivateKey: []byte("key-data"),
+			},
+			expectedOk: true,
+		},
+		{
+			name: "HTTPS protocol without TLS (should fail)",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.HTTPSProtocolType,
+				},
+				TLSInfo: nil,
+			},
+			expectedProto: api.Protocol_HTTPS,
+			expectedTLS:   nil,
+			expectedOk:    false,
+		},
+		{
+			name: "TCP protocol",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.TCPProtocolType,
+				},
+				TLSInfo: nil,
+			},
+			expectedProto: api.Protocol_TCP,
+			expectedTLS:   nil,
+			expectedOk:    true,
+		},
+		{
+			name: "TLS protocol with TLS",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.TLSProtocolType,
+				},
+				TLSInfo: &TLSInfo{
+					Cert: []byte("tls-cert"),
+					Key:  []byte("tls-key"),
+				},
+			},
+			expectedProto: api.Protocol_TLS,
+			expectedTLS: &api.TLSConfig{
+				Cert:       []byte("tls-cert"),
+				PrivateKey: []byte("tls-key"),
+			},
+			expectedOk: true,
 		},
 	}
 
-	snapshot := &agentGwSnapshot{
-		AgentGwA2AServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			a2aTarget,
-		}),
-		AgentGwMcpServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			mcpTarget,
-		}),
-		Listeners: envoycache.NewResources("v1", []envoytypes.Resource{
-			listener,
-		}),
-	}
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			syncer := &AgentGwSyncer{}
 
-	// Set the snapshot in the cache
-	err := cache.SetSnapshot(ctx, "test-node", snapshot)
-	require.NoError(t, err)
-
-	// Test dumping the cache state
-	dumpXDSCacheState(ctx, cache)
-
-	// Verify the resources were properly set
-	retrievedSnapshot, err := cache.GetSnapshot("test-node")
-	require.NoError(t, err)
-
-	// Verify A2A resources
-	a2aResources := retrievedSnapshot.GetResources(TargetTypeA2AUrl)
-	assert.NotNil(t, a2aResources)
-	assert.Contains(t, a2aResources, "test-a2a-service")
-	retrievedA2A := a2aResources["test-a2a-service"].(*a2a.Target)
-	assert.Equal(t, "10.0.0.1", retrievedA2A.Host)
-	assert.Equal(t, uint32(8080), retrievedA2A.Port)
-	assert.Equal(t, "/api", retrievedA2A.Path)
-
-	// Verify MCP resources
-	mcpResources := retrievedSnapshot.GetResources(TargetTypeMcpUrl)
-	assert.NotNil(t, mcpResources)
-	assert.Contains(t, mcpResources, "test-mcp-service")
-	retrievedMCP := mcpResources["test-mcp-service"].(*mcp.Target)
-	assert.Equal(t, "10.0.0.2", retrievedMCP.GetSse().Host)
-	assert.Equal(t, uint32(8081), retrievedMCP.GetSse().Port)
-	assert.Equal(t, "/events", retrievedMCP.GetSse().Path)
-
-	// Verify Listener resources
-	listenerResources := retrievedSnapshot.GetResources(TargetTypeListenerUrl)
-	assert.NotNil(t, listenerResources)
-	assert.Contains(t, listenerResources, "test-listener")
-	retrievedListener := listenerResources["test-listener"].(*agentgateway.Listener)
-	assert.Equal(t, agentgateway.Listener_A2A, retrievedListener.Protocol)
-	assert.Equal(t, uint32(8080), retrievedListener.GetSse().Port)
+			proto, tlsConfig, ok := syncer.getProtocolAndTLSConfig(tc.gateway)
+
+			assert.Equal(t, tc.expectedOk, ok)
+			if tc.expectedOk {
+				assert.Equal(t, tc.expectedProto, proto)
+				if tc.expectedTLS != nil {
+					require.NotNil(t, tlsConfig)
+					assert.Equal(t, tc.expectedTLS.Cert, tlsConfig.Cert)
+					assert.Equal(t, tc.expectedTLS.PrivateKey, tlsConfig.PrivateKey)
+				} else {
+					assert.Nil(t, tlsConfig)
+				}
+			}
+		})
+	}
 }
 
-// TestGetTargetName checks that the getTargetName function correctly formats target names
-func TestGetTargetName(t *testing.T) {
-	tests := []struct {
-		name     string
-		input    string
-		expected string
+func TestADPResourceCreation(t *testing.T) {
+	testCases := []struct {
+		name                 string
+		expectedResource     *api.Resource
+		expectedResourceName string
 	}{
 		{
-			name:     "simple name",
-			input:    "test-service",
-			expected: "test-service",
+			name: "Create Bind resource",
+			expectedResource: &api.Resource{
+				Kind: &api.Resource_Bind{
+					Bind: &api.Bind{
+						Key:  "8080/default/test-gateway",
+						Port: 8080,
+					},
+				},
+			},
+			expectedResourceName: "bind/8080/default/test-gateway",
 		},
 		{
-			name:     "name with slashes",
-			input:    "namespace/service",
-			expected: "namespace-service",
+			name: "Create Listener resource",
+			expectedResource: &api.Resource{
+				Kind: &api.Resource_Listener{
+					Listener: &api.Listener{
+						Key:         "default/test-gateway",
+						Name:        "http",
+						BindKey:     "8080/default/test-gateway",
+						GatewayName: "default/test-gateway",
+						Protocol:    api.Protocol_HTTP,
+						Hostname:    "example.com",
+					},
+				},
+			},
+			expectedResourceName: "listener/default/test-gateway",
 		},
 		{
-			name:     "name with invalid characters",
-			input:    "test@service#123",
-			expected: "test-service-123",
+			name: "Create Route resource",
+			expectedResource: &api.Resource{
+				Kind: &api.Resource_Route{
+					Route: &api.Route{
+						Key:         "default.test-route.0.0",
+						RouteName:   "default/test-route",
+						ListenerKey: "http",
+						Hostnames:   []string{"example.com"},
+						Matches: []*api.RouteMatch{
+							{
+								Path: &api.PathMatch{
+									Kind: &api.PathMatch_PathPrefix{
+										PathPrefix: "/api",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedResourceName: "route/default.test-route.0.0",
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			gateway := types.NamespacedName{
+				Name:      "test-gateway",
+				Namespace: "default",
+			}
+
+			adpResource := ADPResource{
+				Resource: tc.expectedResource,
+				Gateway:  gateway,
+			}
+
+			assert.Equal(t, tc.expectedResourceName, adpResource.ResourceName())
+
+			// Test that two identical resources are equal
+			adpResource2 := ADPResource{
+				Resource: tc.expectedResource,
+				Gateway:  gateway,
+			}
+			assert.True(t, adpResource.Equals(adpResource2))
+		})
+	}
+}
+
+func TestMergeProxyReports(t *testing.T) {
+	tests := []struct {
+		name     string
+		proxies  []agentGwXdsResources
+		expected reports.ReportMap
+	}{
+		{
+			name: "Merge HTTPRoute reports for different parents",
+			proxies: []agentGwXdsResources{
+				{
+					reports: reports.ReportMap{
+						HTTPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					reports: reports.ReportMap{
+						HTTPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expected: reports.ReportMap{
+				HTTPRoutes: map[types.NamespacedName]*reports.RouteReport{
+					{Name: "route1", Namespace: "default"}: {
+						Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+							{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+							{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
 		},
 		{
-			name:     "name with multiple consecutive dashes",
-			input:    "test--service",
-			expected: "test-service",
+			name: "Merge TCPRoute reports for different parents",
+			proxies: []agentGwXdsResources{
+				{
+					reports: reports.ReportMap{
+						TCPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					reports: reports.ReportMap{
+						TCPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expected: reports.ReportMap{
+				TCPRoutes: map[types.NamespacedName]*reports.RouteReport{
+					{Name: "route1", Namespace: "default"}: {
+						Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+							{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+							{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
 		},
 		{
-			name:     "name with leading/trailing dashes",
-			input:    "-test-service-",
-			expected: "test-service",
+			name: "Merge Gateway reports from multiple proxies",
+			proxies: []agentGwXdsResources{
+				{
+					reports: reports.ReportMap{
+						Gateways: map[types.NamespacedName]*reports.GatewayReport{
+							{Name: "gw1", Namespace: "default"}: {},
+						},
+					},
+				},
+				{
+					reports: reports.ReportMap{
+						Gateways: map[types.NamespacedName]*reports.GatewayReport{
+							{Name: "gw2", Namespace: "default"}: {},
+						},
+					},
+				},
+			},
+			expected: reports.ReportMap{
+				Gateways: map[types.NamespacedName]*reports.GatewayReport{
+					{Name: "gw1", Namespace: "default"}: {},
+					{Name: "gw2", Namespace: "default"}: {},
+				},
+			},
 		},
 	}
 
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			result := getTargetName(tt.input)
-			assert.Equal(t, tt.expected, result)
+			a := assert.New(t)
+
+			actual := mergeProxyReports(tt.proxies)
+			if tt.expected.HTTPRoutes != nil {
+				a.Equal(tt.expected.HTTPRoutes, actual.HTTPRoutes)
+			}
+			if tt.expected.TCPRoutes != nil {
+				a.Equal(tt.expected.TCPRoutes, actual.TCPRoutes)
+			}
+			if tt.expected.TLSRoutes != nil {
+				a.Equal(tt.expected.TLSRoutes, actual.TLSRoutes)
+			}
+			if tt.expected.GRPCRoutes != nil {
+				a.Equal(tt.expected.GRPCRoutes, actual.GRPCRoutes)
+			}
+			if tt.expected.Gateways != nil {
+				a.Equal(tt.expected.Gateways, actual.Gateways)
+			}
 		})
 	}
 }
 
-// TestAgentGwSnapshot checks that the snapshot GetVersion and GetResources methods work as expected
-func TestAgentGwSnapshot(t *testing.T) {
-	a2aTarget := &a2a.Target{
-		Name:      "test-a2a-service",
-		Host:      "10.0.0.1",
-		Port:      8080,
-		Path:      "/api",
-		Listeners: []string{"a2a-listener"},
-	}
-	mcpTarget := &mcp.Target{
-		Name: "test-mcp-service",
-		Target: &mcp.Target_Sse{
-			Sse: &mcp.Target_SseTarget{
-				Host: "10.0.0.2",
-				Port: 8081,
-				Path: "/events",
+func TestADPResourceEquals(t *testing.T) {
+	testCases := []struct {
+		name      string
+		resource1 ADPResource
+		resource2 ADPResource
+		expected  bool
+	}{
+		{
+			name: "Equal bind resources",
+			resource1: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
 			},
+			resource2: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			expected: true,
 		},
-		Listeners: []string{"mcp-listener"},
-	}
-	listener := &agentgateway.Listener{
-		Name:     "test-listener",
-		Protocol: agentgateway.Listener_A2A,
-		Listener: &agentgateway.Listener_Sse{
-			Sse: &agentgateway.SseListener{
-				Address: "[::]",
-				Port:    8080,
+		{
+			name: "Different gateway",
+			resource1: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			resource2: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "other", Namespace: "default"},
+			},
+			expected: false,
+		},
+		{
+			name: "Different resource port",
+			resource1: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			resource2: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 9090,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
 			},
+			expected: false,
 		},
 	}
 
-	// manually build the snapshot
-	snapshot := &agentGwSnapshot{
-		AgentGwA2AServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			a2aTarget,
-		}),
-		AgentGwMcpServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			mcpTarget,
-		}),
-		Listeners: envoycache.NewResources("v1", []envoytypes.Resource{
-			listener,
-		}),
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			result := tc.resource1.Equals(tc.resource2)
+			assert.Equal(t, tc.expected, result)
+		})
 	}
-
-	// Construct the version map based on the snapshot
-	err := snapshot.ConstructVersionMap()
-	assert.NoError(t, err)
-
-	assert.Equal(t, "v1", snapshot.GetVersion(TargetTypeA2AUrl))
-	assert.Equal(t, "v1", snapshot.GetVersion(TargetTypeMcpUrl))
-	assert.Equal(t, "v1", snapshot.GetVersion(TargetTypeListenerUrl))
-	assert.Equal(t, "", snapshot.GetVersion("invalid-type"))
-
-	a2aResources := snapshot.GetResources(TargetTypeA2AUrl)
-	assert.NotNil(t, a2aResources)
-	assert.Len(t, a2aResources, 1)
-	a2aVersionMap := snapshot.GetVersionMap(TargetTypeA2AUrl)
-	assert.NotNil(t, a2aVersionMap)
-
-	mcpResources := snapshot.GetResources(TargetTypeMcpUrl)
-	assert.NotNil(t, mcpResources)
-	assert.Len(t, mcpResources, 1)
-	mcpVersionMap := snapshot.GetVersionMap(TargetTypeMcpUrl)
-	assert.NotNil(t, mcpVersionMap)
-
-	listenerResources := snapshot.GetResources(TargetTypeListenerUrl)
-	assert.NotNil(t, listenerResources)
-	assert.Len(t, listenerResources, 1)
-	listenerVersionMap := snapshot.GetVersionMap(TargetTypeListenerUrl)
-	assert.NotNil(t, listenerVersionMap)
-
-	err = snapshot.ConstructVersionMap()
-	assert.NoError(t, err)
-	assert.NotNil(t, snapshot.VersionMap)
 }
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
new file mode 100644
index 000000000..654a4c142
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -0,0 +1,857 @@
+package agentgatewaysyncer
+
+import (
+	"fmt"
+	"net/netip"
+	"strings"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
+	"istio.io/api/annotation"
+	"istio.io/api/label"
+	apiv1 "istio.io/api/networking/v1"
+	networkingv1alpha3 "istio.io/api/networking/v1alpha3"
+	networkingv1beta1 "istio.io/api/networking/v1beta1"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube"
+	labelutil "istio.io/istio/pilot/pkg/serviceregistry/util/label"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/krt"
+	kubelabels "istio.io/istio/pkg/kube/labels"
+	"istio.io/istio/pkg/log"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/sets"
+	corev1 "k8s.io/api/core/v1"
+	discovery "k8s.io/api/discovery/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+)
+
+type NamespaceHostname struct {
+	Namespace string
+	Hostname  string
+}
+
+func (n NamespaceHostname) String() string {
+	return n.Namespace + "/" + n.Hostname
+}
+
+// index maintains an index of ambient WorkloadInfo objects by various keys.
+// These are intentionally pre-computed based on events such that lookups are efficient.
+type index struct {
+	namespaces krt.Collection[krtcollections.NamespaceMetadata]
+
+	SystemNamespace string
+	DomainSuffix    string
+	ClusterID       string
+}
+
+// WorkloadsCollection builds out the core Workload object type used in ambient mode.
+// A Workload represents a single addressable unit of compute -- typically a Pod or a VM.
+// Workloads can come from a variety of sources; these are joined together to build one complete `Collection[WorkloadInfo]`.
+func (a *index) WorkloadsCollection(
+	pods krt.Collection[krtcollections.WrappedPod],
+	workloadServices krt.Collection[ServiceInfo],
+	serviceEntries krt.Collection[*networkingclient.ServiceEntry],
+	endpointSlices krt.Collection[*discovery.EndpointSlice],
+	namespaces krt.Collection[*corev1.Namespace],
+	krtopts krtutil.KrtOptions,
+) krt.Collection[WorkloadInfo] {
+	WorkloadServicesNamespaceIndex := krt.NewNamespaceIndex(workloadServices)
+	EndpointSlicesByIPIndex := endpointSliceAddressIndex(endpointSlices)
+	// Workloads coming from pods. There should be one workload for each (running) Pod.
+	PodWorkloads := krt.NewCollection(
+		pods,
+		a.podWorkloadBuilder(
+			workloadServices,
+			WorkloadServicesNamespaceIndex,
+			endpointSlices,
+			EndpointSlicesByIPIndex,
+		),
+		krtopts.ToOptions("PodWorkloads")...,
+	)
+	// TODO(npolshak): Add support for WE?
+
+	// Workloads coming from serviceEntries. These are inlined workloadEntries (under `spec.endpoints`); these serviceEntries will
+	// also be generating `api.Service` definitions in the `ServicesCollection` logic.
+	//ServiceEntryWorkloads := krt.NewManyCollection(
+	//	serviceEntries,
+	//	a.serviceEntryWorkloadBuilder(),
+	//	krtopts.ToOptions("ServiceEntryWorkloads")...,
+	//)
+
+	// Workloads coming from endpointSlices. These are for *manually added* endpoints. Typically, Kubernetes will insert each pod
+	// into the EndpointSlice. This is because Kubernetes has 3 APIs in its model: Service, Pod, and EndpointSlice.
+	// In our API, we only have two: Service and Workload.
+	// Pod provides much more information than EndpointSlice, so typically we just consume that directly; see method for more details
+	// on when we will build from an EndpointSlice.
+	EndpointSliceWorkloads := krt.NewManyCollection(
+		endpointSlices,
+		a.endpointSlicesBuilder(workloadServices),
+		krtopts.ToOptions("EndpointSliceWorkloads")...)
+
+	Workloads := krt.JoinCollection(
+		[]krt.Collection[WorkloadInfo]{
+			PodWorkloads,
+			//ServiceEntryWorkloads,
+			EndpointSliceWorkloads,
+		},
+		// Each collection has its own unique UID as the key. This guarantees an object can exist in only a single collection
+		// This enables us to use the JoinUnchecked optimization.
+		append(krtopts.ToOptions("Workloads"), krt.WithJoinUnchecked())...)
+	return Workloads
+}
+
+// name format: <cluster>/<group>/<kind>/<namespace>/<name></section-name>
+func (a *index) generatePodUID(p krtcollections.WrappedPod) string {
+	return a.ClusterID + "//" + "Pod/" + p.Namespace + "/" + p.Name
+}
+
+func (a *index) podWorkloadBuilder(
+	workloadServices krt.Collection[ServiceInfo],
+	workloadServicesNamespaceIndex krt.Index[string, ServiceInfo],
+	endpointSlices krt.Collection[*discovery.EndpointSlice],
+	endpointSlicesAddressIndex krt.Index[TargetRef, *discovery.EndpointSlice],
+) krt.TransformationSingle[krtcollections.WrappedPod, WorkloadInfo] {
+	return func(ctx krt.HandlerContext, p krtcollections.WrappedPod) *WorkloadInfo {
+		// Pod Is Pending but have a pod IP should be a valid workload, we should build it ,
+		// Such as the pod have initContainer which is initialing.
+		// See https://github.com/istio/istio/issues/48854
+		if p.Terminal {
+			return nil
+		}
+		k8sPodIPs := p.PodIPs
+		if len(k8sPodIPs) == 0 {
+			return nil
+		}
+		podIPs, err := slices.MapErr(k8sPodIPs, func(e corev1.PodIP) ([]byte, error) {
+			n, err := netip.ParseAddr(e.IP)
+			if err != nil {
+				return nil, err
+			}
+			return n.AsSlice(), nil
+		})
+		if err != nil {
+			// Is this possible? Probably not in typical case, but anyone could put garbage there.
+			return nil
+		}
+
+		fo := []krt.FetchOption{krt.FilterIndex(workloadServicesNamespaceIndex, p.Namespace), krt.FilterSelectsNonEmpty(p.Labels)}
+		if !features.EnableServiceEntrySelectPods {
+			fo = append(fo, krt.FilterGeneric(func(a any) bool {
+				return a.(ServiceInfo).Source.Kind == kind.Service.String()
+			}))
+		}
+		services := krt.Fetch(ctx, workloadServices, fo...)
+		services = append(services, a.matchingServicesWithoutSelectors(ctx, p, services, workloadServices, endpointSlices, endpointSlicesAddressIndex)...)
+		// Logic from https://github.com/kubernetes/kubernetes/blob/7c873327b679a70337288da62b96dd610858181d/staging/src/k8s.io/endpointslice/utils.go#L37
+		// Kubernetes has Ready, Serving, and Terminating. We only have a boolean, which is sufficient for our cases
+		status := api.WorkloadStatus_HEALTHY
+		if !p.Ready || p.DeletionTimestamp != nil {
+			status = api.WorkloadStatus_UNHEALTHY
+		}
+
+		w := &api.Workload{
+			Uid:       a.generatePodUID(p),
+			Name:      p.Name,
+			Namespace: p.Namespace,
+			//Network:               network,
+			//NetworkGateway:        a.getNetworkGatewayAddress(ctx, network),
+			ClusterId:      a.ClusterID,
+			Addresses:      podIPs,
+			ServiceAccount: p.ServiceAccountName,
+			Node:           p.NodeName,
+			Services:       constructServices(p, services),
+			Status:         status,
+			//Locality:              getPodLocality(ctx, nodes, p),
+		}
+
+		if p.HostNetwork {
+			w.NetworkMode = api.NetworkMode_HOST_NETWORK
+		}
+
+		w.WorkloadName = p.WorkloadNameForPod
+		w.WorkloadType = api.WorkloadType_POD // backwards compatibility
+		w.CanonicalName, w.CanonicalRevision = kubelabels.CanonicalService(p.Labels, w.WorkloadName)
+
+		setTunnelProtocol(p.Labels, p.Annotations, w)
+		return precomputeWorkloadPtr(&WorkloadInfo{
+			Workload:     w,
+			Labels:       p.Labels,
+			Source:       kind.Pod,
+			CreationTime: p.CreationTimestamp.Time,
+		})
+	}
+}
+
+// matchingServicesWithoutSelectors finds all Services that match a given pod that do not use selectors.
+// See https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors for more info.
+// For selector service, we query by the selector elsewhere, so this only handles the services that are NOT already found
+// by a selector.
+// For EndpointSlices that happen to point to the same IP as the pod, but are not directly bound to the pod (via TargetRef),
+// we ignore them here. These will produce a Workload directly from the EndpointSlice, but with limited information;
+// we do not implicitly merge a Pod with an EndpointSlice just based on IP.
+func (a *index) matchingServicesWithoutSelectors(
+	ctx krt.HandlerContext,
+	p krtcollections.WrappedPod,
+	alreadyMatchingServices []ServiceInfo,
+	workloadServices krt.Collection[ServiceInfo],
+	endpointSlices krt.Collection[*discovery.EndpointSlice],
+	endpointSlicesAddressIndex krt.Index[TargetRef, *discovery.EndpointSlice],
+) []ServiceInfo {
+	var res []ServiceInfo
+	// Build out our set of already-matched services to avoid double-selecting a service
+	seen := sets.NewWithLength[string](len(alreadyMatchingServices))
+	for _, s := range alreadyMatchingServices {
+		seen.Insert(s.Service.Hostname)
+	}
+	tr := TargetRef{
+		Kind:      gvk.Pod.Kind,
+		Namespace: p.Namespace,
+		Name:      p.Name,
+		UID:       p.UID,
+	}
+	// For each IP, find any endpointSlices referencing it.
+	matchedSlices := krt.Fetch(ctx, endpointSlices, krt.FilterIndex(endpointSlicesAddressIndex, tr))
+	for _, es := range matchedSlices {
+		serviceName, f := es.Labels[discovery.LabelServiceName]
+		if !f {
+			// Not for a service; we don't care about it.
+			continue
+		}
+		hostname := string(kube.ServiceHostname(serviceName, es.Namespace, a.DomainSuffix))
+		if seen.Contains(hostname) {
+			// We already know about this service
+			continue
+		}
+		// This pod is included in the EndpointSlice. We need to fetch the Service object for it, by key.
+		serviceKey := es.Namespace + "/" + hostname
+		svcs := krt.Fetch(ctx, workloadServices, krt.FilterKey(serviceKey), krt.FilterGeneric(func(a any) bool {
+			// Only find Service, not Service Entry
+			return a.(ServiceInfo).Source.Kind == kind.Service.String()
+		}))
+		if len(svcs) == 0 {
+			// no service found
+			continue
+		}
+		// There SHOULD only be one. This is only for `Service` which has unique hostnames.
+		svc := svcs[0]
+		res = append(res, svc)
+	}
+	return res
+}
+
+func (a *index) serviceEntriesInfo(ctx krt.HandlerContext, s *networkingclient.ServiceEntry) []ServiceInfo {
+	sel := NewSelector(s.Spec.GetWorkloadSelector().GetLabels())
+	portNames := map[int32]ServicePortName{}
+	for _, p := range s.Spec.Ports {
+		portNames[int32(p.Number)] = ServicePortName{
+			PortName: p.Name,
+		}
+	}
+	return slices.Map(a.constructServiceEntries(ctx, s), func(e *api.Service) ServiceInfo {
+		return precomputeService(ServiceInfo{
+			Service:       e,
+			PortNames:     portNames,
+			LabelSelector: sel,
+			Source:        MakeSource(s),
+		})
+	})
+}
+
+// MakeSource is a helper to turn an Object into a model.TypedObject.
+func MakeSource(o controllers.Object) TypedObject {
+	kind := o.GetObjectKind().GroupVersionKind().Kind
+	return TypedObject{
+		NamespacedName: config.NamespacedName(o),
+		Kind:           kind,
+	}
+}
+
+func precomputeServicePtr(w *ServiceInfo) *ServiceInfo {
+	return ptr.Of(precomputeService(*w))
+}
+
+func precomputeService(w ServiceInfo) ServiceInfo {
+	addr := serviceToAddress(w.Service)
+	w.MarshaledAddress = protoconv.MessageToAny(addr)
+	w.AsAddress = AddressInfo{
+		Address:   addr,
+		Marshaled: w.MarshaledAddress,
+	}
+	return w
+}
+
+func serviceToAddress(s *api.Service) *api.Address {
+	return &api.Address{
+		Type: &api.Address_Service{
+			Service: s,
+		},
+	}
+}
+
+func toAppProtocolFromIstio(p *networkingv1alpha3.ServicePort) api.AppProtocol {
+	return toAppProtocolFromProtocol(p.Protocol)
+}
+
+func toAppProtocolFromProtocol(p string) api.AppProtocol {
+	switch p {
+	case "HTTP":
+		return api.AppProtocol_HTTP11
+	case "HTTP2":
+		return api.AppProtocol_HTTP2
+	case "GRPC":
+		return api.AppProtocol_GRPC
+	}
+	return api.AppProtocol_UNKNOWN
+}
+
+func GetHostAddressesFromServiceEntry(se *networkingclient.ServiceEntry) map[string][]netip.Addr {
+	if se == nil {
+		return map[string][]netip.Addr{}
+	}
+	return getHostAddressesFromServiceEntryStatus(&se.Status)
+}
+
+func getHostAddressesFromServiceEntryStatus(status *apiv1.ServiceEntryStatus) map[string][]netip.Addr {
+	results := map[string][]netip.Addr{}
+	for _, addr := range status.GetAddresses() {
+		parsed, err := netip.ParseAddr(addr.GetValue())
+		if err != nil {
+			// strange, we should have written these so it probaby should parse but for now unreadable is unusable and we move on
+			continue
+		}
+		host := addr.GetHost()
+		results[host] = append(results[host], parsed)
+	}
+	return results
+}
+
+func (a *index) constructServiceEntries(ctx krt.HandlerContext, svc *networkingclient.ServiceEntry) []*api.Service {
+	var autoassignedHostAddresses map[string][]netip.Addr
+	addresses, err := slices.MapErr(svc.Spec.Addresses, func(e string) (*api.NetworkAddress, error) {
+		return a.toNetworkAddressFromCidr(ctx, e)
+	})
+	if err != nil {
+		// TODO: perhaps we should support CIDR in the future?
+		return nil
+	}
+	// if this se has autoallocation we can se autoallocated IP, otherwise it will remain an empty slice
+	if ShouldV2AutoAllocateIP(svc) {
+		autoassignedHostAddresses = GetHostAddressesFromServiceEntry(svc)
+	}
+	ports := make([]*api.Port, 0, len(svc.Spec.Ports))
+	for _, p := range svc.Spec.Ports {
+		target := p.TargetPort
+		if target == 0 {
+			target = p.Number
+		}
+		ports = append(ports, &api.Port{
+			ServicePort: p.Number,
+			TargetPort:  target,
+			AppProtocol: toAppProtocolFromIstio(p),
+		})
+	}
+
+	// TODO this is only checking one controller - we may be missing service vips for instances in another cluster
+	res := make([]*api.Service, 0, len(svc.Spec.Hosts))
+	for _, h := range svc.Spec.Hosts {
+		// if we have no user-provided hostsAddresses and h is not wildcarded and we have hostsAddresses supported resolution
+		// we can try to use autoassigned hostsAddresses
+		hostsAddresses := addresses
+		if len(hostsAddresses) == 0 && !host.Name(h).IsWildCarded() && svc.Spec.Resolution != networkingv1beta1.ServiceEntry_NONE {
+			if hostsAddrs, ok := autoassignedHostAddresses[h]; ok {
+				hostsAddresses = slices.Map(hostsAddrs, func(e netip.Addr) *api.NetworkAddress {
+					return a.toNetworkAddressFromIP(ctx, e)
+				})
+			}
+		}
+		res = append(res, &api.Service{
+			Name:            svc.Name,
+			Namespace:       svc.Namespace,
+			Hostname:        h,
+			Addresses:       hostsAddresses,
+			Ports:           ports,
+			SubjectAltNames: svc.Spec.SubjectAltNames,
+			//LoadBalancing:   lb, // TODO: add lb support
+		})
+	}
+	return res
+}
+
+func ShouldV2AutoAllocateIP(se *networkingclient.ServiceEntry) bool {
+	if se == nil {
+		return false
+	}
+	return shouldV2AutoAllocateIPFromPieces(se.ObjectMeta, &se.Spec)
+}
+
+func shouldV2AutoAllocateIPFromPieces(meta metav1.ObjectMeta, spec *apiv1.ServiceEntry) bool {
+	// if the feature is off we should not assign/use addresses
+	if !features.EnableIPAutoallocate {
+		return false
+	}
+
+	// if resolution is none we cannot honor the assigned IP in the dataplane and should not assign
+	if spec.Resolution == apiv1.ServiceEntry_NONE {
+		return false
+	}
+
+	// check for opt-out by user
+	enabledValue, enabledFound := meta.Labels[label.NetworkingEnableAutoallocateIp.Name]
+	if enabledFound && strings.EqualFold(enabledValue, "false") {
+		return false
+	}
+
+	// if the user assigned their own we don't alloate or use autoassigned addresses
+	if len(spec.Addresses) > 0 {
+		return false
+	}
+
+	return true
+}
+
+// name format: <cluster>/<group>/<kind>/<namespace>/<name></section-name>
+// section name should be the WE address, which needs to be stable across SE updates (it is assumed WE addresses are unique)
+func (a *index) generateServiceEntryUID(svcEntryNamespace, svcEntryName, addr string) string {
+	return a.ClusterID + "/networking.istio.io/ServiceEntry/" + svcEntryNamespace + "/" + svcEntryName + "/" + addr
+}
+
+func (a *index) serviceEntryWorkloadBuilder() krt.TransformationMulti[*networkingclient.ServiceEntry, WorkloadInfo] {
+	return func(ctx krt.HandlerContext, se *networkingclient.ServiceEntry) []WorkloadInfo {
+		eps := se.Spec.Endpoints
+		// If we have a DNS service, endpoints are not required
+		implicitEndpoints := len(eps) == 0 &&
+			(se.Spec.Resolution == networkingv1alpha3.ServiceEntry_DNS || se.Spec.Resolution == networkingv1alpha3.ServiceEntry_DNS_ROUND_ROBIN) &&
+			se.Spec.WorkloadSelector == nil
+		if len(eps) == 0 && !implicitEndpoints {
+			return nil
+		}
+		// only going to use a subset of the info in `allServices` (since we are building workloads here, not services).
+		allServices := a.serviceEntriesInfo(ctx, se)
+		if implicitEndpoints {
+			eps = slices.Map(allServices, func(si ServiceInfo) *networkingv1alpha3.WorkloadEntry {
+				return &networkingv1alpha3.WorkloadEntry{Address: si.Service.Hostname}
+			})
+		}
+		if len(eps) == 0 {
+			return nil
+		}
+		res := make([]WorkloadInfo, 0, len(eps))
+
+		for i, wle := range eps {
+			services := allServices
+			if implicitEndpoints {
+				// For implicit endpoints, we generate each one from the hostname it was from.
+				// Otherwise, use all.
+				// [i] is safe here since we these are constructed to mirror each other
+				services = []ServiceInfo{allServices[i]}
+			}
+
+			w := &api.Workload{
+				Uid:       a.generateServiceEntryUID(se.Namespace, se.Name, wle.Address),
+				Name:      se.Name,
+				Namespace: se.Namespace,
+				//Network:               network,
+				ClusterId:      a.ClusterID,
+				ServiceAccount: wle.ServiceAccount,
+				Services:       constructServicesFromWorkloadEntry(wle, services),
+				Status:         api.WorkloadStatus_HEALTHY,
+				Locality:       getWorkloadEntryLocality(wle),
+			}
+			if wle.Weight > 0 {
+				w.Capacity = wrappers.UInt32(wle.Weight)
+			}
+
+			if addr, err := netip.ParseAddr(wle.Address); err == nil {
+				w.Addresses = [][]byte{addr.AsSlice()}
+			} else {
+				w.Hostname = wle.Address
+			}
+
+			w.WorkloadName, w.WorkloadType = se.Name, api.WorkloadType_POD // XXX(shashankram): HACK to impersonate pod
+			w.CanonicalName, w.CanonicalRevision = kubelabels.CanonicalService(se.Labels, w.WorkloadName)
+
+			setTunnelProtocol(se.Labels, se.Annotations, w)
+			res = append(res, precomputeWorkload(WorkloadInfo{
+				Workload:     w,
+				Labels:       se.Labels,
+				Source:       kind.WorkloadEntry,
+				CreationTime: se.CreationTimestamp.Time,
+			}))
+		}
+		return res
+	}
+}
+
+func (a *index) endpointSlicesBuilder(
+	workloadServices krt.Collection[ServiceInfo],
+) krt.TransformationMulti[*discovery.EndpointSlice, WorkloadInfo] {
+	return func(ctx krt.HandlerContext, es *discovery.EndpointSlice) []WorkloadInfo {
+		// EndpointSlices carry port information and a list of IPs.
+		// We only care about EndpointSlices that are for a Service.
+		// Otherwise, it is just an arbitrary bag of IP addresses for some user-specific purpose, which doesn't have a clear
+		// usage for us (if it had some additional info like service account, etc, then perhaps it would be useful).
+		serviceName, f := es.Labels[discovery.LabelServiceName]
+		if !f {
+			return nil
+		}
+		if es.AddressType == discovery.AddressTypeFQDN {
+			// Currently we do not support FQDN. In theory, we could, but its' support in Kubernetes entirely is questionable and
+			// may be removed in the near future.
+			return nil
+		}
+		var res []WorkloadInfo
+		seen := sets.New[string]()
+
+		// The slice must be for a single service, based on the label above.
+		serviceKey := es.Namespace + "/" + string(kube.ServiceHostname(serviceName, es.Namespace, a.DomainSuffix))
+		svcs := krt.Fetch(ctx, workloadServices, krt.FilterKey(serviceKey), krt.FilterGeneric(func(a any) bool {
+			// Only find Service, not Service Entry
+			return a.(ServiceInfo).Source.Kind == kind.Service.String()
+		}))
+		if len(svcs) == 0 {
+			// no service found
+			return nil
+		}
+		// There SHOULD only be one. This is only Service which has unique hostnames.
+		svc := svcs[0]
+
+		// Translate slice ports to our port.
+		pl := &api.PortList{Ports: make([]*api.Port, 0, len(es.Ports))}
+		for _, p := range es.Ports {
+			// We must have name and port (Kubernetes should always set these)
+			if p.Name == nil {
+				continue
+			}
+			if p.Port == nil {
+				continue
+			}
+			// We only support TCP for now
+			if p.Protocol == nil || *p.Protocol != corev1.ProtocolTCP {
+				continue
+			}
+			// Endpoint slice port has name (service port name, not containerPort) and port (targetPort)
+			// We need to join with the Service port list to translate the port name to
+			for _, svcPort := range svc.Service.Ports {
+				portName := svc.PortNames[int32(svcPort.ServicePort)]
+				if portName.PortName != *p.Name {
+					continue
+				}
+				pl.Ports = append(pl.Ports, &api.Port{
+					ServicePort: svcPort.ServicePort,
+					TargetPort:  uint32(*p.Port),
+				})
+				break
+			}
+		}
+		services := map[string]*api.PortList{
+			serviceKey: pl,
+		}
+
+		// Each endpoint in the slice is going to create a Workload
+		for _, ep := range es.Endpoints {
+			if ep.TargetRef != nil && ep.TargetRef.Kind == gvk.Pod.Kind {
+				// Normal case; this is a slice for a pod. We already handle pods, with much more information, so we can skip them
+				continue
+			}
+			// This should not be possible
+			if len(ep.Addresses) == 0 {
+				continue
+			}
+			// We currently only support 1 address. Kubernetes will never set more (IPv4 and IPv6 will be two slices), so its mostly undefined.
+			key := ep.Addresses[0]
+			if seen.InsertContains(key) {
+				// Shouldn't happen. Make sure our UID is actually unique
+				log.Warnf("IP address %v seen twice in %v/%v", key, es.Namespace, es.Name)
+				continue
+			}
+			health := api.WorkloadStatus_UNHEALTHY
+			if ep.Conditions.Ready == nil || *ep.Conditions.Ready {
+				health = api.WorkloadStatus_HEALTHY
+			}
+			// Translate our addresses.
+			// Note: users may put arbitrary addresses here. It is recommended by Kubernetes to not
+			// give untrusted users EndpointSlice write access.
+			addresses, err := slices.MapErr(ep.Addresses, func(e string) ([]byte, error) {
+				n, err := netip.ParseAddr(e)
+				if err != nil {
+					log.Warnf("invalid address in endpointslice %v: %v", e, err)
+					return nil, err
+				}
+				return n.AsSlice(), nil
+			})
+			if err != nil {
+				// If any invalid, skip
+				continue
+			}
+			w := &api.Workload{
+				Uid:       a.ClusterID + "/discovery.k8s.io/EndpointSlice/" + es.Namespace + "/" + es.Name + "/" + key,
+				Name:      es.Name,
+				Namespace: es.Namespace,
+				Addresses: addresses,
+				Hostname:  "",
+				//Network:     a.Network(ctx).String(),
+				Services:  services,
+				Status:    health,
+				ClusterId: string(a.ClusterID),
+				// For opaque endpoints, we do not know anything about them. They could be overlapping with other IPs, so treat it
+				// as a shared address rather than a unique one.
+				NetworkMode:           api.NetworkMode_HOST_NETWORK,
+				AuthorizationPolicies: nil, // Not support. This can only be used for outbound, so not relevant
+				ServiceAccount:        "",  // Unknown.
+				Locality:              nil, // Not supported. We could maybe, there is a "zone", but it doesn't seem to be well supported
+			}
+			res = append(res, precomputeWorkload(WorkloadInfo{
+				Workload:     w,
+				Labels:       nil,
+				Source:       kind.EndpointSlice,
+				CreationTime: es.CreationTimestamp.Time,
+			}))
+		}
+
+		return res
+	}
+}
+
+func setTunnelProtocol(labels, annotations map[string]string, w *api.Workload) {
+	if annotations[annotation.AmbientRedirection.Name] == constants.AmbientRedirectionEnabled {
+		// Configured for override
+		w.TunnelProtocol = api.TunnelProtocol_HBONE
+	}
+	// Otherwise supports tunnel directly
+	if SupportsTunnel(labels, TunnelHTTP) {
+		w.TunnelProtocol = api.TunnelProtocol_HBONE
+		w.NativeTunnel = true
+	}
+	if w.TunnelProtocol == api.TunnelProtocol_NONE &&
+		GetTLSModeFromEndpointLabels(labels) == MutualTLSModeLabel {
+		w.TunnelProtocol = api.TunnelProtocol_LEGACY_ISTIO_MTLS
+	}
+}
+
+func constructServicesFromWorkloadEntry(p *networkingv1alpha3.WorkloadEntry, services []ServiceInfo) map[string]*api.PortList {
+	res := map[string]*api.PortList{}
+	for _, svc := range services {
+		n := namespacedHostname(svc.Service.Namespace, svc.Service.Hostname)
+		pl := &api.PortList{}
+		res[n] = pl
+		for _, port := range svc.Service.Ports {
+			targetPort := port.TargetPort
+			// Named targetPort has different semantics from Service vs ServiceEntry
+			if svc.Source.Kind == kind.Service.String() {
+				// Service has explicit named targetPorts.
+				if named, f := svc.PortNames[int32(port.ServicePort)]; f && named.TargetPortName != "" {
+					// This port is a named target port, look it up
+					tv, ok := p.Ports[named.TargetPortName]
+					if !ok {
+						// We needed an explicit port, but didn't find one - skip this port
+						continue
+					}
+					targetPort = tv
+				}
+			} else {
+				// ServiceEntry has no explicit named targetPorts; targetPort only allows a number
+				// Instead, there is name matching between the port names
+				if named, f := svc.PortNames[int32(port.ServicePort)]; f {
+					// get port name or target port
+					tv, ok := p.Ports[named.PortName]
+					if ok {
+						// if we match one, override it. Otherwise, use the service port
+						targetPort = tv
+					} else if targetPort == 0 {
+						targetPort = port.ServicePort
+					}
+				}
+			}
+			pl.Ports = append(pl.Ports, &api.Port{
+				ServicePort: port.ServicePort,
+				TargetPort:  targetPort,
+			})
+		}
+	}
+	return res
+}
+
+func constructServices(p krtcollections.WrappedPod, services []ServiceInfo) map[string]*api.PortList {
+	res := map[string]*api.PortList{}
+	for _, svc := range services {
+		n := namespacedHostname(svc.Service.Namespace, svc.Service.Hostname)
+		pl := &api.PortList{
+			Ports: make([]*api.Port, 0, len(svc.Service.Ports)),
+		}
+		res[n] = pl
+		for _, port := range svc.Service.Ports {
+			targetPort := port.TargetPort
+			// The svc.Ports represents the api.Service, which drops the port name info and just has numeric target Port.
+			// TargetPort can be 0 which indicates its a named port. Check if its a named port and replace with the real targetPort if so.
+			if named, f := svc.PortNames[int32(port.ServicePort)]; f && named.TargetPortName != "" {
+				// Pods only match on TargetPort names
+				tp, ok := FindPortName(p, named.TargetPortName)
+				if !ok {
+					// Port not present for this workload. Exclude the port entirely
+					continue
+				}
+				targetPort = uint32(tp)
+			}
+
+			pl.Ports = append(pl.Ports, &api.Port{
+				ServicePort: port.ServicePort,
+				TargetPort:  targetPort,
+			})
+		}
+	}
+	return res
+}
+
+func getWorkloadEntryLocality(p *networkingv1alpha3.WorkloadEntry) *api.Locality {
+	region, zone, subzone := labelutil.SplitLocalityLabel(p.GetLocality())
+	if region == "" && zone == "" && subzone == "" {
+		return nil
+	}
+	return &api.Locality{
+		Region:  region,
+		Zone:    zone,
+		Subzone: subzone,
+	}
+}
+
+// TargetRef is a subset of the Kubernetes ObjectReference which has some fields we don't care about
+type TargetRef struct {
+	Kind      string
+	Namespace string
+	Name      string
+	UID       types.UID
+}
+
+func (t TargetRef) String() string {
+	return t.Kind + "/" + t.Namespace + "/" + t.Name + "/" + string(t.UID)
+}
+
+// endpointSliceAddressIndex builds an index from IP Address
+func endpointSliceAddressIndex(EndpointSlices krt.Collection[*discovery.EndpointSlice]) krt.Index[TargetRef, *discovery.EndpointSlice] {
+	return krt.NewIndex(EndpointSlices, func(es *discovery.EndpointSlice) []TargetRef {
+		if es.AddressType == discovery.AddressTypeFQDN {
+			// Currently we do not support FQDN.
+			return nil
+		}
+		_, f := es.Labels[discovery.LabelServiceName]
+		if !f {
+			// Not for a service; we don't care about it.
+			return nil
+		}
+		res := make([]TargetRef, 0, len(es.Endpoints))
+		for _, ep := range es.Endpoints {
+			if ep.TargetRef == nil || ep.TargetRef.Kind != gvk.Pod.Kind {
+				// We only want pods here
+				continue
+			}
+			tr := TargetRef{
+				Kind:      ep.TargetRef.Kind,
+				Namespace: ep.TargetRef.Namespace,
+				Name:      ep.TargetRef.Name,
+				UID:       ep.TargetRef.UID,
+			}
+			res = append(res, tr)
+		}
+		return res
+	})
+}
+
+func precomputeWorkloadPtr(w *WorkloadInfo) *WorkloadInfo {
+	return ptr.Of(precomputeWorkload(*w))
+}
+
+func precomputeWorkload(w WorkloadInfo) WorkloadInfo {
+	addr := workloadToAddress(w.Workload)
+	w.MarshaledAddress = protoconv.MessageToAny(addr)
+	w.AsAddress = AddressInfo{
+		Address:   addr,
+		Marshaled: w.MarshaledAddress,
+	}
+	return w
+}
+
+func workloadToAddress(w *api.Workload) *api.Address {
+	return &api.Address{
+		Type: &api.Address_Workload{
+			Workload: w,
+		},
+	}
+}
+
+func mustByteIPToString(b []byte) string {
+	ip, _ := netip.AddrFromSlice(b) // Address only comes from objects we create, so it must be valid
+	return ip.String()
+}
+
+func (a *index) toNetworkAddress(ctx krt.HandlerContext, vip string) (*api.NetworkAddress, error) {
+	ip, err := netip.ParseAddr(vip)
+	if err != nil {
+		return nil, fmt.Errorf("parse %v: %v", vip, err)
+	}
+	return &api.NetworkAddress{
+		// TODO: calculate network
+		Address: ip.AsSlice(),
+	}, nil
+}
+
+func (a *index) toNetworkAddressFromIP(ctx krt.HandlerContext, ip netip.Addr) *api.NetworkAddress {
+	return &api.NetworkAddress{
+		// TODO: calculate network
+		Address: ip.AsSlice(),
+	}
+}
+
+func (a *index) toNetworkAddressFromCidr(ctx krt.HandlerContext, vip string) (*api.NetworkAddress, error) {
+	ip, err := parseCidrOrIP(vip)
+	if err != nil {
+		return nil, err
+	}
+	return &api.NetworkAddress{
+		// TODO: calculate network
+		Address: ip.AsSlice(),
+	}, nil
+}
+
+// parseCidrOrIP parses an IP or a CIDR of a exactly 1 IP (e.g. /32).
+// This is to support ServiceEntry which supports CIDRs, but we don't currently support more than 1 IP
+func parseCidrOrIP(ip string) (netip.Addr, error) {
+	if strings.Contains(ip, "/") {
+		prefix, err := netip.ParsePrefix(ip)
+		if err != nil {
+			return netip.Addr{}, err
+		}
+		if !prefix.IsSingleIP() {
+			return netip.Addr{}, fmt.Errorf("only single IP CIDR is allowed")
+		}
+		return prefix.Addr(), nil
+	}
+	return netip.ParseAddr(ip)
+}
+
+func FindPortName(pod krtcollections.WrappedPod, name string) (int32, bool) {
+	for _, ports := range pod.ContainerPorts {
+		for _, port := range ports {
+			if port.Name == name && port.Protocol == corev1.ProtocolTCP {
+				return port.ContainerPort, true
+			}
+		}
+	}
+	return 0, false
+}
+
+func namespacedHostname(namespace, hostname string) string {
+	return namespace + "/" + hostname
+}
diff --git a/internal/kgateway/controller/start.go b/internal/kgateway/controller/start.go
index 82ccf371c..6841b69c9 100644
--- a/internal/kgateway/controller/start.go
+++ b/internal/kgateway/controller/start.go
@@ -80,6 +80,8 @@ type StartConfig struct {
 	Client      istiokube.Client
 
 	AugmentedPods krt.Collection[krtcollections.LocalityPod]
+	// Special collection built using envoy callbacks
+	// Need this for DR (failover for eds snapshot)
 	UniqueClients krt.Collection[ir.UniqlyConnectedClient]
 
 	KrtOptions krtutil.KrtOptions
@@ -210,14 +212,17 @@ func NewControllerBuilder(ctx context.Context, cfg StartConfig) (*ControllerBuil
 	proxySyncer.Init(ctx, cfg.KrtOptions)
 
 	if cfg.SetupOpts.GlobalSettings.EnableAgentGateway {
+		domainSuffix := "cluster.local" // TODO: don't hard code
 		agentGatewaySyncer := agentgatewaysyncer.NewAgentGwSyncer(
-			ctx,
 			cfg.ControllerName,
 			cfg.AgentGatewayClassName,
-			mgr,
 			cfg.Client,
+			mgr,
 			commoncol,
 			cfg.SetupOpts.Cache,
+			domainSuffix,
+			namespaces.GetPodNamespace(),
+			cfg.Client.ClusterID().String(),
 		)
 		agentGatewaySyncer.Init(cfg.KrtOptions)
 
diff --git a/internal/kgateway/crds/inferencemodels.yaml b/internal/kgateway/crds/inferencemodels.yaml
index 4176475b1..a6be540ca 100644
--- a/internal/kgateway/crds/inferencemodels.yaml
+++ b/internal/kgateway/crds/inferencemodels.yaml
@@ -89,7 +89,7 @@ spec:
                   ModelNames must be unique for a referencing InferencePool
                   (names can be reused for a different pool in the same cluster).
                   The modelName with the oldest creation timestamp is retained, and the incoming
-                  InferenceModel's Ready status is set to false with a corresponding reason.
+                  InferenceModel is sets the Ready status to false with a corresponding reason.
                   In the rare case of a race condition, one Model will be selected randomly to be considered valid, and the other rejected.
                   Names can be reserved without an underlying model configured in the pool.
                   This can be done by specifying a target model and setting the weight to zero,
diff --git a/internal/kgateway/crds/inferencepools.yaml b/internal/kgateway/crds/inferencepools.yaml
index edf351025..ab63a8243 100644
--- a/internal/kgateway/crds/inferencepools.yaml
+++ b/internal/kgateway/crds/inferencepools.yaml
@@ -135,32 +135,16 @@ spec:
             - targetPortNumber
             type: object
           status:
-            default:
-              parent:
-              - conditions:
-                - lastTransitionTime: "1970-01-01T00:00:00Z"
-                  message: Waiting for controller
-                  reason: Pending
-                  status: Unknown
-                  type: Accepted
-                parentRef:
-                  kind: Status
-                  name: default
-            description: Status defines the observed state of InferencePool.
+            description: InferencePoolStatus defines the observed state of InferencePool
             properties:
               parent:
                 description: |-
                   Parents is a list of parent resources (usually Gateways) that are
-                  associated with the InferencePool, and the status of the InferencePool with respect to
+                  associated with the route, and the status of the InferencePool with respect to
                   each parent.
 
-                  A maximum of 32 Gateways will be represented in this list. When the list contains
-                  `kind: Status, name: default`, it indicates that the InferencePool is not
-                  associated with any Gateway and a controller must perform the following:
-
-                   - Remove the parent when setting the "Accepted" condition.
-                   - Add the parent when the controller will no longer manage the InferencePool
-                     and no other parents exist.
+                  A maximum of 32 Gateways will be represented in this list. An empty list
+                  means the route has not been attached to any Gateway.
                 items:
                   description: PoolStatus defines the observed state of InferencePool
                     from a Gateway.
diff --git a/internal/kgateway/deployer/gateway_parameters_test.go b/internal/kgateway/deployer/gateway_parameters_test.go
index ac27cc4bb..a923fe5b7 100644
--- a/internal/kgateway/deployer/gateway_parameters_test.go
+++ b/internal/kgateway/deployer/gateway_parameters_test.go
@@ -28,7 +28,6 @@ import (
 	common "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/collections"
 	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/pkg/schemes"
-	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 )
 
 const (
@@ -73,8 +72,7 @@ func TestShouldUseExtendedGatewayParameters(t *testing.T) {
 	gwc := defaultGatewayClass()
 	gwParams := emptyGatewayParameters()
 	extraGwParams := &corev1.ConfigMap{
-		ObjectMeta: metav1.ObjectMeta{Namespace: defaultNamespace},
-	}
+		ObjectMeta: metav1.ObjectMeta{Namespace: defaultNamespace}}
 
 	gw := &api.Gateway{
 		ObjectMeta: metav1.ObjectMeta{
@@ -229,7 +227,7 @@ func newCommonCols(t test.Failer, initObjs ...client.Object) *common.CommonColle
 	}
 	mock := krttest.NewMock(t, anys)
 
-	policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{}, settings.Settings{})
+	policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{})
 	kubeRawGateways := krttest.GetMockCollection[*api.Gateway](mock)
 	kubeRawListenerSets := krttest.GetMockCollection[*apixv1a1.XListenerSet](mock)
 	gatewayClasses := krttest.GetMockCollection[*api.GatewayClass](mock)
diff --git a/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin.go b/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin.go
index 89c31169f..0d5f29703 100644
--- a/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin.go
+++ b/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin.go
@@ -257,6 +257,7 @@ func translate(commoncol *common.CommonCollections, krtctx krt.HandlerContext, p
 	if pol.Spec.Http1ProtocolOptions != nil {
 		http1ProtocolOptions, err := translateHttp1ProtocolOptions(pol.Spec.Http1ProtocolOptions)
 		if err != nil {
+			logger.Error("failed to translate http1 protocol options", "error", err)
 			return &ir, err
 		}
 		ir.http1ProtocolOptions = http1ProtocolOptions
diff --git a/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin_test.go b/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin_test.go
index b9011dd81..de7677be6 100644
--- a/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin_test.go
+++ b/internal/kgateway/extensions2/plugins/backendconfigpolicy/plugin_test.go
@@ -209,8 +209,8 @@ func TestBackendConfigPolicyFlow(t *testing.T) {
 							ExplicitHttpConfig: &envoy_upstreams_http_v3.HttpProtocolOptions_ExplicitHttpConfig{
 								ProtocolConfig: &envoy_upstreams_http_v3.HttpProtocolOptions_ExplicitHttpConfig_Http2ProtocolOptions{
 									Http2ProtocolOptions: &corev3.Http2ProtocolOptions{
-										InitialStreamWindowSize:                 &wrapperspb.UInt32Value{Value: 65536},
-										InitialConnectionWindowSize:             &wrapperspb.UInt32Value{Value: 65536},
+										InitialStreamWindowSize:                 &wrapperspb.UInt32Value{Value: 65536000},
+										InitialConnectionWindowSize:             &wrapperspb.UInt32Value{Value: 65536000},
 										MaxConcurrentStreams:                    &wrapperspb.UInt32Value{Value: 100},
 										OverrideStreamErrorOnInvalidHttpMessage: &wrapperspb.BoolValue{Value: true},
 									},
@@ -258,6 +258,12 @@ func TestBackendConfigPolicyFlow(t *testing.T) {
 				backend = &ir.BackendObjectIR{}
 			}
 			processBackend(context.Background(), policyIR, *backend, cluster)
+
+			// Compare the resulting cluster configuration
+			if tt.wantErr {
+				assert.Error(t, err)
+				return
+			}
 			assert.Equal(t, tt.want, cluster)
 		})
 	}
diff --git a/internal/kgateway/extensions2/plugins/backendconfigpolicy/protocoloptions.go b/internal/kgateway/extensions2/plugins/backendconfigpolicy/protocoloptions.go
index 11dc660e6..ce97106a4 100644
--- a/internal/kgateway/extensions2/plugins/backendconfigpolicy/protocoloptions.go
+++ b/internal/kgateway/extensions2/plugins/backendconfigpolicy/protocoloptions.go
@@ -76,10 +76,10 @@ func translateHttp2ProtocolOptions(http2ProtocolOptions *v1alpha1.Http2ProtocolO
 		out.MaxConcurrentStreams = &wrapperspb.UInt32Value{Value: uint32(*http2ProtocolOptions.MaxConcurrentStreams)}
 	}
 	if http2ProtocolOptions.InitialStreamWindowSize != nil {
-		out.InitialStreamWindowSize = &wrapperspb.UInt32Value{Value: uint32(http2ProtocolOptions.InitialStreamWindowSize.Value())}
+		out.InitialStreamWindowSize = &wrapperspb.UInt32Value{Value: uint32(http2ProtocolOptions.InitialStreamWindowSize.MilliValue())}
 	}
 	if http2ProtocolOptions.InitialConnectionWindowSize != nil {
-		out.InitialConnectionWindowSize = &wrapperspb.UInt32Value{Value: uint32(http2ProtocolOptions.InitialConnectionWindowSize.Value())}
+		out.InitialConnectionWindowSize = &wrapperspb.UInt32Value{Value: uint32(http2ProtocolOptions.InitialConnectionWindowSize.MilliValue())}
 	}
 	if http2ProtocolOptions.OverrideStreamErrorOnInvalidHttpMessage != nil {
 		out.OverrideStreamErrorOnInvalidHttpMessage = &wrapperspb.BoolValue{Value: *http2ProtocolOptions.OverrideStreamErrorOnInvalidHttpMessage}
diff --git a/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls.go b/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls.go
index b93438964..4fe560a8d 100644
--- a/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls.go
+++ b/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls.go
@@ -99,7 +99,7 @@ func translateTLSConfig(
 		return nil, errors.New("invalid TLS config: certChain and privateKey must both be provided")
 	}
 
-	sanMatchers := verifySanListToTypedMatchSanList(tlsConfig.VerifySubjectAltName)
+	sanList := verifySanListToMatchSanList(tlsConfig.VerifySubjectAltName)
 
 	if rootCaData != nil {
 		validationCtx := &envoyauth.CommonTlsContext_ValidationContext{
@@ -107,11 +107,11 @@ func translateTLSConfig(
 				TrustedCa: rootCaData,
 			},
 		}
-		if len(sanMatchers) != 0 {
-			validationCtx.ValidationContext.MatchTypedSubjectAltNames = sanMatchers
+		if len(sanList) != 0 {
+			validationCtx.ValidationContext.MatchSubjectAltNames = sanList
 		}
 		tlsContext.ValidationContextType = validationCtx
-	} else if len(sanMatchers) != 0 {
+	} else if len(sanList) != 0 {
 		return nil, errors.New("a root_ca must be provided if verify_subject_alt_name is not empty")
 	}
 
@@ -225,14 +225,11 @@ func stringDataSourceGenerator(inlineDataSource bool) func(s string) *corev3.Dat
 	}
 }
 
-func verifySanListToTypedMatchSanList(sanList []string) []*envoyauth.SubjectAltNameMatcher {
-	var matchSanList []*envoyauth.SubjectAltNameMatcher
+func verifySanListToMatchSanList(sanList []string) []*envoymatcher.StringMatcher {
+	var matchSanList []*envoymatcher.StringMatcher
 	for _, san := range sanList {
-		matchSan := &envoyauth.SubjectAltNameMatcher{
-			SanType: envoyauth.SubjectAltNameMatcher_DNS,
-			Matcher: &envoymatcher.StringMatcher{
-				MatchPattern: &envoymatcher.StringMatcher_Exact{Exact: san},
-			},
+		matchSan := &envoymatcher.StringMatcher{
+			MatchPattern: &envoymatcher.StringMatcher_Exact{Exact: san},
 		}
 		matchSanList = append(matchSanList, matchSan)
 	}
diff --git a/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls_test.go b/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls_test.go
index b38f83f63..3e0de817f 100644
--- a/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls_test.go
+++ b/internal/kgateway/extensions2/plugins/backendconfigpolicy/tls_test.go
@@ -5,7 +5,6 @@ import (
 	"testing"
 
 	envoyauth "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
-	envoymatcher "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
 	corev1 "k8s.io/api/core/v1"
@@ -272,38 +271,6 @@ func TestTranslateTLSConfig(t *testing.T) {
 				assert.Nil(t, result.CommonTlsContext.GetValidationContext())
 			},
 		},
-		{
-			name: "TLS config with SAN verification",
-			tlsConfig: &v1alpha1.TLS{
-				TLSFiles: &v1alpha1.TLSFiles{
-					TLSCertificate: CACert,
-					TLSKey:         TLSKey,
-					RootCA:         CACert,
-				},
-				VerifySubjectAltName: []string{"test.example.com", "api.example.com"},
-				Sni:                  "test.example.com",
-			},
-			wantErr: false,
-			check: func(t *testing.T, result *envoyauth.UpstreamTlsContext) {
-				assert.NotNil(t, result)
-				assert.Equal(t, "test.example.com", result.Sni)
-				assert.NotNil(t, result.CommonTlsContext)
-
-				validationCtx := result.CommonTlsContext.GetValidationContext()
-				assert.NotNil(t, validationCtx)
-				assert.Equal(t, CACert, validationCtx.TrustedCa.GetFilename())
-
-				assert.Len(t, validationCtx.MatchTypedSubjectAltNames, 2)
-
-				san1 := validationCtx.MatchTypedSubjectAltNames[0]
-				assert.Equal(t, envoyauth.SubjectAltNameMatcher_DNS, san1.SanType)
-				assert.Equal(t, "test.example.com", san1.Matcher.GetExact())
-
-				san2 := validationCtx.MatchTypedSubjectAltNames[1]
-				assert.Equal(t, envoyauth.SubjectAltNameMatcher_DNS, san2.SanType)
-				assert.Equal(t, "api.example.com", san2.Matcher.GetExact())
-			},
-		},
 	}
 
 	for _, tt := range tests {
@@ -356,66 +323,3 @@ func validateCommonTlsContextFiles(t *testing.T, result *envoyauth.UpstreamTlsCo
 	assert.Equal(t, CACert, result.CommonTlsContext.TlsCertificates[0].GetCertificateChain().GetFilename())
 	assert.Equal(t, TLSKey, result.CommonTlsContext.TlsCertificates[0].GetPrivateKey().GetFilename())
 }
-
-func TestVerifySanListToTypedMatchSanList(t *testing.T) {
-	tests := []struct {
-		name     string
-		sanList  []string
-		expected []*envoyauth.SubjectAltNameMatcher
-	}{
-		{
-			name:     "empty SAN list",
-			sanList:  []string{},
-			expected: []*envoyauth.SubjectAltNameMatcher{},
-		},
-		{
-			name:    "single SAN",
-			sanList: []string{"example.com"},
-			expected: []*envoyauth.SubjectAltNameMatcher{
-				{
-					SanType: envoyauth.SubjectAltNameMatcher_DNS,
-					Matcher: &envoymatcher.StringMatcher{
-						MatchPattern: &envoymatcher.StringMatcher_Exact{Exact: "example.com"},
-					},
-				},
-			},
-		},
-		{
-			name:    "multiple SANs",
-			sanList: []string{"example.com", "api.example.com", "www.example.com"},
-			expected: []*envoyauth.SubjectAltNameMatcher{
-				{
-					SanType: envoyauth.SubjectAltNameMatcher_DNS,
-					Matcher: &envoymatcher.StringMatcher{
-						MatchPattern: &envoymatcher.StringMatcher_Exact{Exact: "example.com"},
-					},
-				},
-				{
-					SanType: envoyauth.SubjectAltNameMatcher_DNS,
-					Matcher: &envoymatcher.StringMatcher{
-						MatchPattern: &envoymatcher.StringMatcher_Exact{Exact: "api.example.com"},
-					},
-				},
-				{
-					SanType: envoyauth.SubjectAltNameMatcher_DNS,
-					Matcher: &envoymatcher.StringMatcher{
-						MatchPattern: &envoymatcher.StringMatcher_Exact{Exact: "www.example.com"},
-					},
-				},
-			},
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			result := verifySanListToTypedMatchSanList(tt.sanList)
-
-			assert.Len(t, result, len(tt.expected))
-
-			for i, expected := range tt.expected {
-				assert.Equal(t, expected.SanType, result[i].SanType)
-				assert.Equal(t, expected.Matcher.GetExact(), result[i].Matcher.GetExact())
-			}
-		})
-	}
-}
diff --git a/internal/kgateway/extensions2/plugins/backendtlspolicy/plugin.go b/internal/kgateway/extensions2/plugins/backendtlspolicy/plugin.go
index e29ff679a..46198fc59 100644
--- a/internal/kgateway/extensions2/plugins/backendtlspolicy/plugin.go
+++ b/internal/kgateway/extensions2/plugins/backendtlspolicy/plugin.go
@@ -28,6 +28,7 @@ import (
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/kube/kubetypes"
 
+	gwv1a2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gwv1a3 "sigs.k8s.io/gateway-api/apis/v1alpha3"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
@@ -35,7 +36,6 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
 	kgwellknown "github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-	pluginutils "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/utils"
 )
 
 var (
@@ -105,7 +105,7 @@ func NewPlugin(ctx context.Context, commoncol *common.CommonCollections) extensi
 			},
 			Policy:     i,
 			PolicyIR:   tlsPolicyIR,
-			TargetRefs: pluginutils.TargetRefsToPolicyRefsWithSectionNameV1Alpha2(i.Spec.TargetRefs),
+			TargetRefs: convertTargetRefs(i.Spec.TargetRefs),
 		}
 		if err != nil {
 			pol.Errors = []error{err}
@@ -208,6 +208,14 @@ func buildTranslateFunc(
 	}
 }
 
+func convertTargetRefs(targetRefs []gwv1a2.LocalPolicyTargetReferenceWithSectionName) []ir.PolicyRef {
+	return []ir.PolicyRef{{
+		Kind:  string(targetRefs[0].Kind),
+		Name:  string(targetRefs[0].Name),
+		Group: string(targetRefs[0].Group),
+	}}
+}
+
 func convertSubjectAltNames(validation gwv1a3.BackendTLSPolicyValidation) []*envoy_tls_v3.SubjectAltNameMatcher {
 	if len(validation.SubjectAltNames) == 0 {
 		hostname := string(validation.Hostname)
diff --git a/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_converter.go b/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_converter.go
index 0c804c712..c293b4fce 100644
--- a/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_converter.go
+++ b/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_converter.go
@@ -12,12 +12,10 @@ import (
 	envoyalfile "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/file/v3"
 	cel "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/filters/cel/v3"
 	envoygrpc "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/grpc/v3"
-	envoy_open_telemetry "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/open_telemetry/v3"
 	envoy_metadata_formatter "github.com/envoyproxy/go-control-plane/envoy/extensions/formatter/metadata/v3"
 	envoy_req_without_query "github.com/envoyproxy/go-control-plane/envoy/extensions/formatter/req_without_query/v3"
 	envoymatcher "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3"
 	"github.com/envoyproxy/go-control-plane/pkg/wellknown"
-	otelv1 "go.opentelemetry.io/proto/otlp/common/v1"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/structpb"
 	"istio.io/istio/pkg/kube/krt"
@@ -49,22 +47,13 @@ func convertAccessLogConfig(
 
 	grpcBackends := make(map[string]*ir.BackendObjectIR, len(policy.Spec.AccessLog))
 	for idx, log := range configs {
-		if log.GrpcService != nil {
+		if log.GrpcService != nil && log.GrpcService.BackendRef != nil {
 			backend, err := commoncol.BackendIndex.GetBackendFromRef(krtctx, parentSrc, log.GrpcService.BackendRef.BackendObjectReference)
 			// TODO: what is the correct behavior? maybe route to static blackhole?
 			if err != nil {
 				return nil, fmt.Errorf("%w: %v", ErrUnresolvedBackendRef, err)
 			}
 			grpcBackends[getLogId(log.GrpcService.LogName, idx)] = backend
-			continue
-		}
-		if log.OpenTelemetry != nil {
-			backend, err := commoncol.BackendIndex.GetBackendFromRef(krtctx, parentSrc, log.OpenTelemetry.GrpcService.BackendRef.BackendObjectReference)
-			// TODO: what is the correct behavior? maybe route to static blackhole?
-			if err != nil {
-				return nil, fmt.Errorf("%w: %v", ErrUnresolvedBackendRef, err)
-			}
-			grpcBackends[getLogId(log.OpenTelemetry.GrpcService.LogName, idx)] = backend
 		}
 	}
 
@@ -106,8 +95,6 @@ func translateAccessLog(logConfig v1alpha1.AccessLog, grpcBackends map[string]*i
 		accessLogCfg, err = createFileAccessLog(logConfig.FileSink)
 	case logConfig.GrpcService != nil:
 		accessLogCfg, err = createGrpcAccessLog(logConfig.GrpcService, grpcBackends, accessLogId)
-	case logConfig.OpenTelemetry != nil:
-		accessLogCfg, err = createOTelAccessLog(logConfig.OpenTelemetry, grpcBackends, accessLogId)
 	default:
 		return nil, errors.New("no access log sink specified")
 	}
@@ -169,7 +156,7 @@ func createFileAccessLog(fileSink *v1alpha1.FileSink) (*envoyaccesslog.AccessLog
 }
 
 // createGrpcAccessLog generates a gRPC-based access log configuration
-func createGrpcAccessLog(grpcService *v1alpha1.AccessLogGrpcService, grpcBackends map[string]*ir.BackendObjectIR, accessLogId int) (*envoyaccesslog.AccessLog, error) {
+func createGrpcAccessLog(grpcService *v1alpha1.GrpcService, grpcBackends map[string]*ir.BackendObjectIR, accessLogId int) (*envoyaccesslog.AccessLog, error) {
 	var cfg envoygrpc.HttpGrpcAccessLogConfig
 	if err := copyGrpcSettings(&cfg, grpcService, grpcBackends, accessLogId); err != nil {
 		return nil, fmt.Errorf("error converting grpc access log config: %w", err)
@@ -178,16 +165,6 @@ func createGrpcAccessLog(grpcService *v1alpha1.AccessLogGrpcService, grpcBackend
 	return newAccessLogWithConfig(wellknown.HTTPGRPCAccessLog, &cfg)
 }
 
-// createOTelAccessLog generates an OTel access log configuration
-func createOTelAccessLog(grpcService *v1alpha1.OpenTelemetryAccessLogService, grpcBackends map[string]*ir.BackendObjectIR, accessLogId int) (*envoyaccesslog.AccessLog, error) {
-	var cfg envoy_open_telemetry.OpenTelemetryAccessLogConfig
-	if err := copyOTelSettings(&cfg, grpcService, grpcBackends, accessLogId); err != nil {
-		return nil, fmt.Errorf("error converting otel access log config: %w", err)
-	}
-
-	return newAccessLogWithConfig("envoy.access_loggers.open_telemetry", &cfg)
-}
-
 // addAccessLogFilter adds filtering logic to an access log configuration
 func addAccessLogFilter(accessLogCfg *envoyaccesslog.AccessLog, filter *v1alpha1.AccessLogFilter) error {
 	var (
@@ -405,113 +382,38 @@ func convertJsonFormat(jsonFormat *runtime.RawExtension) *structpb.Struct {
 	return structVal
 }
 
-func generateCommonAccessLogGrpcConfig(grpcService v1alpha1.CommonAccessLogGrpcService, grpcBackends map[string]*ir.BackendObjectIR, accessLogId int) (*envoygrpc.CommonGrpcAccessLogConfig, error) {
+func copyGrpcSettings(cfg *envoygrpc.HttpGrpcAccessLogConfig, grpcService *v1alpha1.GrpcService, grpcBackends map[string]*ir.BackendObjectIR, accessLogId int) error {
+	if grpcService == nil {
+		return errors.New("grpc service object cannot be nil")
+	}
+
 	if grpcService.LogName == "" {
-		return nil, errors.New("grpc service log name cannot be empty")
+		return errors.New("grpc service log name cannot be empty")
 	}
 
 	backend := grpcBackends[getLogId(grpcService.LogName, accessLogId)]
 	if backend == nil {
-		return nil, errors.New("backend ref not found")
-	}
-
-	commonConfig, err := ToEnvoyGrpc(grpcService.CommonGrpcService, backend)
-	if err != nil {
-		return nil, err
+		return errors.New("backend ref not found")
 	}
 
-	return &envoygrpc.CommonGrpcAccessLogConfig{
-		LogName:             grpcService.LogName,
-		GrpcService:         commonConfig,
-		TransportApiVersion: envoycore.ApiVersion_V3,
-	}, nil
-}
-
-func copyGrpcSettings(cfg *envoygrpc.HttpGrpcAccessLogConfig, grpcService *v1alpha1.AccessLogGrpcService, grpcBackends map[string]*ir.BackendObjectIR, accessLogId int) error {
-	config, err := generateCommonAccessLogGrpcConfig(grpcService.CommonAccessLogGrpcService, grpcBackends, accessLogId)
-	if err != nil {
-		return err
+	svc := &envoycore.GrpcService{
+		TargetSpecifier: &envoycore.GrpcService_EnvoyGrpc_{
+			EnvoyGrpc: &envoycore.GrpcService_EnvoyGrpc{
+				ClusterName: backend.ClusterName(),
+			},
+		},
 	}
-
-	cfg.CommonConfig = config
 	cfg.AdditionalRequestHeadersToLog = grpcService.AdditionalRequestHeadersToLog
 	cfg.AdditionalResponseHeadersToLog = grpcService.AdditionalResponseHeadersToLog
 	cfg.AdditionalResponseTrailersToLog = grpcService.AdditionalResponseTrailersToLog
-	return cfg.Validate()
-}
-
-func copyOTelSettings(cfg *envoy_open_telemetry.OpenTelemetryAccessLogConfig, otelService *v1alpha1.OpenTelemetryAccessLogService, grpcBackends map[string]*ir.BackendObjectIR, accessLogId int) error {
-	config, err := generateCommonAccessLogGrpcConfig(otelService.GrpcService, grpcBackends, accessLogId)
-	if err != nil {
-		return err
-	}
-
-	cfg.CommonConfig = config
-	if otelService.Body != nil {
-		cfg.Body = &otelv1.AnyValue{
-			Value: &otelv1.AnyValue_StringValue{
-				StringValue: *otelService.Body,
-			},
-		}
-	}
-	if otelService.DisableBuiltinLabels != nil {
-		cfg.DisableBuiltinLabels = *otelService.DisableBuiltinLabels
-	}
-	if otelService.Attributes != nil {
-		cfg.Attributes = ToOTelKeyValueList(otelService.Attributes)
+	cfg.CommonConfig = &envoygrpc.CommonGrpcAccessLogConfig{
+		LogName:             grpcService.LogName,
+		GrpcService:         svc,
+		TransportApiVersion: envoycore.ApiVersion_V3,
 	}
-
 	return cfg.Validate()
 }
 
-func ToOTelKeyValueList(in *v1alpha1.KeyAnyValueList) *otelv1.KeyValueList {
-	kvList := make([]*otelv1.KeyValue, len(in.Values))
-	ret := &otelv1.KeyValueList{
-		Values: kvList,
-	}
-	for i, value := range in.Values {
-		ret.GetValues()[i] = &otelv1.KeyValue{
-			Key:   value.Key,
-			Value: ToOTelAnyValue(&value.Value),
-		}
-	}
-	return ret
-}
-
-func ToOTelAnyValue(in *v1alpha1.AnyValue) *otelv1.AnyValue {
-	if in == nil {
-		return nil
-	}
-	if in.StringValue != nil {
-		return &otelv1.AnyValue{
-			Value: &otelv1.AnyValue_StringValue{
-				StringValue: *in.StringValue,
-			},
-		}
-	}
-	if in.ArrayValue != nil {
-		arrayValue := &otelv1.AnyValue_ArrayValue{
-			ArrayValue: &otelv1.ArrayValue{
-				Values: make([]*otelv1.AnyValue, len(in.ArrayValue)),
-			},
-		}
-		for i, value := range in.ArrayValue {
-			arrayValue.ArrayValue.GetValues()[i] = ToOTelAnyValue(&value)
-		}
-		return &otelv1.AnyValue{
-			Value: arrayValue,
-		}
-	}
-	if in.KvListValue != nil {
-		return &otelv1.AnyValue{
-			Value: &otelv1.AnyValue_KvlistValue{
-				KvlistValue: ToOTelKeyValueList(in.KvListValue),
-			},
-		}
-	}
-	return nil
-}
-
 func getFormatterExtensions() ([]*envoycore.TypedExtensionConfig, error) {
 	reqWithoutQueryFormatter := &envoy_req_without_query.ReqWithoutQuery{}
 	reqWithoutQueryFormatterTc, err := utils.MessageToAny(reqWithoutQueryFormatter)
diff --git a/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_listener_plugin_test.go b/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_listener_plugin_test.go
index db42a6993..994f5989d 100644
--- a/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_listener_plugin_test.go
+++ b/internal/kgateway/extensions2/plugins/httplistenerpolicy/access_logging_listener_plugin_test.go
@@ -3,7 +3,6 @@ package httplistenerpolicy
 import (
 	"context"
 	"testing"
-	"time"
 
 	v33 "github.com/envoyproxy/go-control-plane/envoy/config/accesslog/v3"
 	envoycore "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
@@ -11,21 +10,15 @@ import (
 	envoyalfile "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/file/v3"
 	cel "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/filters/cel/v3"
 	envoygrpc "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/grpc/v3"
-	envoy_open_telemetry "github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/open_telemetry/v3"
 	envoy_metadata_formatter "github.com/envoyproxy/go-control-plane/envoy/extensions/formatter/metadata/v3"
 	envoy_req_without_query "github.com/envoyproxy/go-control-plane/envoy/extensions/formatter/req_without_query/v3"
 	envoymatcher "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
-	otelv1 "go.opentelemetry.io/proto/otlp/common/v1"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/anypb"
-	"google.golang.org/protobuf/types/known/durationpb"
 	"google.golang.org/protobuf/types/known/structpb"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/utils/pointer"
 	"k8s.io/utils/ptr"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
@@ -108,17 +101,13 @@ func TestConvertJsonFormat_EdgeCases(t *testing.T) {
 				name: "GRPCAdditionalHeaders",
 				config: []v1alpha1.AccessLog{
 					{
-						GrpcService: &v1alpha1.AccessLogGrpcService{
-							CommonAccessLogGrpcService: v1alpha1.CommonAccessLogGrpcService{
-								CommonGrpcService: v1alpha1.CommonGrpcService{
-									BackendRef: &gwv1.BackendRef{
-										BackendObjectReference: gwv1.BackendObjectReference{
-											Name: "test-service",
-										},
-									},
+						GrpcService: &v1alpha1.GrpcService{
+							BackendRef: &gwv1.BackendRef{
+								BackendObjectReference: gwv1.BackendObjectReference{
+									Name: "test-service",
 								},
-								LogName: "grpc-log",
 							},
+							LogName:                         "grpc-log",
 							AdditionalRequestHeadersToLog:   []string{"x-request-id"},
 							AdditionalResponseHeadersToLog:  []string{"x-response-id"},
 							AdditionalResponseTrailersToLog: []string{"x-trailer"},
@@ -283,17 +272,13 @@ func TestConvertJsonFormat_EdgeCases(t *testing.T) {
 				name: "GrpcServiceConfig",
 				config: []v1alpha1.AccessLog{
 					{
-						GrpcService: &v1alpha1.AccessLogGrpcService{
-							CommonAccessLogGrpcService: v1alpha1.CommonAccessLogGrpcService{
-								CommonGrpcService: v1alpha1.CommonGrpcService{
-									BackendRef: &gwv1.BackendRef{
-										BackendObjectReference: gwv1.BackendObjectReference{
-											Name: "test-service",
-										},
-									},
+						GrpcService: &v1alpha1.GrpcService{
+							BackendRef: &gwv1.BackendRef{
+								BackendObjectReference: gwv1.BackendObjectReference{
+									Name: "test-service",
 								},
-								LogName: "grpc-log",
 							},
+							LogName: "grpc-log",
 						},
 					},
 				},
@@ -318,125 +303,6 @@ func TestConvertJsonFormat_EdgeCases(t *testing.T) {
 					},
 				},
 			},
-			{
-				name: "GrpcServiceConfig with invalid retry policy",
-				config: []v1alpha1.AccessLog{
-					{
-						GrpcService: &v1alpha1.AccessLogGrpcService{
-							CommonAccessLogGrpcService: v1alpha1.CommonAccessLogGrpcService{
-								CommonGrpcService: v1alpha1.CommonGrpcService{
-									BackendRef: &gwv1.BackendRef{
-										BackendObjectReference: gwv1.BackendObjectReference{
-											Name: "test-service",
-										},
-									},
-									RetryPolicy: &v1alpha1.RetryPolicy{
-										RetryBackOff: &v1alpha1.BackoffStrategy{
-											BaseInterval: metav1.Duration{Duration: 5 * time.Second},
-											MaxInterval:  &metav1.Duration{Duration: 1 * time.Second},
-										},
-									},
-								},
-								LogName: "grpc-log",
-							},
-						},
-					},
-				},
-				expected: []*v33.AccessLog{
-					{
-						Name: "envoy.access_loggers.http_grpc",
-						ConfigType: &v33.AccessLog_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &envoygrpc.HttpGrpcAccessLogConfig{
-								CommonConfig: &envoygrpc.CommonGrpcAccessLogConfig{
-									LogName: "grpc-log",
-									GrpcService: &envoycore.GrpcService{
-										TargetSpecifier: &envoycore.GrpcService_EnvoyGrpc_{
-											EnvoyGrpc: &envoycore.GrpcService_EnvoyGrpc{
-												ClusterName: "backend_default_test-service_0",
-											},
-										},
-										RetryPolicy: &envoycore.RetryPolicy{
-											RetryBackOff: &envoycore.BackoffStrategy{
-												BaseInterval: &durationpb.Duration{Seconds: 5},
-											},
-										},
-									},
-									TransportApiVersion: envoycore.ApiVersion_V3,
-								},
-							}),
-						},
-					},
-				},
-			},
-			{
-				name: "GrpcServiceConfig with all the common options",
-				config: []v1alpha1.AccessLog{
-					{
-						GrpcService: &v1alpha1.AccessLogGrpcService{
-							CommonAccessLogGrpcService: v1alpha1.CommonAccessLogGrpcService{
-								CommonGrpcService: v1alpha1.CommonGrpcService{
-									BackendRef: &gwv1.BackendRef{
-										BackendObjectReference: gwv1.BackendObjectReference{
-											Name: "test-service",
-										},
-									},
-									Authority:               pointer.String("www.example.com"),
-									MaxReceiveMessageLength: pointer.Uint32(127),
-									SkipEnvoyHeaders:        pointer.Bool(true),
-									Timeout:                 &metav1.Duration{Duration: 10 * time.Second},
-									InitialMetadata: []v1alpha1.HeaderValue{{
-										Key:   "key",
-										Value: "value",
-									}},
-									RetryPolicy: &v1alpha1.RetryPolicy{
-										RetryBackOff: &v1alpha1.BackoffStrategy{
-											BaseInterval: metav1.Duration{Duration: 5 * time.Second},
-											MaxInterval:  &metav1.Duration{Duration: 10 * time.Second},
-										},
-										NumRetries: pointer.Uint32(3),
-									},
-								},
-								LogName: "grpc-log",
-							},
-						},
-					},
-				},
-				expected: []*v33.AccessLog{
-					{
-						Name: "envoy.access_loggers.http_grpc",
-						ConfigType: &v33.AccessLog_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &envoygrpc.HttpGrpcAccessLogConfig{
-								CommonConfig: &envoygrpc.CommonGrpcAccessLogConfig{
-									LogName: "grpc-log",
-									GrpcService: &envoycore.GrpcService{
-										TargetSpecifier: &envoycore.GrpcService_EnvoyGrpc_{
-											EnvoyGrpc: &envoycore.GrpcService_EnvoyGrpc{
-												ClusterName:             "backend_default_test-service_0",
-												Authority:               "www.example.com",
-												MaxReceiveMessageLength: &wrapperspb.UInt32Value{Value: 127},
-												SkipEnvoyHeaders:        true,
-											},
-										},
-										Timeout: &durationpb.Duration{Seconds: 10},
-										InitialMetadata: []*envoycore.HeaderValue{{
-											Key:   "key",
-											Value: "value",
-										}},
-										RetryPolicy: &envoycore.RetryPolicy{
-											RetryBackOff: &envoycore.BackoffStrategy{
-												BaseInterval: &durationpb.Duration{Seconds: 5},
-												MaxInterval:  &durationpb.Duration{Seconds: 10},
-											},
-											NumRetries: &wrapperspb.UInt32Value{Value: 3},
-										},
-									},
-									TransportApiVersion: envoycore.ApiVersion_V3,
-								},
-							}),
-						},
-					},
-				},
-			},
 			{
 				name: "AccessLogWithStatusCodeFilter",
 				config: []v1alpha1.AccessLog{
@@ -757,264 +623,6 @@ func TestConvertJsonFormat_EdgeCases(t *testing.T) {
 					},
 				},
 			},
-			{
-				name: "OTel Sink",
-				config: []v1alpha1.AccessLog{
-					{
-						OpenTelemetry: &v1alpha1.OpenTelemetryAccessLogService{
-							GrpcService: v1alpha1.CommonAccessLogGrpcService{
-								CommonGrpcService: v1alpha1.CommonGrpcService{
-									BackendRef: &gwv1.BackendRef{
-										BackendObjectReference: gwv1.BackendObjectReference{
-											Name: "test-service",
-										},
-									},
-								},
-								LogName: "otel-log",
-							},
-						},
-					},
-				},
-				expected: []*v33.AccessLog{
-					{
-						Name: "envoy.access_loggers.open_telemetry",
-						ConfigType: &v33.AccessLog_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &envoy_open_telemetry.OpenTelemetryAccessLogConfig{
-								CommonConfig: &envoygrpc.CommonGrpcAccessLogConfig{
-									LogName: "otel-log",
-									GrpcService: &envoycore.GrpcService{
-										TargetSpecifier: &envoycore.GrpcService_EnvoyGrpc_{
-											EnvoyGrpc: &envoycore.GrpcService_EnvoyGrpc{
-												ClusterName: "backend_default_test-service_0",
-											},
-										},
-									},
-									TransportApiVersion: envoycore.ApiVersion_V3,
-								},
-							}),
-						},
-					},
-				},
-			},
-			{
-				name: "OTel Sink with all the options",
-				config: []v1alpha1.AccessLog{
-					{
-						OpenTelemetry: &v1alpha1.OpenTelemetryAccessLogService{
-							GrpcService: v1alpha1.CommonAccessLogGrpcService{
-								CommonGrpcService: v1alpha1.CommonGrpcService{
-									BackendRef: &gwv1.BackendRef{
-										BackendObjectReference: gwv1.BackendObjectReference{
-											Name: "test-service",
-										},
-									},
-								},
-								LogName: "otel-log",
-							},
-							Body:                 pointer.String(`"%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %RESPONSE_CODE% "%REQ(:AUTHORITY)%" "%UPSTREAM_CLUSTER%"\n'`),
-							DisableBuiltinLabels: pointer.Bool(true),
-							Attributes: &v1alpha1.KeyAnyValueList{
-								Values: []v1alpha1.KeyAnyValue{
-									{
-										Key: "string-key-1",
-										Value: v1alpha1.AnyValue{
-											StringValue: pointer.String("string-value-1"),
-										},
-									},
-									{
-										Key: "array-key",
-										Value: v1alpha1.AnyValue{
-											ArrayValue: []v1alpha1.AnyValue{
-												{
-													StringValue: pointer.String("1-string-value"),
-												},
-												{
-													StringValue: pointer.String("2-string-value"),
-												},
-											},
-										},
-									},
-									{
-										Key: "kvlist-key",
-										Value: v1alpha1.AnyValue{
-											KvListValue: &v1alpha1.KeyAnyValueList{
-												Values: []v1alpha1.KeyAnyValue{
-													{
-														Key: "string-key-2",
-														Value: v1alpha1.AnyValue{
-															StringValue: pointer.String("string-value-2"),
-														},
-													},
-													{
-														Key: "array-key",
-														Value: v1alpha1.AnyValue{
-															ArrayValue: []v1alpha1.AnyValue{
-																{
-																	StringValue: pointer.String("3-string-value"),
-																},
-																{
-																	StringValue: pointer.String("4-string-value"),
-																},
-															},
-														},
-													},
-													{
-														Key: "kvlist-key",
-														Value: v1alpha1.AnyValue{
-															KvListValue: &v1alpha1.KeyAnyValueList{
-																Values: []v1alpha1.KeyAnyValue{
-																	{
-																		Key: "string-key-3",
-																		Value: v1alpha1.AnyValue{
-																			StringValue: pointer.String("string-value-3"),
-																		},
-																	},
-																	{
-																		Key: "string-key-4",
-																		Value: v1alpha1.AnyValue{
-																			StringValue: pointer.String("string-value-4"),
-																		},
-																	},
-																},
-															},
-														},
-													},
-												},
-											},
-										},
-									},
-								},
-							},
-						},
-					},
-				},
-				expected: []*v33.AccessLog{
-					{
-						Name: "envoy.access_loggers.open_telemetry",
-						ConfigType: &v33.AccessLog_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &envoy_open_telemetry.OpenTelemetryAccessLogConfig{
-								CommonConfig: &envoygrpc.CommonGrpcAccessLogConfig{
-									LogName: "otel-log",
-									GrpcService: &envoycore.GrpcService{
-										TargetSpecifier: &envoycore.GrpcService_EnvoyGrpc_{
-											EnvoyGrpc: &envoycore.GrpcService_EnvoyGrpc{
-												ClusterName: "backend_default_test-service_0",
-											},
-										},
-									},
-									TransportApiVersion: envoycore.ApiVersion_V3,
-								},
-								Body: &otelv1.AnyValue{
-									Value: &otelv1.AnyValue_StringValue{
-										StringValue: `"%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %RESPONSE_CODE% "%REQ(:AUTHORITY)%" "%UPSTREAM_CLUSTER%"\n'`,
-									},
-								},
-								DisableBuiltinLabels: true,
-								Attributes: &otelv1.KeyValueList{
-									Values: []*otelv1.KeyValue{
-										{
-											Key: "string-key-1",
-											Value: &otelv1.AnyValue{
-												Value: &otelv1.AnyValue_StringValue{
-													StringValue: "string-value-1",
-												},
-											},
-										},
-										{
-											Key: "array-key",
-											Value: &otelv1.AnyValue{
-												Value: &otelv1.AnyValue_ArrayValue{
-													ArrayValue: &otelv1.ArrayValue{
-														Values: []*otelv1.AnyValue{
-															{
-																Value: &otelv1.AnyValue_StringValue{
-																	StringValue: "1-string-value",
-																},
-															},
-															{
-																Value: &otelv1.AnyValue_StringValue{
-																	StringValue: "2-string-value",
-																},
-															},
-														},
-													},
-												},
-											},
-										},
-										{
-											Key: "kvlist-key",
-											Value: &otelv1.AnyValue{
-												Value: &otelv1.AnyValue_KvlistValue{
-													KvlistValue: &otelv1.KeyValueList{
-														Values: []*otelv1.KeyValue{
-															{
-																Key: "string-key-2",
-																Value: &otelv1.AnyValue{
-																	Value: &otelv1.AnyValue_StringValue{
-																		StringValue: "string-value-2",
-																	},
-																},
-															},
-															{
-																Key: "array-key",
-																Value: &otelv1.AnyValue{
-																	Value: &otelv1.AnyValue_ArrayValue{
-																		ArrayValue: &otelv1.ArrayValue{
-																			Values: []*otelv1.AnyValue{
-																				{
-																					Value: &otelv1.AnyValue_StringValue{
-																						StringValue: "3-string-value",
-																					},
-																				},
-																				{
-																					Value: &otelv1.AnyValue_StringValue{
-																						StringValue: "4-string-value",
-																					},
-																				},
-																			},
-																		},
-																	},
-																},
-															},
-															{
-																Key: "kvlist-key",
-																Value: &otelv1.AnyValue{
-																	Value: &otelv1.AnyValue_KvlistValue{
-																		KvlistValue: &otelv1.KeyValueList{
-																			Values: []*otelv1.KeyValue{
-																				{
-																					Key: "string-key-3",
-																					Value: &otelv1.AnyValue{
-																						Value: &otelv1.AnyValue_StringValue{
-																							StringValue: "string-value-3",
-																						},
-																					},
-																				},
-																				{
-																					Key: "string-key-4",
-																					Value: &otelv1.AnyValue{
-																						Value: &otelv1.AnyValue_StringValue{
-																							StringValue: "string-value-4",
-																						},
-																					},
-																				},
-																			},
-																		},
-																	},
-																},
-															},
-														},
-													},
-												},
-											},
-										},
-									},
-								},
-							}),
-						},
-					},
-				},
-			},
 		}
 		for _, tc := range testCases {
 			_, cancel := context.WithCancel(context.Background())
@@ -1032,13 +640,6 @@ func TestConvertJsonFormat_EdgeCases(t *testing.T) {
 								Namespace: "default",
 							},
 						},
-						"otel-log-0": {
-							ObjectSource: ir.ObjectSource{
-								Kind:      "Backend",
-								Name:      "test-service",
-								Namespace: "default",
-							},
-						},
 					},
 				)
 				require.NoError(t, err, "failed to convert access log config")
diff --git a/internal/kgateway/extensions2/plugins/httplistenerpolicy/common.go b/internal/kgateway/extensions2/plugins/httplistenerpolicy/common.go
deleted file mode 100644
index 6272a43c6..000000000
--- a/internal/kgateway/extensions2/plugins/httplistenerpolicy/common.go
+++ /dev/null
@@ -1,67 +0,0 @@
-package httplistenerpolicy
-
-import (
-	envoycore "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-
-	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
-)
-
-func ToEnvoyGrpc(in v1alpha1.CommonGrpcService, backend *ir.BackendObjectIR) (*envoycore.GrpcService, error) {
-	envoyGrpcService := &envoycore.GrpcService_EnvoyGrpc{
-		ClusterName: backend.ClusterName(),
-	}
-	if in.Authority != nil {
-		envoyGrpcService.Authority = *in.Authority
-	}
-	if in.MaxReceiveMessageLength != nil {
-		envoyGrpcService.MaxReceiveMessageLength = &wrapperspb.UInt32Value{
-			Value: *in.MaxReceiveMessageLength,
-		}
-	}
-	if in.SkipEnvoyHeaders != nil {
-		envoyGrpcService.SkipEnvoyHeaders = *in.SkipEnvoyHeaders
-	}
-	grpcService := &envoycore.GrpcService{
-		TargetSpecifier: &envoycore.GrpcService_EnvoyGrpc_{
-			EnvoyGrpc: envoyGrpcService,
-		},
-	}
-
-	if in.Timeout != nil {
-		grpcService.Timeout = utils.DurationToProto(in.Timeout.Duration)
-	}
-	if in.InitialMetadata != nil {
-		grpcService.InitialMetadata = make([]*envoycore.HeaderValue, len(in.InitialMetadata))
-		for i, metadata := range in.InitialMetadata {
-			grpcService.GetInitialMetadata()[i] = &envoycore.HeaderValue{
-				Key:   metadata.Key,
-				Value: metadata.Value,
-			}
-		}
-	}
-	if in.RetryPolicy != nil {
-		retryPolicy := &envoycore.RetryPolicy{}
-		if in.RetryPolicy.NumRetries != nil {
-			retryPolicy.NumRetries = &wrapperspb.UInt32Value{
-				Value: *in.RetryPolicy.NumRetries,
-			}
-		}
-		if in.RetryPolicy.RetryBackOff != nil {
-			retryPolicy.RetryBackOff = &envoycore.BackoffStrategy{
-				BaseInterval: utils.DurationToProto(in.RetryPolicy.RetryBackOff.BaseInterval.Duration),
-			}
-			if in.RetryPolicy.RetryBackOff.MaxInterval != nil {
-				if in.RetryPolicy.RetryBackOff.MaxInterval.Duration.Nanoseconds() < in.RetryPolicy.RetryBackOff.BaseInterval.Duration.Nanoseconds() {
-					logger.Error("retryPolicy.RetryBackOff.MaxInterval is lesser than RetryPolicy.RetryBackOff.MaxInterval. Ignoring MaxInterval", "max_interval", in.RetryPolicy.RetryBackOff.MaxInterval.Duration.Seconds(), "base_interval", in.RetryPolicy.RetryBackOff.BaseInterval.Duration.Seconds())
-				} else {
-					retryPolicy.GetRetryBackOff().MaxInterval = utils.DurationToProto(in.RetryPolicy.RetryBackOff.MaxInterval.Duration)
-				}
-			}
-		}
-		grpcService.RetryPolicy = retryPolicy
-	}
-	return grpcService, nil
-}
diff --git a/internal/kgateway/extensions2/plugins/httplistenerpolicy/httplistener_plugin.go b/internal/kgateway/extensions2/plugins/httplistenerpolicy/httplistener_plugin.go
index 73d3672e5..4c710d408 100644
--- a/internal/kgateway/extensions2/plugins/httplistenerpolicy/httplistener_plugin.go
+++ b/internal/kgateway/extensions2/plugins/httplistenerpolicy/httplistener_plugin.go
@@ -35,7 +35,6 @@ var logger = logging.New("plugin/httplistenerpolicy")
 type httpListenerPolicy struct {
 	ct                         time.Time
 	accessLog                  []*envoyaccesslog.AccessLog
-	tracing                    *envoy_hcm.HttpConnectionManager_Tracing
 	upgradeConfigs             []*envoy_hcm.HttpConnectionManager_UpgradeConfig
 	useRemoteAddress           *bool
 	xffNumTrustedHops          *uint32
@@ -60,11 +59,6 @@ func (d *httpListenerPolicy) Equals(in any) bool {
 		return false
 	}
 
-	// Check tracing
-	if !proto.Equal(d.tracing, d2.tracing) {
-		return false
-	}
-
 	// Check upgrade configs
 	if !slices.EqualFunc(d.upgradeConfigs, d2.upgradeConfigs, func(cfg, cfg2 *envoy_hcm.HttpConnectionManager_UpgradeConfig) bool {
 		return proto.Equal(cfg, cfg2)
@@ -155,11 +149,6 @@ func NewPlugin(ctx context.Context, commoncol *common.CommonCollections) extensi
 			logger.Error("error translating access log", "error", err)
 			errs = append(errs, err)
 		}
-		tracing, err := convertTracingConfig(ctx, i, commoncol, krtctx, objSrc)
-		if err != nil {
-			logger.Error("error translating tracing", "error", err)
-			errs = append(errs, err)
-		}
 
 		upgradeConfigs := convertUpgradeConfig(i)
 		serverHeaderTransformation := convertServerHeaderTransformation(i.Spec.ServerHeaderTransformation)
@@ -177,7 +166,6 @@ func NewPlugin(ctx context.Context, commoncol *common.CommonCollections) extensi
 			PolicyIR: &httpListenerPolicy{
 				ct:                         i.CreationTimestamp.Time,
 				accessLog:                  accessLog,
-				tracing:                    tracing,
 				upgradeConfigs:             upgradeConfigs,
 				useRemoteAddress:           i.Spec.UseRemoteAddress,
 				xffNumTrustedHops:          i.Spec.XffNumTrustedHops,
@@ -227,9 +215,6 @@ func (p *httpListenerPolicyPluginGwPass) ApplyHCM(
 	// translate access logging configuration
 	out.AccessLog = append(out.GetAccessLog(), policy.accessLog...)
 
-	// translate tracing configuration
-	out.Tracing = policy.tracing
-
 	// translate upgrade configuration
 	if policy.upgradeConfigs != nil {
 		out.UpgradeConfigs = append(out.GetUpgradeConfigs(), policy.upgradeConfigs...)
diff --git a/internal/kgateway/extensions2/plugins/httplistenerpolicy/tracing_converter.go b/internal/kgateway/extensions2/plugins/httplistenerpolicy/tracing_converter.go
deleted file mode 100644
index eac609d40..000000000
--- a/internal/kgateway/extensions2/plugins/httplistenerpolicy/tracing_converter.go
+++ /dev/null
@@ -1,262 +0,0 @@
-package httplistenerpolicy
-
-import (
-	"context"
-	"fmt"
-
-	corev3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
-	tracev3 "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3"
-	envoy_hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
-	resource_detectorsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/tracers/opentelemetry/resource_detectors/v3"
-	samplersv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/tracers/opentelemetry/samplers/v3"
-	metadatav3 "github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3"
-	tracingv3 "github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3"
-	typev3 "github.com/envoyproxy/go-control-plane/envoy/type/v3"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-	"istio.io/istio/pkg/kube/krt"
-
-	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
-)
-
-func convertTracingConfig(
-	ctx context.Context,
-	policy *v1alpha1.HTTPListenerPolicy,
-	commoncol *common.CommonCollections,
-	krtctx krt.HandlerContext,
-	parentSrc ir.ObjectSource,
-) (*envoy_hcm.HttpConnectionManager_Tracing, error) {
-	config := policy.Spec.Tracing
-	if config == nil {
-		return nil, nil
-	}
-
-	if config.Provider.OpenTelemetry.GrpcService.BackendRef == nil {
-		return nil, fmt.Errorf("Tracing.OpenTelemetryConfig.GrpcService.BackendRef must be specified")
-	}
-
-	backend, err := commoncol.BackendIndex.GetBackendFromRef(krtctx, parentSrc, config.Provider.OpenTelemetry.GrpcService.BackendRef.BackendObjectReference)
-	if err != nil {
-		return nil, fmt.Errorf("%w: %v", ErrUnresolvedBackendRef, err)
-	}
-
-	return translateTracing(config, backend)
-}
-
-func translateTracing(
-	config *v1alpha1.Tracing,
-	backend *ir.BackendObjectIR,
-) (*envoy_hcm.HttpConnectionManager_Tracing, error) {
-	if config == nil {
-		return nil, nil
-	}
-
-	if config.Provider.OpenTelemetry == nil || config.Provider.OpenTelemetry.GrpcService.BackendRef == nil {
-		return nil, fmt.Errorf("Tracing.OpenTelemetryConfig.GrpcService.BackendRef must be specified")
-	}
-
-	provider, err := convertOTelTracingConfig(config.Provider.OpenTelemetry, backend)
-	if err != nil {
-		return nil, err
-	}
-
-	tracingConfig := &envoy_hcm.HttpConnectionManager_Tracing{
-		Provider: provider,
-	}
-	if config.ClientSampling != nil {
-		tracingConfig.ClientSampling = &typev3.Percent{
-			Value: float64(*config.ClientSampling),
-		}
-	}
-	if config.RandomSampling != nil {
-		tracingConfig.RandomSampling = &typev3.Percent{
-			Value: float64(*config.RandomSampling),
-		}
-	}
-	if config.OverallSampling != nil {
-		tracingConfig.OverallSampling = &typev3.Percent{
-			Value: float64(*config.OverallSampling),
-		}
-	}
-	if config.Verbose != nil {
-		tracingConfig.Verbose = *config.Verbose
-	}
-	if config.MaxPathTagLength != nil {
-		tracingConfig.MaxPathTagLength = &wrapperspb.UInt32Value{
-			Value: *config.MaxPathTagLength,
-		}
-	}
-	if len(config.Attributes) != 0 {
-		tracingConfig.CustomTags = make([]*tracingv3.CustomTag, len(config.Attributes))
-		for i, ct := range config.Attributes {
-			if ct.Literal != nil {
-				tracingConfig.GetCustomTags()[i] = &tracingv3.CustomTag{
-					Tag: ct.Name,
-					Type: &tracingv3.CustomTag_Literal_{
-						Literal: &tracingv3.CustomTag_Literal{
-							Value: ct.Literal.Value,
-						},
-					},
-				}
-				continue
-			}
-
-			if ct.Environment != nil {
-				tagType := &tracingv3.CustomTag_Environment_{
-					Environment: &tracingv3.CustomTag_Environment{
-						Name: ct.Environment.Name,
-					},
-				}
-				if ct.Environment.DefaultValue != nil {
-					tagType.Environment.DefaultValue = *ct.Environment.DefaultValue
-				}
-
-				tracingConfig.GetCustomTags()[i] = &tracingv3.CustomTag{
-					Tag:  ct.Name,
-					Type: tagType,
-				}
-				continue
-			}
-
-			if ct.RequestHeader != nil {
-				tagType := &tracingv3.CustomTag_RequestHeader{
-					RequestHeader: &tracingv3.CustomTag_Header{
-						Name: ct.RequestHeader.Name,
-					},
-				}
-				if ct.RequestHeader.DefaultValue != nil {
-					tagType.RequestHeader.DefaultValue = *ct.RequestHeader.DefaultValue
-				}
-
-				tracingConfig.GetCustomTags()[i] = &tracingv3.CustomTag{
-					Tag:  ct.Name,
-					Type: tagType,
-				}
-				continue
-			}
-
-			if ct.Metadata != nil {
-				tagType := &tracingv3.CustomTag_Metadata_{
-					Metadata: &tracingv3.CustomTag_Metadata{
-						MetadataKey: &metadatav3.MetadataKey{
-							Key: ct.Metadata.MetadataKey.Key,
-						},
-					},
-				}
-
-				if len(ct.Metadata.MetadataKey.Path) != 0 {
-					paths := make([]*metadatav3.MetadataKey_PathSegment, len(ct.Metadata.MetadataKey.Path))
-					for i, p := range ct.Metadata.MetadataKey.Path {
-						paths[i] = &metadatav3.MetadataKey_PathSegment{
-							Segment: &metadatav3.MetadataKey_PathSegment_Key{
-								Key: p.Key,
-							},
-						}
-					}
-					tagType.Metadata.GetMetadataKey().Path = paths
-				}
-
-				switch ct.Metadata.Kind {
-				case v1alpha1.MetadataKindRequest:
-					tagType.Metadata.Kind = &metadatav3.MetadataKind{
-						Kind: &metadatav3.MetadataKind_Request_{
-							Request: &metadatav3.MetadataKind_Request{},
-						},
-					}
-				case v1alpha1.MetadataKindRoute:
-					tagType.Metadata.Kind = &metadatav3.MetadataKind{
-						Kind: &metadatav3.MetadataKind_Route_{
-							Route: &metadatav3.MetadataKind_Route{},
-						},
-					}
-				case v1alpha1.MetadataKindCluster:
-					tagType.Metadata.Kind = &metadatav3.MetadataKind{
-						Kind: &metadatav3.MetadataKind_Cluster_{
-							Cluster: &metadatav3.MetadataKind_Cluster{},
-						},
-					}
-				case v1alpha1.MetadataKindHost:
-					tagType.Metadata.Kind = &metadatav3.MetadataKind{
-						Kind: &metadatav3.MetadataKind_Host_{
-							Host: &metadatav3.MetadataKind_Host{},
-						},
-					}
-				}
-
-				if ct.Metadata.DefaultValue != nil {
-					tagType.Metadata.DefaultValue = *ct.Metadata.DefaultValue
-				}
-
-				tracingConfig.GetCustomTags()[i] = &tracingv3.CustomTag{
-					Tag:  ct.Name,
-					Type: tagType,
-				}
-				continue
-			}
-		}
-	}
-	if config.SpawnUpstreamSpan != nil {
-		tracingConfig.SpawnUpstreamSpan = &wrapperspb.BoolValue{
-			Value: *config.SpawnUpstreamSpan,
-		}
-	}
-
-	return tracingConfig, nil
-}
-
-func convertOTelTracingConfig(
-	config *v1alpha1.OpenTelemetryTracingConfig,
-	backend *ir.BackendObjectIR,
-) (*tracev3.Tracing_Http, error) {
-	if config == nil {
-		return nil, nil
-	}
-
-	envoyGrpcService, err := ToEnvoyGrpc(config.GrpcService, backend)
-	if err != nil {
-		return nil, err
-	}
-
-	tracingCfg := &tracev3.OpenTelemetryConfig{
-		GrpcService: envoyGrpcService,
-		ServiceName: config.ServiceName,
-	}
-
-	if len(config.ResourceDetectors) != 0 {
-		translatedResourceDetectors := make([]*corev3.TypedExtensionConfig, len(config.ResourceDetectors))
-		for i, rd := range config.ResourceDetectors {
-			if rd.EnvironmentResourceDetector != nil {
-				detector, _ := utils.MessageToAny(&resource_detectorsv3.EnvironmentResourceDetectorConfig{})
-				translatedResourceDetectors[i] = &corev3.TypedExtensionConfig{
-					Name:        "envoy.tracers.opentelemetry.resource_detectors.environment",
-					TypedConfig: detector,
-				}
-			}
-		}
-		tracingCfg.ResourceDetectors = translatedResourceDetectors
-	}
-
-	if config.Sampler != nil {
-		if config.Sampler.AlwaysOn != nil {
-			alwaysOnSampler, _ := utils.MessageToAny(&samplersv3.AlwaysOnSamplerConfig{})
-			tracingCfg.Sampler = &corev3.TypedExtensionConfig{
-				Name:        "envoy.tracers.opentelemetry.samplers.always_on",
-				TypedConfig: alwaysOnSampler,
-			}
-		}
-	}
-
-	otelCfg, err := utils.MessageToAny(tracingCfg)
-	if err != nil {
-		return nil, err
-	}
-
-	return &tracev3.Tracing_Http{
-		Name: "envoy.tracers.opentelemetry",
-		ConfigType: &tracev3.Tracing_Http_TypedConfig{
-			TypedConfig: otelCfg,
-		},
-	}, nil
-}
diff --git a/internal/kgateway/extensions2/plugins/httplistenerpolicy/tracing_listener_plugin_test.go b/internal/kgateway/extensions2/plugins/httplistenerpolicy/tracing_listener_plugin_test.go
deleted file mode 100644
index 1bf9aad16..000000000
--- a/internal/kgateway/extensions2/plugins/httplistenerpolicy/tracing_listener_plugin_test.go
+++ /dev/null
@@ -1,410 +0,0 @@
-package httplistenerpolicy
-
-import (
-	"context"
-	"testing"
-
-	corev3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
-	tracev3 "github.com/envoyproxy/go-control-plane/envoy/config/trace/v3"
-	envoy_hcm "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
-	resource_detectorsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/tracers/opentelemetry/resource_detectors/v3"
-	samplersv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/tracers/opentelemetry/samplers/v3"
-	metadatav3 "github.com/envoyproxy/go-control-plane/envoy/type/metadata/v3"
-	tracingv3 "github.com/envoyproxy/go-control-plane/envoy/type/tracing/v3"
-	typev3 "github.com/envoyproxy/go-control-plane/envoy/type/v3"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/protobuf/proto"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-	"k8s.io/utils/pointer"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
-)
-
-func TestTracingConverter(t *testing.T) {
-	t.Run("Tracing Conversion", func(t *testing.T) {
-		testCases := []struct {
-			name     string
-			config   *v1alpha1.Tracing
-			expected *envoy_hcm.HttpConnectionManager_Tracing
-		}{
-			{
-				name:     "NilConfig",
-				config:   nil,
-				expected: nil,
-			},
-			{
-				name: "OTel Tracing minimal config",
-				config: &v1alpha1.Tracing{
-					Provider: v1alpha1.TracingProvider{
-						OpenTelemetry: &v1alpha1.OpenTelemetryTracingConfig{
-							GrpcService: v1alpha1.CommonGrpcService{
-								BackendRef: &gwv1.BackendRef{
-									BackendObjectReference: gwv1.BackendObjectReference{
-										Name: "test-service",
-									},
-								},
-							},
-							ServiceName: "my:service",
-						},
-					},
-				},
-				expected: &envoy_hcm.HttpConnectionManager_Tracing{
-					Provider: &tracev3.Tracing_Http{
-						Name: "envoy.tracers.opentelemetry",
-						ConfigType: &tracev3.Tracing_Http_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &tracev3.OpenTelemetryConfig{
-								GrpcService: &corev3.GrpcService{
-									TargetSpecifier: &corev3.GrpcService_EnvoyGrpc_{
-										EnvoyGrpc: &corev3.GrpcService_EnvoyGrpc{
-											ClusterName: "backend_default_test-service_0",
-										},
-									},
-								},
-								ServiceName: "my:service",
-							}),
-						},
-					},
-				},
-			},
-			{
-				name: "OTel Tracing with nil attributes",
-				config: &v1alpha1.Tracing{
-					Provider: v1alpha1.TracingProvider{
-						OpenTelemetry: &v1alpha1.OpenTelemetryTracingConfig{
-							GrpcService: v1alpha1.CommonGrpcService{
-								BackendRef: &gwv1.BackendRef{
-									BackendObjectReference: gwv1.BackendObjectReference{
-										Name: "test-service",
-									},
-								},
-							},
-							ServiceName: "my:service",
-						},
-					},
-					Attributes: nil,
-				},
-				expected: &envoy_hcm.HttpConnectionManager_Tracing{
-					Provider: &tracev3.Tracing_Http{
-						Name: "envoy.tracers.opentelemetry",
-						ConfigType: &tracev3.Tracing_Http_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &tracev3.OpenTelemetryConfig{
-								GrpcService: &corev3.GrpcService{
-									TargetSpecifier: &corev3.GrpcService_EnvoyGrpc_{
-										EnvoyGrpc: &corev3.GrpcService_EnvoyGrpc{
-											ClusterName: "backend_default_test-service_0",
-										},
-									},
-								},
-								ServiceName: "my:service",
-							}),
-						},
-					},
-				},
-			},
-			{
-				name: "OTel Tracing with nil attributes",
-				config: &v1alpha1.Tracing{
-					Provider: v1alpha1.TracingProvider{
-						OpenTelemetry: &v1alpha1.OpenTelemetryTracingConfig{
-							GrpcService: v1alpha1.CommonGrpcService{
-								BackendRef: &gwv1.BackendRef{
-									BackendObjectReference: gwv1.BackendObjectReference{
-										Name: "test-service",
-									},
-								},
-							},
-							ServiceName: "my:service",
-						},
-					},
-					Attributes: []v1alpha1.CustomAttribute{},
-				},
-				expected: &envoy_hcm.HttpConnectionManager_Tracing{
-					Provider: &tracev3.Tracing_Http{
-						Name: "envoy.tracers.opentelemetry",
-						ConfigType: &tracev3.Tracing_Http_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &tracev3.OpenTelemetryConfig{
-								GrpcService: &corev3.GrpcService{
-									TargetSpecifier: &corev3.GrpcService_EnvoyGrpc_{
-										EnvoyGrpc: &corev3.GrpcService_EnvoyGrpc{
-											ClusterName: "backend_default_test-service_0",
-										},
-									},
-								},
-								ServiceName: "my:service",
-							}),
-						},
-					},
-					CustomTags: []*tracingv3.CustomTag{},
-				},
-			},
-			{
-				name: "OTel Tracing full config",
-				config: &v1alpha1.Tracing{
-					Provider: v1alpha1.TracingProvider{
-						OpenTelemetry: &v1alpha1.OpenTelemetryTracingConfig{
-							GrpcService: v1alpha1.CommonGrpcService{
-								BackendRef: &gwv1.BackendRef{
-									BackendObjectReference: gwv1.BackendObjectReference{
-										Name: "test-service",
-									},
-								},
-							},
-							ServiceName: "my:service",
-							ResourceDetectors: []v1alpha1.ResourceDetector{{
-								EnvironmentResourceDetector: &v1alpha1.EnvironmentResourceDetectorConfig{},
-							}},
-							Sampler: &v1alpha1.Sampler{
-								AlwaysOn: &v1alpha1.AlwaysOnConfig{},
-							},
-						},
-					},
-					ClientSampling:   pointer.Uint32(45),
-					RandomSampling:   pointer.Uint32(55),
-					OverallSampling:  pointer.Uint32(65),
-					Verbose:          pointer.Bool(true),
-					MaxPathTagLength: pointer.Uint32(127),
-					Attributes: []v1alpha1.CustomAttribute{
-						{
-							Name: "Literal",
-							Literal: &v1alpha1.CustomAttributeLiteral{
-								Value: "Literal Value",
-							},
-						},
-						{
-							Name: "Environment",
-							Environment: &v1alpha1.CustomAttributeEnvironment{
-								Name:         "Env",
-								DefaultValue: pointer.String("Environment Value"),
-							},
-						},
-						{
-							Name: "Request Header",
-							RequestHeader: &v1alpha1.CustomAttributeHeader{
-								Name:         "Header",
-								DefaultValue: pointer.String("Request"),
-							},
-						},
-						{
-							Name: "Metadata Request",
-							Metadata: &v1alpha1.CustomAttributeMetadata{
-								Kind: v1alpha1.MetadataKindRequest,
-								MetadataKey: v1alpha1.MetadataKey{
-									Key: "Request",
-									Path: []v1alpha1.MetadataPathSegment{{
-										Key: "Request-key",
-									}},
-								},
-							},
-						},
-						{
-							Name: "Metadata Route",
-							Metadata: &v1alpha1.CustomAttributeMetadata{
-								Kind: v1alpha1.MetadataKindRoute,
-								MetadataKey: v1alpha1.MetadataKey{
-									Key: "Route",
-									Path: []v1alpha1.MetadataPathSegment{{
-										Key: "Route-key",
-									}},
-								},
-							},
-						},
-						{
-							Name: "Metadata Cluster",
-							Metadata: &v1alpha1.CustomAttributeMetadata{
-								Kind: v1alpha1.MetadataKindCluster,
-								MetadataKey: v1alpha1.MetadataKey{
-									Key: "Cluster",
-									Path: []v1alpha1.MetadataPathSegment{{
-										Key: "Cluster-key",
-									}},
-								},
-							},
-						},
-						{
-							Name: "Metadata Host",
-							Metadata: &v1alpha1.CustomAttributeMetadata{
-								Kind: v1alpha1.MetadataKindHost,
-								MetadataKey: v1alpha1.MetadataKey{
-									Key: "Host",
-									Path: []v1alpha1.MetadataPathSegment{{
-										Key: "Host-key-1",
-									}, {
-										Key: "Host-key-2",
-									}},
-								},
-							},
-						},
-					},
-					SpawnUpstreamSpan: pointer.Bool(true),
-				},
-				expected: &envoy_hcm.HttpConnectionManager_Tracing{
-					Provider: &tracev3.Tracing_Http{
-						Name: "envoy.tracers.opentelemetry",
-						ConfigType: &tracev3.Tracing_Http_TypedConfig{
-							TypedConfig: mustMessageToAny(t, &tracev3.OpenTelemetryConfig{
-								GrpcService: &corev3.GrpcService{
-									TargetSpecifier: &corev3.GrpcService_EnvoyGrpc_{
-										EnvoyGrpc: &corev3.GrpcService_EnvoyGrpc{
-											ClusterName: "backend_default_test-service_0",
-										},
-									},
-								},
-								ServiceName: "my:service",
-								ResourceDetectors: []*corev3.TypedExtensionConfig{{
-									Name:        "envoy.tracers.opentelemetry.resource_detectors.environment",
-									TypedConfig: mustMessageToAny(t, &resource_detectorsv3.EnvironmentResourceDetectorConfig{}),
-								}},
-								Sampler: &corev3.TypedExtensionConfig{
-									Name:        "envoy.tracers.opentelemetry.samplers.always_on",
-									TypedConfig: mustMessageToAny(t, &samplersv3.AlwaysOnSamplerConfig{}),
-								},
-							}),
-						},
-					},
-					ClientSampling:   &typev3.Percent{Value: 45},
-					RandomSampling:   &typev3.Percent{Value: 55},
-					OverallSampling:  &typev3.Percent{Value: 65},
-					Verbose:          true,
-					MaxPathTagLength: &wrapperspb.UInt32Value{Value: 127},
-					CustomTags: []*tracingv3.CustomTag{
-						{
-							Tag: "Literal",
-							Type: &tracingv3.CustomTag_Literal_{
-								Literal: &tracingv3.CustomTag_Literal{
-									Value: "Literal Value",
-								},
-							},
-						},
-						{
-							Tag: "Environment",
-							Type: &tracingv3.CustomTag_Environment_{
-								Environment: &tracingv3.CustomTag_Environment{
-									Name:         "Env",
-									DefaultValue: "Environment Value",
-								},
-							},
-						},
-						{
-							Tag: "Request Header",
-							Type: &tracingv3.CustomTag_RequestHeader{
-								RequestHeader: &tracingv3.CustomTag_Header{
-									Name:         "Header",
-									DefaultValue: "Request",
-								},
-							},
-						},
-						{
-							Tag: "Metadata Request",
-							Type: &tracingv3.CustomTag_Metadata_{
-								Metadata: &tracingv3.CustomTag_Metadata{
-									Kind: &metadatav3.MetadataKind{
-										Kind: &metadatav3.MetadataKind_Request_{
-											Request: &metadatav3.MetadataKind_Request{},
-										},
-									},
-									MetadataKey: &metadatav3.MetadataKey{
-										Key: "Request",
-										Path: []*metadatav3.MetadataKey_PathSegment{{
-											Segment: &metadatav3.MetadataKey_PathSegment_Key{
-												Key: "Request-key",
-											},
-										}},
-									},
-								},
-							},
-						},
-						{
-							Tag: "Metadata Route",
-							Type: &tracingv3.CustomTag_Metadata_{
-								Metadata: &tracingv3.CustomTag_Metadata{
-									Kind: &metadatav3.MetadataKind{
-										Kind: &metadatav3.MetadataKind_Route_{
-											Route: &metadatav3.MetadataKind_Route{},
-										},
-									},
-									MetadataKey: &metadatav3.MetadataKey{
-										Key: "Route",
-										Path: []*metadatav3.MetadataKey_PathSegment{{
-											Segment: &metadatav3.MetadataKey_PathSegment_Key{
-												Key: "Route-key",
-											},
-										}},
-									},
-								},
-							},
-						},
-						{
-							Tag: "Metadata Cluster",
-							Type: &tracingv3.CustomTag_Metadata_{
-								Metadata: &tracingv3.CustomTag_Metadata{
-									Kind: &metadatav3.MetadataKind{
-										Kind: &metadatav3.MetadataKind_Cluster_{
-											Cluster: &metadatav3.MetadataKind_Cluster{},
-										},
-									},
-									MetadataKey: &metadatav3.MetadataKey{
-										Key: "Cluster",
-										Path: []*metadatav3.MetadataKey_PathSegment{{
-											Segment: &metadatav3.MetadataKey_PathSegment_Key{
-												Key: "Cluster-key",
-											},
-										}},
-									},
-								},
-							},
-						},
-						{
-							Tag: "Metadata Host",
-							Type: &tracingv3.CustomTag_Metadata_{
-								Metadata: &tracingv3.CustomTag_Metadata{
-									Kind: &metadatav3.MetadataKind{
-										Kind: &metadatav3.MetadataKind_Host_{
-											Host: &metadatav3.MetadataKind_Host{},
-										},
-									},
-									MetadataKey: &metadatav3.MetadataKey{
-										Key: "Host",
-										Path: []*metadatav3.MetadataKey_PathSegment{{
-											Segment: &metadatav3.MetadataKey_PathSegment_Key{
-												Key: "Host-key-1",
-											}}, {
-											Segment: &metadatav3.MetadataKey_PathSegment_Key{
-												Key: "Host-key-2",
-											}},
-										},
-									},
-								},
-							},
-						},
-					},
-					SpawnUpstreamSpan: &wrapperspb.BoolValue{Value: true},
-				},
-			},
-		}
-		for _, tc := range testCases {
-			_, cancel := context.WithCancel(context.Background())
-			t.Cleanup(cancel)
-
-			t.Run(tc.name, func(t *testing.T) {
-				result, err := translateTracing(
-					tc.config,
-					&ir.BackendObjectIR{
-						ObjectSource: ir.ObjectSource{
-							Kind:      "Backend",
-							Name:      "test-service",
-							Namespace: "default",
-						},
-					},
-				)
-				require.NoError(t, err, "failed to convert access log config")
-				if tc.expected != nil {
-					assert.True(t, proto.Equal(tc.expected, result),
-						"Tracing config mismatch\n %v\n %v\n", tc.expected, result)
-				}
-			})
-		}
-	})
-}
diff --git a/internal/kgateway/extensions2/plugins/kubernetes/k8s.go b/internal/kgateway/extensions2/plugins/kubernetes/k8s.go
index 0191434a8..d08a67101 100644
--- a/internal/kgateway/extensions2/plugins/kubernetes/k8s.go
+++ b/internal/kgateway/extensions2/plugins/kubernetes/k8s.go
@@ -32,7 +32,7 @@ func NewPlugin(ctx context.Context, commonCol *common.CommonCollections) extensi
 		kclient.Filter{ObjectFilter: commonCol.Client.ObjectFilter()},
 	)
 	endpointSlices := krt.WrapClient(epSliceClient, commonCol.KrtOpts.ToOptions("EndpointSlices")...)
-	return NewPluginFromCollections(ctx, commonCol.KrtOpts, commonCol.Pods, commonCol.Services, endpointSlices, commonCol.Settings)
+	return NewPluginFromCollections(ctx, commonCol.KrtOpts, commonCol.LocalityPods, commonCol.Services, endpointSlices, commonCol.Settings)
 }
 
 func NewPluginFromCollections(
diff --git a/internal/kgateway/extensions2/plugins/serviceentry/collections.go b/internal/kgateway/extensions2/plugins/serviceentry/collections.go
index 6a9d01c08..b620950c7 100644
--- a/internal/kgateway/extensions2/plugins/serviceentry/collections.go
+++ b/internal/kgateway/extensions2/plugins/serviceentry/collections.go
@@ -65,7 +65,7 @@ func (s seSelector) Equals(in seSelector) bool {
 	return metaEqual && proto.Equal(&s.ServiceEntry.Spec, &in.ServiceEntry.Spec)
 }
 
-// selectedWorkload adds the following to LocalityPod:
+// selectedWorkload adds the following to Pods:
 // * fields specific to workload entry (portMapping, network, weight)
 // * selectedBy pointers to the selecting ServiceEntries
 // Usable with FilterSelect
@@ -137,7 +137,7 @@ func initServiceEntryCollections(
 	SelectedWorkloads, selectedWorkloadsIndex := selectedWorkloads(
 		SelectingServiceEntries,
 		WorkloadEntries,
-		commonCols.Pods,
+		commonCols.LocalityPods,
 		opts.Aliaser,
 	)
 
@@ -197,7 +197,7 @@ func selectedWorkloads(
 		return namespaces.UnsortedList()
 	})
 
-	// WorkloadEntries: selection logic and conver to LocalityPod
+	// WorkloadEntries: selection logic and convert to Pod
 	selectedWorkloadEntries := krt.NewCollection(WorkloadEntries, func(ctx krt.HandlerContext, we *networkingclient.WorkloadEntry) *selectedWorkload {
 		// find all the SEs that select this we
 		// if there are none, we can stop early
diff --git a/internal/kgateway/extensions2/plugins/trafficpolicy/buffer.go b/internal/kgateway/extensions2/plugins/trafficpolicy/buffer.go
deleted file mode 100644
index d84ff437b..000000000
--- a/internal/kgateway/extensions2/plugins/trafficpolicy/buffer.go
+++ /dev/null
@@ -1,69 +0,0 @@
-package trafficpolicy
-
-import (
-	"math"
-
-	bufferv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/buffer/v3"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-
-	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
-)
-
-const bufferFilterName = "envoy.filters.http.buffer"
-
-type BufferIR struct {
-	maxRequestBytes uint32
-}
-
-func (b *BufferIR) Equals(other *BufferIR) bool {
-	if b == nil && other == nil {
-		return true
-	}
-	if b == nil || other == nil {
-		return false
-	}
-
-	return b.maxRequestBytes == other.maxRequestBytes
-}
-
-// bufferForSpec translates the buffer spec into an envoy buffer policy and stores it in the traffic policy IR
-func bufferForSpec(spec v1alpha1.TrafficPolicySpec, out *trafficPolicySpecIr) {
-	if spec.Buffer == nil {
-		return
-	}
-
-	out.buffer = &BufferIR{
-		maxRequestBytes: uint32(spec.Buffer.MaxRequestSize.Value()),
-	}
-}
-
-func (p *trafficPolicyPluginGwPass) handleBuffer(fcn string, pCtxTypedFilterConfig *ir.TypedFilterConfigMap, buffer *BufferIR) {
-	if buffer == nil {
-		return
-	}
-
-	// Add buffer configuration to the typed_per_filter_config for route-level override
-	bufferPerRoute := &bufferv3.BufferPerRoute{
-		Override: &bufferv3.BufferPerRoute_Buffer{
-			Buffer: &bufferv3.Buffer{
-				MaxRequestBytes: &wrapperspb.UInt32Value{Value: buffer.maxRequestBytes},
-			},
-		},
-	}
-	pCtxTypedFilterConfig.AddTypedConfig(bufferFilterName, bufferPerRoute)
-
-	// Add a filter to the chain. When having a buffer policy for a route we need to also have a
-	// globally disabled buffer filter in the chain otherwise it will be ignored.
-	if p.bufferInChain == nil {
-		p.bufferInChain = make(map[string]*bufferv3.Buffer)
-	}
-	if _, ok := p.bufferInChain[fcn]; !ok {
-		p.bufferInChain[fcn] = &bufferv3.Buffer{
-			MaxRequestBytes: &wrapperspb.UInt32Value{Value: math.MaxUint32},
-		}
-	}
-}
-
-// need to add disabled buffer to the filter chain
-// enable on route
diff --git a/internal/kgateway/extensions2/plugins/trafficpolicy/buffer_test.go b/internal/kgateway/extensions2/plugins/trafficpolicy/buffer_test.go
deleted file mode 100644
index 37e900f1f..000000000
--- a/internal/kgateway/extensions2/plugins/trafficpolicy/buffer_test.go
+++ /dev/null
@@ -1,101 +0,0 @@
-package trafficpolicy
-
-import (
-	"testing"
-
-	"github.com/stretchr/testify/assert"
-	"k8s.io/apimachinery/pkg/api/resource"
-	"k8s.io/utils/ptr"
-
-	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-)
-
-func TestBufferForSpec(t *testing.T) {
-	tests := []struct {
-		name     string
-		spec     v1alpha1.TrafficPolicySpec
-		expected *BufferIR
-	}{
-		{
-			name:     "nil buffer spec",
-			spec:     v1alpha1.TrafficPolicySpec{},
-			expected: nil,
-		},
-		{
-			name: "valid buffer spec",
-			spec: v1alpha1.TrafficPolicySpec{
-				Buffer: &v1alpha1.Buffer{
-					MaxRequestSize: ptr.To(resource.MustParse("1Ki")),
-				},
-			},
-			expected: &BufferIR{
-				maxRequestBytes: 1024,
-			},
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			out := &trafficPolicySpecIr{}
-			bufferForSpec(tt.spec, out)
-
-			if tt.expected == nil {
-				assert.Nil(t, out.buffer)
-			} else {
-				assert.NotNil(t, out.buffer)
-				assert.Equal(t, tt.expected.maxRequestBytes, out.buffer.maxRequestBytes)
-			}
-		})
-	}
-}
-
-func TestBufferIREquals(t *testing.T) {
-	tests := []struct {
-		name     string
-		b1       *BufferIR
-		b2       *BufferIR
-		expected bool
-	}{
-		{
-			name:     "both nil",
-			b1:       nil,
-			b2:       nil,
-			expected: true,
-		},
-		{
-			name: "one nil",
-			b1:   nil,
-			b2: &BufferIR{
-				maxRequestBytes: 1024,
-			},
-			expected: false,
-		},
-		{
-			name: "equal buffers",
-			b1: &BufferIR{
-				maxRequestBytes: 1024,
-			},
-			b2: &BufferIR{
-				maxRequestBytes: 1024,
-			},
-			expected: true,
-		},
-		{
-			name: "different max request bytes",
-			b1: &BufferIR{
-				maxRequestBytes: 1024,
-			},
-			b2: &BufferIR{
-				maxRequestBytes: 2048,
-			},
-			expected: false,
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			result := tt.b1.Equals(tt.b2)
-			assert.Equal(t, tt.expected, result)
-		})
-	}
-}
diff --git a/internal/kgateway/extensions2/plugins/trafficpolicy/builder.go b/internal/kgateway/extensions2/plugins/trafficpolicy/builder.go
index 601c3f941..36425e949 100644
--- a/internal/kgateway/extensions2/plugins/trafficpolicy/builder.go
+++ b/internal/kgateway/extensions2/plugins/trafficpolicy/builder.go
@@ -104,8 +104,6 @@ func (b *TrafficPolicyBuilder) Translate(
 		errors = append(errors, err)
 	}
 
-	bufferForSpec(policyCR.Spec, &outSpec)
-
 	for _, err := range errors {
 		logger.Error("error translating gateway extension", "namespace", policyCR.GetNamespace(), "name", policyCR.GetName(), "error", err)
 	}
diff --git a/internal/kgateway/extensions2/plugins/trafficpolicy/cors_policy.go b/internal/kgateway/extensions2/plugins/trafficpolicy/cors_policy.go
index f99f43918..4fe38a81b 100644
--- a/internal/kgateway/extensions2/plugins/trafficpolicy/cors_policy.go
+++ b/internal/kgateway/extensions2/plugins/trafficpolicy/cors_policy.go
@@ -7,7 +7,7 @@ import (
 
 	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
 )
 
 type CorsIR struct {
@@ -32,7 +32,7 @@ func corsForSpec(spec v1alpha1.TrafficPolicySpec, out *trafficPolicySpecIr) erro
 		return nil
 	}
 	out.cors = &CorsIR{
-		corsConfig: utils.ToEnvoyCorsPolicy(spec.Cors.HTTPCORSFilter),
+		corsConfig: krtcollections.ToEnvoyCorsPolicy(spec.Cors.HTTPCORSFilter),
 	}
 	return nil
 }
diff --git a/internal/kgateway/extensions2/plugins/trafficpolicy/traffic_policy_plugin.go b/internal/kgateway/extensions2/plugins/trafficpolicy/traffic_policy_plugin.go
index 7f5ac5b9e..7552d0800 100644
--- a/internal/kgateway/extensions2/plugins/trafficpolicy/traffic_policy_plugin.go
+++ b/internal/kgateway/extensions2/plugins/trafficpolicy/traffic_policy_plugin.go
@@ -10,7 +10,6 @@ import (
 
 	routev3 "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
 	exteniondynamicmodulev3 "github.com/envoyproxy/go-control-plane/envoy/extensions/dynamic_modules/v3"
-	bufferv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/buffer/v3"
 	corsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/cors/v3"
 	envoy_csrf_v3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/csrf/v3"
 	dynamicmodulesv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/dynamic_modules/v3"
@@ -86,7 +85,6 @@ type trafficPolicySpecIr struct {
 	rateLimit                  *GlobalRateLimitIR
 	cors                       *CorsIR
 	csrf                       *CsrfIR
-	buffer                     *BufferIR
 }
 
 func (d *TrafficPolicy) CreationTime() time.Time {
@@ -152,10 +150,6 @@ func (d *TrafficPolicy) Equals(in any) bool {
 		return false
 	}
 
-	if !d.spec.buffer.Equals(d2.spec.buffer) {
-		return false
-	}
-
 	return true
 }
 
@@ -173,7 +167,6 @@ type trafficPolicyPluginGwPass struct {
 	rateLimitPerProvider  ProviderNeededMap
 	corsInChain           map[string]*corsv3.Cors
 	csrfInChain           map[string]*envoy_csrf_v3.CsrfPolicy
-	bufferInChain         map[string]*bufferv3.Buffer
 }
 
 var _ ir.ProxyTranslationPass = &trafficPolicyPluginGwPass{}
@@ -530,16 +523,6 @@ func (p *trafficPolicyPluginGwPass) HttpFilters(ctx context.Context, fcc ir.Filt
 		filters = append(filters, filter)
 	}
 
-	// Add Buffer filter to enable buffer for the listener.
-	// Requires the buffer policy to be set as typed_per_filter_config.
-	if p.bufferInChain[fcc.FilterChainName] != nil {
-		filter := plugins.MustNewStagedFilter(bufferFilterName,
-			p.bufferInChain[fcc.FilterChainName],
-			plugins.DuringStage(plugins.RouteStage))
-		filter.Filter.Disabled = true
-		filters = append(filters, filter)
-	}
-
 	if len(filters) == 0 {
 		return nil, nil
 	}
@@ -562,8 +545,6 @@ func (p *trafficPolicyPluginGwPass) handlePolicies(fcn string, typedFilterConfig
 
 	// Apply CSRF configuration if present
 	p.handleCsrf(fcn, typedFilterConfig, spec.csrf)
-
-	p.handleBuffer(fcn, typedFilterConfig, spec.buffer)
 }
 
 func (p *trafficPolicyPluginGwPass) SupportsPolicyMerge() bool {
@@ -681,12 +662,5 @@ func MergeTrafficPolicies(
 		p1.spec.csrf = p2.spec.csrf
 		mergeOrigins["csrf"] = p2Ref
 	}
-
-	// Handle buffer policy merging
-	if policy.IsMergeable(p1.spec.buffer, p2.spec.buffer, mergeOpts) {
-		p1.spec.buffer = p2.spec.buffer
-		mergeOrigins["buffer"] = p2Ref
-	}
-
 	return mergeOrigins
 }
diff --git a/internal/kgateway/extensions2/plugins/waypoint/filters.go b/internal/kgateway/extensions2/plugins/waypoint/filters.go
index ac3d2094a..a8d985cb6 100644
--- a/internal/kgateway/extensions2/plugins/waypoint/filters.go
+++ b/internal/kgateway/extensions2/plugins/waypoint/filters.go
@@ -1,9 +1,10 @@
 package waypoint
 
 import (
+	"google.golang.org/protobuf/types/known/anypb"
+
 	listenerv3 "github.com/envoyproxy/go-control-plane/envoy/config/listener/v3"
 	hcmv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3"
-	"google.golang.org/protobuf/types/known/anypb"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/filters"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/plugins"
diff --git a/internal/kgateway/extensions2/plugins/waypoint/plugin.go b/internal/kgateway/extensions2/plugins/waypoint/plugin.go
index c1070201e..39fea6dbf 100644
--- a/internal/kgateway/extensions2/plugins/waypoint/plugin.go
+++ b/internal/kgateway/extensions2/plugins/waypoint/plugin.go
@@ -3,14 +3,15 @@ package waypoint
 import (
 	"context"
 
-	envoy_config_cluster_v3 "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
-	envoy_config_core_v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
-	envoy_config_endpoint_v3 "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
 	istioannot "istio.io/api/annotation"
 	"istio.io/istio/pkg/kube/krt"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
+	envoy_config_cluster_v3 "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
+	envoy_config_core_v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	envoy_config_endpoint_v3 "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	extensionsplug "github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/plugin"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/plugins/waypoint/waypointquery"
diff --git a/internal/kgateway/extensions2/plugins/waypoint/rbac.go b/internal/kgateway/extensions2/plugins/waypoint/rbac.go
index 513cbcd21..7ca37bffe 100644
--- a/internal/kgateway/extensions2/plugins/waypoint/rbac.go
+++ b/internal/kgateway/extensions2/plugins/waypoint/rbac.go
@@ -3,6 +3,7 @@ package waypoint
 import (
 	"fmt"
 
+	"github.com/caarlos0/log"
 	"google.golang.org/protobuf/types/known/anypb"
 	authpb "istio.io/api/security/v1"
 	authcr "istio.io/client-go/pkg/apis/security/v1"
@@ -15,6 +16,7 @@ import (
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/plugins/waypoint/waypointquery"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/filters"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 )
 
@@ -38,6 +40,7 @@ func BuildRBAC(
 ) {
 	// Deduplicate and separate policies by action
 	policyResult := separateAndDeduplicatePolicies(authzPolicies)
+
 	// If no policies are applicable, return early
 	if len(policyResult.Deny) == 0 && len(policyResult.Allow) == 0 &&
 		len(policyResult.Audit) == 0 && len(policyResult.Custom) == 0 {
@@ -55,10 +58,11 @@ func BuildRBAC(
 	const predicate = filters.FilterStage_After
 
 	tcpFilters := authzBuilder.BuildTCP()
+	httpFilters := authzBuilder.BuildHTTP()
+
 	if len(tcpFilters) > 0 {
 		tcpRBAC = append(tcpRBAC, CustomNetworkFilters(tcpFilters, stage, predicate)...)
 	}
-	httpFilters := authzBuilder.BuildHTTP()
 	if len(httpFilters) > 0 {
 		httpRBAC = append(httpRBAC, CustomHTTPFilters(httpFilters, stage, predicate)...)
 	}
@@ -66,33 +70,31 @@ func BuildRBAC(
 }
 
 func applyHTTPRBACFilters(httpChain *ir.HttpFilterChainIR, httpRBAC []*ir.CustomEnvoyFilter) {
-	if len(httpRBAC) == 0 {
-		return
-	}
 	// Apply RBAC filters regardless of the presence of proxy_protocol_authority
-	// Initialize CustomHTTPFilters if it's nil
-	if httpChain.CustomHTTPFilters == nil {
-		httpChain.CustomHTTPFilters = []ir.CustomEnvoyFilter{}
-	}
+	if len(httpRBAC) > 0 {
+		// Initialize CustomHTTPFilters if it's nil
+		if httpChain.CustomHTTPFilters == nil {
+			httpChain.CustomHTTPFilters = []ir.CustomEnvoyFilter{}
+		}
 
-	// Add RBAC filters to CustomHTTPFilters
-	for _, f := range httpRBAC {
-		httpChain.CustomHTTPFilters = append(httpChain.CustomHTTPFilters, *f)
+		// Add RBAC filters to CustomHTTPFilters
+		for _, f := range httpRBAC {
+			httpChain.CustomHTTPFilters = append(httpChain.CustomHTTPFilters, *f)
+		}
 	}
 }
 
 func applyTCPRBACFilters(tcpChain *ir.TcpIR, tcpRBAC []*ir.CustomEnvoyFilter, svc waypointquery.Service) {
-	if len(tcpRBAC) == 0 {
-		return
-	}
 	// Apply RBAC filters regardless of the presence of proxy_protocol_authority
-	if tcpChain.NetworkFilters == nil {
-		tcpChain.NetworkFilters = []*anypb.Any{}
-	}
+	if len(tcpRBAC) > 0 {
+		if tcpChain.NetworkFilters == nil {
+			tcpChain.NetworkFilters = []*anypb.Any{}
+		}
 
-	// Add RBAC filters as built-in network filters
-	for _, f := range tcpRBAC {
-		tcpChain.NetworkFilters = append(tcpChain.NetworkFilters, f.Config)
+		// Add RBAC filters as built-in network filters
+		for _, f := range tcpRBAC {
+			tcpChain.NetworkFilters = append(tcpChain.NetworkFilters, f.Config)
+		}
 	}
 }
 
@@ -134,11 +136,8 @@ func separateAndDeduplicatePolicies(policies []*authcr.AuthorizationPolicy) mode
 			result.Custom = append(result.Custom, convertedPolicy)
 		default:
 			// Log error for unsupported action
-			logger.Error("ignored authorization policy",
-				"namespace", policy.GetNamespace(),
-				"name", policy.GetName(),
-				"action", convertedSpec.GetAction(),
-			)
+			log.Errorf("ignored authorization policy %s.%s with unsupported action: %s",
+				policy.GetNamespace(), policy.GetName(), convertedSpec.GetAction())
 		}
 	}
 
diff --git a/internal/kgateway/extensions2/plugins/waypoint/waypoint_translator.go b/internal/kgateway/extensions2/plugins/waypoint/waypoint_translator.go
index ac1976ac7..759965f11 100644
--- a/internal/kgateway/extensions2/plugins/waypoint/waypoint_translator.go
+++ b/internal/kgateway/extensions2/plugins/waypoint/waypoint_translator.go
@@ -7,9 +7,6 @@ import (
 
 	"google.golang.org/protobuf/types/known/wrapperspb"
 	authcr "istio.io/client-go/pkg/apis/security/v1"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/util/sets"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
@@ -27,6 +24,10 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	reports "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/stringutils"
+
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/sets"
 )
 
 const (
@@ -39,7 +40,7 @@ const (
 	wildcardBindAddrV6 = "::"
 )
 
-var logger = logging.New("plugin/waypoint")
+var _ extensionsplug.KGwTranslator = &waypointTranslator{}
 
 type waypointTranslator struct {
 	queries         query.GatewayQueries
@@ -50,8 +51,6 @@ type waypointTranslator struct {
 	bindIpv6      bool
 }
 
-var _ extensionsplug.KGwTranslator = &waypointTranslator{}
-
 func NewTranslator(
 	queries query.GatewayQueries,
 	waypointQueries waypointquery.WaypointQueries,
@@ -66,6 +65,8 @@ func NewTranslator(
 	}
 }
 
+var logger = logging.New("plugin/waypoint")
+
 // Translate implements extensionsplug.KGwTranslator.
 func (w *waypointTranslator) Translate(
 	kctx krt.HandlerContext,
diff --git a/internal/kgateway/extensions2/pluginutils/pluginutils.go b/internal/kgateway/extensions2/pluginutils/pluginutils.go
index 8f00e7e3f..3a1c84dfe 100644
--- a/internal/kgateway/extensions2/pluginutils/pluginutils.go
+++ b/internal/kgateway/extensions2/pluginutils/pluginutils.go
@@ -1,11 +1,10 @@
 package pluginutils
 
 import (
-	"fmt"
-
 	envoy_config_cluster_v3 "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
 	envoy_config_core_v3 "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	envoy_config_endpoint_v3 "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
+	"github.com/pkg/errors"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/anypb"
 
@@ -47,7 +46,7 @@ func EnvoyEndpoint(address string, port uint32) *envoy_config_endpoint_v3.Endpoi
 func SetExtensionProtocolOptions(out *envoy_config_cluster_v3.Cluster, filterName string, protoext proto.Message) error {
 	protoextAny, err := utils.MessageToAny(protoext)
 	if err != nil {
-		return fmt.Errorf("converting extension %s protocol options to struct: %w", filterName, err)
+		return errors.Wrapf(err, "converting extension %s protocol options to struct", filterName)
 	}
 	if out.GetTypedExtensionProtocolOptions() == nil {
 		out.TypedExtensionProtocolOptions = make(map[string]*anypb.Any)
diff --git a/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml b/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
index 0b2ab2686..389772225 100644
--- a/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
+++ b/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
@@ -40,7 +40,8 @@ spec:
             {{- toYaml $gateway.resources | nindent 12 }}
           {{- end }} {{/* if $gateway.resources */}}
           args:
-            - --file=/config/config.json
+            - -f
+            - /config/config.json
           env:
             - name: NODE_NAME
               valueFrom:
@@ -60,6 +61,16 @@ spec:
               value: "1"
             - name: RUST_LOG
               value: {{ $gateway.agentGateway.logLevel }}
+            - name: XDS_ADDRESS
+              value: "http://{{ $gateway.xds.host }}:{{ $gateway.xds.port }}"
+            - name: NAMESPACE
+              valueFrom:
+                fieldRef:
+                  fieldPath: metadata.namespace
+            - name: GATEWAY
+              value: {{ include "kgateway.gateway.fullname" . }}
+{{/*            - name: LOCAL_XDS_PATH*/}}
+{{/*              value: /config/config.json*/}}
             {{- if $gateway.env }}
             {{- toYaml $gateway.env | nindent 12 }}
             {{- end }} {{/* if $gateway.env */}}
@@ -114,11 +125,7 @@ metadata:
 data:
   config.json: |
     {
-      "type": "xds",
-      "xds_address": "http://{{ $gateway.xds.host }}:{{ $gateway.xds.port }}",
-      "metadata": {},
-      "alt_xds_hostname": "{{ $gateway.gatewayName | default (include "kgateway.gateway.fullname" .) }}.{{ $gateway.gatewayNamespace }}.svc.cluster.local",
-      "listeners": []
+      "config": {}
     }
 
 {{- end }} {{/* if $gateway.agentGateway.enabled */}}
diff --git a/internal/kgateway/helm/kgateway/templates/gateway/proxy-deployment.yaml b/internal/kgateway/helm/kgateway/templates/gateway/proxy-deployment.yaml
index 0769a5daa..d0013ca01 100644
--- a/internal/kgateway/helm/kgateway/templates/gateway/proxy-deployment.yaml
+++ b/internal/kgateway/helm/kgateway/templates/gateway/proxy-deployment.yaml
@@ -299,10 +299,8 @@ spec:
         terminationMessagePath: /dev/termination-log
         terminationMessagePolicy: File
         volumeMounts:
-{{- if or $gateway.aiExtension.stats $gateway.aiExtension.tracing }}
-          - mountPath: /var/run/ai-otel-config
-            name: ai-otel-config
-{{- end }}
+          - mountPath: /var/run/stats
+            name: ai-stats-config
 {{- end }} {{/* if (($gateway.aiExtension).enabled) */}}
       {{- with $gateway.nodeSelector }}
       nodeSelector:
@@ -324,11 +322,9 @@ spec:
           name: {{ include "kgateway.gateway.fullname" . }}
         name: envoy-config
 {{- if (($gateway.aiExtension).enabled) }}
-{{- if or $gateway.aiExtension.stats $gateway.aiExtension.tracing }}
       - configMap:
-          name: {{ include "kgateway.gateway.fullname" . }}-ai-otel-config
-        name: ai-otel-config
-{{- end }}
+          name: {{ include "kgateway.gateway.fullname" . }}-ai-stats-config
+        name: ai-stats-config
 {{- end }} {{/* if (($gateway.aiExtension).enabled) */}}
 {{- if $gateway.istio.enabled }}
       - emptyDir:
@@ -406,23 +402,18 @@ spec:
     {{- include "kgateway.gateway.selectorLabels" . | nindent 4 }}
 ---
 {{- if (($gateway.aiExtension).enabled) }}
-{{- if or $gateway.aiExtension.stats $gateway.aiExtension.tracing }}
 apiVersion: v1
 kind: ConfigMap
 metadata:
-  name: {{ include "kgateway.gateway.fullname" . }}-ai-otel-config
+  name: {{ include "kgateway.gateway.fullname" . }}-ai-stats-config
   labels:
     {{- include "kgateway.gateway.constLabels" . | nindent 4 }}
     {{- include "kgateway.gateway.labels" . | nindent 4 }}
-data:
 {{- if $gateway.aiExtension.stats }}
-  stats.json: {{ $gateway.aiExtension.stats | toJson | quote }}
-{{- end }}
-{{- if $gateway.aiExtension.tracing }}
-  tracing.json: {{ $gateway.aiExtension.tracing | toJson | quote }}
-{{- end }}
-{{- end }} {{/* if or $gateway.aiExtension.stats $gateway.aiExtension.tracing */}}
-{{- end }} {{/* if (($gateway.aiExtension).enabled) */}}
+data:
+  stats.json: {{ $gateway.aiExtension.stats }}
+{{- end}}
+{{- end}}
 ---
 apiVersion: v1
 kind: ConfigMap
@@ -605,4 +596,4 @@ data:
         resource_api_version: V3
         ads: {}
 {{- end }} {{/* if not $gateway.agentGateway.enabled */}}
----
+---
\ No newline at end of file
diff --git a/internal/kgateway/krtcollections/builtin.go b/internal/kgateway/krtcollections/builtin.go
index 2a83c92fc..11913e958 100644
--- a/internal/kgateway/krtcollections/builtin.go
+++ b/internal/kgateway/krtcollections/builtin.go
@@ -2,6 +2,7 @@ package krtcollections
 
 import (
 	"context"
+	"fmt"
 	"strings"
 	"time"
 
@@ -329,12 +330,7 @@ func convertSessionPersistence(sessionPersistence *gwv1.SessionPersistence) *any
 			TypedConfig: sessionStateAny,
 		},
 	}
-	perRoute := &stateful_sessionv3.StatefulSessionPerRoute{
-		Override: &stateful_sessionv3.StatefulSessionPerRoute_StatefulSession{
-			StatefulSession: statefulSession,
-		},
-	}
-	typedConfig, err := utils.MessageToAny(perRoute)
+	typedConfig, err := utils.MessageToAny(statefulSession)
 	if err != nil {
 		logger.Error("failed to create session state: %v", "error", err)
 		return nil
@@ -624,6 +620,52 @@ func (p *builtinPluginGwPass) HttpFilters(ctx context.Context, fcc ir.FilterChai
 	return builtinStaged, nil
 }
 
+func ToEnvoyCorsPolicy(f *gwv1.HTTPCORSFilter) *corsv3.CorsPolicy {
+	if f == nil {
+		return nil
+	}
+	corsPolicy := &corsv3.CorsPolicy{}
+	if len(f.AllowOrigins) > 0 {
+		origins := make([]*envoy_type_matcher_v3.StringMatcher, len(f.AllowOrigins))
+		for i, origin := range f.AllowOrigins {
+			origins[i] = &envoy_type_matcher_v3.StringMatcher{
+				MatchPattern: &envoy_type_matcher_v3.StringMatcher_Exact{
+					Exact: string(origin),
+				},
+			}
+		}
+		corsPolicy.AllowOriginStringMatch = origins
+	}
+	if len(f.AllowMethods) > 0 {
+		methods := make([]string, len(f.AllowMethods))
+		for i, method := range f.AllowMethods {
+			methods[i] = string(method)
+		}
+		corsPolicy.AllowMethods = strings.Join(methods, ", ")
+	}
+	if len(f.AllowHeaders) > 0 {
+		headers := make([]string, len(f.AllowHeaders))
+		for i, header := range f.AllowHeaders {
+			headers[i] = string(header)
+		}
+		corsPolicy.AllowHeaders = strings.Join(headers, ", ")
+	}
+	if f.AllowCredentials {
+		corsPolicy.AllowCredentials = &wrapperspb.BoolValue{Value: bool(f.AllowCredentials)}
+	}
+	if len(f.ExposeHeaders) > 0 {
+		headers := make([]string, len(f.ExposeHeaders))
+		for i, header := range f.ExposeHeaders {
+			headers[i] = string(header)
+		}
+		corsPolicy.ExposeHeaders = strings.Join(headers, ", ")
+	}
+	if f.MaxAge != 0 {
+		corsPolicy.MaxAge = fmt.Sprintf("%d", f.MaxAge)
+	}
+	return corsPolicy
+}
+
 // New helper to create filterIr
 func convertFilterIr(kctx krt.HandlerContext, f gwv1.HTTPRouteFilter, fromgk schema.GroupKind, fromns string, refgrants *RefGrantIndex, ups *BackendIndex) *filterIr {
 	var policy applyToRoute
@@ -798,7 +840,7 @@ func convertCORSIR(_ krt.HandlerContext, f *gwv1.HTTPCORSFilter) *corsIr {
 	if f == nil {
 		return nil
 	}
-	corsPolicyAny, err := utils.MessageToAny(utils.ToEnvoyCorsPolicy(f))
+	corsPolicyAny, err := utils.MessageToAny(ToEnvoyCorsPolicy(f))
 	if err != nil {
 		// this should never happen.
 		logger.Error("failed to convert CORS policy to Any", "error", err)
diff --git a/internal/kgateway/krtcollections/grpc_route_test.go b/internal/kgateway/krtcollections/grpc_route_test.go
index e8074cab9..f33fe53ee 100644
--- a/internal/kgateway/krtcollections/grpc_route_test.go
+++ b/internal/kgateway/krtcollections/grpc_route_test.go
@@ -475,7 +475,7 @@ func TestTransformGRPCRoute(t *testing.T) {
 			grpcRoutes := krttest.GetMockCollection[*gwv1.GRPCRoute](mock)
 			services := krttest.GetMockCollection[*corev1.Service](mock)
 			refgrants := krtcollections.NewRefGrantIndex(krttest.GetMockCollection[*gwv1beta1.ReferenceGrant](mock))
-			policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{}, settings.Settings{})
+			policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{})
 
 			// Set up backend index
 			backends := krtcollections.NewBackendIndex(krtutil.KrtOptions{}, policies, refgrants)
diff --git a/internal/kgateway/krtcollections/metrics_test.go b/internal/kgateway/krtcollections/metrics_test.go
index e896c874e..28df800c9 100644
--- a/internal/kgateway/krtcollections/metrics_test.go
+++ b/internal/kgateway/krtcollections/metrics_test.go
@@ -21,7 +21,6 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/pkg/metrics"
 	"github.com/kgateway-dev/kgateway/v2/pkg/metrics/metricstest"
 	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/ir"
-	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 )
 
 func setupTest() {
@@ -285,8 +284,7 @@ func TestGatewaysCollectionMetrics(t *testing.T) {
 			mockGws := krttest.GetMockCollection[*gwv1.Gateway](mock)
 			mockLss := krttest.GetMockCollection[*gwxv1a1.XListenerSet](mock)
 
-			idx := NewGatewayIndex(krtutil.KrtOptions{}, "test",
-				NewPolicyIndex(krtutil.KrtOptions{}, nil, settings.Settings{}), mockGws, mockLss, mockGwcs, mockNs)
+			idx := NewGatewayIndex(krtutil.KrtOptions{}, "test", NewPolicyIndex(krtutil.KrtOptions{}, nil), mockGws, mockLss, mockGwcs, mockNs)
 			idx.Gateways.WaitUntilSynced(context.Background().Done())
 
 			time.Sleep(5 * time.Millisecond) // Allow some time for events to process.
diff --git a/internal/kgateway/krtcollections/pods.go b/internal/kgateway/krtcollections/pods.go
index 65204294e..4d1143de3 100644
--- a/internal/kgateway/krtcollections/pods.go
+++ b/internal/kgateway/krtcollections/pods.go
@@ -10,6 +10,7 @@ import (
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/slices"
 	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
@@ -34,6 +35,91 @@ var (
 	_ krt.Equaler[NodeMetadata] = NodeMetadata{}
 )
 
+// WrappedPod is used by agentgateway as a stripped down representation of the pod
+type WrappedPod struct {
+	krt.Named
+	HostNetwork        bool
+	ServiceAccountName string
+	NodeName           string
+	CreationTimestamp  metav1.Time
+	DeletionTimestamp  *metav1.Time
+	Labels             map[string]string
+	ContainerPorts     map[string][]corev1.ContainerPort
+	WorkloadNameForPod string
+	UID                types.UID
+	Annotations        map[string]string
+	// status fields
+	Ready    bool
+	PodIPs   []corev1.PodIP
+	Terminal bool
+}
+
+func (c WrappedPod) Equals(in WrappedPod) bool {
+	return c.Named == in.Named &&
+		c.Ready == in.Ready &&
+		c.Terminal == in.Terminal &&
+		c.podIPsEquals(c.PodIPs, in.PodIPs) &&
+		c.HostNetwork == in.HostNetwork &&
+		c.NodeName == in.NodeName &&
+		c.ServiceAccountName == in.ServiceAccountName &&
+		c.CreationTimestamp.Equal(&in.CreationTimestamp) &&
+		(c.DeletionTimestamp == nil && in.DeletionTimestamp == nil ||
+			c.DeletionTimestamp != nil && in.DeletionTimestamp != nil &&
+				c.DeletionTimestamp.Equal(in.DeletionTimestamp)) &&
+		c.mapStringEquals(c.Labels, in.Labels) &&
+		c.containerPortsEquals(c.ContainerPorts, in.ContainerPorts) &&
+		c.WorkloadNameForPod == in.WorkloadNameForPod &&
+		c.UID == in.UID &&
+		c.mapStringEquals(c.Annotations, in.Annotations)
+}
+
+func (c WrappedPod) podIPsEquals(ips1, ips2 []corev1.PodIP) bool {
+	if len(ips1) != len(ips2) {
+		return false
+	}
+	for i, ip1 := range ips1 {
+		if ip1.IP != ips2[i].IP {
+			return false
+		}
+	}
+	return true
+}
+
+func (c WrappedPod) mapStringEquals(m1, m2 map[string]string) bool {
+	if len(m1) != len(m2) {
+		return false
+	}
+	for k, v := range m1 {
+		if v2, exists := m2[k]; !exists || v != v2 {
+			return false
+		}
+	}
+	return true
+}
+
+func (c WrappedPod) containerPortsEquals(cp1, cp2 map[string][]corev1.ContainerPort) bool {
+	if len(cp1) != len(cp2) {
+		return false
+	}
+	for k, ports1 := range cp1 {
+		ports2, exists := cp2[k]
+		if !exists || len(ports1) != len(ports2) {
+			return false
+		}
+		for i, port1 := range ports1 {
+			port2 := ports2[i]
+			if port1.Name != port2.Name ||
+				port1.HostPort != port2.HostPort ||
+				port1.ContainerPort != port2.ContainerPort ||
+				port1.Protocol != port2.Protocol ||
+				port1.HostIP != port2.HostIP {
+				return false
+			}
+		}
+	}
+	return true
+}
+
 type LocalityPod struct {
 	krt.Named
 	Locality        ir.PodLocality
@@ -74,20 +160,98 @@ func NewNodeMetadataCollection(nodes krt.Collection[*corev1.Node]) krt.Collectio
 	})
 }
 
-func NewPodsCollection(istioClient kube.Client, krtOptions krtutil.KrtOptions) krt.Collection[LocalityPod] {
+func NewPodsCollection(istioClient kube.Client, krtOptions krtutil.KrtOptions) (krt.Collection[LocalityPod], krt.Collection[WrappedPod]) {
 	podClient := kclient.NewFiltered[*corev1.Pod](istioClient, kclient.Filter{
 		ObjectTransform: kube.StripPodUnusedFields,
 		ObjectFilter:    istioClient.ObjectFilter(),
 	})
 	pods := krt.WrapClient(podClient, krtOptions.ToOptions("Pods")...)
 	nodes := newNodeCollection(istioClient, krtOptions)
-	return NewLocalityPodsCollection(nodes, pods, krtOptions)
+	return NewLocalityPodsCollection(nodes, pods, krtOptions), NewPodWrapperCollection(pods, krtOptions)
 }
 
 func NewLocalityPodsCollection(nodes krt.Collection[NodeMetadata], pods krt.Collection[*corev1.Pod], krtOptions krtutil.KrtOptions) krt.Collection[LocalityPod] {
 	return krt.NewCollection(pods, augmentPodLabels(nodes), krtOptions.ToOptions("AugmentPod")...)
 }
 
+func NewPodWrapperCollection(pods krt.Collection[*corev1.Pod], krtOptions krtutil.KrtOptions) krt.Collection[WrappedPod] {
+	return krt.NewCollection(pods, func(ctx krt.HandlerContext, obj *corev1.Pod) *WrappedPod {
+		objMeta, _ := kube.GetWorkloadMetaFromPod(obj)
+		containerPorts := map[string][]corev1.ContainerPort{}
+		for _, container := range obj.Spec.Containers {
+			containerPorts[container.Name] = []corev1.ContainerPort{}
+			for _, port := range container.Ports {
+				containerPorts[container.Name] = append(containerPorts[container.Name], port)
+			}
+		}
+
+		return &WrappedPod{
+			Named: krt.Named{
+				Name:      obj.Name,
+				Namespace: obj.Namespace,
+			},
+			HostNetwork:        obj.Spec.HostNetwork,
+			NodeName:           obj.Spec.NodeName,
+			ServiceAccountName: obj.Spec.ServiceAccountName,
+			DeletionTimestamp:  obj.GetDeletionTimestamp(),
+			CreationTimestamp:  obj.GetCreationTimestamp(),
+			Labels:             obj.GetLabels(),
+			Annotations:        obj.GetAnnotations(),
+			WorkloadNameForPod: objMeta.Name,
+			ContainerPorts:     containerPorts,
+			UID:                obj.UID,
+			// status
+			Terminal: checkPodTerminal(obj),
+			Ready:    isPodReadyConditionTrue(obj.Status),
+			PodIPs:   getPodIPs(obj),
+		}
+	}, krtOptions.ToOptions("WrappedPod")...)
+}
+
+// isPodReadyConditionTrue returns true if a pod is ready; false otherwise.
+func isPodReadyConditionTrue(status corev1.PodStatus) bool {
+	condition := GetPodReadyCondition(status)
+	return condition != nil && condition.Status == corev1.ConditionTrue
+}
+
+func GetPodReadyCondition(status corev1.PodStatus) *corev1.PodCondition {
+	_, condition := GetPodCondition(&status, corev1.PodReady)
+	return condition
+}
+
+func GetPodCondition(status *corev1.PodStatus, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
+	if status == nil {
+		return -1, nil
+	}
+	return GetPodConditionFromList(status.Conditions, conditionType)
+}
+
+func checkPodTerminal(pod *corev1.Pod) bool {
+	return pod.Status.Phase == corev1.PodFailed || pod.Status.Phase == corev1.PodSucceeded
+}
+
+// GetPodConditionFromList extracts the provided condition from the given list of condition and
+// returns the index of the condition and the condition. Returns -1 and nil if the condition is not present.
+func GetPodConditionFromList(conditions []corev1.PodCondition, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
+	if conditions == nil {
+		return -1, nil
+	}
+	for i := range conditions {
+		if conditions[i].Type == conditionType {
+			return i, &conditions[i]
+		}
+	}
+	return -1, nil
+}
+
+func getPodIPs(p *corev1.Pod) []corev1.PodIP {
+	k8sPodIPs := p.Status.PodIPs
+	if len(k8sPodIPs) == 0 && p.Status.PodIP != "" {
+		k8sPodIPs = []corev1.PodIP{{IP: p.Status.PodIP}}
+	}
+	return k8sPodIPs
+}
+
 func augmentPodLabels(nodes krt.Collection[NodeMetadata]) func(kctx krt.HandlerContext, pod *corev1.Pod) *LocalityPod {
 	return func(kctx krt.HandlerContext, pod *corev1.Pod) *LocalityPod {
 		labels := maps.Clone(pod.Labels)
diff --git a/internal/kgateway/krtcollections/policy.go b/internal/kgateway/krtcollections/policy.go
index 6229190ac..f001c4734 100644
--- a/internal/kgateway/krtcollections/policy.go
+++ b/internal/kgateway/krtcollections/policy.go
@@ -508,8 +508,7 @@ type policyAndIndex struct {
 	forBackends         bool
 }
 type PolicyIndex struct {
-	globalPolicyNamespace string
-	availablePolicies     map[schema.GroupKind]policyAndIndex
+	availablePolicies map[schema.GroupKind]policyAndIndex
 
 	policiesFetch  map[schema.GroupKind]func(n string, ns string) ir.PolicyIR
 	globalPolicies []globalPolicy
@@ -535,16 +534,8 @@ func (h *PolicyIndex) HasSynced() bool {
 	return true
 }
 
-func NewPolicyIndex(
-	krtopts krtutil.KrtOptions,
-	contributesPolicies extensionsplug.ContributesPolicies,
-	globalSettings settings.Settings,
-) *PolicyIndex {
-	index := &PolicyIndex{
-		globalPolicyNamespace: globalSettings.GlobalPolicyNamespace,
-		policiesFetch:         policyFetcherMap{},
-		availablePolicies:     map[schema.GroupKind]policyAndIndex{},
-	}
+func NewPolicyIndex(krtopts krtutil.KrtOptions, contributesPolicies extensionsplug.ContributesPolicies) *PolicyIndex {
+	index := &PolicyIndex{policiesFetch: policyFetcherMap{}, availablePolicies: map[schema.GroupKind]policyAndIndex{}}
 
 	for gk, plugin := range contributesPolicies {
 		if plugin.Policies != nil {
@@ -720,15 +711,6 @@ func (p *PolicyIndex) getTargetingPoliciesMaybeForBackends(
 		}
 		policiesByLabel := p.fetchByTargetRefLabels(kctx, refIndexKeyByNamespace, onlyBackends, targetLabels)
 		policies = append(policies, policiesByLabel...)
-
-		// Check if policies defined in the global policy namespace target this ref.
-		// `targetRef.Namespace != p.globalPolicyNamespace` ensures we avoid a duplicate lookup as done
-		// above when targetRef.Namespace is the same as globalPolicyNamespace
-		if p.globalPolicyNamespace != "" && targetRef.Namespace != p.globalPolicyNamespace {
-			refIndexKeyByNamespace.Namespace = p.globalPolicyNamespace
-			globalPolicies := p.fetchByTargetRefLabels(kctx, refIndexKeyByNamespace, onlyBackends, targetLabels)
-			policies = append(policies, globalPolicies...)
-		}
 	}
 
 	for _, p := range policies {
diff --git a/internal/kgateway/krtcollections/policy_test.go b/internal/kgateway/krtcollections/policy_test.go
index 6e49815b8..1163bae98 100644
--- a/internal/kgateway/krtcollections/policy_test.go
+++ b/internal/kgateway/krtcollections/policy_test.go
@@ -688,15 +688,11 @@ func preRouteIndex(t test.Failer, inputs []any) *RoutesIndex {
 	services := krttest.GetMockCollection[*corev1.Service](mock)
 	policyCol := krttest.GetMockCollection[ir.PolicyWrapper](mock)
 
-	policies := NewPolicyIndex(
-		krtutil.KrtOptions{},
-		extensionsplug.ContributesPolicies{
-			wellknown.TrafficPolicyGVK.GroupKind(): {
-				Policies: policyCol,
-			},
+	policies := NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{
+		wellknown.TrafficPolicyGVK.GroupKind(): {
+			Policies: policyCol,
 		},
-		settings.Settings{},
-	)
+	})
 	refgrants := NewRefGrantIndex(krttest.GetMockCollection[*gwv1beta1.ReferenceGrant](mock))
 	upstreams := NewBackendIndex(krtutil.KrtOptions{}, policies, refgrants)
 	upstreams.AddBackends(svcGk, k8sSvcUpstreams(services))
diff --git a/internal/kgateway/krtcollections/setup.go b/internal/kgateway/krtcollections/setup.go
index e4dc4b346..3a61ec351 100644
--- a/internal/kgateway/krtcollections/setup.go
+++ b/internal/kgateway/krtcollections/setup.go
@@ -144,7 +144,7 @@ func InitCollections(
 	gatewayClasses := krt.WrapClient(kclient.New[*gwv1.GatewayClass](istioClient), krtopts.ToOptions("KubeGatewayClasses")...)
 	namespaces, _ := NewNamespaceCollection(ctx, istioClient, krtopts)
 
-	policies := NewPolicyIndex(krtopts, plugins.ContributesPolicies, globalSettings)
+	policies := NewPolicyIndex(krtopts, plugins.ContributesPolicies)
 	backendIndex := NewBackendIndex(krtopts, policies, refgrants)
 	initBackends(plugins, backendIndex)
 	endpointIRs := initEndpoints(plugins, krtopts)
diff --git a/internal/kgateway/proxy_syncer/proxy_syncer.go b/internal/kgateway/proxy_syncer/proxy_syncer.go
index dc4680d9a..4a82b177e 100644
--- a/internal/kgateway/proxy_syncer/proxy_syncer.go
+++ b/internal/kgateway/proxy_syncer/proxy_syncer.go
@@ -381,7 +381,7 @@ func (s *ProxySyncer) Start(ctx context.Context) error {
 	latestReportQueue := utils.NewAsyncQueue[reports.ReportMap]()
 	s.statusReport.Register(func(o krt.Event[report]) {
 		if o.Event == controllers.EventDelete {
-			// TODO: handle garbage collection (see: https://github.com/solo-io/solo-projects/issues/7086)
+			// TODO: handle garbage collection
 			return
 		}
 		latestReportQueue.Enqueue(o.Latest().reportMap)
diff --git a/internal/kgateway/query/query_test.go b/internal/kgateway/query/query_test.go
index 2555c5fc1..efe39e7c1 100644
--- a/internal/kgateway/query/query_test.go
+++ b/internal/kgateway/query/query_test.go
@@ -1131,7 +1131,7 @@ func newQueries(t test.Failer, initObjs ...client.Object) query.GatewayQueries {
 	services := krttest.GetMockCollection[*corev1.Service](mock)
 	refgrants := krtcollections.NewRefGrantIndex(krttest.GetMockCollection[*gwv1beta1.ReferenceGrant](mock))
 
-	policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{}, settings.Settings{})
+	policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{})
 	upstreams := krtcollections.NewBackendIndex(krtutil.KrtOptions{}, policies, refgrants)
 	upstreams.AddBackends(SvcGk, k8sUpstreams(services))
 
diff --git a/internal/kgateway/reports/reporter.go b/internal/kgateway/reports/reporter.go
index 794b9c22e..dc58225b3 100644
--- a/internal/kgateway/reports/reporter.go
+++ b/internal/kgateway/reports/reporter.go
@@ -81,15 +81,24 @@ func key(obj metav1.Object) types.NamespacedName {
 //
 // NOTE: Exported for unit testing, validation_test.go should be refactored to reduce this visibility
 func (r *ReportMap) Gateway(gateway *gwv1.Gateway) *GatewayReport {
+	fmt.Printf("debug(npolshak) Gateway() %s\n", gateway.Name)
 	key := key(gateway)
+	if r.Gateways[key] == nil {
+		fmt.Printf("debug(npolshak) nil gateway report %v\n", r.Gateways[key])
+	} else {
+		fmt.Printf("debug(npolshak) val gateway report not nil %v\n", r.Gateways[key].conditions)
+	}
 	return r.Gateways[key]
 }
 
 func (r *ReportMap) newGatewayReport(gateway *gwv1.Gateway) *GatewayReport {
+	fmt.Printf("debug(npolshak) creating new gateway report %s\n", gateway.Name)
+
 	gr := &GatewayReport{}
 	gr.observedGeneration = gateway.Generation
 	key := key(gateway)
 	r.Gateways[key] = gr
+	fmt.Printf("debug(npolshak) newGatewayReport val gateway report %v\n", gr.conditions)
 	return gr
 }
 
@@ -199,6 +208,7 @@ func (g *GatewayReport) SetCondition(gc pluginsdkreporter.GatewayCondition) {
 		Reason:  string(gc.Reason),
 		Message: gc.Message,
 	}
+	fmt.Printf("debug(npolshak) SetCondition %v for %v\n", condition, g)
 	meta.SetStatusCondition(&g.conditions, condition)
 }
 
@@ -272,6 +282,7 @@ type reporter struct {
 }
 
 func (r *reporter) Gateway(gateway *gwv1.Gateway) pluginsdkreporter.GatewayReporter {
+	fmt.Printf("debug(npolshak) reporter Gateway(gateway) %s\n", gateway.Name)
 	gr := r.report.Gateway(gateway)
 	if gr == nil {
 		gr = r.report.newGatewayReport(gateway)
diff --git a/internal/kgateway/reports/status.go b/internal/kgateway/reports/status.go
index d67126a8d..ef28eac2f 100644
--- a/internal/kgateway/reports/status.go
+++ b/internal/kgateway/reports/status.go
@@ -23,6 +23,7 @@ import (
 // TODO: refactor this struct + methods to better reflect the usage now in proxy_syncer
 
 func (r *ReportMap) BuildGWStatus(ctx context.Context, gw gwv1.Gateway) *gwv1.GatewayStatus {
+	fmt.Printf("debug(npolshak) BuildGWStatus %v\n", gw.Name)
 	gwReport := r.Gateway(&gw)
 	if gwReport == nil {
 		return nil
@@ -52,6 +53,7 @@ func (r *ReportMap) BuildGWStatus(ctx context.Context, gw gwv1.Gateway) *gwv1.Ga
 		finalListeners = append(finalListeners, lisReport.Status)
 	}
 
+	fmt.Printf("debug(npolshak) adding missing gateway conditions %v\n", gw.Name)
 	addMissingGatewayConditions(r.Gateway(&gw))
 
 	finalConditions := make([]metav1.Condition, 0)
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index db564e641..5f9eb5cb1 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -2,321 +2,635 @@ package setup_test
 
 import (
 	"context"
+	"encoding/json"
 	"fmt"
 	"os"
+	"path/filepath"
+	"sort"
 	"strings"
 	"testing"
 	"time"
 
+	"github.com/agentgateway/agentgateway/go/api"
+	envoycore "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	discovery_v3 "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
+	"google.golang.org/grpc"
+	"google.golang.org/grpc/credentials/insecure"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/types/known/structpb"
 	istiokube "istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/krt"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"istio.io/istio/pkg/test/util/retry"
 
+	"google.golang.org/protobuf/encoding/protojson"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
 	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 )
 
-func TestAgentGatewaySelfManaged(t *testing.T) {
+func TestAgentgateway(t *testing.T) {
 	st, err := settings.BuildSettings()
 	st.EnableAgentGateway = true
 
 	if err != nil {
 		t.Fatalf("can't get settings %v", err)
 	}
-	setupEnvTestAndRun(t, st, func(t *testing.T, ctx context.Context, kdbg *krt.DebugHandler, client istiokube.CLIClient, xdsPort int) {
-		client.Kube().CoreV1().Namespaces().Create(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: "gwtest"}}, metav1.CreateOptions{})
-
-		err = client.ApplyYAMLContents("gwtest", `
-apiVersion: v1
-kind: Service
-metadata:
-  name: mcp
-  namespace: gwtest
-  labels:
-    app: mcp
-spec:
-  clusterIP: "10.0.0.11"
-  ports:
-    - name: http
-      port: 8080
-      targetPort: 8080
-      appProtocol: kgateway.dev/mcp
-  selector:
-    app: mcp
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: a2a
-  namespace: gwtest
-  labels:
-    app: a2a
-spec:
-  clusterIP: "10.0.0.12"
-  ports:
-    - name: http
-      port: 8081
-      targetPort: 8081
-      appProtocol: kgateway.dev/a2a
-  selector:
-    app: a2a
----
-kind: GatewayClass
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: agentgateway
-spec:
-  controllerName: kgateway.dev/kgateway
-  parametersRef:
-    group: gateway.kgateway.dev
-    kind: GatewayParameters
-    name: kgateway
-    namespace: default
----
-kind: GatewayParameters
-apiVersion: gateway.kgateway.dev/v1alpha1
-metadata:
-  name: kgateway
-spec:
-  selfManaged: {}
----
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: http-gw
-  namespace: gwtest
-spec:
-  gatewayClassName: agentgateway
-  listeners:
-  - protocol: kgateway.dev/mcp
-    port: 8080
-    name: mcp
-    allowedRoutes:
-      namespaces:
-        from: All
-  - protocol: kgateway.dev/a2a
-    port: 8081
-    name: a2a
-    allowedRoutes:
-      namespaces:
-        from: All
-`)
 
+	// Use the runScenario approach to test agent gateway scenarios
+	runAgentGatewayScenario(t, "testdata/agentgateway", st)
+}
+
+func runAgentGatewayScenario(t *testing.T, scenarioDir string, globalSettings *settings.Settings) {
+	setupEnvTestAndRun(t, globalSettings, func(t *testing.T, ctx context.Context, kdbg *krt.DebugHandler, client istiokube.CLIClient, xdsPort int) {
+
+		// list all yamls in test data
+		files, err := os.ReadDir(scenarioDir)
 		if err != nil {
-			t.Fatalf("failed to apply yamls: %v", err)
+			t.Fatalf("failed to read dir: %v", err)
+		}
+		for _, f := range files {
+			// run tests with the yaml files (agentgateway dumps json output)
+			parentT := t
+			if strings.HasSuffix(f.Name(), ".yaml") {
+				if os.Getenv("TEST_PREFIX") != "" && !strings.HasPrefix(f.Name(), os.Getenv("TEST_PREFIX")) {
+					continue
+				}
+				fullpath := filepath.Join(scenarioDir, f.Name())
+				t.Run(strings.TrimSuffix(f.Name(), ".yaml"), func(t *testing.T) {
+					writer.set(t)
+					t.Cleanup(func() {
+						writer.set(parentT)
+					})
+					testAgentGatewayScenario(t, ctx, kdbg, client, xdsPort, fullpath)
+				})
+			}
 		}
+	})
+}
 
-		time.Sleep(time.Second / 2)
+func testAgentGatewayScenario(
+	t *testing.T,
+	ctx context.Context,
+	kdbg *krt.DebugHandler,
+	client istiokube.CLIClient,
+	xdsPort int,
+	f string,
+) {
+	fext := filepath.Ext(f)
+	fpre := strings.TrimSuffix(f, fext)
+	t.Logf("running agent gateway scenario for test file: %s", f)
 
-		dumper := newAgentGatewayXdsDumper(t, ctx, xdsPort, "http-gw", "gwtest")
-		t.Cleanup(dumper.Close)
-		t.Cleanup(func() {
-			if t.Failed() {
-				logKrtState(t, fmt.Sprintf("krt state for failed test: %s", t.Name()), kdbg)
-			} else if os.Getenv("KGW_DUMP_KRT_ON_SUCCESS") == "true" {
-				logKrtState(t, fmt.Sprintf("krt state for successful test: %s", t.Name()), kdbg)
-			}
-		})
+	// read the out file
+	fout := fpre + "-out.json"
+	write := false
+	_, err := os.ReadFile(fout)
+	// if not exist
+	if os.IsNotExist(err) {
+		write = true
+		err = nil
+	}
+	if os.Getenv("REFRESH_GOLDEN") == "true" {
+		write = true
+	}
+	if err != nil {
+		t.Fatalf("failed to read file %s: %v", fout, err)
+	}
+
+	const gwname = "http-gw-for-test"
+	testgwname := "http-" + filepath.Base(fpre)
+	testyamlbytes, err := os.ReadFile(f)
+	if err != nil {
+		t.Fatalf("failed to read file: %v", err)
+	}
+	// change the gw name, so we could potentially run multiple tests in parallel (though currently
+	// it has other issues, so we don't run them in parallel)
+	testyaml := strings.ReplaceAll(string(testyamlbytes), gwname, testgwname)
+
+	yamlfile := filepath.Join(t.TempDir(), "test.yaml")
+	os.WriteFile(yamlfile, []byte(testyaml), 0o644)
+
+	err = client.ApplyYAMLFiles("", yamlfile)
 
+	t.Cleanup(func() {
+		// always delete yamls, even if there was an error applying them; to prevent test pollution.
+		err := client.DeleteYAMLFiles("", yamlfile)
+		if err != nil {
+			t.Fatalf("failed to delete yaml: %v", err)
+		}
+		t.Log("deleted yamls", t.Name())
+	})
+
+	if err != nil {
+		t.Fatalf("failed to apply yaml: %v", err)
+	}
+	t.Log("applied yamls", t.Name())
+
+	// wait at least a second before the first check
+	// to give the CP time to process
+	time.Sleep(time.Second)
+
+	t.Cleanup(func() {
+		if t.Failed() {
+			logKrtState(t, fmt.Sprintf("krt state for failed test: %s", t.Name()), kdbg)
+		} else if os.Getenv("KGW_DUMP_KRT_ON_SUCCESS") == "true" {
+			logKrtState(t, fmt.Sprintf("krt state for successful test: %s", t.Name()), kdbg)
+		}
+	})
+
+	// Use retry to wait for the agent gateway to be ready
+	retry.UntilSuccessOrFail(t, func() error {
+		dumper := newAgentGatewayXdsDumper(t, ctx, xdsPort, testgwname, "gwtest")
+		defer dumper.Close()
 		dump := dumper.DumpAgentGateway(t, ctx)
-		if len(dump.McpTargets) != 1 {
-			t.Fatalf("expected 1 mcp target config, got %d", len(dump.McpTargets))
+		if len(dump.Resources) == 0 {
+			return fmt.Errorf("timed out waiting for agent gateway resources")
 		}
-		if len(dump.A2ATargets) != 1 {
-			t.Fatalf("expected 1 a2a target config, got %d", len(dump.A2ATargets))
+
+		if write {
+			t.Logf("writing out file")
+			// Use proto dump instead of manual YAML writing
+			dumpProtoToJSON(t, dump, fpre)
+			return fmt.Errorf("wrote out file - nothing to test")
 		}
-		if len(dump.Listeners) != 2 {
-			t.Fatalf("expected 2 listener config, got %d", len(dump.Listeners))
+
+		// Output the config dump
+		t.Logf("Agent Gateway Config Dump for %s:", testgwname)
+		t.Logf("Total resources: %d", len(dump.Resources))
+
+		// Count different types of resources
+		var bindCount, listenerCount, routeCount, worklodCount, serviceCount int
+		for _, resource := range dump.Resources {
+			switch resource.GetKind().(type) {
+			case *api.Resource_Bind:
+				bindCount++
+				t.Logf("Bind resource: %+v", resource.GetBind())
+			case *api.Resource_Listener:
+				listenerCount++
+				t.Logf("Listener resource: %+v", resource.GetListener())
+			case *api.Resource_Route:
+				routeCount++
+				t.Logf("Route resource: %+v", resource.GetRoute())
+			}
 		}
-		t.Logf("%s finished", t.Name())
-	})
+		t.Logf("Resource counts - Binds: %d, Listeners: %d, Routes: %d", bindCount, listenerCount, routeCount)
+
+		for _, resource := range dump.Addresses {
+			switch resource.GetType().(type) {
+			case *api.Address_Workload:
+				worklodCount++
+				t.Logf("workload resource: %+v", resource.GetWorkload())
+			case *api.Address_Service:
+				serviceCount++
+				t.Logf("service resource: %+v", resource.GetService())
+			}
+		}
+		t.Logf("Address counts - Workload: %d, Service: %d", worklodCount, serviceCount)
+
+		if !write {
+			// Read expected values from out.json file and compare
+			expectedDump, err := readExpectedDump(t, fout)
+			t.Logf("expected dump: %+v", expectedDump)
+			if err != nil {
+				return fmt.Errorf("failed to read expected dump from %s: %v", fout, err)
+			}
+
+			// Compare actual vs expected dump
+			if err := compareDumps(dump, expectedDump); err != nil {
+				return fmt.Errorf("dump comparison failed: %v", err)
+			}
+		}
+
+		return nil
+	}, retry.Converge(2), retry.BackoffDelay(2*time.Second), retry.Timeout(10*time.Second))
+
+	t.Logf("%s finished", t.Name())
 }
 
-func TestAgentGatewayAllowedRoutes(t *testing.T) {
-	st, err := settings.BuildSettings()
-	st.EnableAgentGateway = true
+// dumpProtoToJSON dumps the agentgateway resources to JSON format
+func dumpProtoToJSON(t *testing.T, dump agentGwDump, fpre string) {
+	jsonFile := fpre + "-out.json"
+
+	// Sort resources and addresses for consistent ordering
+	sortedResources := make([]*api.Resource, len(dump.Resources))
+	copy(sortedResources, dump.Resources)
+	sortResources(sortedResources)
+
+	sortedAddresses := make([]*api.Address, len(dump.Addresses))
+	copy(sortedAddresses, dump.Addresses)
+	sortAddresses(sortedAddresses)
+
+	// Create a structured dump map
+	dumpMap := map[string]interface{}{
+		"resources": sortedResources,
+		"addresses": sortedAddresses,
+	}
 
+	// Marshal to JSON using standard JSON marshaling to maintain consistency
+	jsonData, err := json.MarshalIndent(dumpMap, "", "  ")
 	if err != nil {
-		t.Fatalf("can't get settings %v", err)
+		t.Logf("failed to marshal to JSON: %v", err)
+		return
 	}
-	setupEnvTestAndRun(t, st, func(t *testing.T, ctx context.Context, kdbg *krt.DebugHandler, client istiokube.CLIClient, xdsPort int) {
-		client.Kube().CoreV1().Namespaces().Create(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: "gwtest"}}, metav1.CreateOptions{})
-
-		err = client.ApplyYAMLContents("", `
-apiVersion: v1
-kind: Namespace
-metadata:
-  name: othernamespace
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: mcp-other
-  namespace: othernamespace
-  labels:
-    app: mcp-other
-spec:
-  clusterIP: "10.0.0.11"
-  ports:
-    - name: http
-      port: 8080
-      targetPort: 8080
-      appProtocol: kgateway.dev/mcp
-  selector:
-    app: mcp-other
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: a2a-other
-  namespace: othernamespace
-  labels:
-    app: a2a-other
-spec:
-  clusterIP: "10.0.0.12"
-  ports:
-    - name: http
-      port: 8081
-      targetPort: 8081
-      appProtocol: kgateway.dev/a2a
-  selector:
-    app: a2a-other
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: mcp-allowed
-  namespace: gwtest
-  labels:
-    app: mcp-allowed
-spec:
-  clusterIP: "10.0.0.13"
-  ports:
-    - name: http
-      port: 8080
-      targetPort: 8080
-      appProtocol: kgateway.dev/mcp
-  selector:
-    app: mcp-allowed
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: a2a-allowed
-  namespace: gwtest
-  labels:
-    app: a2a-allowed
-spec:
-  clusterIP: "10.0.0.14"
-  ports:
-    - name: http
-      port: 8081
-      targetPort: 8081
-      appProtocol: kgateway.dev/a2a
-  selector:
-    app: a2a-allowed
----
-kind: GatewayParameters
-apiVersion: gateway.kgateway.dev/v1alpha1
-metadata:
-  name: kgateway
-  namespace: gwtest
-spec:
-  kube:
-    agentGateway:
-      enabled: true
----
-kind: GatewayClass
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: agentgateway
-  namespace: gwtest
-spec:
-  controllerName: kgateway.dev/kgateway
-  parametersRef:
-    group: gateway.kgateway.dev
-    kind: GatewayParameters
-    name: kgateway
-    namespace: gwtest
----
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: http-gw
-  namespace: gwtest
-spec:
-  gatewayClassName: agentgateway
-  listeners:
-  - protocol: kgateway.dev/mcp
-    port: 8080
-    name: mcp
-    allowedRoutes:
-      namespaces:
-        from: Same
-  - protocol: kgateway.dev/a2a
-    port: 8081
-    name: a2a
-    allowedRoutes:
-      namespaces:
-        from: Same
-`)
 
-		if err != nil {
-			t.Fatalf("failed to apply yamls: %v", err)
-		}
+	err = os.WriteFile(jsonFile, jsonData, 0o644)
+	if err != nil {
+		t.Logf("failed to write JSON file: %v", err)
+		return
+	}
 
-		time.Sleep(time.Second / 2)
+	t.Logf("wrote JSON dump to: %s", jsonFile)
+}
 
-		dumper := newAgentGatewayXdsDumper(t, ctx, xdsPort, "http-gw", "gwtest")
-		t.Cleanup(dumper.Close)
-		t.Cleanup(func() {
-			if t.Failed() {
-				logKrtState(t, fmt.Sprintf("krt state for failed test: %s", t.Name()), kdbg)
-			} else if os.Getenv("KGW_DUMP_KRT_ON_SUCCESS") == "true" {
-				logKrtState(t, fmt.Sprintf("krt state for successful test: %s", t.Name()), kdbg)
-			}
-		})
+// sortResources sorts resources by type and key for consistent ordering
+func sortResources(resources []*api.Resource) {
+	sort.Slice(resources, func(i, j int) bool {
+		// First sort by resource type
+		typeI := getResourceType(resources[i])
+		typeJ := getResourceType(resources[j])
+		if typeI != typeJ {
+			return typeI < typeJ
+		}
 
-		dump := dumper.DumpAgentGateway(t, ctx)
-		if len(dump.McpTargets) != 2 {
-			t.Fatalf("expected 2 mcp target config, got %d", len(dump.McpTargets))
+		// Then sort by key within the same type
+		keyI := getResourceKey(resources[i])
+		keyJ := getResourceKey(resources[j])
+		return keyI < keyJ
+	})
+}
+
+// sortAddresses sorts addresses by type and identifier for consistent ordering
+func sortAddresses(addresses []*api.Address) {
+	sort.Slice(addresses, func(i, j int) bool {
+		// First sort by address type
+		typeI := getAddressType(addresses[i])
+		typeJ := getAddressType(addresses[j])
+		if typeI != typeJ {
+			return typeI < typeJ
 		}
-		for _, mcpTarget := range dump.McpTargets {
-			// same namespace should have mcp listener
-			if strings.Contains(mcpTarget.Name, "mcp-allowed") {
-				if len(mcpTarget.Listeners) != 1 {
-					t.Fatalf("expected mcp target to have 1 listener, got %v", mcpTarget.Listeners)
-				}
-				if mcpTarget.Listeners[0] != "mcp" {
-					t.Fatalf("expected mcp target to have listener mcp, got %s", mcpTarget.Listeners[0])
+
+		// Then sort by identifier within the same type
+		idI := getAddressIdentifier(addresses[i])
+		idJ := getAddressIdentifier(addresses[j])
+		return idI < idJ
+	})
+}
+
+// getResourceType returns a string representation of the resource type for sorting
+func getResourceType(resource *api.Resource) string {
+	switch resource.GetKind().(type) {
+	case *api.Resource_Bind:
+		return "bind"
+	case *api.Resource_Listener:
+		return "listener"
+	case *api.Resource_Route:
+		return "route"
+	default:
+		return "unknown"
+	}
+}
+
+// getResourceKey returns the key for a resource for sorting
+func getResourceKey(resource *api.Resource) string {
+	switch x := resource.GetKind().(type) {
+	case *api.Resource_Bind:
+		return x.Bind.GetKey()
+	case *api.Resource_Listener:
+		return x.Listener.GetKey()
+	case *api.Resource_Route:
+		return x.Route.GetKey()
+	default:
+		return ""
+	}
+}
+
+// getAddressType returns a string representation of the address type for sorting
+func getAddressType(address *api.Address) string {
+	switch address.GetType().(type) {
+	case *api.Address_Workload:
+		return "workload"
+	case *api.Address_Service:
+		return "service"
+	default:
+		return "unknown"
+	}
+}
+
+// getAddressIdentifier returns an identifier for an address for sorting
+func getAddressIdentifier(address *api.Address) string {
+	switch x := address.GetType().(type) {
+	case *api.Address_Workload:
+		return x.Workload.GetName()
+	case *api.Address_Service:
+		return x.Service.GetHostname()
+	default:
+		return ""
+	}
+}
+
+// readExpectedDump reads and parses the expected dump from a JSON file
+func readExpectedDump(t *testing.T, filename string) (agentGwDump, error) {
+	var dump agentGwDump
+
+	data, err := os.ReadFile(filename)
+	if err != nil {
+		return dump, fmt.Errorf("failed to read file: %v", err)
+	}
+
+	// Parse the JSON structure using a custom approach that matches the actual JSON format
+	var jsonData map[string]interface{}
+	if err := json.Unmarshal(data, &jsonData); err != nil {
+		return dump, fmt.Errorf("failed to unmarshal JSON: %v", err)
+	}
+
+	// Create unmarshaler for protobuf types
+	unmarshaler := protojson.UnmarshalOptions{
+		DiscardUnknown: true,
+	}
+
+	// Parse resources
+	if resourcesData, ok := jsonData["resources"].([]interface{}); ok {
+		for _, r := range resourcesData {
+			if resourceMap, ok := r.(map[string]interface{}); ok {
+				resource := &api.Resource{}
+
+				// Parse Kind field
+				if kindData, ok := resourceMap["Kind"].(map[string]interface{}); ok {
+					if bindData, ok := kindData["Bind"].(map[string]interface{}); ok {
+						bindJSON, err := json.Marshal(bindData)
+						if err != nil {
+							t.Logf("failed to marshal bind data: %v", err)
+							continue
+						}
+						bind := &api.Bind{}
+						if err := unmarshaler.Unmarshal(bindJSON, bind); err != nil {
+							t.Logf("failed to unmarshal bind: %v", err)
+							continue
+						}
+						resource.Kind = &api.Resource_Bind{Bind: bind}
+					} else if listenerData, ok := kindData["Listener"].(map[string]interface{}); ok {
+						listenerJSON, err := json.Marshal(listenerData)
+						if err != nil {
+							t.Logf("failed to marshal listener data: %v", err)
+							continue
+						}
+						listener := &api.Listener{}
+						if err := unmarshaler.Unmarshal(listenerJSON, listener); err != nil {
+							t.Logf("failed to unmarshal listener: %v", err)
+							continue
+						}
+						resource.Kind = &api.Resource_Listener{Listener: listener}
+					} else if routeData, ok := kindData["Route"].(map[string]interface{}); ok {
+						routeJSON, err := json.Marshal(routeData)
+						if err != nil {
+							t.Logf("failed to marshal route data: %v", err)
+							continue
+						}
+						route := &api.Route{}
+						if err := unmarshaler.Unmarshal(routeJSON, route); err != nil {
+							t.Logf("failed to unmarshal route: %v", err)
+							continue
+						}
+						resource.Kind = &api.Resource_Route{Route: route}
+					}
 				}
-			} else {
-				if len(mcpTarget.Listeners) != 0 {
-					t.Fatalf("expected mcp target to not have listeners, got %v", mcpTarget.Listeners)
+
+				if resource.Kind != nil {
+					dump.Resources = append(dump.Resources, resource)
 				}
 			}
 		}
-		if len(dump.A2ATargets) != 2 {
-			t.Fatalf("expected 2 a2a target config, got %d", len(dump.A2ATargets))
-		}
-		for _, a2aTarget := range dump.A2ATargets {
-			// same namespace should have a2a listener
-			if strings.Contains(a2aTarget.Name, "a2a-allowed") {
-				if len(a2aTarget.Listeners) != 1 {
-					t.Fatalf("expected mcp target to have 1 listener, got %v", a2aTarget.Listeners)
+	}
+
+	// Parse addresses
+	if addressesData, ok := jsonData["addresses"].([]interface{}); ok {
+		for _, a := range addressesData {
+			if addressMap, ok := a.(map[string]interface{}); ok {
+				address := &api.Address{}
+
+				// Parse Type field
+				if typeData, ok := addressMap["Type"].(map[string]interface{}); ok {
+					if serviceData, ok := typeData["Service"].(map[string]interface{}); ok {
+						serviceJSON, err := json.Marshal(serviceData)
+						if err != nil {
+							t.Logf("failed to marshal service data: %v", err)
+							continue
+						}
+						service := &api.Service{}
+						if err := unmarshaler.Unmarshal(serviceJSON, service); err != nil {
+							t.Logf("failed to unmarshal service: %v", err)
+							continue
+						}
+						address.Type = &api.Address_Service{Service: service}
+					} else if workloadData, ok := typeData["Workload"].(map[string]interface{}); ok {
+						workloadJSON, err := json.Marshal(workloadData)
+						if err != nil {
+							t.Logf("failed to marshal workload data: %v", err)
+							continue
+						}
+						workload := &api.Workload{}
+						if err := unmarshaler.Unmarshal(workloadJSON, workload); err != nil {
+							t.Logf("failed to unmarshal workload: %v", err)
+							continue
+						}
+						address.Type = &api.Address_Workload{Workload: workload}
+					}
 				}
-				if a2aTarget.Listeners[0] != "a2a" {
-					t.Fatalf("expected a2a target to have listener mcp, got %s", a2aTarget.Listeners[0])
+
+				if address.Type != nil {
+					dump.Addresses = append(dump.Addresses, address)
 				}
-			} else {
-				if len(a2aTarget.Listeners) != 0 {
-					t.Fatalf("expected a2a target to not have listeners, got %v", a2aTarget.Listeners)
+			}
+		}
+	}
+
+	return dump, nil
+}
+
+// compareDumps compares two dumps and returns an error if they differ
+func compareDumps(actual, expected agentGwDump) error {
+	// Sort both dumps for comparison
+	sortedActual := agentGwDump{
+		Resources: make([]*api.Resource, len(actual.Resources)),
+		Addresses: make([]*api.Address, len(actual.Addresses)),
+	}
+	copy(sortedActual.Resources, actual.Resources)
+	copy(sortedActual.Addresses, actual.Addresses)
+	sortResources(sortedActual.Resources)
+	sortAddresses(sortedActual.Addresses)
+
+	sortedExpected := agentGwDump{
+		Resources: make([]*api.Resource, len(expected.Resources)),
+		Addresses: make([]*api.Address, len(expected.Addresses)),
+	}
+	copy(sortedExpected.Resources, expected.Resources)
+	copy(sortedExpected.Addresses, expected.Addresses)
+	sortResources(sortedExpected.Resources)
+	sortAddresses(sortedExpected.Addresses)
+
+	// Compare resources
+	if len(sortedActual.Resources) != len(sortedExpected.Resources) {
+		return fmt.Errorf("resource count mismatch: actual=%d, expected=%d", len(sortedActual.Resources), len(sortedExpected.Resources))
+	}
+
+	for i, actualRes := range sortedActual.Resources {
+		expectedRes := sortedExpected.Resources[i]
+		if getResourceType(actualRes) != getResourceType(expectedRes) {
+			return fmt.Errorf("resource type mismatch at index %d: actual=%s, expected=%s", i, getResourceType(actualRes), getResourceType(expectedRes))
+		}
+		if getResourceKey(actualRes) != getResourceKey(expectedRes) {
+			return fmt.Errorf("resource key mismatch at index %d: actual=%s, expected=%s", i, getResourceKey(actualRes), getResourceKey(expectedRes))
+		}
+	}
+
+	// Compare addresses
+	if len(sortedActual.Addresses) != len(sortedExpected.Addresses) {
+		return fmt.Errorf("address count mismatch: actual=%d, expected=%d", len(sortedActual.Addresses), len(sortedExpected.Addresses))
+	}
+
+	for i, actualAddr := range sortedActual.Addresses {
+		expectedAddr := sortedExpected.Addresses[i]
+		if getAddressType(actualAddr) != getAddressType(expectedAddr) {
+			return fmt.Errorf("address type mismatch at index %d: actual=%s, expected=%s", i, getAddressType(actualAddr), getAddressType(expectedAddr))
+		}
+		if getAddressIdentifier(actualAddr) != getAddressIdentifier(expectedAddr) {
+			return fmt.Errorf("address identifier mismatch at index %d: actual=%s, expected=%s", i, getAddressIdentifier(actualAddr), getAddressIdentifier(expectedAddr))
+		}
+	}
+
+	return nil
+}
+
+func newAgentGatewayXdsDumper(t *testing.T, ctx context.Context, xdsPort int, gwname, gwnamespace string) xdsDumper {
+	conn, err := grpc.NewClient(fmt.Sprintf("localhost:%d", xdsPort),
+		grpc.WithTransportCredentials(insecure.NewCredentials()),
+		grpc.WithIdleTimeout(time.Second*10),
+	)
+	if err != nil {
+		t.Fatalf("failed to connect to xds server: %v", err)
+	}
+
+	d := xdsDumper{
+		conn: conn,
+		dr: &discovery_v3.DiscoveryRequest{
+			Node: &envoycore.Node{
+				Id: "gateway.gwtest",
+				Metadata: &structpb.Struct{
+					Fields: map[string]*structpb.Value{
+						"role": structpb.NewStringValue(fmt.Sprintf("%s~%s", gwnamespace, gwname)),
+					},
+				},
+			},
+		},
+	}
+
+	ads := discovery_v3.NewAggregatedDiscoveryServiceClient(d.conn)
+	ctx, cancel := context.WithTimeout(ctx, time.Second*30) // long timeout - just in case. we should never reach it.
+	adsClient, err := ads.StreamAggregatedResources(ctx)
+	if err != nil {
+		t.Fatalf("failed to get ads client: %v", err)
+	}
+	d.adsClient = adsClient
+	d.cancel = cancel
+
+	return d
+}
+
+type agentGwDump struct {
+	Resources []*api.Resource
+	Addresses []*api.Address
+}
+
+func (x xdsDumper) DumpAgentGateway(t *testing.T, ctx context.Context) agentGwDump {
+	// get resources
+	resources := x.GetResources(t, ctx)
+	addresses := x.GetAddress(t, ctx)
+
+	return agentGwDump{
+		Resources: resources,
+		Addresses: addresses,
+	}
+}
+
+func (x xdsDumper) GetResources(t *testing.T, ctx context.Context) []*api.Resource {
+	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
+	dr.TypeUrl = agentgatewaysyncer.TargetTypeResourceUrl
+	x.adsClient.Send(dr)
+	var resources []*api.Resource
+	// run this in parallel with a 5s timeout
+	done := make(chan struct{})
+	go func() {
+		defer close(done)
+		sent := 1
+		for i := 0; i < sent; i++ {
+			dresp, err := x.adsClient.Recv()
+			if err != nil {
+				t.Errorf("failed to get response from xds server: %v", err)
+			}
+			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
+			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeResourceUrl {
+				for _, anyResource := range dresp.GetResources() {
+					var resource api.Resource
+					if err := anyResource.UnmarshalTo(&resource); err != nil {
+						t.Errorf("failed to unmarshal resource: %v", err)
+					}
+					resources = append(resources, &resource)
 				}
 			}
 		}
-		if len(dump.Listeners) != 2 {
-			t.Fatalf("expected 2 listener config, got %d", len(dump.Listeners))
+	}()
+	select {
+	case <-done:
+	case <-time.After(5 * time.Second):
+		// don't fatal yet as we want to dump the state while still connected
+		t.Error("timed out waiting for resources for agent gateway xds dump")
+		return nil
+	}
+	if len(resources) == 0 {
+		t.Error("no resources found")
+		return nil
+	}
+	t.Logf("xds: found %d resources", len(resources))
+	return resources
+}
+
+func (x xdsDumper) GetAddress(t *testing.T, ctx context.Context) []*api.Address {
+	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
+	dr.TypeUrl = agentgatewaysyncer.TargetTypeAddressUrl
+	x.adsClient.Send(dr)
+	var address []*api.Address
+	// run this in parallel with a 5s timeout
+	done := make(chan struct{})
+	go func() {
+		defer close(done)
+		sent := 1
+		for i := 0; i < sent; i++ {
+			dresp, err := x.adsClient.Recv()
+			if err != nil {
+				t.Errorf("failed to get response from xds server: %v", err)
+			}
+			t.Logf("got address response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
+			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeAddressUrl {
+				for _, anyResource := range dresp.GetResources() {
+					var resource api.Address
+					if err := anyResource.UnmarshalTo(&resource); err != nil {
+						t.Errorf("failed to unmarshal resource: %v", err)
+					}
+					address = append(address, &resource)
+				}
+			}
 		}
-		t.Logf("%s finished", t.Name())
-	})
+	}()
+	select {
+	case <-done:
+	case <-time.After(5 * time.Second):
+		// don't fatal yet as we want to dump the state while still connected
+		t.Error("timed out waiting for address resources for agent gateway xds dump")
+		return nil
+	}
+	if len(address) == 0 {
+		t.Error("no address resources found")
+		return nil
+	}
+	t.Logf("xds: found %d address resources", len(address))
+	return address
 }
diff --git a/internal/kgateway/setup/setup.go b/internal/kgateway/setup/setup.go
index 2c62811ac..696ca8e11 100644
--- a/internal/kgateway/setup/setup.go
+++ b/internal/kgateway/setup/setup.go
@@ -207,13 +207,14 @@ func StartKgatewayWithConfig(
 		return err
 	}
 
-	metrics.SetRegistry(setupOpts.GlobalSettings.EnableBuiltinDefaultMetrics, nil)
-	metrics.SetActive(!(setupOpts.MetricsBindAddress == "" || setupOpts.MetricsBindAddress == "0"))
+	if setupOpts.MetricsBindAddress == "" || setupOpts.MetricsBindAddress == "0" {
+		metrics.SetActive(false)
+	}
 
 	slog.Info("creating krt collections")
 	krtOpts := krtutil.NewKrtOptions(ctx.Done(), setupOpts.KrtDebugger)
 
-	augmentedPods := krtcollections.NewPodsCollection(kubeClient, krtOpts)
+	augmentedPods, _ := krtcollections.NewPodsCollection(kubeClient, krtOpts)
 	augmentedPodsForUcc := augmentedPods
 	if envutils.IsEnvTruthy("DISABLE_POD_LOCALITY_XDS") {
 		augmentedPodsForUcc = nil
diff --git a/internal/kgateway/setup/setup_test.go b/internal/kgateway/setup/setup_test.go
index 2d216476b..17433812a 100644
--- a/internal/kgateway/setup/setup_test.go
+++ b/internal/kgateway/setup/setup_test.go
@@ -17,9 +17,6 @@ import (
 	"testing"
 	"time"
 
-	agentgateway "github.com/agentgateway/agentgateway/go/api"
-	"github.com/agentgateway/agentgateway/go/api/a2a"
-	"github.com/agentgateway/agentgateway/go/api/mcp"
 	envoycluster "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
 	envoycore "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	envoyendpoint "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
@@ -48,7 +45,6 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/log"
 	"sigs.k8s.io/yaml"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/proxy_syncer"
 	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 	"github.com/kgateway-dev/kgateway/v2/test/envtestutil"
@@ -512,188 +508,6 @@ func newXdsDumper(t *testing.T, ctx context.Context, xdsPort int, gwname string)
 	return d
 }
 
-func newAgentGatewayXdsDumper(t *testing.T, ctx context.Context, xdsPort int, gwname, gwnamespace string) xdsDumper {
-	conn, err := grpc.NewClient(fmt.Sprintf("localhost:%d", xdsPort),
-		grpc.WithTransportCredentials(insecure.NewCredentials()),
-		grpc.WithIdleTimeout(time.Second*10),
-	)
-	if err != nil {
-		t.Fatalf("failed to connect to xds server: %v", err)
-	}
-
-	d := xdsDumper{
-		conn: conn,
-		dr: &discovery_v3.DiscoveryRequest{
-			Node: &envoycore.Node{
-				Id: "gateway.gwtest",
-				Metadata: &structpb.Struct{
-					Fields: map[string]*structpb.Value{
-						"role": structpb.NewStringValue(fmt.Sprintf("%s~%s~%s", agentgatewaysyncer.OwnerNodeId, gwnamespace, gwname)),
-					},
-				},
-			},
-		},
-	}
-
-	ads := discovery_v3.NewAggregatedDiscoveryServiceClient(d.conn)
-	ctx, cancel := context.WithTimeout(ctx, time.Second*30) // long timeout - just in case. we should never reach it.
-	adsClient, err := ads.StreamAggregatedResources(ctx)
-	if err != nil {
-		t.Fatalf("failed to get ads client: %v", err)
-	}
-	d.adsClient = adsClient
-	d.cancel = cancel
-
-	return d
-}
-
-type agentGwDump struct {
-	A2ATargets []*a2a.Target
-	McpTargets []*mcp.Target
-	Listeners  []*agentgateway.Listener
-}
-
-func (x xdsDumper) DumpAgentGateway(t *testing.T, ctx context.Context) agentGwDump {
-	// get a2a targets
-	a2aTargets := x.GetA2ATargets(t, ctx)
-	// get mcp targets
-	mcpTargets := x.GetMcpTargets(t, ctx)
-	// get listeners
-	listeners := x.GetListeners(t, ctx)
-
-	return agentGwDump{
-		A2ATargets: a2aTargets,
-		McpTargets: mcpTargets,
-		Listeners:  listeners,
-	}
-}
-
-func (x xdsDumper) GetA2ATargets(t *testing.T, ctx context.Context) []*a2a.Target {
-	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
-	dr.TypeUrl = agentgatewaysyncer.TargetTypeA2AUrl
-	x.adsClient.Send(dr)
-	var a2aTargets []*a2a.Target
-	// run this in parallel with a 5s timeout
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		sent := 1
-		for i := 0; i < sent; i++ {
-			dresp, err := x.adsClient.Recv()
-			if err != nil {
-				t.Errorf("failed to get response from xds server: %v", err)
-			}
-			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
-			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeA2AUrl {
-				for _, anyResource := range dresp.GetResources() {
-					var target a2a.Target
-					if err := anyResource.UnmarshalTo(&target); err != nil {
-						t.Errorf("failed to unmarshal target: %v", err)
-					}
-					a2aTargets = append(a2aTargets, &target)
-				}
-			}
-		}
-	}()
-	select {
-	case <-done:
-	case <-time.After(5 * time.Second):
-		// don't fatal yet as we want to dump the state while still connected
-		t.Error("timed out waiting for targets for a2a xds dump")
-		return nil
-	}
-	if len(a2aTargets) == 0 {
-		t.Error("no a2a targets found")
-		return nil
-	}
-	t.Logf("xds: found %d a2a targets", len(a2aTargets))
-	return a2aTargets
-}
-
-func (x xdsDumper) GetMcpTargets(t *testing.T, ctx context.Context) []*mcp.Target {
-	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
-	dr.TypeUrl = agentgatewaysyncer.TargetTypeMcpUrl
-	x.adsClient.Send(dr)
-	var mcpTargets []*mcp.Target
-	// run this in parallel with a 5s timeout
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		sent := 1
-		for i := 0; i < sent; i++ {
-			dresp, err := x.adsClient.Recv()
-			if err != nil {
-				t.Errorf("failed to get response from xds server: %v", err)
-			}
-			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
-			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeMcpUrl {
-				for _, anyResource := range dresp.GetResources() {
-					var target mcp.Target
-					if err := anyResource.UnmarshalTo(&target); err != nil {
-						t.Errorf("failed to unmarshal target: %v", err)
-					}
-					mcpTargets = append(mcpTargets, &target)
-				}
-			}
-		}
-	}()
-	select {
-	case <-done:
-	case <-time.After(5 * time.Second):
-		// don't fatal yet as we want to dump the state while still connected
-		t.Error("timed out waiting for targets for mcp xds dump")
-		return nil
-	}
-	if len(mcpTargets) == 0 {
-		t.Error("no mcp targets found")
-		return nil
-	}
-	t.Logf("xds: found %d mcp targets", len(mcpTargets))
-	return mcpTargets
-}
-
-func (x xdsDumper) GetListeners(t *testing.T, ctx context.Context) []*agentgateway.Listener {
-	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
-	dr.TypeUrl = agentgatewaysyncer.TargetTypeListenerUrl
-	x.adsClient.Send(dr)
-	var listeners []*agentgateway.Listener
-	// run this in parallel with a 5s timeout
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		sent := 1
-		for i := 0; i < sent; i++ {
-			dresp, err := x.adsClient.Recv()
-			if err != nil {
-				t.Errorf("failed to get response from xds server: %v", err)
-			}
-			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
-			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeListenerUrl {
-				for _, anyResource := range dresp.GetResources() {
-					var listener agentgateway.Listener
-					if err := anyResource.UnmarshalTo(&listener); err != nil {
-						t.Errorf("failed to unmarshal target: %v", err)
-					}
-					listeners = append(listeners, &listener)
-				}
-			}
-		}
-	}()
-	select {
-	case <-done:
-	case <-time.After(5 * time.Second):
-		// don't fatal yet as we want to dump the state while still connected
-		t.Error("timed out waiting for listeners for xds dump")
-		return nil
-	}
-	if len(listeners) == 0 {
-		t.Error("no listeners found")
-		return nil
-	}
-	t.Logf("xds: found %d listeners", len(listeners))
-	return listeners
-}
-
 func (x xdsDumper) Dump(t *testing.T, ctx context.Context) (xdsDump, error) {
 	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
 	dr.TypeUrl = "type.googleapis.com/envoy.config.cluster.v3.Cluster"
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
new file mode 100644
index 000000000..be8929cec
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
@@ -0,0 +1,285 @@
+{
+  "addresses": [
+    {
+      "Type": {
+        "Service": {
+          "name": "http-httproute",
+          "namespace": "gwtest",
+          "hostname": "http-httproute.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAbg=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "kubernetes",
+          "namespace": "default",
+          "hostname": "kubernetes.default.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAAQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 443,
+              "target_port": 59848
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "reviews",
+          "namespace": "gwtest",
+          "hostname": "reviews.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAA/g=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8000,
+              "target_port": 8080,
+              "app_protocol": 1
+            },
+            {
+              "service_port": 9090,
+              "target_port": 9090
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-1",
+          "name": "reviews-1",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQBCw=="
+          ],
+          "service_account": "default",
+          "node": "worker",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-1",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-2",
+          "name": "reviews-2",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQCDg=="
+          ],
+          "service_account": "default",
+          "node": "worker2",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-2",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-3",
+          "name": "reviews-3",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQDAw=="
+          ],
+          "service_account": "default",
+          "node": "worker3",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-3",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-4",
+          "name": "reviews-4",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQEBA=="
+          ],
+          "service_account": "default",
+          "node": "worker4",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-4",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
+    }
+  ],
+  "resources": [
+    {
+      "Kind": {
+        "Bind": {
+          "key": "8080/gwtest/http-httproute",
+          "port": 8080
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Listener": {
+          "key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
+          "name": "http",
+          "bind_key": "8080/gwtest/http-httproute",
+          "gateway_name": "gwtest/http-httproute",
+          "protocol": 1
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Route": {
+          "key": "gwtest.my-route.0.0.http",
+          "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
+          "route_name": "gwtest/my-route",
+          "hostnames": [
+            "www.example.com"
+          ],
+          "matches": [
+            {
+              "path": {
+                "Kind": {
+                  "PathPrefix": "/myapp"
+                }
+              }
+            }
+          ],
+          "backends": [
+            {
+              "Kind": {
+                "Service": "gwtest/reviews.gwtest.svc.cluster.local"
+              },
+              "weight": 1,
+              "port": 8080
+            }
+          ]
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Route": {
+          "key": "gwtest.my-route2.0.0.http",
+          "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
+          "route_name": "gwtest/my-route2",
+          "hostnames": [
+            "www.example2.com"
+          ],
+          "matches": [
+            {
+              "path": {
+                "Kind": {
+                  "PathPrefix": "/"
+                }
+              }
+            }
+          ],
+          "backends": [
+            {
+              "Kind": {
+                "Service": "gwtest/reviews.gwtest.svc.cluster.local"
+              },
+              "weight": 1,
+              "port": 8080
+            }
+          ]
+        }
+      }
+    }
+  ]
+}
\ No newline at end of file
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute.yaml b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
new file mode 100644
index 000000000..d0c005d8c
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
@@ -0,0 +1,92 @@
+---
+kind: Gateway
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: http-gw-for-test
+  namespace: gwtest
+spec:
+  gatewayClassName: agentgateway
+  listeners:
+    - protocol: HTTP
+      port: 8080
+      name: http
+      allowedRoutes:
+        namespaces:
+          from: All
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: reviews
+  namespace: gwtest
+  labels:
+    app: reviews
+    service: reviews
+spec:
+  ports:
+    - name: http
+      port: 8000
+      targetPort: 8080
+    - name: tcp
+      port: 9090
+  selector:
+    app: reviews
+---
+apiVersion: discovery.k8s.io/v1
+kind: EndpointSlice
+metadata:
+  name: reviews-slice
+  namespace: gwtest
+  labels:
+    kubernetes.io/service-name: reviews
+    app: reviews
+    service: reviews
+addressType: IPv4
+endpoints:
+  - addresses:
+      - 10.244.1.11
+    conditions:
+      ready: true
+    nodeName: worker
+    targetRef:
+      kind: Pod
+      name: reviews-1
+      namespace: default
+ports:
+  - name: http
+    port: 8080
+    protocol: TCP
+---
+apiVersion: gateway.networking.k8s.io/v1beta1
+kind: HTTPRoute
+metadata:
+  name: my-route
+  namespace: gwtest
+spec:
+  parentRefs:
+    - name: http-gw-for-test
+  hostnames:
+    - "www.example.com"
+  rules:
+    - matches:
+        - path:
+            type: PathPrefix
+            value: /myapp
+      backendRefs:
+        - name: reviews
+          port: 8080
+---
+apiVersion: gateway.networking.k8s.io/v1beta1
+kind: HTTPRoute
+metadata:
+  name: my-route2
+  namespace: gwtest
+spec:
+  parentRefs:
+    - name: http-gw-for-test
+  hostnames:
+    - "www.example2.com"
+  rules:
+    - backendRefs:
+        - name: reviews
+          port: 8080
\ No newline at end of file
diff --git a/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
new file mode 100644
index 000000000..ab31fcdfd
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
@@ -0,0 +1,232 @@
+{
+  "addresses": [
+    {
+      "Type": {
+        "Service": {
+          "name": "gateway-pool-endpoint-picker",
+          "namespace": "gwtest",
+          "hostname": "gateway-pool-endpoint-picker.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAATQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 9002,
+              "target_port": 9002,
+              "app_protocol": 3
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "gateway-pool",
+          "namespace": "gwtest",
+          "hostname": "gateway-pool.gwtest.inference.cluster.local",
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080,
+              "app_protocol": 1
+            }
+          ]
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "http-httproute",
+          "namespace": "gwtest",
+          "hostname": "http-httproute.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAbg=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "http-inferencepool",
+          "namespace": "gwtest",
+          "hostname": "http-inferencepool.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAIQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "kubernetes",
+          "namespace": "default",
+          "hostname": "kubernetes.default.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAAQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 443,
+              "target_port": 59848
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-1",
+          "name": "reviews-1",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQBCw=="
+          ],
+          "service_account": "default",
+          "node": "worker",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-1",
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-2",
+          "name": "reviews-2",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQCDg=="
+          ],
+          "service_account": "default",
+          "node": "worker2",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-2",
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-3",
+          "name": "reviews-3",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQDAw=="
+          ],
+          "service_account": "default",
+          "node": "worker3",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-3",
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-4",
+          "name": "reviews-4",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQEBA=="
+          ],
+          "service_account": "default",
+          "node": "worker4",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-4",
+          "status": 1
+        }
+      }
+    }
+  ],
+  "resources": [
+    {
+      "Kind": {
+        "Bind": {
+          "key": "8080/gwtest/http-inferencepool",
+          "port": 8080
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Listener": {
+          "key": "http-inferencepool-agentgateway-autogenerated-k8s-gateway-http",
+          "name": "http",
+          "bind_key": "8080/gwtest/http-inferencepool",
+          "gateway_name": "gwtest/http-inferencepool",
+          "protocol": 1
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Route": {
+          "key": "gwtest.gateway-route.0.0.http",
+          "listener_key": "http-inferencepool-agentgateway-autogenerated-k8s-gateway-http",
+          "route_name": "gwtest/gateway-route",
+          "hostnames": [
+            "www.example.com"
+          ],
+          "matches": [
+            {
+              "path": {
+                "Kind": {
+                  "PathPrefix": "/"
+                }
+              }
+            }
+          ],
+          "backends": [
+            {
+              "Kind": {
+                "Service": "gwtest/gateway-pool.gwtest.inference.cluster.local"
+              },
+              "weight": 1,
+              "port": 8080
+            }
+          ]
+        }
+      }
+    }
+  ]
+}
\ No newline at end of file
diff --git a/internal/kgateway/setup/testdata/agentgateway/inferencepool.yaml b/internal/kgateway/setup/testdata/agentgateway/inferencepool.yaml
new file mode 100644
index 000000000..7782b7a4c
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/inferencepool.yaml
@@ -0,0 +1,65 @@
+# One Gateway with one HTTPRoute referencing one InferencePool
+---
+kind: Gateway
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: http-gw-for-test
+  namespace: gwtest
+spec:
+  gatewayClassName: agentgateway
+  listeners:
+    - protocol: HTTP
+      port: 8080
+      name: http
+      allowedRoutes:
+        namespaces:
+          from: All
+---
+apiVersion: gateway.networking.k8s.io/v1beta1
+kind: HTTPRoute
+metadata:
+  name: gateway-route
+  namespace: gwtest
+spec:
+  parentRefs:
+    - name: http-gw-for-test
+  hostnames:
+    - "www.example.com"
+  rules:
+    - backendRefs:
+        - name: gateway-pool
+          kind: InferencePool
+          group: inference.networking.x-k8s.io
+          weight: 1
+---
+# This service is auto created by the inference extension deployer but it's created
+# here for clean-up purposes (avoid test pollution). Repeat for additional endpoint
+# picker tests or until test cases are run in parallel.
+apiVersion: v1
+kind: Service
+metadata:
+  name: gateway-pool-endpoint-picker
+  namespace: gwtest
+spec:
+  ports:
+    - name: grpc
+      port: 9002
+      targetPort: 9002
+  selector:
+    app: gateway
+---
+apiVersion: inference.networking.x-k8s.io/v1alpha2
+kind: InferencePool
+metadata:
+  name: gateway-pool
+  namespace: gwtest
+spec:
+  extensionRef:
+    failureMode: FailClose
+    group: ""
+    kind: Service
+    name: gateway-pool-endpoint-picker
+    portNumber: 9002
+  selector:
+    app: gateway
+  targetPortNumber: 8080
diff --git a/internal/kgateway/setup/testdata/standard/cors-httproute-rule-out.yaml b/internal/kgateway/setup/testdata/standard/cors-httproute-rule-out.yaml
index 04caa80ac..9d3987ac2 100644
--- a/internal/kgateway/setup/testdata/standard/cors-httproute-rule-out.yaml
+++ b/internal/kgateway/setup/testdata/standard/cors-httproute-rule-out.yaml
@@ -95,10 +95,5 @@ routes:
           '@type': type.googleapis.com/envoy.extensions.filters.http.cors.v3.CorsPolicy
           allowMethods: POST
           allowOriginStringMatch:
-          - safeRegex:
-              googleRe2: {}
-              regex: ^https://.*\.notexample\.com$
-          - prefix: https://a.b
-          - exact: https://exact.domain.com
-          - prefix: http://
+          - exact: https://notexample.com
           maxAge: "5"
diff --git a/internal/kgateway/setup/testdata/standard/cors-httproute-rule.yaml b/internal/kgateway/setup/testdata/standard/cors-httproute-rule.yaml
index 99a2c0964..1e9bde7df 100644
--- a/internal/kgateway/setup/testdata/standard/cors-httproute-rule.yaml
+++ b/internal/kgateway/setup/testdata/standard/cors-httproute-rule.yaml
@@ -112,10 +112,7 @@ spec:
     filters: # Filters that are applied at the rule level
       - cors:
           allowOrigins:
-          - "https://*.notexample.com"
-          - "https://a.b*"
-          - "https://exact.domain.com"
-          - "http://*"
+          - "https://notexample.com"
           allowMethods:
           - POST
         type: CORS
\ No newline at end of file
diff --git a/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route-out.yaml b/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route-out.yaml
index 0166a67b0..c6324f3e2 100644
--- a/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route-out.yaml
+++ b/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route-out.yaml
@@ -78,10 +78,5 @@ routes:
           allowMethods: GET, POST, OPTIONS
           allowOriginStringMatch:
           - exact: https://example.com
-          - safeRegex:
-              googleRe2: {}
-              regex: ^https://.*\.notexample\.com$
-          - prefix: https://a.b
-          - prefix: http://
           exposeHeaders: X-Custom-Header
           maxAge: "86400"
diff --git a/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route.yaml b/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route.yaml
index 0efc74f4d..4158f96ef 100644
--- a/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route.yaml
+++ b/internal/kgateway/setup/testdata/standard/cors-trafficpolicy-route.yaml
@@ -82,9 +82,6 @@ spec:
   cors:
     allowOrigins:
     - "https://example.com"
-    - "https://*.notexample.com"
-    - "https://a.b*"
-    - "http://*"
     allowMethods:
     - "GET"
     - "POST"
diff --git a/internal/kgateway/translator/gateway/gateway_translator_test.go b/internal/kgateway/translator/gateway/gateway_translator_test.go
index 5f580b207..152a6aaae 100644
--- a/internal/kgateway/translator/gateway/gateway_translator_test.go
+++ b/internal/kgateway/translator/gateway/gateway_translator_test.go
@@ -257,28 +257,6 @@ var _ = DescribeTable("Basic GatewayTranslator Tests",
 				assertAcceptedPolicyStatus(reportsMap, expectedPolicies)
 			},
 		}),
-	Entry(
-		"TrafficPolicy with targetSelectors and global policy attachment",
-		translatorTestCase{
-			inputFile:  "traffic-policy/label_based.yaml",
-			outputFile: "traffic-policy/label_based_global_policy.yaml",
-			gwNN: types.NamespacedName{
-				Namespace: "infra",
-				Name:      "example-gateway",
-			},
-			assertReports: func(gwNN types.NamespacedName, reportsMap reports.ReportMap) {
-				expectedPolicies := []reports.PolicyKey{
-					{Group: "gateway.kgateway.dev", Kind: "TrafficPolicy", Namespace: "infra", Name: "transform"},
-					{Group: "gateway.kgateway.dev", Kind: "TrafficPolicy", Namespace: "infra", Name: "rate-limit"},
-					{Group: "gateway.kgateway.dev", Kind: "TrafficPolicy", Namespace: "kgateway-system", Name: "global-policy"},
-				}
-				assertAcceptedPolicyStatus(reportsMap, expectedPolicies)
-			},
-		},
-		func(s *settings.Settings) {
-			s.GlobalPolicyNamespace = "kgateway-system"
-		},
-	),
 	Entry(
 		"TrafficPolicy edge cases",
 		translatorTestCase{
@@ -289,26 +267,6 @@ var _ = DescribeTable("Basic GatewayTranslator Tests",
 				Name:      "example-gateway",
 			},
 		}),
-	Entry(
-		"TrafficPolicy with buffer attached to gateway",
-		translatorTestCase{
-			inputFile:  "traffic-policy/buffer-gateway.yaml",
-			outputFile: "traffic-policy/buffer-gateway.yaml",
-			gwNN: types.NamespacedName{
-				Namespace: "default",
-				Name:      "example-gateway",
-			},
-		}),
-	Entry(
-		"TrafficPolicy with buffer attached to route",
-		translatorTestCase{
-			inputFile:  "traffic-policy/buffer-route.yaml",
-			outputFile: "traffic-policy/buffer-route.yaml",
-			gwNN: types.NamespacedName{
-				Namespace: "default",
-				Name:      "example-gateway",
-			},
-		}),
 	Entry(
 		"tcp gateway with basic routing",
 		translatorTestCase{
@@ -628,89 +586,6 @@ var _ = DescribeTable("Basic GatewayTranslator Tests",
 			Name:      "example-gateway",
 		},
 	}),
-	Entry("DirectResponse with missing reference reports correctly", translatorTestCase{
-		inputFile:  "directresponse/missing-ref.yaml",
-		outputFile: "directresponse/missing-ref.yaml",
-		gwNN: types.NamespacedName{
-			Namespace: "default",
-			Name:      "example-gateway",
-		},
-		assertReports: func(gwNN types.NamespacedName, reportsMap reports.ReportMap) {
-			route := &gwv1.HTTPRoute{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "example-route",
-					Namespace: "default",
-				},
-			}
-			routeStatus := reportsMap.BuildRouteStatus(context.Background(), route, wellknown.DefaultGatewayClassName)
-			Expect(routeStatus).NotTo(BeNil())
-			Expect(routeStatus.Parents).To(HaveLen(1))
-
-			// The route itself is considered resolved, but there should be a condition indicating the DirectResponse issue
-			resolvedRefs := meta.FindStatusCondition(routeStatus.Parents[0].Conditions, string(gwv1.RouteConditionResolvedRefs))
-			Expect(resolvedRefs).NotTo(BeNil())
-			Expect(resolvedRefs.Status).To(Equal(metav1.ConditionTrue))
-			Expect(resolvedRefs.Reason).To(Equal(string(gwv1.RouteReasonResolvedRefs)))
-
-			// Check if there's a PartiallyInvalid condition that reports the missing DirectResponse
-			partiallyInvalid := meta.FindStatusCondition(routeStatus.Parents[0].Conditions, string(gwv1.RouteConditionPartiallyInvalid))
-			Expect(partiallyInvalid).NotTo(BeNil())
-			Expect(partiallyInvalid.Status).To(Equal(metav1.ConditionTrue))
-			Expect(partiallyInvalid.Message).To(ContainSubstring("Dropped Rule"))
-			Expect(partiallyInvalid.Message).To(ContainSubstring("no action specified"))
-		},
-	}),
-	Entry("DirectResponse with overlapping filters reports correctly", translatorTestCase{
-		inputFile:  "directresponse/overlapping-filters.yaml",
-		outputFile: "directresponse/overlapping-filters.yaml",
-		gwNN: types.NamespacedName{
-			Namespace: "default",
-			Name:      "example-gateway",
-		},
-		assertReports: func(gwNN types.NamespacedName, reportsMap reports.ReportMap) {
-			route := &gwv1.HTTPRoute{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "example-route",
-					Namespace: "default",
-				},
-			}
-			routeStatus := reportsMap.BuildRouteStatus(context.Background(), route, wellknown.DefaultGatewayClassName)
-			Expect(routeStatus).NotTo(BeNil())
-			Expect(routeStatus.Parents).To(HaveLen(1))
-
-			// Check for PartiallyInvalid condition due to overlapping filters
-			partiallyInvalid := meta.FindStatusCondition(routeStatus.Parents[0].Conditions, string(gwv1.RouteConditionPartiallyInvalid))
-			Expect(partiallyInvalid).NotTo(BeNil())
-			Expect(partiallyInvalid.Status).To(Equal(metav1.ConditionTrue))
-			Expect(partiallyInvalid.Reason).To(Equal(string(gwv1.RouteReasonUnsupportedValue)))
-			Expect(partiallyInvalid.Message).To(ContainSubstring("cannot be applied to route with existing action"))
-		},
-	}),
-	Entry("DirectResponse with invalid backendRef filter reports correctly", translatorTestCase{
-		inputFile:  "directresponse/invalid-backendref-filter.yaml",
-		outputFile: "directresponse/invalid-backendref-filter.yaml",
-		gwNN: types.NamespacedName{
-			Namespace: "default",
-			Name:      "example-gateway",
-		},
-		assertReports: func(gwNN types.NamespacedName, reportsMap reports.ReportMap) {
-			route := &gwv1.HTTPRoute{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "example-route",
-					Namespace: "default",
-				},
-			}
-			routeStatus := reportsMap.BuildRouteStatus(context.Background(), route, wellknown.DefaultGatewayClassName)
-			Expect(routeStatus).NotTo(BeNil())
-			Expect(routeStatus.Parents).To(HaveLen(1))
-
-			// DirectResponse attached to backendRef should be ignored, route should resolve normally
-			resolvedRefs := meta.FindStatusCondition(routeStatus.Parents[0].Conditions, string(gwv1.RouteConditionResolvedRefs))
-			Expect(resolvedRefs).NotTo(BeNil())
-			Expect(resolvedRefs.Status).To(Equal(metav1.ConditionTrue))
-			Expect(resolvedRefs.Reason).To(Equal(string(gwv1.RouteReasonResolvedRefs)))
-		},
-	}),
 	Entry("HTTPRoutes with timeout and retry", translatorTestCase{
 		inputFile:  "httproute-timeout-retry/manifest.yaml",
 		outputFile: "httproute-timeout-retry-proxy.yaml",
@@ -835,14 +710,6 @@ var _ = DescribeTable("Basic GatewayTranslator Tests",
 			Name:      "example-gateway",
 		},
 	}),
-	Entry("Backend Config Policy with TLS and SAN verification", translatorTestCase{
-		inputFile:  "backendconfigpolicy/tls-san.yaml",
-		outputFile: "backendconfigpolicy/tls-san.yaml",
-		gwNN: types.NamespacedName{
-			Namespace: "default",
-			Name:      "example-gateway",
-		},
-	}),
 	Entry(
 		"TrafficPolicy with explicit generation",
 		translatorTestCase{
@@ -873,7 +740,7 @@ var _ = DescribeTable("Basic GatewayTranslator Tests",
 )
 
 var _ = DescribeTable("Route Delegation translator",
-	func(inputFile string, errors map[types.NamespacedName]string) {
+	func(inputFile string, errdesc string) {
 		dir := fsutils.MustGetThisDir()
 		translatortest.TestTranslation(
 			GinkgoT(),
@@ -888,76 +755,39 @@ var _ = DescribeTable("Route Delegation translator",
 				Name:      "example-gateway",
 			},
 			func(gwNN types.NamespacedName, reportsMap reports.ReportMap) {
-				if errors == nil {
+				if errdesc == "" {
 					Expect(translatortest.AreReportsSuccess(gwNN, reportsMap)).NotTo(HaveOccurred())
 				} else {
-					for route, err := range errors {
-						Expect(translatortest.GetHTTPRouteStatusError(reportsMap, &route)).To(MatchError(ContainSubstring(err)))
-					}
+					Expect(translatortest.AreReportsSuccess(gwNN, reportsMap)).To(MatchError(ContainSubstring(errdesc)))
 				}
 			},
 		)
 	},
-	Entry("Basic config", "basic.yaml", nil),
-	Entry("Child matches parent via parentRefs", "basic_parentref_match.yaml", nil),
-	Entry("Child doesn't match parent via parentRefs", "basic_parentref_mismatch.yaml",
-		map[types.NamespacedName]string{
-			{Name: "example-route", Namespace: "infra"}: "BackendNotFound gateway.networking.k8s.io/HTTPRoute/a/*: unresolved reference",
-		},
-	),
-	Entry("Children using parentRefs and inherit-parent-matcher", "inherit_parentref.yaml", nil),
-	Entry("Parent delegates to multiple chidren", "multiple_children.yaml", nil),
-	Entry("Child is invalid as it is delegatee and specifies hostnames", "basic_invalid_hostname.yaml",
-		map[types.NamespacedName]string{
-			{Name: "route-a", Namespace: "a"}:           "spec.hostnames must be unset on a delegatee route as they are inherited from the parent route",
-			{Name: "example-route", Namespace: "infra"}: "BackendNotFound gateway.networking.k8s.io/HTTPRoute/a/*: unresolved reference",
-		},
-	),
-	Entry("Multi-level recursive delegation", "recursive.yaml", nil),
-	Entry("Cyclic child route", "cyclic1.yaml",
-		map[types.NamespacedName]string{
-			{Name: "route-a", Namespace: "a"}: "cyclic reference detected while evaluating delegated routes",
-		},
-	),
-	Entry("Multi-level cyclic child route", "cyclic2.yaml",
-		map[types.NamespacedName]string{
-			{Name: "route-a-b", Namespace: "a-b"}: "cyclic reference detected while evaluating delegated routes",
-		},
-	),
-	Entry("Child rule matcher", "child_rule_matcher.yaml",
-		map[types.NamespacedName]string{
-			{Name: "example-route", Namespace: "infra"}: "BackendNotFound gateway.networking.k8s.io/HTTPRoute/b/*: unresolved reference",
-		},
-	),
-	Entry("Child with multiple parents", "multiple_parents.yaml",
-		map[types.NamespacedName]string{
-			{Name: "foo-route", Namespace: "infra"}: "BackendNotFound gateway.networking.k8s.io/HTTPRoute/b/*: unresolved reference",
-		},
-	),
-	Entry("Child can be an invalid delegatee but valid standalone", "invalid_child_valid_standalone.yaml",
-		map[types.NamespacedName]string{
-			{Name: "route-a", Namespace: "a"}: "spec.hostnames must be unset on a delegatee route as they are inherited from the parent route",
-		},
-	),
-	Entry("Relative paths", "relative_paths.yaml", nil),
-	Entry("Nested absolute and relative path inheritance", "nested_absolute_relative.yaml", nil),
-	Entry("Child route matcher does not match parent", "discard_invalid_child_matches.yaml", nil),
-	Entry("Multi-level multiple parents delegation", "multi_level_multiple_parents.yaml", nil),
-	Entry("TrafficPolicy only on child", "traffic_policy.yaml", nil),
-	Entry("TrafficPolicy inheritance from parent", "traffic_policy_inheritance.yaml", nil),
-	Entry("TrafficPolicy ignore child override on conflict", "traffic_policy_inheritance_child_override_ignore.yaml", nil),
-	Entry("TrafficPolicy merge child override on no conflict", "traffic_policy_inheritance_child_override_ok.yaml", nil),
-	Entry("TrafficPolicy multi level inheritance with child override disabled", "traffic_policy_multi_level_inheritance_override_disabled.yaml", nil),
-	Entry("TrafficPolicy multi level inheritance with child override enabled", "traffic_policy_multi_level_inheritance_override_enabled.yaml", nil),
-	Entry("TrafficPolicy filter override merge", "traffic_policy_filter_override_merge.yaml", nil),
-	Entry("Built-in rule inheritance", "builtin_rule_inheritance.yaml", nil),
-	Entry("Label based delegation", "label_based.yaml", nil),
-	Entry("Unresolved child reference", "unresolved_ref.yaml",
-		map[types.NamespacedName]string{
-			{Name: "example-route", Namespace: "infra"}: "BackendNotFound gateway.networking.k8s.io/HTTPRoute/b/*: unresolved reference",
-			{Name: "route-a", Namespace: "a"}:           "BackendNotFound gateway.networking.k8s.io/HTTPRoute/a-c/: unresolved reference",
-		},
-	),
+	Entry("Basic config", "basic.yaml", ""),
+	Entry("Child matches parent via parentRefs", "basic_parentref_match.yaml", ""),
+	Entry("Child doesn't match parent via parentRefs", "basic_parentref_mismatch.yaml", "BackendNotFound unresolved reference gateway.networking.k8s.io/HTTPRoute/a/*"),
+	Entry("Children using parentRefs and inherit-parent-matcher", "inherit_parentref.yaml", ""),
+	Entry("Parent delegates to multiple chidren", "multiple_children.yaml", ""),
+	Entry("Child is invalid as it is delegatee and specifies hostnames", "basic_invalid_hostname.yaml", "spec.hostnames must be unset on a delegatee route as they are inherited from the parent route"),
+	Entry("Multi-level recursive delegation", "recursive.yaml", ""),
+	Entry("Cyclic child route", "cyclic1.yaml", "cyclic reference detected while evaluating delegated routes"),
+	Entry("Multi-level cyclic child route", "cyclic2.yaml", "cyclic reference detected while evaluating delegated routes"),
+	Entry("Child rule matcher", "child_rule_matcher.yaml", ""),
+	Entry("Child with multiple parents", "multiple_parents.yaml", "BackendNotFound unresolved reference gateway.networking.k8s.io/HTTPRoute/b/*"),
+	Entry("Child can be an invalid delegatee but valid standalone", "invalid_child_valid_standalone.yaml", "spec.hostnames must be unset on a delegatee route as they are inherited from the parent route"),
+	Entry("Relative paths", "relative_paths.yaml", ""),
+	Entry("Nested absolute and relative path inheritance", "nested_absolute_relative.yaml", ""),
+	Entry("Child route matcher does not match parent", "discard_invalid_child_matches.yaml", ""),
+	Entry("Multi-level multiple parents delegation", "multi_level_multiple_parents.yaml", ""),
+	Entry("TrafficPolicy only on child", "traffic_policy.yaml", ""),
+	Entry("TrafficPolicy inheritance from parent", "traffic_policy_inheritance.yaml", ""),
+	Entry("TrafficPolicy ignore child override on conflict", "traffic_policy_inheritance_child_override_ignore.yaml", ""),
+	Entry("TrafficPolicy merge child override on no conflict", "traffic_policy_inheritance_child_override_ok.yaml", ""),
+	Entry("TrafficPolicy multi level inheritance with child override disabled", "traffic_policy_multi_level_inheritance_override_disabled.yaml", ""),
+	Entry("TrafficPolicy multi level inheritance with child override enabled", "traffic_policy_multi_level_inheritance_override_enabled.yaml", ""),
+	Entry("TrafficPolicy filter override merge", "traffic_policy_filter_override_merge.yaml", ""),
+	Entry("Built-in rule inheritance", "builtin_rule_inheritance.yaml", ""),
+	Entry("Label based delegation", "label_based.yaml", ""),
 )
 
 var _ = DescribeTable("Discovery Namespace Selector",
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/backendconfigpolicy/tls-san.yaml b/internal/kgateway/translator/gateway/testutils/inputs/backendconfigpolicy/tls-san.yaml
deleted file mode 100644
index bfba6b347..000000000
--- a/internal/kgateway/translator/gateway/testutils/inputs/backendconfigpolicy/tls-san.yaml
+++ /dev/null
@@ -1,75 +0,0 @@
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: example-gateway
-spec:
-  gatewayClassName: kgateway
-  listeners:
-  - protocol: HTTP
-    port: 8080
-    name: http
-    allowedRoutes:
-      namespaces:
-        from: All
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: backend-service
-  labels:
-    app: backend
-    service: backend
-spec:
-  ports:
-    - name: https
-      port: 443
-      targetPort: 8443
-      appProtocol: https
-  selector:
-    app: backend
----
-apiVersion: v1
-kind: Secret
-metadata:
-  name: client-tls-secret
-type: kubernetes.io/tls
-data:
-  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURGekNDQWYrZ0F3SUJBZ0lVVVAramhQa3Jpa2RxVzg3bEhNRHBXM3dZMTN3d0RRWUpLb1pJaHZjTkFRRUwKQlFBd0d6RVpNQmNHQTFVRUF3d1FkR1Z6ZEM1bGVHRnRjR3hsTG1OdmJUQWVGdzB5TlRBM01ESXhNak0wTWpSYQpGdzB5TmpBM01ESXhNak0wTWpSYU1Cc3hHVEFYQmdOVkJBTU1FSFJsYzNRdVpYaGhiWEJzWlM1amIyMHdnZ0VpCk1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQkFRQzJ4UGkreEwrNU05ZTZ1SmI0QjlmOURzMnoKMU1xZXEyT21FYVBBd2cxQk9hUnBnOXBaNVg5amFqL0xHa0o4WDdCUjZEZk1PRXZ4RUJ1MnVndk8vemxOVmQyMwp1V2N4ZFNNalJCNTJtR1pETnljc1NDS1NKNzFFZWFXamhJNytJR2RKSjJyemF3Mk5ad2lDZmNqVmdrSDdHZnhmCk9ZYzdtbTE4d2lmOVl4VkppODdJRjhhQkpFNnU3YUtoblFUK1NnRDJ3OTErT1pORlZCZEZFSWNxalJIMVdNT0YKS2tDWThlanIwYWlCV2ltUVZrNDFpTGoxL0YvYlNxaGRhZE1sQlJjM1RvTEZYT1kzOUhsVTdEcTdjZjJRZlZ3Zgp6a1VWaUZ3cHp2UEVUWC9XVk85SWlWRXhEM2NwQzN6VWpEdWtqU0FkMjZRUzR4UDRtdm5qbzNweW1OVG5BZ01CCkFBR2pVekJSTUIwR0ExVWREZ1FXQkJTazNGbFdpSDkyMzZ5NWhoajdJdFQvZWZTc1ZqQWZCZ05WSFNNRUdEQVcKZ0JTazNGbFdpSDkyMzZ5NWhoajdJdFQvZWZTc1ZqQVBCZ05WSFJNQkFmOEVCVEFEQVFIL01BMEdDU3FHU0liMwpEUUVCQ3dVQUE0SUJBUUIvajhlRDRUZlV1Q1BQQ3AzN1BkL1lpV1VGYTBwWldEMXJKY3dadG1aRlcyRTcvODZUCmwweUJFY2diS0lzWm1VVDJybkpHNHpjQ3VtQXhwelA1THVvTzlXdTVSVWdxRmJNK25HblEzOXc1M21WQzNDVjQKaGNaeFNOaXpNaWNTd21BMDFNNEhUZHY5UDd0ai83bTl0VGI4VlEvVHl3STNrZE1hak9QREkrR3RyRTc2bStwUApzb3pRb3R2Uk1SbW9uYTkrNDk2TEJGc1N0QmFQOE5pQXFaZnVsZU5qMGhEMW9BZEwzZWtRK0haMWIxQUJmYTZECkJ4SXJRQ1Z2eUM0SmwwekxtbkVEUElCdnNyb0NWaXZxNEMvTUtYYlhzbi9iRHJoTUhkNXlxRHYxL21tdkdSU24KMmI1dk5hMWFWdElxV0pHS3B1STJyS3pkN0xTSVF2K2t1RkYzCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
-  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQzJ4UGkreEwrNU05ZTYKdUpiNEI5ZjlEczJ6MU1xZXEyT21FYVBBd2cxQk9hUnBnOXBaNVg5amFqL0xHa0o4WDdCUjZEZk1PRXZ4RUJ1Mgp1Z3ZPL3psTlZkMjN1V2N4ZFNNalJCNTJtR1pETnljc1NDS1NKNzFFZWFXamhJNytJR2RKSjJyemF3Mk5ad2lDCmZjalZna0g3R2Z4Zk9ZYzdtbTE4d2lmOVl4VkppODdJRjhhQkpFNnU3YUtoblFUK1NnRDJ3OTErT1pORlZCZEYKRUljcWpSSDFXTU9GS2tDWThlanIwYWlCV2ltUVZrNDFpTGoxL0YvYlNxaGRhZE1sQlJjM1RvTEZYT1kzOUhsVQo3RHE3Y2YyUWZWd2Z6a1VWaUZ3cHp2UEVUWC9XVk85SWlWRXhEM2NwQzN6VWpEdWtqU0FkMjZRUzR4UDRtdm5qCm8zcHltTlRuQWdNQkFBRUNnZ0VBQnZ3cGZZWkxjQ3FPWTNFaE9VTE9KYnBtY05SVndoRk94NlFEbkI3NUhyV3oKUU9Kc2VvOE9KVXN1NWt1UFN1MlA4WWJCeXlqdVRoSTRNa0xvcDBxVEhXVGJYN3JTNU0yb2xYVWZBa0treXpZcQpaY09EL3JpaUZTSGVZTGQwNGpySmQ3N3RQc3hTbDVyZWRRNUFSSzRCRTRyL1hZR2lBaUhPeEJFdmgyYm9BMTE4Cm1pejZzMjhhSXVxekZoUUdpOEh5ejREOVJCUzJkRWFsazFWK2V1QVhocHFxZ29HRms4TFhrWGxtUlpzZVdYN0MKZEpyVjhQL0grTGZXb3JCM09KRGs3SWIrek9Cc0pLeklwM3NiRlVsajdraGcyd2xjYi9SZUQrUU5BR1VQR3h1YQpHVndqRFVBSmpwb1RmamhIdjdhYUwwaWtyVVB6a1J2TEFQdjBwc0syb1FLQmdRRE05V2tyZkFhZjh2ZVNxR2lzCk1aSkNtOWFVVkUwdGY4eWkxL3owaGxRYlJFb25Mc2xZM0NCWlFZMHZ1T1owWFc1U29PQ1BUamRKRW1lUjFHTFIKVS9BSUJwRmhnNW5VMVIxaEprUkkyOWtPaGFHVXFBREpSR1ErZWdhK0IrQldLNVhUa3hGVFdFRjBSRDhVWENkQQpXa2lzaFBrU1V0VjV2VjdqNy9ibitSR09hUUtCZ1FEa1NQSmlBMTFNODhBSENTdjRWaHJDb3NRdjZURnZyK0p2CnFJVmlmMHowcFBvT0ZDVE1OdUcxN1Zxa29WV0d6U0R6ejBMYUJHWllGRlk5M2E0cGtxZWNnS3kxZVN1eHJKdlEKUko4WTRKSXpKYXlDbzRhc0lURGJPV21LaGk1am92bHkxRDVmSlFKMjNyUVNsWlRSbHVOdWJpVWxTQkErTS9EcQptcFg4c3ZkK3p3S0JnSCszTlEvWnV5OFVjZDA3Zis0OC9ZendHdWhYRjdpUWVHM0k5V0ZTQ3pycWRPS3hydG5tCllXbjlCUU9Gem1VWWkxU0YxeWkxYnBIa0hCR3RMTjZQMVhUSzB2RFcxcGJmTGUySnNPZE54NVhiQTNMa3RZaTEKUzFuN0pCUnFTQXFxSWpTeTRncnpaZVlUV05OUkVVeHlkZks2OFpIUGVDTGlOQzBKTE93a01pSnhBb0dCQUkvMgpGS3lNdEp6ZnBueUpZeW96bXFLZHBKMFdNTy9lK2l3eUdSTzVkZDFkNExkYUtxNkIrYXNSNkxTamJWMGFKU3E3CnpNdlNOSHhkTHRuSzM1Y2wvZjlyQWY5YlQ1dTNYM2RpbnZaQVFOSnljcXpiMVFUZDFZS2FYUjFYYXcrNGFoanAKRWdCTVJaYVM4UG83VEdNMEJXN1JsU2xDbmNPc1c4U0hBZ2tmRDRidkFvR0FUdmxGT0JiNDJmb3hIMTZsQzVtbQpsZThYdWd0eE5zUGY1OTVUVWw4OFRVZVhnZXlFUlQwMDY4NGo4M0pxcjViTENoc016RlYraTUwUjVQWnZsYW1tCnVkdm04NEFmblN1MktHaVBoTFovZkU2K3NVT284NWIza3R6UkZreFBIQklkbEt6V3FWRDhhV0NjcmxGbjdXTVUKM3RlUllXL2NFRFExUFRnTGZBa2I3Rms9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K
-  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURGekNDQWYrZ0F3SUJBZ0lVVVAramhQa3Jpa2RxVzg3bEhNRHBXM3dZMTN3d0RRWUpLb1pJaHZjTkFRRUwKQlFBd0d6RVpNQmNHQTFVRUF3d1FkR1Z6ZEM1bGVHRnRjR3hsTG1OdmJUQWVGdzB5TlRBM01ESXhNak0wTWpSYQpGdzB5TmpBM01ESXhNak0wTWpSYU1Cc3hHVEFYQmdOVkJBTU1FSFJsYzNRdVpYaGhiWEJzWlM1amIyMHdnZ0VpCk1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQkFRQzJ4UGkreEwrNU05ZTZ1SmI0QjlmOURzMnoKMU1xZXEyT21FYVBBd2cxQk9hUnBnOXBaNVg5amFqL0xHa0o4WDdCUjZEZk1PRXZ4RUJ1MnVndk8vemxOVmQyMwp1V2N4ZFNNalJCNTJtR1pETnljc1NDS1NKNzFFZWFXamhJNytJR2RKSjJyemF3Mk5ad2lDZmNqVmdrSDdHZnhmCk9ZYzdtbTE4d2lmOVl4VkppODdJRjhhQkpFNnU3YUtoblFUK1NnRDJ3OTErT1pORlZCZEZFSWNxalJIMVdNT0YKS2tDWThlanIwYWlCV2ltUVZrNDFpTGoxL0YvYlNxaGRhZE1sQlJjM1RvTEZYT1kzOUhsVTdEcTdjZjJRZlZ3Zgp6a1VWaUZ3cHp2UEVUWC9XVk85SWlWRXhEM2NwQzN6VWpEdWtqU0FkMjZRUzR4UDRtdm5qbzNweW1OVG5BZ01CCkFBR2pVekJSTUIwR0ExVWREZ1FXQkJTazNGbFdpSDkyMzZ5NWhoajdJdFQvZWZTc1ZqQWZCZ05WSFNNRUdEQVcKZ0JTazNGbFdpSDkyMzZ5NWhoajdJdFQvZWZTc1ZqQVBCZ05WSFJNQkFmOEVCVEFEQVFIL01BMEdDU3FHU0liMwpEUUVCQ3dVQUE0SUJBUUIvajhlRDRUZlV1Q1BQQ3AzN1BkL1lpV1VGYTBwWldEMXJKY3dadG1aRlcyRTcvODZUCmwweUJFY2diS0lzWm1VVDJybkpHNHpjQ3VtQXhwelA1THVvTzlXdTVSVWdxRmJNK25HblEzOXc1M21WQzNDVjQKaGNaeFNOaXpNaWNTd21BMDFNNEhUZHY5UDd0ai83bTl0VGI4VlEvVHl3STNrZE1hak9QREkrR3RyRTc2bStwUApzb3pRb3R2Uk1SbW9uYTkrNDk2TEJGc1N0QmFQOE5pQXFaZnVsZU5qMGhEMW9BZEwzZWtRK0haMWIxQUJmYTZECkJ4SXJRQ1Z2eUM0SmwwekxtbkVEUElCdnNyb0NWaXZxNEMvTUtYYlhzbi9iRHJoTUhkNXlxRHYxL21tdkdSU24KMmI1dk5hMWFWdElxV0pHS3B1STJyS3pkN0xTSVF2K2t1RkYzCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
----
-kind: BackendConfigPolicy
-apiVersion: gateway.kgateway.dev/v1alpha1
-metadata:
-  name: backend-tls-policy
-spec:
-  targetRefs:
-    - name: backend-service
-      group: ""
-      kind: Service
-  tls:
-    secretRef:
-      name: client-tls-secret
-    sni: test.example.com
-    verifySubjectAltName:
-      - test.example.com
-      - api.example.com
-    allowRenegotiation: true
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: backend-route
-spec:
-  parentRefs:
-    - name: example-gateway
-  hostnames:
-    - "example.com"
-  rules:
-    - matches:
-        - path:
-            type: PathPrefix
-            value: /
-      backendRefs:
-        - name: backend-service
-          port: 443
\ No newline at end of file
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/delegation/unresolved_ref.yaml b/internal/kgateway/translator/gateway/testutils/inputs/delegation/unresolved_ref.yaml
deleted file mode 100644
index 82e07ff5f..000000000
--- a/internal/kgateway/translator/gateway/testutils/inputs/delegation/unresolved_ref.yaml
+++ /dev/null
@@ -1,111 +0,0 @@
-# This test contains 3 levels of delegation (parent -> child -> grandchild).
-#
-# Input:
-# - Parent infra/example-route:
-#   - Delegate /a to routes in "a" namespace
-#   - Delegate /b to routes in "b" namespace -> results in an unresolved reference (500 direct response)
-#   - Everything else goes to infra/example-svc
-# - Child a/route-a:
-#   - /a/1 goes to a/svc-a
-#   - Delegate /a/b to route a-b/route-a-b
-#   - Delegate /a/c to routes in a-c namespace -> results in an unresolved reference (500 direct response)
-# - Child a-b/route-a-b:
-#   - /a/b/1 goes to a-b/svc-a-b
-#
-# Expected output routes:
-# - /a/b/1 -> a-b/svc-a-b
-# - /a/1 -> a/svc-a
-# - /a/c -> 500 direct response 
-# - /b -> 500 direct response
-# - /* -> infra/example-svc
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: example-route
-  namespace: infra
-spec:
-  parentRefs:
-  - name: example-gateway
-  hostnames:
-  - "example.com"
-  rules:
-  - backendRefs:
-    - name: example-svc
-      port: 80
-  - matches:
-    - path:
-        type: PathPrefix
-        value: /a
-    backendRefs:
-    - group: gateway.networking.k8s.io
-      kind: HTTPRoute
-      name: "*"
-      namespace: a
-  # Unresolved ref
-  - matches:
-    - path:
-        type: PathPrefix
-        value: /b
-    backendRefs:
-    - group: gateway.networking.k8s.io
-      kind: HTTPRoute
-      name: "*"
-      namespace: b
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: route-a
-  namespace: a
-spec:
-  rules:
-  - matches:
-    - path:
-        type: PathPrefix
-        value: /a/1
-    backendRefs:
-    - name: svc-a
-      port: 8080
-  - matches:
-    - path:
-        type: PathPrefix
-        value: /a/b
-    backendRefs:
-    - group: gateway.networking.k8s.io
-      kind: HTTPRoute
-      name: "route-a-b"
-      namespace: a-b
-  # Unresolved ref
-  - matches:
-    - path:
-        type: PathPrefix
-        value: /a/c
-    backendRefs:
-    - group: gateway.networking.k8s.io
-      kind: HTTPRoute
-      namespace: a-c
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: route-a-b
-  namespace: a-b
-spec:
-  rules:
-  - matches:
-    - path:
-        type: PathPrefix
-        value: /a/b/1
-    backendRefs:
-    - name: svc-a-b
-      port: 8080
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: svc-a-b
-  namespace: a-b
-spec:
-  ports:
-    - protocol: TCP
-      port: 8080
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/directresponse/invalid-backendref-filter.yaml b/internal/kgateway/translator/gateway/testutils/inputs/directresponse/invalid-backendref-filter.yaml
deleted file mode 100644
index 5612e71fe..000000000
--- a/internal/kgateway/translator/gateway/testutils/inputs/directresponse/invalid-backendref-filter.yaml
+++ /dev/null
@@ -1,56 +0,0 @@
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: example-gateway
-spec:
-  gatewayClassName: kgateway
-  listeners:
-    - protocol: HTTP
-      port: 8080
-      name: http
-      allowedRoutes:
-        namespaces:
-          from: Same
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: example-route
-spec:
-  parentRefs:
-    - name: example-gateway
-  hostnames:
-    - "www.example.com"
-  rules:
-    - matches:
-      - path:
-          type: PathPrefix
-          value: /
-      backendRefs:
-      - name: httpbin
-        port: 8000
-        filters:
-        - type: ExtensionRef
-          extensionRef:
-            name: robots-txt
-            group: gateway.kgateway.dev
-            kind: DirectResponse
----
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: DirectResponse
-metadata:
-  name: robots-txt
-spec:
-  status: 200
-  body: "User-agent: *\nDisallow: /custom\n"
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: httpbin
-spec:
-  selector:
-    app: httpbin
-  ports:
-  - port: 8000
-    targetPort: 80
\ No newline at end of file
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/directresponse/missing-ref.yaml b/internal/kgateway/translator/gateway/testutils/inputs/directresponse/missing-ref.yaml
deleted file mode 100644
index 3cc96ffed..000000000
--- a/internal/kgateway/translator/gateway/testutils/inputs/directresponse/missing-ref.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: example-gateway
-spec:
-  gatewayClassName: kgateway
-  listeners:
-    - protocol: HTTP
-      port: 8080
-      name: http
-      allowedRoutes:
-        namespaces:
-          from: Same
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: example-route
-spec:
-  parentRefs:
-    - name: example-gateway
-  hostnames:
-    - "www.example.com"
-  rules:
-    - matches:
-      - path:
-          type: Exact
-          value: /non-existent
-      filters:
-      - type: ExtensionRef
-        extensionRef:
-          name: non-existent-ref
-          group: gateway.kgateway.dev
-          kind: DirectResponse
\ No newline at end of file
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/directresponse/overlapping-filters.yaml b/internal/kgateway/translator/gateway/testutils/inputs/directresponse/overlapping-filters.yaml
deleted file mode 100644
index e1986976c..000000000
--- a/internal/kgateway/translator/gateway/testutils/inputs/directresponse/overlapping-filters.yaml
+++ /dev/null
@@ -1,51 +0,0 @@
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: example-gateway
-spec:
-  gatewayClassName: kgateway
-  listeners:
-    - protocol: HTTP
-      port: 8080
-      name: http
-      allowedRoutes:
-        namespaces:
-          from: Same
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: example-route
-spec:
-  parentRefs:
-    - name: example-gateway
-  hostnames:
-    - "www.example.com"
-  rules:
-    - filters:
-      - type: ExtensionRef
-        extensionRef:
-          name: test-1
-          group: gateway.kgateway.dev
-          kind: DirectResponse
-      - type: ExtensionRef
-        extensionRef:
-          name: test-2
-          group: gateway.kgateway.dev
-          kind: DirectResponse
----
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: DirectResponse
-metadata:
-  name: test-1
-spec:
-  status: 301
-  body: "Test 1 body"
----
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: DirectResponse
-metadata:
-  name: test-2
-spec:
-  status: 302
-  body: "Test 2 body"
\ No newline at end of file
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/buffer-gateway.yaml b/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/buffer-gateway.yaml
deleted file mode 100644
index 75cb33e7d..000000000
--- a/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/buffer-gateway.yaml
+++ /dev/null
@@ -1,25 +0,0 @@
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: example-gateway
-spec:
-  gatewayClassName: kgateway
-  listeners:
-  - protocol: HTTP
-    port: 8080
-    name: http
-    allowedRoutes:
-      namespaces:
-        from: All
----
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: TrafficPolicy
-metadata:
-  name: buffer-policy
-spec:
-  targetRefs:
-    - group: gateway.networking.k8s.io
-      kind: Gateway
-      name: example-gateway
-  buffer:
-    maxRequestSize: "65536"
\ No newline at end of file
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/buffer-route.yaml b/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/buffer-route.yaml
deleted file mode 100644
index 5a7e58845..000000000
--- a/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/buffer-route.yaml
+++ /dev/null
@@ -1,79 +0,0 @@
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: example-gateway
-spec:
-  gatewayClassName: kgateway
-  listeners:
-  - protocol: HTTP
-    port: 8080
-    name: http
-    hostname: "www.example.com"
-  - protocol: HTTP
-    port: 8081
-    name: http2
-    hostname: "www.test.com"
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: example-route
-spec:
-  parentRefs:
-    - name: example-gateway
-  hostnames:
-    - "www.example.com"
-  rules:
-    - backendRefs:
-        - name: example-svc
-          port: 80
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: example-route-2
-spec:
-  parentRefs:
-    - name: example-gateway
-  hostnames:
-    - "www.test.com"
-  rules:
-    - backendRefs:
-        - name: example-svc-2
-          port: 3000
----
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: TrafficPolicy
-metadata:
-  name: buffer-policy
-spec:
-  targetRefs:
-    - group: gateway.networking.k8s.io
-      kind: HTTPRoute
-      name: example-route
-  buffer:
-    maxRequestSize: "65536"
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: example-svc
-spec:
-  selector:
-    test: test
-  ports:
-  - protocol: TCP
-    port: 80
-    targetPort: test
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: example-svc-2
-spec:
-  selector:
-    test: test
-  ports:
-  - protocol: TCP
-    port: 3000
-    targetPort: test
\ No newline at end of file
diff --git a/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/label_based.yaml b/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/label_based.yaml
index a7ebce341..dfcb3194e 100644
--- a/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/label_based.yaml
+++ b/internal/kgateway/translator/gateway/testutils/inputs/traffic-policy/label_based.yaml
@@ -46,7 +46,6 @@ metadata:
   namespace: infra
   labels:
     route: example
-    global-policy: cors # will be applied only when Settings.GlobalPolicyNamespace=kgateway-system
 spec:
   parentRefs:
   - name: example-gateway
@@ -121,18 +120,3 @@ spec:
     targetPort: 50051
   selector:
     app: log-test
----
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: TrafficPolicy
-metadata:
-  name: global-policy
-  namespace: kgateway-system
-spec:
-  targetSelectors:
-  - group: gateway.networking.k8s.io
-    kind: HTTPRoute
-    matchLabels: 
-      global-policy: cors
-  cors:
-    allowOrigins:
-    - "https://example.com"
\ No newline at end of file
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/backendconfigpolicy/http2.yaml b/internal/kgateway/translator/gateway/testutils/outputs/backendconfigpolicy/http2.yaml
index 6d1ed27bf..1b3a05601 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/backendconfigpolicy/http2.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/backendconfigpolicy/http2.yaml
@@ -13,8 +13,8 @@ Clusters:
       '@type': type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
       explicitHttpConfig:
         http2ProtocolOptions:
-          initialConnectionWindowSize: 1048576
-          initialStreamWindowSize: 1048576
+          initialConnectionWindowSize: 1048576000
+          initialStreamWindowSize: 1048576000
           maxConcurrentStreams: 101
           overrideStreamErrorOnInvalidHttpMessage: true
 - connectTimeout: 5s
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/backendconfigpolicy/tls-san.yaml b/internal/kgateway/translator/gateway/testutils/outputs/backendconfigpolicy/tls-san.yaml
deleted file mode 100644
index 5199d6feb..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/backendconfigpolicy/tls-san.yaml
+++ /dev/null
@@ -1,141 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_default_backend-service_443
-  transportSocket:
-    name: envoy.transport_sockets.tls
-    typedConfig:
-      '@type': type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
-      allowRenegotiation: true
-      commonTlsContext:
-        tlsCertificates:
-        - certificateChain:
-            inlineString: |
-              -----BEGIN CERTIFICATE-----
-              MIIDFzCCAf+gAwIBAgIUUP+jhPkrikdqW87lHMDpW3wY13wwDQYJKoZIhvcNAQEL
-              BQAwGzEZMBcGA1UEAwwQdGVzdC5leGFtcGxlLmNvbTAeFw0yNTA3MDIxMjM0MjRa
-              Fw0yNjA3MDIxMjM0MjRaMBsxGTAXBgNVBAMMEHRlc3QuZXhhbXBsZS5jb20wggEi
-              MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC2xPi+xL+5M9e6uJb4B9f9Ds2z
-              1Mqeq2OmEaPAwg1BOaRpg9pZ5X9jaj/LGkJ8X7BR6DfMOEvxEBu2ugvO/zlNVd23
-              uWcxdSMjRB52mGZDNycsSCKSJ71EeaWjhI7+IGdJJ2rzaw2NZwiCfcjVgkH7Gfxf
-              OYc7mm18wif9YxVJi87IF8aBJE6u7aKhnQT+SgD2w91+OZNFVBdFEIcqjRH1WMOF
-              KkCY8ejr0aiBWimQVk41iLj1/F/bSqhdadMlBRc3ToLFXOY39HlU7Dq7cf2QfVwf
-              zkUViFwpzvPETX/WVO9IiVExD3cpC3zUjDukjSAd26QS4xP4mvnjo3pymNTnAgMB
-              AAGjUzBRMB0GA1UdDgQWBBSk3FlWiH9236y5hhj7ItT/efSsVjAfBgNVHSMEGDAW
-              gBSk3FlWiH9236y5hhj7ItT/efSsVjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
-              DQEBCwUAA4IBAQB/j8eD4TfUuCPPCp37Pd/YiWUFa0pZWD1rJcwZtmZFW2E7/86T
-              l0yBEcgbKIsZmUT2rnJG4zcCumAxpzP5LuoO9Wu5RUgqFbM+nGnQ39w53mVC3CV4
-              hcZxSNizMicSwmA01M4HTdv9P7tj/7m9tTb8VQ/TywI3kdMajOPDI+GtrE76m+pP
-              sozQotvRMRmona9+496LBFsStBaP8NiAqZfuleNj0hD1oAdL3ekQ+HZ1b1ABfa6D
-              BxIrQCVvyC4Jl0zLmnEDPIBvsroCVivq4C/MKXbXsn/bDrhMHd5yqDv1/mmvGRSn
-              2b5vNa1aVtIqWJGKpuI2rKzd7LSIQv+kuFF3
-              -----END CERTIFICATE-----
-          privateKey:
-            inlineString: |
-              -----BEGIN PRIVATE KEY-----
-              MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC2xPi+xL+5M9e6
-              uJb4B9f9Ds2z1Mqeq2OmEaPAwg1BOaRpg9pZ5X9jaj/LGkJ8X7BR6DfMOEvxEBu2
-              ugvO/zlNVd23uWcxdSMjRB52mGZDNycsSCKSJ71EeaWjhI7+IGdJJ2rzaw2NZwiC
-              fcjVgkH7GfxfOYc7mm18wif9YxVJi87IF8aBJE6u7aKhnQT+SgD2w91+OZNFVBdF
-              EIcqjRH1WMOFKkCY8ejr0aiBWimQVk41iLj1/F/bSqhdadMlBRc3ToLFXOY39HlU
-              7Dq7cf2QfVwfzkUViFwpzvPETX/WVO9IiVExD3cpC3zUjDukjSAd26QS4xP4mvnj
-              o3pymNTnAgMBAAECggEABvwpfYZLcCqOY3EhOULOJbpmcNRVwhFOx6QDnB75HrWz
-              QOJseo8OJUsu5kuPSu2P8YbByyjuThI4MkLop0qTHWTbX7rS5M2olXUfAkKkyzYq
-              ZcOD/riiFSHeYLd04jrJd77tPsxSl5redQ5ARK4BE4r/XYGiAiHOxBEvh2boA118
-              miz6s28aIuqzFhQGi8Hyz4D9RBS2dEalk1V+euAXhpqqgoGFk8LXkXlmRZseWX7C
-              dJrV8P/H+LfWorB3OJDk7Ib+zOBsJKzIp3sbFUlj7khg2wlcb/ReD+QNAGUPGxua
-              GVwjDUAJjpoTfjhHv7aaL0ikrUPzkRvLAPv0psK2oQKBgQDM9WkrfAaf8veSqGis
-              MZJCm9aUVE0tf8yi1/z0hlQbREonLslY3CBZQY0vuOZ0XW5SoOCPTjdJEmeR1GLR
-              U/AIBpFhg5nU1R1hJkRI29kOhaGUqADJRGQ+ega+B+BWK5XTkxFTWEF0RD8UXCdA
-              WkishPkSUtV5vV7j7/bn+RGOaQKBgQDkSPJiA11M88AHCSv4VhrCosQv6TFvr+Jv
-              qIVif0z0pPoOFCTMNuG17VqkoVWGzSDzz0LaBGZYFFY93a4pkqecgKy1eSuxrJvQ
-              RJ8Y4JIzJayCo4asITDbOWmKhi5jovly1D5fJQJ23rQSlZTRluNubiUlSBA+M/Dq
-              mpX8svd+zwKBgH+3NQ/Zuy8Ucd07f+48/YzwGuhXF7iQeG3I9WFSCzrqdOKxrtnm
-              YWn9BQOFzmUYi1SF1yi1bpHkHBGtLN6P1XTK0vDW1pbfLe2JsOdNx5XbA3LktYi1
-              S1n7JBRqSAqqIjSy4grzZeYTWNNREUxydfK68ZHPeCLiNC0JLOwkMiJxAoGBAI/2
-              FKyMtJzfpnyJYyozmqKdpJ0WMO/e+iwyGRO5dd1d4LdaKq6B+asR6LSjbV0aJSq7
-              zMvSNHxdLtnK35cl/f9rAf9bT5u3X3dinvZAQNJycqzb1QTd1YKaXR1Xaw+4ahjp
-              EgBMRZaS8Po7TGM0BW7RlSlCncOsW8SHAgkfD4bvAoGATvlFOBb42foxH16lC5mm
-              le8XugtxNsPf595TUl88TUeXgeyERT00684j83Jqr5bLChsMzFV+i50R5PZvlamm
-              udvm84AfnSu2KGiPhLZ/fE6+sUOo85b3ktzRFkxPHBIdlKzWqVD8aWCcrlFn7WMU
-              3teRYW/cEDQ1PTgLfAkb7Fk=
-              -----END PRIVATE KEY-----
-        validationContext:
-          matchTypedSubjectAltNames:
-          - matcher:
-              exact: test.example.com
-            sanType: DNS
-          - matcher:
-              exact: api.example.com
-            sanType: DNS
-          trustedCa:
-            inlineString: |
-              -----BEGIN CERTIFICATE-----
-              MIIDFzCCAf+gAwIBAgIUUP+jhPkrikdqW87lHMDpW3wY13wwDQYJKoZIhvcNAQEL
-              BQAwGzEZMBcGA1UEAwwQdGVzdC5leGFtcGxlLmNvbTAeFw0yNTA3MDIxMjM0MjRa
-              Fw0yNjA3MDIxMjM0MjRaMBsxGTAXBgNVBAMMEHRlc3QuZXhhbXBsZS5jb20wggEi
-              MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC2xPi+xL+5M9e6uJb4B9f9Ds2z
-              1Mqeq2OmEaPAwg1BOaRpg9pZ5X9jaj/LGkJ8X7BR6DfMOEvxEBu2ugvO/zlNVd23
-              uWcxdSMjRB52mGZDNycsSCKSJ71EeaWjhI7+IGdJJ2rzaw2NZwiCfcjVgkH7Gfxf
-              OYc7mm18wif9YxVJi87IF8aBJE6u7aKhnQT+SgD2w91+OZNFVBdFEIcqjRH1WMOF
-              KkCY8ejr0aiBWimQVk41iLj1/F/bSqhdadMlBRc3ToLFXOY39HlU7Dq7cf2QfVwf
-              zkUViFwpzvPETX/WVO9IiVExD3cpC3zUjDukjSAd26QS4xP4mvnjo3pymNTnAgMB
-              AAGjUzBRMB0GA1UdDgQWBBSk3FlWiH9236y5hhj7ItT/efSsVjAfBgNVHSMEGDAW
-              gBSk3FlWiH9236y5hhj7ItT/efSsVjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3
-              DQEBCwUAA4IBAQB/j8eD4TfUuCPPCp37Pd/YiWUFa0pZWD1rJcwZtmZFW2E7/86T
-              l0yBEcgbKIsZmUT2rnJG4zcCumAxpzP5LuoO9Wu5RUgqFbM+nGnQ39w53mVC3CV4
-              hcZxSNizMicSwmA01M4HTdv9P7tj/7m9tTb8VQ/TywI3kdMajOPDI+GtrE76m+pP
-              sozQotvRMRmona9+496LBFsStBaP8NiAqZfuleNj0hD1oAdL3ekQ+HZ1b1ABfa6D
-              BxIrQCVvyC4Jl0zLmnEDPIBvsroCVivq4C/MKXbXsn/bDrhMHd5yqDv1/mmvGRSn
-              2b5vNa1aVtIqWJGKpuI2rKzd7LSIQv+kuFF3
-              -----END CERTIFICATE-----
-      sni: test.example.com
-  type: EDS
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~8080
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~8080
-  name: listener~8080
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~8080
-  virtualHosts:
-  - domains:
-    - example.com
-    name: listener~8080~example_com
-    routes:
-    - match:
-        prefix: /
-      name: listener~8080~example_com-route-0-httproute-backend-route-default-0-0-matcher-0
-      route:
-        cluster: kube_default_backend-service_443
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_invalid_hostname.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_invalid_hostname.yaml
index 244ab4927..18a1c4139 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_invalid_hostname.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_invalid_hostname.yaml
@@ -63,11 +63,6 @@ Routes:
     - example.com
     name: listener~80~example_com
     routes:
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /a
-      name: listener~80~example_com-route-0-httproute-example-route-infra-1-0-matcher-0
     - match:
         prefix: /
       name: listener~80~example_com-route-1-httproute-example-route-infra-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_parentref_mismatch.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_parentref_mismatch.yaml
index 244ab4927..18a1c4139 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_parentref_mismatch.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/delegation/basic_parentref_mismatch.yaml
@@ -63,11 +63,6 @@ Routes:
     - example.com
     name: listener~80~example_com
     routes:
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /a
-      name: listener~80~example_com-route-0-httproute-example-route-infra-1-0-matcher-0
     - match:
         prefix: /
       name: listener~80~example_com-route-1-httproute-example-route-infra-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/child_rule_matcher.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/child_rule_matcher.yaml
index 8f3dd39ce..7a79bb168 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/child_rule_matcher.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/delegation/child_rule_matcher.yaml
@@ -83,25 +83,6 @@ Routes:
       route:
         cluster: kube_a_svc-a_8080
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
-    - directResponse:
-        status: 500
-      match:
-        headers:
-        - name: header2
-          stringMatch:
-            exact: val2
-        - name: header3
-          stringMatch:
-            exact: val3
-        pathSeparatedPrefix: /b
-        queryParameters:
-        - name: query2
-          stringMatch:
-            exact: val2
-        - name: query3
-          stringMatch:
-            exact: val3
-      name: listener~80~example_com-route-1-httproute-example-route-infra-2-0-matcher-0
     - match:
         prefix: /
       name: listener~80~example_com-route-3-httproute-example-route-infra-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic1.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic1.yaml
index c061d48b7..88e5c7c72 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic1.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic1.yaml
@@ -69,11 +69,6 @@ Routes:
       route:
         cluster: kube_a_svc-a_8080
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /a/b
-      name: listener~80~example_com-route-1-httproute-route-a-a-1-0-matcher-0
     - match:
         prefix: /
       name: listener~80~example_com-route-3-httproute-example-route-infra-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic2.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic2.yaml
index 8ef3a760b..bdfb450e7 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic2.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/delegation/cyclic2.yaml
@@ -63,11 +63,6 @@ Routes:
     - example.com
     name: listener~80~example_com
     routes:
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /a/b/1
-      name: listener~80~example_com-route-0-httproute-route-a-b-a-b-0-0-matcher-0
     - match:
         pathSeparatedPrefix: /a/1
       name: listener~80~example_com-route-1-httproute-route-a-a-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/invalid_child_valid_standalone.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/invalid_child_valid_standalone.yaml
index 851543fa9..4185ff838 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/invalid_child_valid_standalone.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/delegation/invalid_child_valid_standalone.yaml
@@ -63,11 +63,6 @@ Routes:
     - example.com
     name: listener~80~example_com
     routes:
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /a
-      name: listener~80~example_com-route-0-httproute-example-route-infra-1-0-matcher-0
     - match:
         prefix: /
       name: listener~80~example_com-route-1-httproute-example-route-infra-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/multiple_parents.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/multiple_parents.yaml
index eaa71d07a..730a249c2 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/multiple_parents.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/delegation/multiple_parents.yaml
@@ -93,8 +93,3 @@ Routes:
       route:
         cluster: kube_a_svc-a_8080
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /b
-      name: listener~80~foo_com-route-2-httproute-foo-route-infra-1-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/delegation/unresolved_ref.yaml b/internal/kgateway/translator/gateway/testutils/outputs/delegation/unresolved_ref.yaml
deleted file mode 100644
index 71ae894ad..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/delegation/unresolved_ref.yaml
+++ /dev/null
@@ -1,102 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_a-b_svc-a-b_8080
-  type: EDS
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_a_svc-a_8080
-  type: EDS
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_b_svc-b_8080
-  type: EDS
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_infra_example-svc_80
-  type: EDS
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~80
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~80
-  name: listener~80
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~80
-  virtualHosts:
-  - domains:
-    - example.com
-    name: listener~80~example_com
-    routes:
-    - match:
-        pathSeparatedPrefix: /a/b/1
-      name: listener~80~example_com-route-0-httproute-route-a-b-a-b-0-0-matcher-0
-      route:
-        cluster: kube_a-b_svc-a-b_8080
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
-    - match:
-        pathSeparatedPrefix: /a/1
-      name: listener~80~example_com-route-1-httproute-route-a-a-0-0-matcher-0
-      route:
-        cluster: kube_a_svc-a_8080
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /a/c
-      name: listener~80~example_com-route-3-httproute-route-a-a-2-0-matcher-0
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /b
-      name: listener~80~example_com-route-5-httproute-example-route-infra-2-0-matcher-0
-    - match:
-        prefix: /
-      name: listener~80~example_com-route-6-httproute-example-route-infra-0-0-matcher-0
-      route:
-        cluster: kube_infra_example-svc_80
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/directresponse/invalid-backendref-filter.yaml b/internal/kgateway/translator/gateway/testutils/outputs/directresponse/invalid-backendref-filter.yaml
deleted file mode 100644
index de3e9c1d1..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/directresponse/invalid-backendref-filter.yaml
+++ /dev/null
@@ -1,53 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_default_httpbin_8000
-  type: EDS
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~8080
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~8080
-  name: listener~8080
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~8080
-  virtualHosts:
-  - domains:
-    - www.example.com
-    name: listener~8080~www_example_com
-    routes:
-    - match:
-        prefix: /
-      name: listener~8080~www_example_com-route-0-httproute-example-route-default-0-0-matcher-0
-      route:
-        cluster: kube_default_httpbin_8000
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/directresponse/missing-ref.yaml b/internal/kgateway/translator/gateway/testutils/outputs/directresponse/missing-ref.yaml
deleted file mode 100644
index 1a10c3366..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/directresponse/missing-ref.yaml
+++ /dev/null
@@ -1,43 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~8080
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~8080
-  name: listener~8080
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~8080
-  virtualHosts:
-  - domains:
-    - www.example.com
-    name: listener~8080~www_example_com
-    routes:
-    - directResponse:
-        status: 500
-      match:
-        path: /non-existent
-      name: listener~8080~www_example_com-route-0-httproute-example-route-default-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/directresponse/overlapping-filters.yaml b/internal/kgateway/translator/gateway/testutils/outputs/directresponse/overlapping-filters.yaml
deleted file mode 100644
index d7ee17e3c..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/directresponse/overlapping-filters.yaml
+++ /dev/null
@@ -1,43 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~8080
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~8080
-  name: listener~8080
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~8080
-  virtualHosts:
-  - domains:
-    - www.example.com
-    name: listener~8080~www_example_com
-    routes:
-    - directResponse:
-        status: 500
-      match:
-        prefix: /
-      name: listener~8080~www_example_com-route-0-httproute-example-route-default-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/discovery-namespace-selector/base_select_infra.yaml b/internal/kgateway/translator/gateway/testutils/outputs/discovery-namespace-selector/base_select_infra.yaml
index 83eeb7dbf..a69a03db4 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/discovery-namespace-selector/base_select_infra.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/discovery-namespace-selector/base_select_infra.yaml
@@ -49,11 +49,6 @@ Routes:
     - example.com
     name: listener~80~example_com
     routes:
-    - directResponse:
-        status: 500
-      match:
-        pathSeparatedPrefix: /a
-      name: listener~80~example_com-route-0-httproute-example-route-infra-1-0-matcher-0
     - match:
         prefix: /
       name: listener~80~example_com-route-1-httproute-example-route-infra-0-0-matcher-0
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/cookie.yaml b/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/cookie.yaml
index a1b9ef2e6..ea1e9ee06 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/cookie.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/cookie.yaml
@@ -59,15 +59,14 @@ Routes:
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
       typedPerFilterConfig:
         envoy.filters.http.stateful_session:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSessionPerRoute
-          statefulSession:
-            sessionState:
-              name: envoy.http.stateful_session.cookie
-              typedConfig:
-                '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
-                cookie:
-                  name: Session-A
-                  ttl: 10s
+          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSession
+          sessionState:
+            name: envoy.http.stateful_session.cookie
+            typedConfig:
+              '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
+              cookie:
+                name: Session-A
+                ttl: 10s
     - match:
         safeRegex:
           googleRe2: {}
@@ -78,15 +77,14 @@ Routes:
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
       typedPerFilterConfig:
         envoy.filters.http.stateful_session:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSessionPerRoute
-          statefulSession:
-            sessionState:
-              name: envoy.http.stateful_session.cookie
-              typedConfig:
-                '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
-                cookie:
-                  name: Session-B
-                  ttl: 31536000s
+          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSession
+          sessionState:
+            name: envoy.http.stateful_session.cookie
+            typedConfig:
+              '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
+              cookie:
+                name: Session-B
+                ttl: 31536000s
     - match:
         safeRegex:
           googleRe2: {}
@@ -97,14 +95,13 @@ Routes:
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
       typedPerFilterConfig:
         envoy.filters.http.stateful_session:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSessionPerRoute
-          statefulSession:
-            sessionState:
-              name: envoy.http.stateful_session.cookie
-              typedConfig:
-                '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
-                cookie:
-                  name: Session-B
+          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSession
+          sessionState:
+            name: envoy.http.stateful_session.cookie
+            typedConfig:
+              '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
+              cookie:
+                name: Session-B
     - match:
         pathSeparatedPrefix: /c1
       name: listener~80~*-route-3-httproute-example-route-default-0-0-matcher-0
@@ -113,15 +110,14 @@ Routes:
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
       typedPerFilterConfig:
         envoy.filters.http.stateful_session:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSessionPerRoute
-          statefulSession:
-            sessionState:
-              name: envoy.http.stateful_session.cookie
-              typedConfig:
-                '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
-                cookie:
-                  name: Session-A
-                  ttl: 10s
+          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSession
+          sessionState:
+            name: envoy.http.stateful_session.cookie
+            typedConfig:
+              '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
+              cookie:
+                name: Session-A
+                ttl: 10s
     - match:
         pathSeparatedPrefix: /c2
       name: listener~80~*-route-4-httproute-example-route-default-1-0-matcher-0
@@ -130,15 +126,14 @@ Routes:
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
       typedPerFilterConfig:
         envoy.filters.http.stateful_session:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSessionPerRoute
-          statefulSession:
-            sessionState:
-              name: envoy.http.stateful_session.cookie
-              typedConfig:
-                '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
-                cookie:
-                  name: Session-B
-                  ttl: 31536000s
+          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSession
+          sessionState:
+            name: envoy.http.stateful_session.cookie
+            typedConfig:
+              '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
+              cookie:
+                name: Session-B
+                ttl: 31536000s
     - match:
         pathSeparatedPrefix: /c3
       name: listener~80~*-route-5-httproute-example-route-default-2-0-matcher-0
@@ -147,11 +142,10 @@ Routes:
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
       typedPerFilterConfig:
         envoy.filters.http.stateful_session:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSessionPerRoute
-          statefulSession:
-            sessionState:
-              name: envoy.http.stateful_session.cookie
-              typedConfig:
-                '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
-                cookie:
-                  name: Session-B
+          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSession
+          sessionState:
+            name: envoy.http.stateful_session.cookie
+            typedConfig:
+              '@type': type.googleapis.com/envoy.extensions.http.stateful_session.cookie.v3.CookieBasedSessionState
+              cookie:
+                name: Session-B
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/header.yaml b/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/header.yaml
index 4a57bf454..3d2945ede 100644
--- a/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/header.yaml
+++ b/internal/kgateway/translator/gateway/testutils/outputs/session-persistence/header.yaml
@@ -57,10 +57,9 @@ Routes:
         clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
       typedPerFilterConfig:
         envoy.filters.http.stateful_session:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSessionPerRoute
-          statefulSession:
-            sessionState:
-              name: envoy.http.stateful_session.header
-              typedConfig:
-                '@type': type.googleapis.com/envoy.extensions.http.stateful_session.header.v3.HeaderBasedSessionState
-                name: Session-A
+          '@type': type.googleapis.com/envoy.extensions.filters.http.stateful_session.v3.StatefulSession
+          sessionState:
+            name: envoy.http.stateful_session.header
+            typedConfig:
+              '@type': type.googleapis.com/envoy.extensions.http.stateful_session.header.v3.HeaderBasedSessionState
+              name: Session-A
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/buffer-gateway.yaml b/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/buffer-gateway.yaml
deleted file mode 100644
index f0baa9203..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/buffer-gateway.yaml
+++ /dev/null
@@ -1,43 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - disabled: true
-          name: envoy.filters.http.buffer
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer
-            maxRequestBytes: 4294967295
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~8080
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~8080
-  name: listener~8080
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~8080
-  typedPerFilterConfig:
-    envoy.filters.http.buffer:
-      '@type': type.googleapis.com/envoy.extensions.filters.http.buffer.v3.BufferPerRoute
-      buffer:
-        maxRequestBytes: 65536
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/buffer-route.yaml b/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/buffer-route.yaml
deleted file mode 100644
index 2aa0414db..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/buffer-route.yaml
+++ /dev/null
@@ -1,110 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_default_example-svc-2_3000
-  type: EDS
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_default_example-svc_80
-  type: EDS
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - disabled: true
-          name: envoy.filters.http.buffer
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.buffer.v3.Buffer
-            maxRequestBytes: 4294967295
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~8080
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~8080
-  name: listener~8080
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8081
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        httpFilters:
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~8081
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~8081
-  name: listener~8081
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~8080
-  virtualHosts:
-  - domains:
-    - www.example.com
-    name: listener~8080~www_example_com
-    routes:
-    - match:
-        prefix: /
-      name: listener~8080~www_example_com-route-0-httproute-example-route-default-0-0-matcher-0
-      route:
-        cluster: kube_default_example-svc_80
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
-      typedPerFilterConfig:
-        envoy.filters.http.buffer:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.buffer.v3.BufferPerRoute
-          buffer:
-            maxRequestBytes: 65536
-- ignorePortInHostMatching: true
-  name: listener~8081
-  virtualHosts:
-  - domains:
-    - www.test.com
-    name: listener~8081~www_test_com
-    routes:
-    - match:
-        prefix: /
-      name: listener~8081~www_test_com-route-0-httproute-example-route-2-default-0-0-matcher-0
-      route:
-        cluster: kube_default_example-svc-2_3000
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
diff --git a/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/label_based_global_policy.yaml b/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/label_based_global_policy.yaml
deleted file mode 100644
index 78a0cb359..000000000
--- a/internal/kgateway/translator/gateway/testutils/outputs/traffic-policy/label_based_global_policy.yaml
+++ /dev/null
@@ -1,127 +0,0 @@
-Clusters:
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_infra_example-svc_80
-  type: EDS
-- connectTimeout: 5s
-  edsClusterConfig:
-    edsConfig:
-      ads: {}
-      resourceApiVersion: V3
-  ignoreHealthOnHostRemoval: true
-  metadata: {}
-  name: kube_infra_log-test_50051
-  type: EDS
-  typedExtensionProtocolOptions:
-    envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
-      '@type': type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
-      explicitHttpConfig:
-        http2ProtocolOptions: {}
-- connectTimeout: 5s
-  metadata: {}
-  name: test-backend-plugin_default_example-svc_80
-Listeners:
-- address:
-    socketAddress:
-      address: '::'
-      ipv4Compat: true
-      portValue: 8080
-  filterChains:
-  - filters:
-    - name: envoy.filters.network.http_connection_manager
-      typedConfig:
-        '@type': type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
-        accessLog:
-        - filter:
-            headerFilter:
-              header:
-                name: x-my-cool-test-filter
-                stringMatch:
-                  exact: test
-          name: envoy.access_loggers.http_grpc
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.HttpGrpcAccessLogConfig
-            commonConfig:
-              grpcService:
-                envoyGrpc:
-                  clusterName: kube_infra_log-test_50051
-              logName: test-accesslog-service
-              transportApiVersion: V3
-        httpFilters:
-        - name: envoy.filters.http.cors
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.cors.v3.Cors
-        - disabled: true
-          name: ratelimit/local
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
-            statPrefix: http_local_rate_limiter
-        - disabled: true
-          name: transformation
-          typedConfig:
-            '@type': type.googleapis.com/envoy.api.v2.filter.http.FilterTransformations
-        - name: envoy.filters.http.router
-          typedConfig:
-            '@type': type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
-        mergeSlashes: true
-        normalizePath: true
-        rds:
-          configSource:
-            ads: {}
-            resourceApiVersion: V3
-          routeConfigName: listener~80
-        statPrefix: http
-        useRemoteAddress: true
-    name: listener~80
-  name: listener~80
-Routes:
-- ignorePortInHostMatching: true
-  name: listener~80
-  virtualHosts:
-  - domains:
-    - example.com
-    name: listener~80~example_com
-    routes:
-    - match:
-        prefix: /
-      name: listener~80~example_com-route-0-httproute-example-route-infra-0-0-matcher-0
-      route:
-        cluster: kube_infra_example-svc_80
-        clusterNotFoundResponseCode: INTERNAL_SERVER_ERROR
-      typedPerFilterConfig:
-        envoy.filters.http.cors:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.cors.v3.CorsPolicy
-          allowOriginStringMatch:
-          - exact: https://example.com
-        ratelimit/local:
-          '@type': type.googleapis.com/envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
-          filterEnabled:
-            defaultValue:
-              numerator: 100
-            runtimeKey: local_rate_limit_enabled
-          filterEnforced:
-            defaultValue:
-              numerator: 100
-            runtimeKey: local_rate_limit_enforced
-          statPrefix: http_local_rate_limiter
-          tokenBucket:
-            fillInterval: 33s
-            maxTokens: 99
-            tokensPerFill: 1
-        transformation:
-          '@type': type.googleapis.com/envoy.api.v2.filter.http.RouteTransformations
-          transformations:
-          - requestMatch:
-              responseTransformation:
-                transformationTemplate:
-                  headersToAppend:
-                  - key: abc
-                    value:
-                      text: custom-value-abc
-                  parseBodyBehavior: DontParse
-                  passthrough: {}
diff --git a/internal/kgateway/translator/httproute/delegation.go b/internal/kgateway/translator/httproute/delegation.go
index 81c986180..8074713a2 100644
--- a/internal/kgateway/translator/httproute/delegation.go
+++ b/internal/kgateway/translator/httproute/delegation.go
@@ -45,8 +45,11 @@ func flattenDelegatedRoutes(
 	defer routesVisited.Delete(parentRef)
 
 	rawChildren, err := parentInfo.GetChildrenForRef(*backend.Delegate)
-	if err != nil {
-		return fmt.Errorf("%s: %w", backend.Delegate.ResourceName(), err)
+	if len(rawChildren) == 0 || err != nil {
+		if err == nil {
+			err = fmt.Errorf("unresolved reference %s", backend.Delegate.ResourceName())
+		}
+		return err
 	}
 	children := filterDelegatedChildren(parentRef, parentMatch, rawChildren)
 
@@ -55,7 +58,6 @@ func flattenDelegatedRoutes(
 	copy(hostnames, parentRoute.Hostnames)
 
 	// For these child routes, recursively flatten them
-	validChildren := 0
 	for _, child := range children {
 		childRoute, ok := child.Object.(*ir.HttpRouteIR)
 		if !ok {
@@ -97,14 +99,10 @@ func flattenDelegatedRoutes(
 			continue
 		}
 
-		validChildren++
 		translateGatewayHTTPRouteRulesUtil(
 			ctx, child, reporter, baseReporter, outputs, routesVisited, delegatingParent)
 	}
 
-	if validChildren == 0 {
-		return fmt.Errorf("%s: %w", backend.Delegate.ResourceName(), query.ErrUnresolvedReference)
-	}
 	return nil
 }
 
diff --git a/internal/kgateway/translator/httproute/gateway_http_route_translator.go b/internal/kgateway/translator/httproute/gateway_http_route_translator.go
index 4508322a8..14d39b5f7 100644
--- a/internal/kgateway/translator/httproute/gateway_http_route_translator.go
+++ b/internal/kgateway/translator/httproute/gateway_http_route_translator.go
@@ -2,6 +2,7 @@ package httproute
 
 import (
 	"context"
+	"log/slog"
 
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/sets"
@@ -10,12 +11,9 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/query"
-	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	reports "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 )
 
-var logger = logging.New("translator/httproute")
-
 // TODO: Uncomment when the gateway_http_route_translator_test.go is uncommented.
 // var (
 // 	awsMissingFuncRefError                = eris.New("upstreams must have a logical name specified in the backend ref via the parameters extensionref")
@@ -175,6 +173,10 @@ func setRouteAction(
 	routesVisited sets.Set[types.NamespacedName],
 ) {
 	backends := rule.Backends
+	// this was coming from internal/kgateway/translator/gateway/gateway_translator.go
+	// TODO: scope this to httproute?
+	logger := slog.Default()
+
 	for _, backend := range backends {
 		// If the backend is an HTTPRoute, it implies route delegation
 		// for which delegated routes are recursively flattened and translated
@@ -194,7 +196,6 @@ func setRouteAction(
 			)
 			if err != nil {
 				query.ProcessBackendError(err, reporter)
-				outputRoute.Error = err
 			}
 			continue
 		}
diff --git a/internal/kgateway/translator/irtranslator/route.go b/internal/kgateway/translator/irtranslator/route.go
index 12d551120..5e26523b6 100644
--- a/internal/kgateway/translator/irtranslator/route.go
+++ b/internal/kgateway/translator/irtranslator/route.go
@@ -182,9 +182,13 @@ func (h *httpRouteConfigurationTranslator) envoyRoutes(
 			}
 		}
 	}
+	out.RequestHeadersToAdd = append(out.GetRequestHeadersToAdd(), backendConfigCtx.RequestHeadersToAdd...)
+	out.RequestHeadersToRemove = append(out.GetRequestHeadersToRemove(), backendConfigCtx.RequestHeadersToRemove...)
+	out.ResponseHeadersToAdd = append(out.GetResponseHeadersToAdd(), backendConfigCtx.ResponseHeadersToAdd...)
+	out.ResponseHeadersToRemove = append(out.GetResponseHeadersToRemove(), backendConfigCtx.ResponseHeadersToRemove...)
 
 	if err == nil && out.GetAction() == nil {
-		if in.Delegates && in.Error == nil {
+		if in.Delegates {
 			return nil
 		} else {
 			err = errors.New("no action specified")
@@ -202,8 +206,6 @@ func (h *httpRouteConfigurationTranslator) envoyRoutes(
 
 		switch h.routeReplacementMode {
 		case settings.RouteReplacementStandard, settings.RouteReplacementStrict:
-			// Unset the TypedPerFilterConfig when the route is replaced with a direct response
-			out.TypedPerFilterConfig = nil
 			// Replace invalid route with a direct response
 			out.Action = &envoy_config_route_v3.Route_DirectResponse{
 				DirectResponse: &envoy_config_route_v3.DirectResponseAction{
@@ -217,11 +219,6 @@ func (h *httpRouteConfigurationTranslator) envoyRoutes(
 		}
 	}
 
-	out.RequestHeadersToAdd = append(out.GetRequestHeadersToAdd(), backendConfigCtx.RequestHeadersToAdd...)
-	out.RequestHeadersToRemove = append(out.GetRequestHeadersToRemove(), backendConfigCtx.RequestHeadersToRemove...)
-	out.ResponseHeadersToAdd = append(out.GetResponseHeadersToAdd(), backendConfigCtx.ResponseHeadersToAdd...)
-	out.ResponseHeadersToRemove = append(out.GetResponseHeadersToRemove(), backendConfigCtx.ResponseHeadersToRemove...)
-
 	return out
 }
 
@@ -450,6 +447,7 @@ func (h *httpRouteConfigurationTranslator) translateRouteAction(
 		clusters = append(clusters, cw)
 	}
 
+	// TODO: i think envoy nacks if all weights are 0, we should error on that.
 	action := outRoute.GetRoute()
 	if action == nil {
 		action = &envoy_config_route_v3.RouteAction{
@@ -511,30 +509,12 @@ func validateEnvoyRoute(r *envoy_config_route_v3.Route) error {
 	validatePath(re.GetSchemeRedirect(), &errs)
 	validatePrefixRewrite(route.GetPrefixRewrite(), &errs)
 	validatePrefixRewrite(re.GetPrefixRewrite(), &errs)
-	validateWeightedClusters(route.GetWeightedClusters().GetClusters(), &errs)
 	if len(errs) == 0 {
 		return nil
 	}
 	return fmt.Errorf("error %s: %w", r.GetName(), errors.Join(errs...))
 }
 
-func validateWeightedClusters(clusters []*envoy_config_route_v3.WeightedCluster_ClusterWeight, errs *[]error) {
-	if len(clusters) == 0 {
-		return
-	}
-
-	allZeroWeight := true
-	for _, cluster := range clusters {
-		if cluster.GetWeight().GetValue() > 0 {
-			allZeroWeight = false
-			break
-		}
-	}
-	if allZeroWeight {
-		*errs = append(*errs, errors.New("All backend weights are 0. At least one backendRef in the HTTPRoute rule must specify a non-zero weight"))
-	}
-}
-
 // creates Envoy routes for each matcher provided on our Gateway route
 func (h *httpRouteConfigurationTranslator) initRoutes(
 	in ir.HttpRouteRuleMatchIR,
diff --git a/internal/kgateway/translator/irtranslator/route_test.go b/internal/kgateway/translator/irtranslator/route_test.go
deleted file mode 100644
index 668177597..000000000
--- a/internal/kgateway/translator/irtranslator/route_test.go
+++ /dev/null
@@ -1,92 +0,0 @@
-package irtranslator
-
-import (
-	"testing"
-
-	envoy_config_route_v3 "github.com/envoyproxy/go-control-plane/envoy/config/route/v3"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-
-	"github.com/stretchr/testify/assert"
-)
-
-func TestValidateWeightedClusters(t *testing.T) {
-	tests := []struct {
-		name     string
-		clusters []*envoy_config_route_v3.WeightedCluster_ClusterWeight
-		wantErr  bool
-	}{
-		{
-			name:     "no clusters",
-			clusters: []*envoy_config_route_v3.WeightedCluster_ClusterWeight{},
-			wantErr:  false,
-		},
-		{
-			name: "single cluster with weight 0",
-			clusters: []*envoy_config_route_v3.WeightedCluster_ClusterWeight{
-				{
-					Weight: wrapperspb.UInt32(0),
-				},
-			},
-			wantErr: true,
-		},
-		{
-			name: "single cluster with weight > 0",
-			clusters: []*envoy_config_route_v3.WeightedCluster_ClusterWeight{
-				{
-					Weight: wrapperspb.UInt32(100),
-				},
-			},
-			wantErr: false,
-		},
-		{
-			name: "multiple clusters all with weight 0",
-			clusters: []*envoy_config_route_v3.WeightedCluster_ClusterWeight{
-				{
-					Weight: wrapperspb.UInt32(0),
-				},
-				{
-					Weight: wrapperspb.UInt32(0),
-				},
-			},
-			wantErr: true,
-		},
-		{
-			name: "multiple clusters with mixed weights",
-			clusters: []*envoy_config_route_v3.WeightedCluster_ClusterWeight{
-				{
-					Weight: wrapperspb.UInt32(0),
-				},
-				{
-					Weight: wrapperspb.UInt32(100),
-				},
-			},
-			wantErr: false,
-		},
-		{
-			name: "multiple clusters all with weight > 0",
-			clusters: []*envoy_config_route_v3.WeightedCluster_ClusterWeight{
-				{
-					Weight: wrapperspb.UInt32(50),
-				},
-				{
-					Weight: wrapperspb.UInt32(50),
-				},
-			},
-			wantErr: false,
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			var errs []error
-			validateWeightedClusters(tt.clusters, &errs)
-
-			if tt.wantErr {
-				assert.Len(t, errs, 1)
-				assert.Contains(t, errs[0].Error(), "All backend weights are 0. At least one backendRef in the HTTPRoute rule must specify a non-zero weight")
-			} else {
-				assert.Len(t, errs, 0)
-			}
-		})
-	}
-}
diff --git a/internal/kgateway/utils/cors.go b/internal/kgateway/utils/cors.go
deleted file mode 100644
index 230a4f643..000000000
--- a/internal/kgateway/utils/cors.go
+++ /dev/null
@@ -1,135 +0,0 @@
-package utils
-
-import (
-	"fmt"
-	"log/slog"
-	"regexp"
-	"strings"
-
-	corsv3 "github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/cors/v3"
-	envoy_type_matcher_v3 "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3"
-	"google.golang.org/protobuf/types/known/wrapperspb"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/regexutils"
-)
-
-// ToEnvoyCorsPolicy converts a Gateway API CORS filter to an Envoy CORS policy
-func ToEnvoyCorsPolicy(f *gwv1.HTTPCORSFilter) *corsv3.CorsPolicy {
-	if f == nil {
-		return nil
-	}
-	corsPolicy := &corsv3.CorsPolicy{}
-	if len(f.AllowOrigins) > 0 {
-		origins := make([]*envoy_type_matcher_v3.StringMatcher, 0, len(f.AllowOrigins))
-		for _, origin := range f.AllowOrigins {
-			matcher := ConvertOriginToEnvoyStringMatcher(string(origin))
-			if matcher != nil {
-				origins = append(origins, matcher)
-			}
-		}
-		if len(origins) > 0 {
-			corsPolicy.AllowOriginStringMatch = origins
-		}
-	}
-	if len(f.AllowMethods) > 0 {
-		methods := make([]string, len(f.AllowMethods))
-		for i, method := range f.AllowMethods {
-			methods[i] = string(method)
-		}
-		corsPolicy.AllowMethods = strings.Join(methods, ", ")
-	}
-	if len(f.AllowHeaders) > 0 {
-		headers := make([]string, len(f.AllowHeaders))
-		for i, header := range f.AllowHeaders {
-			headers[i] = string(header)
-		}
-		corsPolicy.AllowHeaders = strings.Join(headers, ", ")
-	}
-	if f.AllowCredentials {
-		corsPolicy.AllowCredentials = &wrapperspb.BoolValue{Value: bool(f.AllowCredentials)}
-	}
-	if len(f.ExposeHeaders) > 0 {
-		headers := make([]string, len(f.ExposeHeaders))
-		for i, header := range f.ExposeHeaders {
-			headers[i] = string(header)
-		}
-		corsPolicy.ExposeHeaders = strings.Join(headers, ", ")
-	}
-	if f.MaxAge != 0 {
-		corsPolicy.MaxAge = fmt.Sprintf("%d", f.MaxAge)
-	}
-	return corsPolicy
-}
-
-// ConvertOriginToEnvoyStringMatcher converts an AllowOrigins value to an Envoy StringMatcher
-// based on the wildcard patterns in the origin string.
-//
-// The AllowOrigins format is: <scheme>://<host>(:<port>)
-// The host part can contain wildcard characters '*' that behave as greedy matches to the left.
-// According to the CORS specification, '*' is a greedy match to the left, including any number
-// of DNS labels to the left of its position.
-//
-// This implementation adheres to the definition above (from the gateway-api spec) and therefore
-// an allowed origin of "https://*.example.com" will not match "https://example.com".
-//
-// Matching strategy:
-// - No wildcard -> Exact match
-// - Single wildcard at the end (e.g., "https://*") -> Prefix match
-// - Any other wildcard pattern -> Regex match where * becomes .*
-//
-// Examples:
-// - "https://example.com" -> Exact match
-// - "https://*.example.com" -> Regex match: ^https://.*\.example\.com$
-// - "https://example.*" -> Prefix match: "https://example."
-// - "https://*" -> Prefix match: "https://"
-// - "https://sub.*.example.com" -> Regex match: ^https://sub\..*\.example\.com$
-// - "https://example.*:8080" -> Regex match: ^https://example\..*:8080$
-func ConvertOriginToEnvoyStringMatcher(origin string) *envoy_type_matcher_v3.StringMatcher {
-	// Check if the origin contains wildcards
-	if !strings.Contains(origin, "*") {
-		// No wildcards, use exact match
-		return &envoy_type_matcher_v3.StringMatcher{
-			MatchPattern: &envoy_type_matcher_v3.StringMatcher_Exact{
-				Exact: origin,
-			},
-		}
-	}
-
-	// Check if there is a single wildcard and it is at the end
-	// In this case, we can use prefix matching
-	if strings.Count(origin, "*") == 1 && strings.HasSuffix(origin, "*") {
-		// Extract the prefix before the wildcard
-		prefix := strings.TrimSuffix(origin, "*")
-		return &envoy_type_matcher_v3.StringMatcher{
-			MatchPattern: &envoy_type_matcher_v3.StringMatcher_Prefix{
-				Prefix: prefix,
-			},
-		}
-	}
-
-	// For any other wildcard pattern, use regex matching
-
-	// First escape all special characters
-	regexPattern := regexp.QuoteMeta(origin)
-
-	// Then convert escaped wildcards to regex wildcard patterns
-	regexPattern = strings.ReplaceAll(regexPattern, "\\*", ".*")
-
-	// Test the regex pattern to make sure it is a valid RE2 pattern
-	if err := regexutils.CheckRegexString(regexPattern); err != nil {
-		slog.Error("failed to convert origin to regex pattern", "origin", origin, "error", err)
-		return nil
-	}
-
-	return &envoy_type_matcher_v3.StringMatcher{
-		MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-			SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-				EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-					GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-				},
-				Regex: "^" + regexPattern + "$",
-			},
-		},
-	}
-}
diff --git a/internal/kgateway/utils/cors_test.go b/internal/kgateway/utils/cors_test.go
deleted file mode 100644
index 6af809376..000000000
--- a/internal/kgateway/utils/cors_test.go
+++ /dev/null
@@ -1,174 +0,0 @@
-package utils
-
-import (
-	"testing"
-
-	envoy_type_matcher_v3 "github.com/envoyproxy/go-control-plane/envoy/type/matcher/v3"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-)
-
-func TestConvertOriginToEnvoyStringMatcher(t *testing.T) {
-	tests := []struct {
-		name     string
-		origin   string
-		expected *envoy_type_matcher_v3.StringMatcher
-	}{
-		{
-			name:   "exact match - no wildcards",
-			origin: "https://example.com",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_Exact{
-					Exact: "https://example.com",
-				},
-			},
-		},
-		{
-			name:   "exact match - with port",
-			origin: "http://example.com:8080",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_Exact{
-					Exact: "http://example.com:8080",
-				},
-			},
-		},
-		{
-			name:   "single wildcard at end - prefix match",
-			origin: "https://*",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_Prefix{
-					Prefix: "https://",
-				},
-			},
-		},
-		{
-			name:   "wildcard subdomain - regex match",
-			origin: "https://*.example.com",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://.*\\.example\\.com$",
-					},
-				},
-			},
-		},
-		{
-			name:   "wildcard subdomain - regex match with port",
-			origin: "https://*.example.com:8080",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://.*\\.example\\.com:8080$",
-					},
-				},
-			},
-		},
-		{
-			name:   "wildcard subdomain - multi-level domain",
-			origin: "https://*.sub.example.com",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://.*\\.sub\\.example\\.com$",
-					},
-				},
-			},
-		},
-		{
-			name:   "complex wildcard pattern - regex match",
-			origin: "https://sub.*.example.com",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://sub\\..*\\.example\\.com$",
-					},
-				},
-			},
-		},
-		{
-			name:   "multiple wildcards - regex match",
-			origin: "https://*.sub.*.example.com",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://.*\\.sub\\..*\\.example\\.com$",
-					},
-				},
-			},
-		},
-		{
-			name:   "wildcard at end of host - prefix match",
-			origin: "https://example.*",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_Prefix{
-					Prefix: "https://example.",
-				},
-			},
-		},
-		{
-			name:   "wildcard at end with port - regex match",
-			origin: "https://example.*:8080",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://example\\..*:8080$",
-					},
-				},
-			},
-		},
-		{
-			name:   "wildcard in middle - regex match",
-			origin: "https://api.*.example.com",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://api\\..*\\.example\\.com$",
-					},
-				},
-			},
-		},
-		{
-			name:   "wildcard at start - regex match",
-			origin: "https://*.example.com",
-			expected: &envoy_type_matcher_v3.StringMatcher{
-				MatchPattern: &envoy_type_matcher_v3.StringMatcher_SafeRegex{
-					SafeRegex: &envoy_type_matcher_v3.RegexMatcher{
-						EngineType: &envoy_type_matcher_v3.RegexMatcher_GoogleRe2{
-							GoogleRe2: &envoy_type_matcher_v3.RegexMatcher_GoogleRE2{},
-						},
-						Regex: "^https://.*\\.example\\.com$",
-					},
-				},
-			},
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			result := ConvertOriginToEnvoyStringMatcher(tt.origin)
-			require.NotNil(t, result)
-			assert.Equal(t, tt.expected, result)
-		})
-	}
-}
diff --git a/internal/kgateway/utils/ip.go b/internal/kgateway/utils/ip.go
index 9e47bd7b3..f3fb536ea 100644
--- a/internal/kgateway/utils/ip.go
+++ b/internal/kgateway/utils/ip.go
@@ -1,8 +1,9 @@
 package utils
 
 import (
-	"fmt"
 	"net"
+
+	"github.com/pkg/errors"
 )
 
 // IsIpv4Address returns whether
@@ -12,7 +13,7 @@ func IsIpv4Address(bindAddress string) (validIpv4, strictIPv4 bool, err error) {
 	bindIP := net.ParseIP(bindAddress)
 	if bindIP == nil {
 		// If bindAddress is not a valid textual representation of an IP address
-		return false, false, fmt.Errorf("bindAddress %s is not a valid IP address", bindAddress)
+		return false, false, errors.Errorf("bindAddress %s is not a valid IP address", bindAddress)
 	} else if bindIP.To4() == nil {
 		// If bindIP is not an IPv4 address, To4 returns nil.
 		// so this is not an acceptable ipv4
diff --git a/internal/kgateway/utils/proto.go b/internal/kgateway/utils/proto.go
deleted file mode 100644
index d443158f8..000000000
--- a/internal/kgateway/utils/proto.go
+++ /dev/null
@@ -1,15 +0,0 @@
-package utils
-
-import (
-	"time"
-
-	"google.golang.org/protobuf/types/known/durationpb"
-)
-
-// DurationToProto converts a go Duration to a protobuf Duration.
-func DurationToProto(d time.Duration) *durationpb.Duration {
-	return &durationpb.Duration{
-		Seconds: int64(d) / int64(time.Second),
-		Nanos:   int32(int64(d) % int64(time.Second)),
-	}
-}
diff --git a/internal/kgateway/wellknown/gwapi.go b/internal/kgateway/wellknown/gwapi.go
index aa1eabb48..e5d4f8439 100644
--- a/internal/kgateway/wellknown/gwapi.go
+++ b/internal/kgateway/wellknown/gwapi.go
@@ -6,6 +6,7 @@ import (
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	infextv1a2 "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	apiv1 "sigs.k8s.io/gateway-api/apis/v1"
+	apiv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	apiv1alpha3 "sigs.k8s.io/gateway-api/apis/v1alpha3"
 	apiv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 	apixv1alpha1 "sigs.k8s.io/gateway-api/apisx/v1alpha1"
@@ -59,6 +60,16 @@ var (
 		Version: apiv1.GroupVersion.Version,
 		Kind:    HTTPRouteKind,
 	}
+	TLSRouteGVK = schema.GroupVersionKind{
+		Group:   GatewayGroup,
+		Version: apiv1alpha2.GroupVersion.Version,
+		Kind:    TLSRouteKind,
+	}
+	TCPRouteGVK = schema.GroupVersionKind{
+		Group:   GatewayGroup,
+		Version: apiv1alpha2.GroupVersion.Version,
+		Kind:    TCPRouteKind,
+	}
 	GRPCRouteGVK = schema.GroupVersionKind{
 		Group:   GatewayGroup,
 		Version: apiv1.GroupVersion.Version,
diff --git a/pkg/deployer/deployer_test.go b/pkg/deployer/deployer_test.go
index 99e03d733..899d891f5 100644
--- a/pkg/deployer/deployer_test.go
+++ b/pkg/deployer/deployer_test.go
@@ -43,7 +43,6 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/pkg/deployer"
 	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/pkg/schemes"
-	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 
 	// TODO BML tests in this suite fail if this no-op import is not imported first.
 	//
@@ -568,7 +567,9 @@ var _ = Describe("Deployer", func() {
 	})
 
 	Context("special cases", func() {
-		var gwc *api.GatewayClass
+		var (
+			gwc *api.GatewayClass
+		)
 		BeforeEach(func() {
 			gwc = defaultGatewayClass()
 		})
@@ -770,7 +771,9 @@ var _ = Describe("Deployer", func() {
 			tag = "1.2.3"
 		})
 		When("a GC is created with an empty spec.parametersRef", func() {
-			var d *deployer.Deployer
+			var (
+				d *deployer.Deployer
+			)
 			It("should use the default in-memory GWP", func() {
 				var objs clientObjects
 				var err error
@@ -1239,16 +1242,6 @@ var _ = Describe("Deployer", func() {
 									Name:          "foo",
 									ContainerPort: 80,
 								}},
-								Tracing: &gw2_v1alpha1.AiExtensionTrace{
-									EndPoint: "http://my-otel-collector.svc.cluster.local:4317",
-									Sampler: &gw2_v1alpha1.OTelTracesSampler{
-										SamplerType: ptr.To(gw2_v1alpha1.OTelTracesSamplerTraceidratio),
-										SamplerArg:  ptr.To("0.5"),
-									},
-									Timeout:           ptr.To(api.Duration("100s")),
-									Protocol:          ptr.To(gw2_v1alpha1.OTLPTracesProtocolTypeGrpc),
-									TransportSecurity: ptr.To(gw2_v1alpha1.OTLPTransportSecurityInsecure),
-								},
 							},
 						},
 					},
@@ -1515,9 +1508,6 @@ var _ = Describe("Deployer", func() {
 			cm := objs.findConfigMap(defaultNamespace, defaultConfigMapName)
 			Expect(cm).ToNot(BeNil())
 
-			aiTracingConfig := objs.findConfigMap(defaultNamespace, defaultConfigMapName+"-ai-otel-config")
-			Expect(aiTracingConfig).ToNot(BeNil())
-
 			logLevelsMap := expectedGwp.EnvoyContainer.Bootstrap.ComponentLogLevels
 			levels := []types.GomegaMatcher{}
 			for k, v := range logLevelsMap {
@@ -2096,7 +2086,7 @@ var _ = Describe("Deployer", func() {
 			Expect(pool.GetFinalizers()).To(ContainElement(wellknown.InferencePoolFinalizer))
 
 			// Get the endpoint picker objects for the InferencePool.
-			objs, err := d.GetObjsToDeploy(context.Background(), pool)
+			objs, err := d.GetObjsToDeploy(nil, pool)
 			Expect(err).NotTo(HaveOccurred())
 			objs = d.SetNamespaceAndOwner(pool, objs)
 
@@ -2164,6 +2154,7 @@ var _ = Describe("Deployer", func() {
 	})
 
 	Context("with listener sets", func() {
+
 		var (
 			listenerSetPort int32 = 4567
 			listenerPort    int32 = 1234
@@ -2442,16 +2433,6 @@ func fullyDefinedGatewayParameters(name, namespace string) *gw2_v1alpha1.Gateway
 						Digest:     ptr.To("ai-extension-digest"),
 						PullPolicy: ptr.To(corev1.PullAlways),
 					},
-					Tracing: &gw2_v1alpha1.AiExtensionTrace{
-						EndPoint: "http://my-otel-collector.svc.cluster.local:4317",
-						Sampler: &gw2_v1alpha1.OTelTracesSampler{
-							SamplerType: ptr.To(gw2_v1alpha1.OTelTracesSamplerTraceidratio),
-							SamplerArg:  ptr.To("0.5"),
-						},
-						Timeout:           ptr.To(api.Duration("100s")),
-						Protocol:          ptr.To(gw2_v1alpha1.OTLPTracesProtocolTypeGrpc),
-						TransportSecurity: ptr.To(gw2_v1alpha1.OTLPTransportSecurityInsecure),
-					},
 				},
 			},
 		},
@@ -2501,7 +2482,7 @@ func newCommonCols(t test.Failer, initObjs ...client.Object) *common.CommonColle
 	}
 	mock := krttest.NewMock(t, anys)
 
-	policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{}, settings.Settings{})
+	policies := krtcollections.NewPolicyIndex(krtutil.KrtOptions{}, extensionsplug.ContributesPolicies{})
 	kubeRawGateways := krttest.GetMockCollection[*api.Gateway](mock)
 	kubeRawListenerSets := krttest.GetMockCollection[*apixv1a1.XListenerSet](mock)
 	gatewayClasses := krttest.GetMockCollection[*api.GatewayClass](mock)
diff --git a/pkg/deployer/merge.go b/pkg/deployer/merge.go
index ea14aade4..96261324a 100644
--- a/pkg/deployer/merge.go
+++ b/pkg/deployer/merge.go
@@ -718,23 +718,7 @@ func deepMergeAIExtension(dst, src *v1alpha1.AiExtension) *v1alpha1.AiExtension
 	dst.Env = DeepMergeSlices(dst.GetEnv(), src.GetEnv())
 	dst.Ports = DeepMergeSlices(dst.GetPorts(), src.GetPorts())
 	dst.Stats = deepMergeAIExtensionStats(dst.GetStats(), src.GetStats())
-	dst.Tracing = deepMergeAIExtensionTracing(dst.GetTracing(), src.GetTracing())
-	return dst
-}
 
-func deepMergeAIExtensionTracing(dst, src *v1alpha1.AiExtensionTrace) *v1alpha1.AiExtensionTrace {
-	// nil src override means just use dst
-	if src == nil {
-		return dst
-	}
-	if dst == nil {
-		return src
-	}
-	dst.EndPoint = MergeComparable(dst.EndPoint, src.EndPoint)
-	dst.Sampler = MergePointers(dst.Sampler, src.Sampler)
-	dst.Timeout = MergePointers(dst.Timeout, src.Timeout)
-	dst.Protocol = MergePointers(dst.Protocol, src.Protocol)
-	dst.TransportSecurity = MergePointers(dst.TransportSecurity, src.TransportSecurity)
 	return dst
 }
 
diff --git a/pkg/deployer/values.go b/pkg/deployer/values.go
index 245cc6789..1fc52a656 100644
--- a/pkg/deployer/values.go
+++ b/pkg/deployer/values.go
@@ -2,7 +2,6 @@ package deployer
 
 import (
 	corev1 "k8s.io/api/core/v1"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
 	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
@@ -160,20 +159,6 @@ type HelmAIExtension struct {
 	Env             []corev1.EnvVar              `json:"env,omitempty"`
 	Ports           []corev1.ContainerPort       `json:"ports,omitempty"`
 	Stats           []byte                       `json:"stats,omitempty"`
-	Tracing         *helmAITracing               `json:"tracing,omitempty"`
-}
-
-type helmAITracing struct {
-	EndPoint          gwv1.AbsoluteURI      `json:"endpoint"`
-	Sampler           *helmAITracingSampler `json:"sampler,omitempty"`
-	Timeout           *gwv1.Duration        `json:"timeout,omitempty"`
-	Protocol          *string               `json:"protocol,omitempty"`
-	TransportSecurity *string               `json:"transportSecurity,omitempty"`
-}
-
-type helmAITracingSampler struct {
-	SamplerType *string `json:"type,omitempty"`
-	SamplerArg  *string `json:"arg,omitempty"`
 }
 
 type HelmInferenceExtension struct {
diff --git a/pkg/deployer/values_helpers.go b/pkg/deployer/values_helpers.go
index 50c6aadae..fa9e0f40c 100644
--- a/pkg/deployer/values_helpers.go
+++ b/pkg/deployer/values_helpers.go
@@ -208,22 +208,6 @@ func GetStatsValues(statsConfig *v1alpha1.StatsConfig) *HelmStatsConfig {
 	}
 }
 
-func getTracingValues(tracingConfig *v1alpha1.AiExtensionTrace) *helmAITracing {
-	if tracingConfig == nil {
-		return nil
-	}
-	return &helmAITracing{
-		EndPoint: tracingConfig.EndPoint,
-		Sampler: &helmAITracingSampler{
-			SamplerType: tracingConfig.GetSamplerType(),
-			SamplerArg:  tracingConfig.GetSamplerArg(),
-		},
-		Timeout:           tracingConfig.GetTimeout(),
-		Protocol:          tracingConfig.GetOTLPProtocolType(),
-		TransportSecurity: tracingConfig.GetTransportSecurityMode(),
-	}
-}
-
 // ComponentLogLevelsToString converts the key-value pairs in the map into a string of the
 // format: key1:value1,key2:value2,key3:value3, where the keys are sorted alphabetically.
 // If an empty map is passed in, then an empty string is returned.
@@ -269,7 +253,6 @@ func GetAIExtensionValues(config *v1alpha1.AiExtension) (*HelmAIExtension, error
 		Env:             config.GetEnv(),
 		Ports:           config.GetPorts(),
 		Stats:           byt,
-		Tracing:         getTracingValues(config.Tracing),
 	}, nil
 }
 
diff --git a/pkg/generated/openapi/zz_generated.openapi.go b/pkg/generated/openapi/zz_generated.openapi.go
index fedbb0aaa..a59386eaa 100644
--- a/pkg/generated/openapi/zz_generated.openapi.go
+++ b/pkg/generated/openapi/zz_generated.openapi.go
@@ -22,14 +22,10 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AIPromptGuard":                             schema_kgateway_v2_api_v1alpha1_AIPromptGuard(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLog":                                 schema_kgateway_v2_api_v1alpha1_AccessLog(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLogFilter":                           schema_kgateway_v2_api_v1alpha1_AccessLogFilter(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLogGrpcService":                      schema_kgateway_v2_api_v1alpha1_AccessLogGrpcService(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AgentGateway":                              schema_kgateway_v2_api_v1alpha1_AgentGateway(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtension":                               schema_kgateway_v2_api_v1alpha1_AiExtension(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtensionStats":                          schema_kgateway_v2_api_v1alpha1_AiExtensionStats(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtensionTrace":                          schema_kgateway_v2_api_v1alpha1_AiExtensionTrace(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AlwaysOnConfig":                            schema_kgateway_v2_api_v1alpha1_AlwaysOnConfig(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AnthropicConfig":                           schema_kgateway_v2_api_v1alpha1_AnthropicConfig(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AnyValue":                                  schema_kgateway_v2_api_v1alpha1_AnyValue(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AuthHeaderOverride":                        schema_kgateway_v2_api_v1alpha1_AuthHeaderOverride(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AwsAuth":                                   schema_kgateway_v2_api_v1alpha1_AwsAuth(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AwsBackend":                                schema_kgateway_v2_api_v1alpha1_AwsBackend(ref),
@@ -42,22 +38,13 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BackendList":                               schema_kgateway_v2_api_v1alpha1_BackendList(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BackendSpec":                               schema_kgateway_v2_api_v1alpha1_BackendSpec(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BackendStatus":                             schema_kgateway_v2_api_v1alpha1_BackendStatus(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BackoffStrategy":                           schema_kgateway_v2_api_v1alpha1_BackoffStrategy(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BodyTransformation":                        schema_kgateway_v2_api_v1alpha1_BodyTransformation(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Buffer":                                    schema_kgateway_v2_api_v1alpha1_Buffer(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BufferSettings":                            schema_kgateway_v2_api_v1alpha1_BufferSettings(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CELFilter":                                 schema_kgateway_v2_api_v1alpha1_CELFilter(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CSRFPolicy":                                schema_kgateway_v2_api_v1alpha1_CSRFPolicy(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CommonAccessLogGrpcService":                schema_kgateway_v2_api_v1alpha1_CommonAccessLogGrpcService(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CommonGrpcService":                         schema_kgateway_v2_api_v1alpha1_CommonGrpcService(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CommonHttpProtocolOptions":                 schema_kgateway_v2_api_v1alpha1_CommonHttpProtocolOptions(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ComparisonFilter":                          schema_kgateway_v2_api_v1alpha1_ComparisonFilter(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CorsPolicy":                                schema_kgateway_v2_api_v1alpha1_CorsPolicy(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttribute":                           schema_kgateway_v2_api_v1alpha1_CustomAttribute(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeEnvironment":                schema_kgateway_v2_api_v1alpha1_CustomAttributeEnvironment(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeHeader":                     schema_kgateway_v2_api_v1alpha1_CustomAttributeHeader(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeLiteral":                    schema_kgateway_v2_api_v1alpha1_CustomAttributeLiteral(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeMetadata":                   schema_kgateway_v2_api_v1alpha1_CustomAttributeMetadata(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomLabel":                               schema_kgateway_v2_api_v1alpha1_CustomLabel(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomResponse":                            schema_kgateway_v2_api_v1alpha1_CustomResponse(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.DirectResponse":                            schema_kgateway_v2_api_v1alpha1_DirectResponse(ref),
@@ -66,7 +53,6 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.DirectResponseStatus":                      schema_kgateway_v2_api_v1alpha1_DirectResponseStatus(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.DurationFilter":                            schema_kgateway_v2_api_v1alpha1_DurationFilter(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.DynamicForwardProxyBackend":                schema_kgateway_v2_api_v1alpha1_DynamicForwardProxyBackend(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.EnvironmentResourceDetectorConfig":         schema_kgateway_v2_api_v1alpha1_EnvironmentResourceDetectorConfig(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.EnvoyBootstrap":                            schema_kgateway_v2_api_v1alpha1_EnvoyBootstrap(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.EnvoyContainer":                            schema_kgateway_v2_api_v1alpha1_EnvoyContainer(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ExtAuthPolicy":                             schema_kgateway_v2_api_v1alpha1_ExtAuthPolicy(ref),
@@ -87,13 +73,13 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.GatewayParametersStatus":                   schema_kgateway_v2_api_v1alpha1_GatewayParametersStatus(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.GeminiConfig":                              schema_kgateway_v2_api_v1alpha1_GeminiConfig(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.GracefulShutdownSpec":                      schema_kgateway_v2_api_v1alpha1_GracefulShutdownSpec(ref),
+		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.GrpcService":                               schema_kgateway_v2_api_v1alpha1_GrpcService(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.GrpcStatusFilter":                          schema_kgateway_v2_api_v1alpha1_GrpcStatusFilter(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HTTPListenerPolicy":                        schema_kgateway_v2_api_v1alpha1_HTTPListenerPolicy(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HTTPListenerPolicyList":                    schema_kgateway_v2_api_v1alpha1_HTTPListenerPolicyList(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HTTPListenerPolicySpec":                    schema_kgateway_v2_api_v1alpha1_HTTPListenerPolicySpec(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderFilter":                              schema_kgateway_v2_api_v1alpha1_HeaderFilter(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderTransformation":                      schema_kgateway_v2_api_v1alpha1_HeaderTransformation(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderValue":                               schema_kgateway_v2_api_v1alpha1_HeaderValue(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HealthCheck":                               schema_kgateway_v2_api_v1alpha1_HealthCheck(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HealthCheckGrpc":                           schema_kgateway_v2_api_v1alpha1_HealthCheckGrpc(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HealthCheckHttp":                           schema_kgateway_v2_api_v1alpha1_HealthCheckHttp(ref),
@@ -103,8 +89,6 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Image":                                     schema_kgateway_v2_api_v1alpha1_Image(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.IstioContainer":                            schema_kgateway_v2_api_v1alpha1_IstioContainer(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.IstioIntegration":                          schema_kgateway_v2_api_v1alpha1_IstioIntegration(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValue":                               schema_kgateway_v2_api_v1alpha1_KeyAnyValue(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValueList":                           schema_kgateway_v2_api_v1alpha1_KeyAnyValueList(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KubernetesProxyConfig":                     schema_kgateway_v2_api_v1alpha1_KubernetesProxyConfig(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LLMProvider":                               schema_kgateway_v2_api_v1alpha1_LLMProvider(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LoadBalancer":                              schema_kgateway_v2_api_v1alpha1_LoadBalancer(ref),
@@ -118,14 +102,9 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetSelector":                 schema_kgateway_v2_api_v1alpha1_LocalPolicyTargetSelector(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalRateLimitPolicy":                      schema_kgateway_v2_api_v1alpha1_LocalRateLimitPolicy(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Message":                                   schema_kgateway_v2_api_v1alpha1_Message(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.MetadataKey":                               schema_kgateway_v2_api_v1alpha1_MetadataKey(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.MetadataPathSegment":                       schema_kgateway_v2_api_v1alpha1_MetadataPathSegment(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Moderation":                                schema_kgateway_v2_api_v1alpha1_Moderation(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.MultiPoolConfig":                           schema_kgateway_v2_api_v1alpha1_MultiPoolConfig(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OTelTracesSampler":                         schema_kgateway_v2_api_v1alpha1_OTelTracesSampler(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OpenAIConfig":                              schema_kgateway_v2_api_v1alpha1_OpenAIConfig(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OpenTelemetryAccessLogService":             schema_kgateway_v2_api_v1alpha1_OpenTelemetryAccessLogService(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OpenTelemetryTracingConfig":                schema_kgateway_v2_api_v1alpha1_OpenTelemetryTracingConfig(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Parameters":                                schema_kgateway_v2_api_v1alpha1_Parameters(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.PathOverride":                              schema_kgateway_v2_api_v1alpha1_PathOverride(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Pod":                                       schema_kgateway_v2_api_v1alpha1_Pod(ref),
@@ -145,10 +124,7 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RateLimitProvider":                         schema_kgateway_v2_api_v1alpha1_RateLimitProvider(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Regex":                                     schema_kgateway_v2_api_v1alpha1_Regex(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RegexMatch":                                schema_kgateway_v2_api_v1alpha1_RegexMatch(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ResourceDetector":                          schema_kgateway_v2_api_v1alpha1_ResourceDetector(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ResponseFlagFilter":                        schema_kgateway_v2_api_v1alpha1_ResponseFlagFilter(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RetryPolicy":                               schema_kgateway_v2_api_v1alpha1_RetryPolicy(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Sampler":                                   schema_kgateway_v2_api_v1alpha1_Sampler(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.SdsBootstrap":                              schema_kgateway_v2_api_v1alpha1_SdsBootstrap(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.SdsContainer":                              schema_kgateway_v2_api_v1alpha1_SdsContainer(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.SelfManagedGateway":                        schema_kgateway_v2_api_v1alpha1_SelfManagedGateway(ref),
@@ -165,8 +141,6 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TLS":                                       schema_kgateway_v2_api_v1alpha1_TLS(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TLSFiles":                                  schema_kgateway_v2_api_v1alpha1_TLSFiles(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TokenBucket":                               schema_kgateway_v2_api_v1alpha1_TokenBucket(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Tracing":                                   schema_kgateway_v2_api_v1alpha1_Tracing(ref),
-		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TracingProvider":                           schema_kgateway_v2_api_v1alpha1_TracingProvider(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TrafficPolicy":                             schema_kgateway_v2_api_v1alpha1_TrafficPolicy(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TrafficPolicyList":                         schema_kgateway_v2_api_v1alpha1_TrafficPolicyList(ref),
 		"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TrafficPolicySpec":                         schema_kgateway_v2_api_v1alpha1_TrafficPolicySpec(ref),
@@ -715,13 +689,7 @@ func schema_kgateway_v2_api_v1alpha1_AccessLog(ref common.ReferenceCallback) com
 					"grpcService": {
 						SchemaProps: spec.SchemaProps{
 							Description: "Send access logs to gRPC service",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLogGrpcService"),
-						},
-					},
-					"openTelemetry": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Send access logs to an OTel collector",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OpenTelemetryAccessLogService"),
+							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.GrpcService"),
 						},
 					},
 					"filter": {
@@ -734,7 +702,7 @@ func schema_kgateway_v2_api_v1alpha1_AccessLog(ref common.ReferenceCallback) com
 			},
 		},
 		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLogFilter", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLogGrpcService", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.FileSink", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OpenTelemetryAccessLogService"},
+			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLogFilter", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.FileSink", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.GrpcService"},
 	}
 }
 
@@ -825,128 +793,6 @@ func schema_kgateway_v2_api_v1alpha1_AccessLogFilter(ref common.ReferenceCallbac
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_AccessLogGrpcService(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "AccessLogGrpcService represents the gRPC service configuration for access logs. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/grpc/v3/als.proto#envoy-v3-api-msg-extensions-access-loggers-grpc-v3-httpgrpcaccesslogconfig",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"backendRef": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The backend gRPC service. Can be any type of supported backend (Kubernetes Service, kgateway Backend, etc..)",
-							Ref:         ref("sigs.k8s.io/gateway-api/apis/v1.BackendRef"),
-						},
-					},
-					"authority": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The :authority header in the grpc request. If this field is not set, the authority header value will be cluster_name. Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"maxReceiveMessageLength": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Maximum gRPC message size that is allowed to be received. If a message over this limit is received, the gRPC stream is terminated with the RESOURCE_EXHAUSTED error. Defaults to 0, which means unlimited.",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-					"skipEnvoyHeaders": {
-						SchemaProps: spec.SchemaProps{
-							Description: "This provides gRPC client level control over envoy generated headers. If false, the header will be sent but it can be overridden by per stream option. If true, the header will be removed and can not be overridden by per stream option. Default to false.",
-							Type:        []string{"boolean"},
-							Format:      "",
-						},
-					},
-					"timeout": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The timeout for the gRPC request. This is the timeout for a specific request",
-							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
-						},
-					},
-					"initialMetadata": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional metadata to include in streams initiated to the GrpcService. This can be used for scenarios in which additional ad hoc authorization headers (e.g. x-foo-bar: baz-key) are to be injected",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderValue"),
-									},
-								},
-							},
-						},
-					},
-					"retryPolicy": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Indicates the retry policy for re-establishing the gRPC stream. If max interval is not provided, it will be set to ten times the provided base interval",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RetryPolicy"),
-						},
-					},
-					"logName": {
-						SchemaProps: spec.SchemaProps{
-							Description: "name of log stream",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"additionalRequestHeadersToLog": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional request headers to log in the access log",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: "",
-										Type:    []string{"string"},
-										Format:  "",
-									},
-								},
-							},
-						},
-					},
-					"additionalResponseHeadersToLog": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional response headers to log in the access log",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: "",
-										Type:    []string{"string"},
-										Format:  "",
-									},
-								},
-							},
-						},
-					},
-					"additionalResponseTrailersToLog": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional response trailers to log in the access log",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: "",
-										Type:    []string{"string"},
-										Format:  "",
-									},
-								},
-							},
-						},
-					},
-				},
-				Required: []string{"backendRef", "logName"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderValue", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RetryPolicy", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration", "sigs.k8s.io/gateway-api/apis/v1.BackendRef"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_AgentGateway(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -1074,17 +920,11 @@ func schema_kgateway_v2_api_v1alpha1_AiExtension(ref common.ReferenceCallback) c
 							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtensionStats"),
 						},
 					},
-					"tracing": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional OTel tracing config for AI Extension.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtensionTrace"),
-						},
-					},
 				},
 			},
 		},
 		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtensionStats", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtensionTrace", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Image", "k8s.io/api/core/v1.ContainerPort", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecurityContext"},
+			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AiExtensionStats", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Image", "k8s.io/api/core/v1.ContainerPort", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecurityContext"},
 	}
 }
 
@@ -1115,68 +955,6 @@ func schema_kgateway_v2_api_v1alpha1_AiExtensionStats(ref common.ReferenceCallba
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_AiExtensionTrace(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "AiExtensionTrace defines the tracing configuration for the AI extension",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"endpoint": {
-						SchemaProps: spec.SchemaProps{
-							Description: "EndPoint specifies the URL of the OTLP Exporter for traces. Example: \"http://my-otel-collector.svc.cluster.local:4317\" https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_endpoint",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"sampler": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Sampler defines the sampling strategy for OpenTelemetry traces. Sampling helps in reducing the volume of trace data by selectively recording only a subset of traces. https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OTelTracesSampler"),
-						},
-					},
-					"timeout": {
-						SchemaProps: spec.SchemaProps{
-							Description: "OTLPTimeout specifies timeout configurations for OTLP (OpenTelemetry Protocol) exports. It allows setting general and trace-specific timeouts for sending data. https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_timeout",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"protocol": {
-						SchemaProps: spec.SchemaProps{
-							Description: "OTLPProtocol specifies the protocol to be used for OTLP exports. This determines how tracing data is serialized and transported (e.g., gRPC, HTTP/Protobuf). https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/#otel_exporter_otlp_traces_protocol",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"transportSecurity": {
-						SchemaProps: spec.SchemaProps{
-							Description: "TransportSecurity controls the TLS (Transport Layer Security) settings when connecting to the tracing server. It determines whether certificate verification should be skipped.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"endpoint"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OTelTracesSampler"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_AlwaysOnConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "AlwaysOnConfig specified the AlwaysOn samplerc",
-				Type:        []string{"object"},
-			},
-		},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_AnthropicConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -1214,45 +992,6 @@ func schema_kgateway_v2_api_v1alpha1_AnthropicConfig(ref common.ReferenceCallbac
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_AnyValue(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "AnyValue is used to represent any type of attribute value. AnyValue may contain a primitive value such as a string or integer or it may contain an arbitrary nested object containing arrays, key-value lists and primitives. This is limited to string and nested values as OTel only supports them",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"stringValue": {
-						SchemaProps: spec.SchemaProps{
-							Type:   []string{"string"},
-							Format: "",
-						},
-					},
-					"arrayValue": {
-						SchemaProps: spec.SchemaProps{
-							Type: []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AnyValue"),
-									},
-								},
-							},
-						},
-					},
-					"kvListValue": {
-						SchemaProps: spec.SchemaProps{
-							Ref: ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValueList"),
-						},
-					},
-				},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AnyValue", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValueList"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_AuthHeaderOverride(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -1847,34 +1586,6 @@ func schema_kgateway_v2_api_v1alpha1_BackendStatus(ref common.ReferenceCallback)
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_BackoffStrategy(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Configuration defining a jittered exponential back off strategy. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/backoff.proto#envoy-v3-api-msg-config-core-v3-backoffstrategy",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"baseInterval": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The base interval to be used for the next back off computation. It should be greater than zero and less than or equal to max_interval.",
-							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
-						},
-					},
-					"maxInterval": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Specifies the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set. The default is 10 times the base_interval.",
-							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
-						},
-					},
-				},
-				Required: []string{"baseInterval"},
-			},
-		},
-		Dependencies: []string{
-			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_BodyTransformation(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -1904,27 +1615,6 @@ func schema_kgateway_v2_api_v1alpha1_BodyTransformation(ref common.ReferenceCall
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_Buffer(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Type: []string{"object"},
-				Properties: map[string]spec.Schema{
-					"maxRequestSize": {
-						SchemaProps: spec.SchemaProps{
-							Description: "MaxRequestSize sets the maximum size in bytes of a message body to buffer. Requests exceeding this size will receive HTTP 413. Example format: \"1Mi\", \"512Ki\", \"1Gi\"",
-							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
-						},
-					},
-				},
-				Required: []string{"maxRequestSize"},
-			},
-		},
-		Dependencies: []string{
-			"k8s.io/apimachinery/pkg/api/resource.Quantity"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_BufferSettings(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -2025,152 +1715,6 @@ func schema_kgateway_v2_api_v1alpha1_CSRFPolicy(ref common.ReferenceCallback) co
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_CommonAccessLogGrpcService(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Common configuration for gRPC access logs. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/grpc/v3/als.proto#envoy-v3-api-msg-extensions-access-loggers-grpc-v3-commongrpcaccesslogconfig",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"backendRef": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The backend gRPC service. Can be any type of supported backend (Kubernetes Service, kgateway Backend, etc..)",
-							Ref:         ref("sigs.k8s.io/gateway-api/apis/v1.BackendRef"),
-						},
-					},
-					"authority": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The :authority header in the grpc request. If this field is not set, the authority header value will be cluster_name. Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"maxReceiveMessageLength": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Maximum gRPC message size that is allowed to be received. If a message over this limit is received, the gRPC stream is terminated with the RESOURCE_EXHAUSTED error. Defaults to 0, which means unlimited.",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-					"skipEnvoyHeaders": {
-						SchemaProps: spec.SchemaProps{
-							Description: "This provides gRPC client level control over envoy generated headers. If false, the header will be sent but it can be overridden by per stream option. If true, the header will be removed and can not be overridden by per stream option. Default to false.",
-							Type:        []string{"boolean"},
-							Format:      "",
-						},
-					},
-					"timeout": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The timeout for the gRPC request. This is the timeout for a specific request",
-							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
-						},
-					},
-					"initialMetadata": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional metadata to include in streams initiated to the GrpcService. This can be used for scenarios in which additional ad hoc authorization headers (e.g. x-foo-bar: baz-key) are to be injected",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderValue"),
-									},
-								},
-							},
-						},
-					},
-					"retryPolicy": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Indicates the retry policy for re-establishing the gRPC stream. If max interval is not provided, it will be set to ten times the provided base interval",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RetryPolicy"),
-						},
-					},
-					"logName": {
-						SchemaProps: spec.SchemaProps{
-							Description: "name of log stream",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"backendRef", "logName"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderValue", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RetryPolicy", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration", "sigs.k8s.io/gateway-api/apis/v1.BackendRef"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_CommonGrpcService(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Common gRPC service configuration created by setting `envoy_grpcâ€œ as the gRPC client Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/grpc_service.proto#envoy-v3-api-msg-config-core-v3-grpcservice Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/grpc_service.proto#envoy-v3-api-msg-config-core-v3-grpcservice-envoygrpc",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"backendRef": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The backend gRPC service. Can be any type of supported backend (Kubernetes Service, kgateway Backend, etc..)",
-							Ref:         ref("sigs.k8s.io/gateway-api/apis/v1.BackendRef"),
-						},
-					},
-					"authority": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The :authority header in the grpc request. If this field is not set, the authority header value will be cluster_name. Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"maxReceiveMessageLength": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Maximum gRPC message size that is allowed to be received. If a message over this limit is received, the gRPC stream is terminated with the RESOURCE_EXHAUSTED error. Defaults to 0, which means unlimited.",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-					"skipEnvoyHeaders": {
-						SchemaProps: spec.SchemaProps{
-							Description: "This provides gRPC client level control over envoy generated headers. If false, the header will be sent but it can be overridden by per stream option. If true, the header will be removed and can not be overridden by per stream option. Default to false.",
-							Type:        []string{"boolean"},
-							Format:      "",
-						},
-					},
-					"timeout": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The timeout for the gRPC request. This is the timeout for a specific request",
-							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
-						},
-					},
-					"initialMetadata": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional metadata to include in streams initiated to the GrpcService. This can be used for scenarios in which additional ad hoc authorization headers (e.g. x-foo-bar: baz-key) are to be injected",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderValue"),
-									},
-								},
-							},
-						},
-					},
-					"retryPolicy": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Indicates the retry policy for re-establishing the gRPC stream. If max interval is not provided, it will be set to ten times the provided base interval",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RetryPolicy"),
-						},
-					},
-				},
-				Required: []string{"backendRef"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.HeaderValue", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RetryPolicy", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration", "sigs.k8s.io/gateway-api/apis/v1.BackendRef"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_CommonHttpProtocolOptions(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -2303,211 +1847,45 @@ func schema_kgateway_v2_api_v1alpha1_CorsPolicy(ref common.ReferenceCallback) co
 							Type:        []string{"array"},
 							Items: &spec.SchemaOrArray{
 								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: "",
-										Type:    []string{"string"},
-										Format:  "",
-									},
-								},
-							},
-						},
-					},
-					"exposeHeaders": {
-						VendorExtensible: spec.VendorExtensible{
-							Extensions: spec.Extensions{
-								"x-kubernetes-list-type": "set",
-							},
-						},
-						SchemaProps: spec.SchemaProps{
-							Description: "ExposeHeaders indicates which HTTP response headers can be exposed to client-side scripts in response to a cross-origin request.\n\nA CORS-safelisted response header is an HTTP header in a CORS response that it is considered safe to expose to the client scripts. The CORS-safelisted response headers include the following headers: `Cache-Control` `Content-Language` `Content-Length` `Content-Type` `Expires` `Last-Modified` `Pragma` (See https://fetch.spec.whatwg.org/#cors-safelisted-response-header-name) The CORS-safelisted response headers are exposed to client by default.\n\nWhen an HTTP header name is specified using the `ExposeHeaders` field, this additional header will be exposed as part of the response to the client.\n\nHeader names are not case sensitive.\n\nMultiple header names in the value of the `Access-Control-Expose-Headers` response header are separated by a comma (\",\").\n\nA wildcard indicates that the responses with all HTTP headers are exposed to clients. The `Access-Control-Expose-Headers` response header can only use `*` wildcard as value when the `AllowCredentials` field is unspecified.\n\nSupport: Extended",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: "",
-										Type:    []string{"string"},
-										Format:  "",
-									},
-								},
-							},
-						},
-					},
-					"maxAge": {
-						SchemaProps: spec.SchemaProps{
-							Description: "MaxAge indicates the duration (in seconds) for the client to cache the results of a \"preflight\" request.\n\nThe information provided by the `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` response headers can be cached by the client until the time specified by `Access-Control-Max-Age` elapses.\n\nThe default value of `Access-Control-Max-Age` response header is 5 (seconds).",
-							Type:        []string{"integer"},
-							Format:      "int32",
-						},
-					},
-				},
-			},
-		},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_CustomAttribute(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Describes attributes for the active span. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#envoy-v3-api-msg-type-tracing-v3-customtag",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"name": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The name of the attribute",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"literal": {
-						SchemaProps: spec.SchemaProps{
-							Description: "A literal attribute value.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeLiteral"),
-						},
-					},
-					"environment": {
-						SchemaProps: spec.SchemaProps{
-							Description: "An environment attribute value.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeEnvironment"),
-						},
-					},
-					"requestHeader": {
-						SchemaProps: spec.SchemaProps{
-							Description: "A request header attribute value.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeHeader"),
-						},
-					},
-					"metadata": {
-						SchemaProps: spec.SchemaProps{
-							Description: "An attribute to obtain the value from the metadata.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeMetadata"),
-						},
-					},
-				},
-				Required: []string{"name"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeEnvironment", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeHeader", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeLiteral", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttributeMetadata"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_CustomAttributeEnvironment(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Environment type attribute with environment name and default value. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-environment",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"name": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Environment variable name to obtain the value to populate the attribute value.",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"defaultValue": {
-						SchemaProps: spec.SchemaProps{
-							Description: "When the environment variable is not found, the attribute value will be populated with this default value if specified, otherwise no attribute will be populated.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"name"},
-			},
-		},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_CustomAttributeHeader(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Header type attribute with header name and default value. https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-header",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"name": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Header name to obtain the value to populate the attribute value.",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"defaultValue": {
-						SchemaProps: spec.SchemaProps{
-							Description: "When the header does not exist, the attribute value will be populated with this default value if specified, otherwise no attribute will be populated.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"name"},
-			},
-		},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_CustomAttributeLiteral(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Literal type attribute with a static value. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-literal",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"value": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Static literal value to populate the attribute value.",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"value"},
-			},
-		},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_CustomAttributeMetadata(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Metadata type attribute using MetadataKey to retrieve the protobuf value from Metadata, and populate the attribute value with the canonical JSON representation of it. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/tracing/v3/custom_tag.proto#type-tracing-v3-customtag-metadata",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"kind": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Specify what kind of metadata to obtain attribute value from",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
+									SchemaProps: spec.SchemaProps{
+										Default: "",
+										Type:    []string{"string"},
+										Format:  "",
+									},
+								},
+							},
 						},
 					},
-					"metadataKey": {
+					"exposeHeaders": {
+						VendorExtensible: spec.VendorExtensible{
+							Extensions: spec.Extensions{
+								"x-kubernetes-list-type": "set",
+							},
+						},
 						SchemaProps: spec.SchemaProps{
-							Description: "Metadata key to define the path to retrieve the attribute value.",
-							Default:     map[string]interface{}{},
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.MetadataKey"),
+							Description: "ExposeHeaders indicates which HTTP response headers can be exposed to client-side scripts in response to a cross-origin request.\n\nA CORS-safelisted response header is an HTTP header in a CORS response that it is considered safe to expose to the client scripts. The CORS-safelisted response headers include the following headers: `Cache-Control` `Content-Language` `Content-Length` `Content-Type` `Expires` `Last-Modified` `Pragma` (See https://fetch.spec.whatwg.org/#cors-safelisted-response-header-name) The CORS-safelisted response headers are exposed to client by default.\n\nWhen an HTTP header name is specified using the `ExposeHeaders` field, this additional header will be exposed as part of the response to the client.\n\nHeader names are not case sensitive.\n\nMultiple header names in the value of the `Access-Control-Expose-Headers` response header are separated by a comma (\",\").\n\nA wildcard indicates that the responses with all HTTP headers are exposed to clients. The `Access-Control-Expose-Headers` response header can only use `*` wildcard as value when the `AllowCredentials` field is unspecified.\n\nSupport: Extended",
+							Type:        []string{"array"},
+							Items: &spec.SchemaOrArray{
+								Schema: &spec.Schema{
+									SchemaProps: spec.SchemaProps{
+										Default: "",
+										Type:    []string{"string"},
+										Format:  "",
+									},
+								},
+							},
 						},
 					},
-					"defaultValue": {
+					"maxAge": {
 						SchemaProps: spec.SchemaProps{
-							Description: "When no valid metadata is found, the attribute value would be populated with this default value if specified, otherwise no attribute would be populated.",
-							Type:        []string{"string"},
-							Format:      "",
+							Description: "MaxAge indicates the duration (in seconds) for the client to cache the results of a \"preflight\" request.\n\nThe information provided by the `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` response headers can be cached by the client until the time specified by `Access-Control-Max-Age` elapses.\n\nThe default value of `Access-Control-Max-Age` response header is 5 (seconds).",
+							Type:        []string{"integer"},
+							Format:      "int32",
 						},
 					},
 				},
-				Required: []string{"kind", "metadataKey"},
 			},
 		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.MetadataKey"},
 	}
 }
 
@@ -2763,17 +2141,6 @@ func schema_kgateway_v2_api_v1alpha1_DynamicForwardProxyBackend(ref common.Refer
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_EnvironmentResourceDetectorConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "EnvironmentResourceDetectorConfig specified the EnvironmentResourceDetector",
-				Type:        []string{"object"},
-			},
-		},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_EnvoyBootstrap(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -3518,6 +2885,81 @@ func schema_kgateway_v2_api_v1alpha1_GracefulShutdownSpec(ref common.ReferenceCa
 	}
 }
 
+func schema_kgateway_v2_api_v1alpha1_GrpcService(ref common.ReferenceCallback) common.OpenAPIDefinition {
+	return common.OpenAPIDefinition{
+		Schema: spec.Schema{
+			SchemaProps: spec.SchemaProps{
+				Description: "GrpcService represents the gRPC service configuration for access logs.",
+				Type:        []string{"object"},
+				Properties: map[string]spec.Schema{
+					"logName": {
+						SchemaProps: spec.SchemaProps{
+							Description: "name of log stream",
+							Default:     "",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
+					"backendRef": {
+						SchemaProps: spec.SchemaProps{
+							Description: "The backend gRPC service. Can be any type of supported backend (Kubernetes Service, kgateway Backend, etc..)",
+							Ref:         ref("sigs.k8s.io/gateway-api/apis/v1.BackendRef"),
+						},
+					},
+					"additionalRequestHeadersToLog": {
+						SchemaProps: spec.SchemaProps{
+							Description: "Additional request headers to log in the access log",
+							Type:        []string{"array"},
+							Items: &spec.SchemaOrArray{
+								Schema: &spec.Schema{
+									SchemaProps: spec.SchemaProps{
+										Default: "",
+										Type:    []string{"string"},
+										Format:  "",
+									},
+								},
+							},
+						},
+					},
+					"additionalResponseHeadersToLog": {
+						SchemaProps: spec.SchemaProps{
+							Description: "Additional response headers to log in the access log",
+							Type:        []string{"array"},
+							Items: &spec.SchemaOrArray{
+								Schema: &spec.Schema{
+									SchemaProps: spec.SchemaProps{
+										Default: "",
+										Type:    []string{"string"},
+										Format:  "",
+									},
+								},
+							},
+						},
+					},
+					"additionalResponseTrailersToLog": {
+						SchemaProps: spec.SchemaProps{
+							Description: "Additional response trailers to log in the access log",
+							Type:        []string{"array"},
+							Items: &spec.SchemaOrArray{
+								Schema: &spec.Schema{
+									SchemaProps: spec.SchemaProps{
+										Default: "",
+										Type:    []string{"string"},
+										Format:  "",
+									},
+								},
+							},
+						},
+					},
+				},
+				Required: []string{"logName", "backendRef"},
+			},
+		},
+		Dependencies: []string{
+			"sigs.k8s.io/gateway-api/apis/v1.BackendRef"},
+	}
+}
+
 func schema_kgateway_v2_api_v1alpha1_GrpcStatusFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -3649,8 +3091,7 @@ func schema_kgateway_v2_api_v1alpha1_HTTPListenerPolicySpec(ref common.Reference
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "HTTPListenerPolicySpec defines the desired state of a HTTP listener policy.",
-				Type:        []string{"object"},
+				Type: []string{"object"},
 				Properties: map[string]spec.Schema{
 					"targetRefs": {
 						SchemaProps: spec.SchemaProps{
@@ -3694,12 +3135,6 @@ func schema_kgateway_v2_api_v1alpha1_HTTPListenerPolicySpec(ref common.Reference
 							},
 						},
 					},
-					"tracing": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Tracing contains various settings for Envoy's OpenTelemetry tracer. See here for more information: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/opentelemetry.proto.html",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Tracing"),
-						},
-					},
 					"upgradeConfig": {
 						SchemaProps: spec.SchemaProps{
 							Description: "UpgradeConfig contains configuration for HTTP upgrades like WebSocket. See here for more information: https://www.envoyproxy.io/docs/envoy/v1.34.1/intro/arch_overview/http/upgrades.html",
@@ -3737,7 +3172,7 @@ func schema_kgateway_v2_api_v1alpha1_HTTPListenerPolicySpec(ref common.Reference
 			},
 		},
 		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLog", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetReference", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetSelector", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Tracing", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.UpgradeConfig", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
+			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AccessLog", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetReference", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetSelector", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.UpgradeConfig", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
 	}
 }
 
@@ -3790,35 +3225,6 @@ func schema_kgateway_v2_api_v1alpha1_HeaderTransformation(ref common.ReferenceCa
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_HeaderValue(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Header name/value pair. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-headervalue",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"key": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Header name.",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"value": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Header value.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"key"},
-			},
-		},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_HealthCheck(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -4190,66 +3596,6 @@ func schema_kgateway_v2_api_v1alpha1_IstioIntegration(ref common.ReferenceCallba
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_KeyAnyValue(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "KeyValue is a key-value pair that is used to store Span attributes, Link attributes, etc.",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"key": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Attribute keys must be unique",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"value": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Value may contain a primitive value such as a string or integer or it may contain an arbitrary nested object containing arrays, key-value lists and primitives.",
-							Default:     map[string]interface{}{},
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AnyValue"),
-						},
-					},
-				},
-				Required: []string{"key", "value"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AnyValue"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_KeyAnyValueList(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "A list of key-value pair that is used to store Span attributes, Link attributes, etc.",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"values": {
-						SchemaProps: spec.SchemaProps{
-							Description: "A collection of key/value pairs of key-value pairs.",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValue"),
-									},
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValue"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_KubernetesProxyConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -4678,111 +4024,51 @@ func schema_kgateway_v2_api_v1alpha1_LocalPolicyTargetSelector(ref common.Refere
 }
 
 func schema_kgateway_v2_api_v1alpha1_LocalRateLimitPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "LocalRateLimitPolicy represents a policy for local rate limiting. It defines the configuration for rate limiting using a token bucket mechanism.",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"tokenBucket": {
-						SchemaProps: spec.SchemaProps{
-							Description: "TokenBucket represents the configuration for a token bucket local rate-limiting mechanism. It defines the parameters for controlling the rate at which requests are allowed.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TokenBucket"),
-						},
-					},
-				},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TokenBucket"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_Message(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "An entry for a message to prepend or append to each prompt.",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"role": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Role of the message. The available roles depend on the backend LLM provider model, such as `SYSTEM` or `USER` in the OpenAI API.",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"content": {
-						SchemaProps: spec.SchemaProps{
-							Description: "String content of the message.",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"role", "content"},
-			},
-		},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_MetadataKey(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "MetadataKey provides a way to retrieve values from Metadata using a key and a path.",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"key": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The key name of the Metadata from which to retrieve the Struct",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"path": {
+	return common.OpenAPIDefinition{
+		Schema: spec.Schema{
+			SchemaProps: spec.SchemaProps{
+				Description: "LocalRateLimitPolicy represents a policy for local rate limiting. It defines the configuration for rate limiting using a token bucket mechanism.",
+				Type:        []string{"object"},
+				Properties: map[string]spec.Schema{
+					"tokenBucket": {
 						SchemaProps: spec.SchemaProps{
-							Description: "The path used to retrieve a specific Value from the Struct. This can be either a prefix or a full path, depending on the use case",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.MetadataPathSegment"),
-									},
-								},
-							},
+							Description: "TokenBucket represents the configuration for a token bucket local rate-limiting mechanism. It defines the parameters for controlling the rate at which requests are allowed.",
+							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TokenBucket"),
 						},
 					},
 				},
-				Required: []string{"key", "path"},
 			},
 		},
 		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.MetadataPathSegment"},
+			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TokenBucket"},
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_MetadataPathSegment(ref common.ReferenceCallback) common.OpenAPIDefinition {
+func schema_kgateway_v2_api_v1alpha1_Message(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "Specifies a segment in a path for retrieving values from Metadata.",
+				Description: "An entry for a message to prepend or append to each prompt.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
-					"key": {
+					"role": {
+						SchemaProps: spec.SchemaProps{
+							Description: "Role of the message. The available roles depend on the backend LLM provider model, such as `SYSTEM` or `USER` in the OpenAI API.",
+							Default:     "",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
+					"content": {
 						SchemaProps: spec.SchemaProps{
-							Description: "The key used to retrieve the value in the struct",
+							Description: "String content of the message.",
 							Default:     "",
 							Type:        []string{"string"},
 							Format:      "",
 						},
 					},
 				},
-				Required: []string{"key"},
+				Required: []string{"role", "content"},
 			},
 		},
 	}
@@ -4839,33 +4125,6 @@ func schema_kgateway_v2_api_v1alpha1_MultiPoolConfig(ref common.ReferenceCallbac
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_OTelTracesSampler(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "OTelTracesSampler defines the configuration for an OpenTelemetry trace sampler. It combines the sampler type with any required arguments for that type.",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"type": {
-						SchemaProps: spec.SchemaProps{
-							Description: "SamplerType specifies the type of sampler to use (default value: \"parentbased_always_on\"). Refer to OTelTracesSamplerType for available options. https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"arg": {
-						SchemaProps: spec.SchemaProps{
-							Description: "SamplerArg provides an argument for the chosen sampler type. For \"traceidratio\" or \"parentbased_traceidratio\" samplers: Sampling probability, a number in the [0..1] range, e.g. 0.25. Default is 1.0 if unset. https://opentelemetry.io/docs/languages/sdk-configuration/general/#otel_traces_sampler_arg",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-				},
-			},
-		},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_OpenAIConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -4896,100 +4155,6 @@ func schema_kgateway_v2_api_v1alpha1_OpenAIConfig(ref common.ReferenceCallback)
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_OpenTelemetryAccessLogService(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "OpenTelemetryAccessLogService represents the OTel configuration for access logs. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/open_telemetry/v3/logs_service.proto",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"grpcService": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Send access logs to gRPC service",
-							Default:     map[string]interface{}{},
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CommonAccessLogGrpcService"),
-						},
-					},
-					"body": {
-						SchemaProps: spec.SchemaProps{
-							Description: "OpenTelemetry LogResource fields, following Envoy access logging formatting.",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"disableBuiltinLabels": {
-						SchemaProps: spec.SchemaProps{
-							Description: "If specified, Envoy will not generate built-in resource labels like log_name, zone_name, cluster_name, node_name.",
-							Type:        []string{"boolean"},
-							Format:      "",
-						},
-					},
-					"attributes": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Additional attributes that describe the specific event occurrence.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValueList"),
-						},
-					},
-				},
-				Required: []string{"grpcService"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CommonAccessLogGrpcService", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.KeyAnyValueList"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_OpenTelemetryTracingConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "OpenTelemetryTracingConfig represents the top-level Envoy's OpenTelemetry tracer. See here for more information: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/opentelemetry.proto.html",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"grpcService": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Send traces to the gRPC service",
-							Default:     map[string]interface{}{},
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CommonGrpcService"),
-						},
-					},
-					"serviceName": {
-						SchemaProps: spec.SchemaProps{
-							Description: "The name for the service. This will be populated in the ResourceSpan Resource attributes",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"resourceDetectors": {
-						SchemaProps: spec.SchemaProps{
-							Description: "An ordered list of resource detectors. Currently supported values are `EnvironmentResourceDetector`",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ResourceDetector"),
-									},
-								},
-							},
-						},
-					},
-					"sampler": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Specifies the sampler to be used by the OpenTelemetry tracer. This field can be left empty. In this case, the default Envoy sampling decision is used. Currently supported values are `AlwaysOn`",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Sampler"),
-						},
-					},
-				},
-				Required: []string{"grpcService", "serviceName"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CommonGrpcService", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ResourceDetector", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Sampler"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_Parameters(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -5774,26 +4939,6 @@ func schema_kgateway_v2_api_v1alpha1_RegexMatch(ref common.ReferenceCallback) co
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_ResourceDetector(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "ResourceDetector defines the list of supported ResourceDetectors",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"environmentResourceDetector": {
-						SchemaProps: spec.SchemaProps{
-							Ref: ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.EnvironmentResourceDetectorConfig"),
-						},
-					},
-				},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.EnvironmentResourceDetectorConfig"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_ResponseFlagFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -5822,54 +4967,6 @@ func schema_kgateway_v2_api_v1alpha1_ResponseFlagFilter(ref common.ReferenceCall
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_RetryPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Specifies the retry policy of remote data source when fetching fails. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-retrypolicy",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"retryBackOff": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Specifies parameters that control retry backoff strategy. the default base interval is 1000 milliseconds and the default maximum interval is 10 times the base interval.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BackoffStrategy"),
-						},
-					},
-					"numRetries": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Specifies the allowed number of retries. Defaults to 1.",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-				},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.BackoffStrategy"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_Sampler(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Sampler defines the list of supported Samplers",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"alwaysOnConfig": {
-						SchemaProps: spec.SchemaProps{
-							Ref: ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AlwaysOnConfig"),
-						},
-					},
-				},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AlwaysOnConfig"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_SdsBootstrap(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -6515,106 +5612,6 @@ func schema_kgateway_v2_api_v1alpha1_TokenBucket(ref common.ReferenceCallback) c
 	}
 }
 
-func schema_kgateway_v2_api_v1alpha1_Tracing(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "Tracing represents the top-level Envoy's tracer. Ref: https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-tracing",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"provider": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Provider defines the upstream to which envoy sends traces",
-							Default:     map[string]interface{}{},
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TracingProvider"),
-						},
-					},
-					"clientSampling": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Target percentage of requests managed by this HTTP connection manager that will be force traced if the x-client-trace-id header is set. Defaults to 100%",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-					"randomSampling": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Target percentage of requests managed by this HTTP connection manager that will be randomly selected for trace generation, if not requested by the client or not forced. Defaults to 100%",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-					"overallSampling": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Target percentage of requests managed by this HTTP connection manager that will be traced after all other sampling checks have been applied (client-directed, force tracing, random sampling). Defaults to 100%",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-					"verbose": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Whether to annotate spans with additional data. If true, spans will include logs for stream events. Defaults to false",
-							Type:        []string{"boolean"},
-							Format:      "",
-						},
-					},
-					"maxPathTagLength": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Maximum length of the request path to extract and include in the HttpUrl tag. Used to truncate lengthy request paths to meet the needs of a tracing backend. Default: 256",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-					"attributes": {
-						SchemaProps: spec.SchemaProps{
-							Description: "A list of attributes with a unique name to create attributes for the active span.",
-							Type:        []string{"array"},
-							Items: &spec.SchemaOrArray{
-								Schema: &spec.Schema{
-									SchemaProps: spec.SchemaProps{
-										Default: map[string]interface{}{},
-										Ref:     ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttribute"),
-									},
-								},
-							},
-						},
-					},
-					"spawnUpstreamSpan": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Create separate tracing span for each upstream request if true. Defaults to false Link to envoy docs for more info",
-							Type:        []string{"boolean"},
-							Format:      "",
-						},
-					},
-				},
-				Required: []string{"provider"},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CustomAttribute", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TracingProvider"},
-	}
-}
-
-func schema_kgateway_v2_api_v1alpha1_TracingProvider(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "TracingProvider defines the list of providers for tracing",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"openTelemetry": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Tracing contains various settings for Envoy's OTel tracer.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OpenTelemetryTracingConfig"),
-						},
-					},
-				},
-			},
-		},
-		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.OpenTelemetryTracingConfig"},
-	}
-}
-
 func schema_kgateway_v2_api_v1alpha1_TrafficPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -6713,8 +5710,7 @@ func schema_kgateway_v2_api_v1alpha1_TrafficPolicySpec(ref common.ReferenceCallb
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "TrafficPolicySpec defines the desired state of a traffic policy.",
-				Type:        []string{"object"},
+				Type: []string{"object"},
 				Properties: map[string]spec.Schema{
 					"targetRefs": {
 						SchemaProps: spec.SchemaProps{
@@ -6786,17 +5782,11 @@ func schema_kgateway_v2_api_v1alpha1_TrafficPolicySpec(ref common.ReferenceCallb
 							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CSRFPolicy"),
 						},
 					},
-					"buffer": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Buffer can be used to set the maximum request size that will be buffered. Requests exceeding this size will return a 413 response.",
-							Ref:         ref("github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Buffer"),
-						},
-					},
 				},
 			},
 		},
 		Dependencies: []string{
-			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AIPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.Buffer", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CSRFPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CorsPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ExtAuthPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ExtProcPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetReferenceWithSectionName", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetSelector", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RateLimit", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TransformationPolicy"},
+			"github.com/kgateway-dev/kgateway/v2/api/v1alpha1.AIPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CSRFPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.CorsPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ExtAuthPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.ExtProcPolicy", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetReferenceWithSectionName", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.LocalPolicyTargetSelector", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.RateLimit", "github.com/kgateway-dev/kgateway/v2/api/v1alpha1.TransformationPolicy"},
 	}
 }
 
diff --git a/pkg/metrics/metrics.go b/pkg/metrics/metrics.go
index f47736390..28da6ed49 100644
--- a/pkg/metrics/metrics.go
+++ b/pkg/metrics/metrics.go
@@ -18,11 +18,8 @@ const (
 
 var (
 	// registry is the global metrics registry.
-	registry     RegistererGatherer = prometheus.NewRegistry()
-	registryLock                    = sync.RWMutex{}
-
-	// DefaultBuckets defines the default buckets used for histograms.
-	DefaultBuckets = prometheus.DefBuckets
+	registry     = metrics.Registry
+	registryLock = sync.RWMutex{}
 )
 
 // Metric defines a base interface for metrics.
@@ -144,10 +141,6 @@ func NewHistogram(opts HistogramOpts, labels []string) Histogram {
 		opts.Namespace = DefaultNamespace
 	}
 
-	if len(opts.Buckets) == 0 {
-		opts.Buckets = DefaultBuckets
-	}
-
 	h := &prometheusHistogram{
 		m:      prometheus.NewHistogramVec(prometheus.HistogramOpts(opts), labels),
 		labels: labels,
@@ -304,14 +297,10 @@ func Registry() RegistererGatherer {
 }
 
 // SetRegistry sets the global metrics registry.
-func SetRegistry(useBuiltinRegistry bool, r RegistererGatherer) {
+func SetRegistry(r RegistererGatherer) {
 	registryLock.Lock()
 	defer registryLock.Unlock()
 
-	if !useBuiltinRegistry {
-		metrics.Registry = registry
-	}
-
 	if isNil(r) {
 		registry = metrics.Registry
 	} else {
diff --git a/pkg/metrics/metrics_test.go b/pkg/metrics/metrics_test.go
index 12bf6c681..18caec607 100644
--- a/pkg/metrics/metrics_test.go
+++ b/pkg/metrics/metrics_test.go
@@ -11,12 +11,8 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/pkg/metrics/metricstest"
 )
 
-func setupTestRegistry() {
-	SetRegistry(false, prometheus.NewRegistry())
-}
-
 func TestCounterInterface(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := CounterOpts{
 		Name: "test_total",
@@ -52,7 +48,7 @@ func TestCounterInterface(t *testing.T) {
 }
 
 func TestCounterPartialLabels(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := CounterOpts{
 		Name: "test_total",
@@ -76,7 +72,7 @@ func TestCounterPartialLabels(t *testing.T) {
 }
 
 func TestCounterNoLabels(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := CounterOpts{
 		Name: "test_total",
@@ -96,7 +92,7 @@ func TestCounterNoLabels(t *testing.T) {
 }
 
 func TestCounterRegistrationPanic(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := CounterOpts{
 		Name: "test_total",
@@ -112,11 +108,12 @@ func TestCounterRegistrationPanic(t *testing.T) {
 }
 
 func TestHistogramInterface(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := HistogramOpts{
-		Name: "test_duration_seconds",
-		Help: "A test histogram metric",
+		Name:    "test_duration_seconds",
+		Help:    "A test histogram metric",
+		Buckets: prometheus.DefBuckets,
 	}
 
 	histogram := NewHistogram(opts, []string{"label1", "label2"})
@@ -133,42 +130,14 @@ func TestHistogramInterface(t *testing.T) {
 		{Name: "label1", Value: "value1"},
 		{Name: "label2", Value: "value2"},
 	})
-	gathered.AssertHistogramBuckets("kgateway_test_duration_seconds", DefaultBuckets)
 
 	histogram.Reset()
 	gathered = metricstest.MustGatherMetrics(t)
 	gathered.AssertMetricNotExists("kgateway_test_duration_seconds")
 }
 
-func TestHistogramBuckets(t *testing.T) {
-	setupTestRegistry()
-
-	testBuckets := []float64{0.1, 0.5, 1.0, 2.5, 5.0, 10.0}
-
-	opts := HistogramOpts{
-		Name:    "test_duration_seconds",
-		Help:    "A test histogram metric",
-		Buckets: testBuckets,
-	}
-
-	histogram := NewHistogram(opts, []string{"label1", "label2"})
-
-	histogram.Observe(1.5, Label{Name: "label1", Value: "value1"}, Label{Name: "label2", Value: "value2"})
-
-	gathered := metricstest.MustGatherMetrics(t)
-	gathered.AssertMetricHistogramValue("kgateway_test_duration_seconds", metricstest.HistogramMetricOutput{
-		SampleCount: 1,
-		SampleSum:   1.5,
-	})
-	gathered.AssertMetricLabels("kgateway_test_duration_seconds", []Label{
-		{Name: "label1", Value: "value1"},
-		{Name: "label2", Value: "value2"},
-	})
-	gathered.AssertHistogramBuckets("kgateway_test_duration_seconds", testBuckets)
-}
-
 func TestHistogramPartialLabels(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := HistogramOpts{
 		Name:    "test_duration_seconds_partial",
@@ -194,7 +163,7 @@ func TestHistogramPartialLabels(t *testing.T) {
 }
 
 func TestHistogramNoLabels(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := HistogramOpts{
 		Name:    "test_duration_seconds_no_labels",
@@ -216,7 +185,7 @@ func TestHistogramNoLabels(t *testing.T) {
 }
 
 func TestHistogramRegistrationPanic(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := HistogramOpts{
 		Name:    "test_duration_seconds_duplicate",
@@ -233,7 +202,7 @@ func TestHistogramRegistrationPanic(t *testing.T) {
 }
 
 func TestGaugeInterface(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := GaugeOpts{
 		Name: "tests",
@@ -275,7 +244,7 @@ func TestGaugeInterface(t *testing.T) {
 }
 
 func TestGaugePartialLabels(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := GaugeOpts{
 		Name: "tests_partial",
@@ -299,7 +268,7 @@ func TestGaugePartialLabels(t *testing.T) {
 }
 
 func TestGaugeNoLabels(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := GaugeOpts{
 		Name: "tests_no_labels",
@@ -320,7 +289,7 @@ func TestGaugeNoLabels(t *testing.T) {
 }
 
 func TestGaugeRegistrationPanic(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := GaugeOpts{
 		Name: "tests_duplicate",
@@ -336,7 +305,7 @@ func TestGaugeRegistrationPanic(t *testing.T) {
 }
 
 func TestGetPromCollector(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	counterOpts := CounterOpts{
 		Name: "test_collector_total",
@@ -371,7 +340,7 @@ func TestGetPromCollector(t *testing.T) {
 }
 
 func TestValidateLabelsOrder(t *testing.T) {
-	setupTestRegistry()
+	SetRegistry(prometheus.NewRegistry())
 
 	opts := CounterOpts{
 		Name: "test_label_order_total",
diff --git a/pkg/metrics/metricstest/metricstest.go b/pkg/metrics/metricstest/metricstest.go
index c107c4576..a637b90b8 100644
--- a/pkg/metrics/metricstest/metricstest.go
+++ b/pkg/metrics/metricstest/metricstest.go
@@ -77,7 +77,6 @@ type GatheredMetrics interface {
 	AssertMetricLabels(name string, expectedLabels []metrics.Label)
 	AssertMetricHistogramValue(name string, expectedValue HistogramMetricOutput)
 	AssertHistogramPopulated(name string)
-	AssertHistogramBuckets(name string, expectedBuckets []float64)
 	AssertMetricExists(name string)
 	AssertMetricNotExists(name string)
 	AssertMetric(name string, expectedMetric ExpectMetric)
@@ -139,7 +138,7 @@ func (g *prometheusGatheredMetrics) assertMetricObjLabels(metric *dto.Metric, ex
 
 func (g *prometheusGatheredMetrics) metricObjLabelsMatch(metric *dto.Metric, expectedLabels []metrics.Label) error {
 	if len(expectedLabels) != len(metric.GetLabel()) {
-		return fmt.Errorf("expected %d labels, got %d", len(expectedLabels), len(metric.GetLabel()))
+		return fmt.Errorf("Expected %d labels, got %d", len(expectedLabels), len(metric.GetLabel()))
 	}
 
 	labelMap := make(map[string]string, len(expectedLabels))
@@ -151,10 +150,10 @@ func (g *prometheusGatheredMetrics) metricObjLabelsMatch(metric *dto.Metric, exp
 	for _, label := range metric.GetLabel() {
 		labelValue, ok := labelMap[label.GetName()]
 		if !ok {
-			return fmt.Errorf("label %s not found", label.GetName())
+			return fmt.Errorf("Label %s not found", label.GetName())
 		}
 		if labelValue != label.GetValue() {
-			return fmt.Errorf("label %s value mismatch - expected %s, got %s", label.GetName(), labelValue, label.GetValue())
+			return fmt.Errorf("Label %s value mismatch - expected %s, got %s", label.GetName(), labelValue, label.GetValue())
 		}
 	}
 
@@ -207,21 +206,6 @@ func (g *prometheusGatheredMetrics) AssertHistogramPopulated(name string) {
 	assert.True(g.t, metric.GetHistogram().GetSampleSum() > 0, "Histogram %s is not populated", name)
 }
 
-// AssertHistogramBuckets asserts that a histogram metric has the expected bucket values.
-func (g *prometheusGatheredMetrics) AssertHistogramBuckets(name string, expectedBuckets []float64) {
-	metric := g.MustGetMetric(name)
-
-	histogram := metric.GetHistogram()
-	require.NotNil(g.t, histogram, "Metric %s is not a histogram", name)
-
-	buckets := histogram.GetBucket()
-	require.Equal(g.t, len(expectedBuckets), len(buckets), "Expected %d buckets for histogram %s, got %d", len(expectedBuckets), name, len(buckets))
-
-	for i, bucket := range buckets {
-		assert.Equal(g.t, expectedBuckets[i], bucket.GetUpperBound(), "Bucket %d for histogram %s does not match expected value", i, name)
-	}
-}
-
 // AssertMetricExists asserts that a metric with the given name exists.
 func (g *prometheusGatheredMetrics) AssertMetricExists(name string) {
 	_, ok := g.metrics[name]
@@ -240,8 +224,6 @@ func (g *prometheusGatheredMetrics) AssertMetric(name string, expected ExpectMet
 }
 
 func (g *prometheusGatheredMetrics) AssertMetrics(name string, expectedMetrics []ExpectMetric) {
-	require.NotEmpty(g.t, g.metrics[name], "Expected metrics %s not found", name)
-
 	for _, m := range g.metrics[name] {
 		matchedExpectedMetric := g.findMetricObj(m, expectedMetrics)
 		assert.NotNil(g.t, matchedExpectedMetric, "Metric %s with labels %v not found", name, m.GetLabel())
diff --git a/pkg/pluginsdk/collections/collections.go b/pkg/pluginsdk/collections/collections.go
index c4cf9f639..d92e9a596 100644
--- a/pkg/pluginsdk/collections/collections.go
+++ b/pkg/pluginsdk/collections/collections.go
@@ -41,9 +41,10 @@ type CommonCollections struct {
 	Services          krt.Collection[*corev1.Service]
 	ServiceEntries    krt.Collection[*networkingclient.ServiceEntry]
 
-	Pods       krt.Collection[krtcollections.LocalityPod]
-	RefGrants  *krtcollections.RefGrantIndex
-	ConfigMaps krt.Collection[*corev1.ConfigMap]
+	WrappedPods  krt.Collection[krtcollections.WrappedPod]
+	LocalityPods krt.Collection[krtcollections.LocalityPod]
+	RefGrants    *krtcollections.RefGrantIndex
+	ConfigMaps   krt.Collection[*corev1.ConfigMap]
 
 	// static set of global Settings, non-krt based for dev speed
 	// TODO: this should be refactored to a more correct location,
@@ -58,7 +59,8 @@ func (c *CommonCollections) HasSynced() bool {
 	return c.Secrets != nil && c.Secrets.HasSynced() &&
 		c.BackendIndex != nil && c.BackendIndex.HasSynced() &&
 		c.Routes != nil && c.Routes.HasSynced() &&
-		c.Pods != nil && c.Pods.HasSynced() &&
+		c.WrappedPods != nil && c.WrappedPods.HasSynced() &&
+		c.LocalityPods != nil && c.LocalityPods.HasSynced() &&
 		c.RefGrants != nil && c.RefGrants.HasSynced() &&
 		c.ConfigMaps != nil && c.ConfigMaps.HasSynced() &&
 		c.GatewayExtensions != nil && c.GatewayExtensions.HasSynced() &&
@@ -139,13 +141,16 @@ func NewCommonCollections(
 
 	gwExts := krtcollections.NewGatewayExtensionsCollection(ctx, client, ourClient, krtOptions)
 
+	localityPods, wrappedPods := krtcollections.NewPodsCollection(client, krtOptions)
+
 	return &CommonCollections{
 		OurClient:         ourClient,
 		Client:            client,
 		CrudClient:        cl,
 		KrtOpts:           krtOptions,
 		Secrets:           krtcollections.NewSecretIndex(secrets, refgrants),
-		Pods:              krtcollections.NewPodsCollection(client, krtOptions),
+		LocalityPods:      localityPods,
+		WrappedPods:       wrappedPods,
 		RefGrants:         refgrants,
 		Settings:          settings,
 		Namespaces:        namespaces,
diff --git a/pkg/pluginsdk/ir/gw2.go b/pkg/pluginsdk/ir/gw2.go
index 7386eb396..69d69e7fd 100644
--- a/pkg/pluginsdk/ir/gw2.go
+++ b/pkg/pluginsdk/ir/gw2.go
@@ -43,9 +43,6 @@ type HttpRouteRuleMatchIR struct {
 	// PrecedenceWeight specifies the weight of this route rule relative to other route rules.
 	// Higher weight means higher priority, and are evaluated before routes with lower weight
 	PrecedenceWeight int32
-
-	// Error encountered during translation
-	Error error
 }
 
 type ListenerIR struct {
diff --git a/pkg/pluginsdk/utils/policy.go b/pkg/pluginsdk/utils/policy.go
index 355d48f8b..acd9531df 100644
--- a/pkg/pluginsdk/utils/policy.go
+++ b/pkg/pluginsdk/utils/policy.go
@@ -4,7 +4,6 @@ import (
 	"maps"
 
 	"k8s.io/utils/ptr"
-	v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
 
 	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
@@ -47,17 +46,3 @@ func TargetRefsToPolicyRefsWithSectionName(
 	}
 	return refs
 }
-
-func TargetRefsToPolicyRefsWithSectionNameV1Alpha2(targetRefs []v1alpha2.LocalPolicyTargetReferenceWithSectionName) []ir.PolicyRef {
-	refs := make([]ir.PolicyRef, 0, len(targetRefs))
-	for _, targetRef := range targetRefs {
-		refs = append(refs, ir.PolicyRef{
-			Group:       string(targetRef.Group),
-			Kind:        string(targetRef.Kind),
-			Name:        string(targetRef.Name),
-			SectionName: string(ptr.Deref(targetRef.SectionName, "")),
-		})
-	}
-
-	return refs
-}
diff --git a/pkg/settings/settings.go b/pkg/settings/settings.go
index 2add6d765..41a7de4e7 100644
--- a/pkg/settings/settings.go
+++ b/pkg/settings/settings.go
@@ -151,14 +151,6 @@ type Settings struct {
 	// - "STANDARD": Rewrites invalid routes to direct responses (typically HTTP 500)
 	// - "STRICT": Builds on STANDARD by running targeted validation
 	RouteReplacementMode RouteReplacementMode `split_words:"true" default:"STANDARD"`
-
-	// EnableBuiltinDefaultMetrics enables the default builtin controller-runtime metrics and go runtime metrics.
-	// Since these metrics can be numerous, it is disabled by default.
-	EnableBuiltinDefaultMetrics bool `split_words:"true" default:"false"`
-
-	// GlobalPolicyNamespace is the namespace where policies that can attach to resources
-	// in any namespace are defined.
-	GlobalPolicyNamespace string `split_words:"true"`
 }
 
 // BuildSettings returns a zero-valued Settings obj if error is encountered when parsing env
diff --git a/pkg/settings/settings_test.go b/pkg/settings/settings_test.go
index c9c8a779f..1aedd1d4a 100644
--- a/pkg/settings/settings_test.go
+++ b/pkg/settings/settings_test.go
@@ -4,8 +4,7 @@ import (
 	"os"
 	"testing"
 
-	"github.com/google/go-cmp/cmp"
-	"github.com/stretchr/testify/require"
+	"github.com/onsi/gomega"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
@@ -51,37 +50,33 @@ func TestSettings(t *testing.T) {
 				EnableAgentGateway:          false,
 				WeightedRoutePrecedence:     false,
 				RouteReplacementMode:        settings.RouteReplacementStandard,
-				EnableBuiltinDefaultMetrics: false,
-				GlobalPolicyNamespace:       "",
 			},
 		},
 		{
 			name: "all values set",
 			envVars: map[string]string{
-				"KGW_DNS_LOOKUP_FAMILY":              string(settings.DnsLookupFamilyV4Only),
-				"KGW_ENABLE_ISTIO_INTEGRATION":       "true",
-				"KGW_ENABLE_ISTIO_AUTO_MTLS":         "true",
-				"KGW_LISTENER_BIND_IPV6":             "false",
-				"KGW_STS_CLUSTER_NAME":               "my-cluster",
-				"KGW_STS_URI":                        "my.sts.uri",
-				"KGW_XDS_SERVICE_HOST":               "my-xds-host",
-				"KGW_XDS_SERVICE_NAME":               "custom-svc",
-				"KGW_XDS_SERVICE_PORT":               "1234",
-				"KGW_USE_RUST_FORMATIONS":            "true",
-				"KGW_ENABLE_INFER_EXT":               "true",
-				"KGW_INFER_EXT_AUTO_PROVISION":       "true",
-				"KGW_DEFAULT_IMAGE_REGISTRY":         "my-registry",
-				"KGW_DEFAULT_IMAGE_TAG":              "my-tag",
-				"KGW_DEFAULT_IMAGE_PULL_POLICY":      "Always",
-				"KGW_WAYPOINT_LOCAL_BINDING":         "true",
-				"KGW_INGRESS_USE_WAYPOINTS":          "true",
-				"KGW_LOG_LEVEL":                      "debug",
-				"KGW_DISCOVERY_NAMESPACE_SELECTORS":  `[{"matchExpressions":[{"key":"kubernetes.io/metadata.name","operator":"In","values":["infra"]}]},{"matchLabels":{"app":"a"}}]`,
-				"KGW_ENABLE_AGENT_GATEWAY":           "true",
-				"KGW_WEIGHTED_ROUTE_PRECEDENCE":      "true",
-				"KGW_ROUTE_REPLACEMENT_MODE":         string(settings.RouteReplacementStrict),
-				"KGW_ENABLE_BUILTIN_DEFAULT_METRICS": "true",
-				"KGW_GLOBAL_POLICY_NAMESPACE":        "foo",
+				"KGW_DNS_LOOKUP_FAMILY":             string(settings.DnsLookupFamilyV4Only),
+				"KGW_ENABLE_ISTIO_INTEGRATION":      "true",
+				"KGW_ENABLE_ISTIO_AUTO_MTLS":        "true",
+				"KGW_LISTENER_BIND_IPV6":            "false",
+				"KGW_STS_CLUSTER_NAME":              "my-cluster",
+				"KGW_STS_URI":                       "my.sts.uri",
+				"KGW_XDS_SERVICE_HOST":              "my-xds-host",
+				"KGW_XDS_SERVICE_NAME":              "custom-svc",
+				"KGW_XDS_SERVICE_PORT":              "1234",
+				"KGW_USE_RUST_FORMATIONS":           "true",
+				"KGW_ENABLE_INFER_EXT":              "true",
+				"KGW_INFER_EXT_AUTO_PROVISION":      "true",
+				"KGW_DEFAULT_IMAGE_REGISTRY":        "my-registry",
+				"KGW_DEFAULT_IMAGE_TAG":             "my-tag",
+				"KGW_DEFAULT_IMAGE_PULL_POLICY":     "Always",
+				"KGW_WAYPOINT_LOCAL_BINDING":        "true",
+				"KGW_INGRESS_USE_WAYPOINTS":         "true",
+				"KGW_LOG_LEVEL":                     "debug",
+				"KGW_DISCOVERY_NAMESPACE_SELECTORS": `[{"matchExpressions":[{"key":"kubernetes.io/metadata.name","operator":"In","values":["infra"]}]},{"matchLabels":{"app":"a"}}]`,
+				"KGW_ENABLE_AGENT_GATEWAY":          "true",
+				"KGW_WEIGHTED_ROUTE_PRECEDENCE":     "true",
+				"KGW_ROUTE_REPLACEMENT_MODE":        string(settings.RouteReplacementStrict),
 			},
 			expectedSettings: &settings.Settings{
 				DnsLookupFamily:             settings.DnsLookupFamilyV4Only,
@@ -105,8 +100,6 @@ func TestSettings(t *testing.T) {
 				EnableAgentGateway:          true,
 				WeightedRoutePrecedence:     true,
 				RouteReplacementMode:        settings.RouteReplacementStrict,
-				EnableBuiltinDefaultMetrics: true,
-				GlobalPolicyNamespace:       "foo",
 			},
 		},
 		{
@@ -155,11 +148,9 @@ func TestSettings(t *testing.T) {
 				DefaultImageTag:             "",
 				DefaultImagePullPolicy:      "IfNotPresent",
 				WaypointLocalBinding:        false,
-				IngressUseWaypoints:         false,
 				LogLevel:                    "info",
 				DiscoveryNamespaceSelectors: "[]",
 				EnableAgentGateway:          false,
-				WeightedRoutePrecedence:     false,
 				RouteReplacementMode:        settings.RouteReplacementStandard,
 			},
 		},
@@ -167,36 +158,27 @@ func TestSettings(t *testing.T) {
 
 	for _, tc := range testCases {
 		t.Run(tc.name, func(t *testing.T) {
+			g := gomega.NewWithT(t)
+
 			t.Cleanup(func() {
-				cleanupEnvVars(t, tc.envVars)
+				for k := range tc.envVars {
+					err := os.Unsetenv(k)
+					g.Expect(err).NotTo(gomega.HaveOccurred())
+				}
 			})
 
 			for k, v := range tc.envVars {
-				if err := os.Setenv(k, v); err != nil {
-					t.Fatalf("Failed to set environment variable %s=%s: %v", k, v, err)
-				}
+				err := os.Setenv(k, v)
+				g.Expect(err).NotTo(gomega.HaveOccurred())
 			}
-
 			s, err := settings.BuildSettings()
-
 			if tc.expectedErrorStr != "" {
-				require.ErrorContains(t, err, tc.expectedErrorStr)
-				return
+				g.Expect(err).To(gomega.HaveOccurred())
+				g.Expect(err.Error()).To(gomega.ContainSubstring(tc.expectedErrorStr))
+			} else {
+				g.Expect(err).NotTo(gomega.HaveOccurred())
+				g.Expect(s).To(gomega.Equal(tc.expectedSettings))
 			}
-
-			require.NoError(t, err)
-
-			diff := cmp.Diff(tc.expectedSettings, s)
-			require.Emptyf(t, diff, "Settings do not match expected values (-expected +got):\n%s", diff)
 		})
 	}
 }
-
-func cleanupEnvVars(t *testing.T, envVars map[string]string) {
-	t.Helper()
-	for k := range envVars {
-		if err := os.Unsetenv(k); err != nil {
-			t.Errorf("Failed to unset environment variable %s: %v", k, err)
-		}
-	}
-}
diff --git a/pkg/utils/cmdutils/local.go b/pkg/utils/cmdutils/local.go
index 96a8c957f..752932b39 100644
--- a/pkg/utils/cmdutils/local.go
+++ b/pkg/utils/cmdutils/local.go
@@ -7,6 +7,7 @@ import (
 	"os/exec"
 	"strings"
 
+	"github.com/pkg/errors"
 	"github.com/solo-io/go-utils/threadsafe"
 )
 
@@ -90,7 +91,7 @@ func (cmd *LocalCmd) Run() *RunError {
 			command:    cmd.Args,
 			output:     combinedOutput.Bytes(),
 			inner:      err,
-			stackTrace: err,
+			stackTrace: errors.WithStack(err),
 		}
 	}
 	return nil
@@ -107,7 +108,7 @@ func (cmd *LocalCmd) Start() *RunError {
 			command:    cmd.Args,
 			output:     cmd.combinedOutput.Bytes(),
 			inner:      err,
-			stackTrace: err,
+			stackTrace: errors.WithStack(err),
 		}
 	}
 	return nil
@@ -121,7 +122,7 @@ func (cmd *LocalCmd) Wait() *RunError {
 			command:    cmd.Args,
 			output:     cmd.combinedOutput.Bytes(),
 			inner:      err,
-			stackTrace: err,
+			stackTrace: errors.WithStack(err),
 		}
 	}
 	return nil
diff --git a/test/e2e/gateway_test.go b/test/e2e/gateway_test.go
index c8c3d6e2b..82b3a61dc 100644
--- a/test/e2e/gateway_test.go
+++ b/test/e2e/gateway_test.go
@@ -258,7 +258,7 @@ var _ = Describe("Gateway", func() {
 						return proxy, nil
 					}
 
-					return nil, fmt.Errorf("non-ssl listener virtual hosts: expected 1, found %d", vhostCount)
+					return nil, errors.Errorf("non-ssl listener virtual hosts: expected 1, found %d ", vhostCount)
 				})
 
 				// Create a third trivial vs with valid config
@@ -281,7 +281,7 @@ var _ = Describe("Gateway", func() {
 						return proxy, nil
 					}
 
-					return nil, fmt.Errorf("non-ssl listener virtual hosts: expected 2, found %d", vhostCount)
+					return nil, errors.Errorf("non-ssl listener virtual hosts: expected 2, found %d ", vhostCount)
 				})
 
 				// Verify that the proxy is as expected (2 functional virtualservices)
diff --git a/test/helpers/snapshot_writer.go b/test/helpers/snapshot_writer.go
index 46db8c46d..c9c77ae0d 100644
--- a/test/helpers/snapshot_writer.go
+++ b/test/helpers/snapshot_writer.go
@@ -3,7 +3,6 @@
 package helpers
 
 import (
-	"fmt"
 	"time"
 
 	"github.com/onsi/ginkgo/v2"
@@ -312,7 +311,7 @@ func (s *SnapshotWriterImpl) waitForProxiesToBeDeleted(deleteOptions clients.Del
 			return err
 		}
 		if len(proxies) > 0 {
-			return fmt.Errorf("expected proxies to be deleted, but found %d", len(proxies))
+			return errors.Errorf("expected proxies to be deleted, but found %d", len(proxies))
 		}
 		return nil
 	},
diff --git a/test/kubernetes/e2e/defaults/defaults.go b/test/kubernetes/e2e/defaults/defaults.go
index bb8abf696..f5e5f7622 100644
--- a/test/kubernetes/e2e/defaults/defaults.go
+++ b/test/kubernetes/e2e/defaults/defaults.go
@@ -85,17 +85,4 @@ Commercial support is available at
 <p><em>Thank you for using nginx.</em></p>
 </body>
 </html>`
-
-	HttpbinManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "httpbin.yaml")
-
-	HttpbinLabelSelector = "app=httpbin"
-
-	HttpbinPod = &corev1.Pod{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "httpbin",
-			Namespace: "default",
-		},
-	}
-
-	WellKnownAppLabel = "app.kubernetes.io/name"
 )
diff --git a/test/kubernetes/e2e/defaults/testdata/httpbin.yaml b/test/kubernetes/e2e/defaults/testdata/httpbin.yaml
deleted file mode 100644
index 0ba65b3e8..000000000
--- a/test/kubernetes/e2e/defaults/testdata/httpbin.yaml
+++ /dev/null
@@ -1,58 +0,0 @@
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  name: httpbin
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: httpbin
-  labels:
-    app: httpbin
-    service: httpbin
-spec:
-  ports:
-    - name: http
-      port: 8000
-      targetPort: 8080
-    - name: tcp
-      port: 9000
-  selector:
-    app: httpbin
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  name: httpbin
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: httpbin
-      version: v1
-  template:
-    metadata:
-      labels:
-        app: httpbin
-        version: v1
-    spec:
-      serviceAccountName: httpbin
-      containers:
-        - image: docker.io/mccutchen/go-httpbin:v2.6.0
-          imagePullPolicy: IfNotPresent
-          name: httpbin
-          command: [ go-httpbin ]
-          args:
-            - "-port"
-            - "8080"
-            - "-max-duration"
-            - "600s" # override default 10s
-          ports:
-            - containerPort: 8080
-        - name: curl
-          image: curlimages/curl:7.83.1
-          imagePullPolicy: IfNotPresent
-          command:
-            - "tail"
-            - "-f"
-            - "/dev/null"
diff --git a/test/kubernetes/e2e/features/accesslog/suite.go b/test/kubernetes/e2e/features/accesslog/suite.go
deleted file mode 100644
index f4b84b8c4..000000000
--- a/test/kubernetes/e2e/features/accesslog/suite.go
+++ /dev/null
@@ -1,141 +0,0 @@
-package accesslog
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/suite"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/kubeutils"
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/requestutils/curl"
-	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/tests/base"
-)
-
-var _ e2e.NewSuiteFunc = NewTestingSuite
-
-type testingSuite struct {
-	*base.BaseTestingSuite
-}
-
-func NewTestingSuite(ctx context.Context, testInst *e2e.TestInstallation) suite.TestingSuite {
-	return &testingSuite{
-		base.NewBaseTestingSuite(ctx, testInst, setup, testCases),
-	}
-}
-
-// SetupSuite runs before all tests in the suite
-func (s *testingSuite) SetupSuite() {
-	s.BaseTestingSuite.SetupSuite()
-
-	s.TestInstallation.Assertions.EventuallyHTTPRouteCondition(s.Ctx, "httpbin", "httpbin", gwv1.RouteConditionAccepted, metav1.ConditionTrue)
-}
-
-func (s *testingSuite) BeforeTest(suiteName, testName string) {
-	s.BaseTestingSuite.BeforeTest(suiteName, testName)
-
-	s.TestInstallation.Assertions.EventuallyHTTPListenerPolicyCondition(s.Ctx, "access-logs", "default", gwv1.GatewayConditionAccepted, metav1.ConditionTrue)
-}
-
-// TestAccessLogWithFileSink tests access log with file sink
-func (s *testingSuite) TestAccessLogWithFileSink() {
-	pods := s.getPods(fmt.Sprintf("app.kubernetes.io/name=%s", gatewayObjectMeta.GetName()))
-	s.sendTestRequest()
-
-	s.Require().EventuallyWithT(func(c *assert.CollectT) {
-		logs, err := s.TestInstallation.Actions.Kubectl().GetContainerLogs(s.Ctx, gatewayService.ObjectMeta.GetNamespace(), pods[0])
-		s.Require().NoError(err)
-
-		// Verify the log contains the expected JSON pattern
-		assert.Contains(c, logs, `"authority":"www.example.com"`)
-		assert.Contains(c, logs, `"method":"GET"`)
-		assert.Contains(c, logs, `"path":"/status/200"`)
-		assert.Contains(c, logs, `"protocol":"HTTP/1.1"`)
-		assert.Contains(c, logs, `"response_code":200`)
-		assert.Contains(c, logs, `"backendCluster":"kube_httpbin_httpbin_8000"`)
-	}, 5*time.Second, 100*time.Millisecond)
-}
-
-// TestAccessLogWithGrpcSink tests access log with grpc sink
-func (s *testingSuite) TestAccessLogWithGrpcSink() {
-	pods := s.getPods("kgateway=gateway-proxy-access-logger")
-	s.sendTestRequest()
-
-	s.Require().EventuallyWithT(func(c *assert.CollectT) {
-		logs, err := s.TestInstallation.Actions.Kubectl().GetContainerLogs(s.Ctx, accessLoggerDeployment.ObjectMeta.GetNamespace(), pods[0])
-		s.Require().NoError(err)
-
-		// Verify the log contains the expected JSON pattern
-		assert.Contains(c, logs, `"logger_name":"test-accesslog-service"`)
-		assert.Contains(c, logs, `"cluster":"kube_httpbin_httpbin_8000"`)
-	}, 5*time.Second, 100*time.Millisecond)
-}
-
-// TestAccessLogWithOTelSink tests access log with OTel sink
-func (s *testingSuite) TestAccessLogWithOTelSink() {
-	pods := s.getPods("app.kubernetes.io/name=otel-collector")
-	s.sendTestRequest()
-
-	s.Require().EventuallyWithT(func(c *assert.CollectT) {
-		logs, err := s.TestInstallation.Actions.Kubectl().GetContainerLogs(s.Ctx, accessLoggerDeployment.ObjectMeta.GetNamespace(), pods[0])
-		s.Require().NoError(err)
-
-		// Example log line for the access log
-		// {"level":"info","ts":"2025-06-20T18:22:57.716Z","msg":"ResourceLog #0\nResource SchemaURL: \nResource attributes:\n     -> log_name: Str(test-otel-accesslog-service)\n     -> zone_name: Str()\n     -> cluster_name: Str(gw.default)\n     -> node_name: Str(gw-69c5b8cd88-ln44n.default)\nScopeLogs #0\nScopeLogs SchemaURL: \nInstrumentationScope  \nLogRecord #0\nObservedTimestamp: 1970-01-01 00:00:00 +0000 UTC\nTimestamp: 2025-06-20 18:22:56.807883 +0000 UTC\nSeverityText: \nSeverityNumber: Unspecified(0)\nBody: Str(\"GET /get 200 \"www.example.com\" \"kube_httpbin_httpbin_8000\"\\n')\nAttributes:\n     -> custom: Str(string)\n     -> kvlist: Map({\"key-1\":\"value-1\",\"key-2\":\"value-2\"})\nTrace ID: \nSpan ID: \nFlags: 0\n","kind":"exporter","data_type":"logs","name":"debug"}
-		assert.Contains(c, logs, `-> log_name: Str(test-otel-accesslog-service)`)
-		assert.Contains(c, logs, `GET /status/200 200`)
-		assert.Contains(c, logs, `www.example.com`)
-		assert.Contains(c, logs, `kube_httpbin_httpbin_8000`)
-		// Custom string attribute passed in the access log config
-		assert.Contains(c, logs, `-> custom: Str(string)`)
-		// Custom kvlist attribute passed in the access log config
-		assert.Contains(c, logs, `-> kvlist: Map`)
-		assert.Contains(c, logs, `key-1`)
-		assert.Contains(c, logs, `value-1`)
-		assert.Contains(c, logs, `key-2`)
-		assert.Contains(c, logs, `value-2`)
-	}, 5*time.Second, 100*time.Millisecond)
-}
-
-func (s *testingSuite) sendTestRequest() {
-	s.TestInstallation.Assertions.AssertEventualCurlResponse(
-		s.Ctx,
-		defaults.CurlPodExecOpt,
-		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(gatewayService.ObjectMeta)),
-			curl.VerboseOutput(),
-			curl.WithHostHeader("www.example.com"),
-			curl.WithPath("/status/200"),
-			curl.WithPort(8080),
-		},
-		&matchers.HttpResponse{
-			StatusCode: http.StatusOK,
-		},
-	)
-}
-
-func (s *testingSuite) getPods(label string) []string {
-	s.TestInstallation.Assertions.EventuallyPodsRunning(
-		s.Ctx,
-		accessLoggerDeployment.ObjectMeta.GetNamespace(),
-		metav1.ListOptions{
-			LabelSelector: label,
-		},
-	)
-
-	pods, err := s.TestInstallation.Actions.Kubectl().GetPodsInNsWithLabel(
-		s.Ctx,
-		accessLoggerDeployment.ObjectMeta.GetNamespace(),
-		label,
-	)
-	s.Require().NoError(err)
-	s.Require().Len(pods, 1)
-	return pods
-}
diff --git a/test/kubernetes/e2e/features/accesslog/testdata/otel.yaml b/test/kubernetes/e2e/features/accesslog/testdata/otel.yaml
deleted file mode 100644
index 52727c1fb..000000000
--- a/test/kubernetes/e2e/features/accesslog/testdata/otel.yaml
+++ /dev/null
@@ -1,126 +0,0 @@
----
-apiVersion: v1
-kind: ConfigMap
-metadata:
-  name: otel-collector-conf
-  labels:
-    app: opentelemetry
-    component: otel-collector-conf
-data:
-  otel-collector-config: |
-    receivers:
-      otlp:
-        protocols:
-          grpc:
-            include_metadata: true
-            endpoint: 0.0.0.0:4317
-    processors:
-    exporters:
-      debug:
-        verbosity: detailed
-    service:
-      extensions: []
-      pipelines:
-        logs:
-          receivers: [otlp]
-          processors: []
-          exporters: [debug]
-        traces:
-          receivers: [otlp]
-          processors: []
-          exporters: [debug]
-      telemetry:
-        logs:
-          level: "DEBUG"
-          development: true
-          encoding: "json"
----
-apiVersion: v1
-kind: Pod
-metadata:
-  name: otel-collector
-  labels:
-    app: opentelemetry
-    component: otel-collector
-    app.kubernetes.io/name: otel-collector
-spec:
-  containers:
-  - command:
-      - "/otelcol-contrib"
-      - "--config"
-      - "/conf/otel-collector-config.yaml"
-    image: otel/opentelemetry-collector-contrib:0.116.1
-    name: otel-collector
-    resources:
-      limits:
-        cpu: 1
-        memory: 2Gi
-      requests:
-        cpu: 200m
-        memory: 400Mi
-    ports: # Comment out ports for platforms as needed.
-    - containerPort: 4317 # Default gRPC endpoint for OpenTelemetry receiver.
-    volumeMounts:
-    - name: otel-collector-config-vol
-      mountPath: /conf
-  volumes:
-    - name: otel-collector-config-vol
-      configMap:
-        name: otel-collector-conf
-        items:
-          - key: otel-collector-config
-            path: otel-collector-config.yaml
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: otel-collector
-  labels:
-    app: opentelemetry
-    component: otel-collector
-    app.kubernetes.io/name: opentelemetry
-spec:
-  ports:
-  - name: otlp-grpc # Default endpoint for OpenTelemetry gRPC receiver.
-    port: 4317
-    protocol: TCP
-    targetPort: 4317
-    appProtocol: grpc
-  selector:
-    app.kubernetes.io/name: otel-collector
----
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: HTTPListenerPolicy
-metadata:
-  name: access-logs
-  namespace: default
-spec:
-  targetRefs:
-  - group: gateway.networking.k8s.io
-    kind: Gateway
-    name: gw
-  accessLog:
-  - openTelemetry:
-      grpcService:
-        backendRef:
-          name: otel-collector
-          namespace: default
-          port: 4317
-        logName: "test-otel-accesslog-service"
-      body: >-
-        "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %RESPONSE_CODE% "%REQ(:AUTHORITY)%" "%UPSTREAM_CLUSTER%"\n'
-      attributes:
-        values:
-        - key: custom
-          value:
-            stringValue: string
-        - key: kvlist
-          value:
-            kvListValue:
-              values:
-              - key: key-1
-                value:
-                  stringValue: value-1
-              - key: key-2
-                value:
-                  stringValue: value-2
diff --git a/test/kubernetes/e2e/features/acesslog/suite.go b/test/kubernetes/e2e/features/acesslog/suite.go
new file mode 100644
index 000000000..ca6de196b
--- /dev/null
+++ b/test/kubernetes/e2e/features/acesslog/suite.go
@@ -0,0 +1,209 @@
+package acesslog
+
+import (
+	"context"
+	"fmt"
+	"net/http"
+	"time"
+
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/suite"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/pkg/utils/kubeutils"
+	"github.com/kgateway-dev/kgateway/v2/pkg/utils/requestutils/curl"
+	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
+	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e"
+	testdefaults "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
+)
+
+var _ e2e.NewSuiteFunc = NewTestingSuite
+
+// testingSuite is a suite of tests for external processing functionality
+type testingSuite struct {
+	suite.Suite
+
+	ctx context.Context
+
+	// testInstallation contains all the metadata/utilities necessary to execute a series of tests
+	// against an installation of kgateway
+	testInstallation *e2e.TestInstallation
+
+	// maps test name to a list of manifests to apply before the test
+	manifests map[string][]string
+
+	// maps manifest name to a list of objects to verify
+	manifestObjects map[string][]client.Object
+
+	// Track core objects for cleanup
+	coreObjects []client.Object
+}
+
+func NewTestingSuite(ctx context.Context, testInst *e2e.TestInstallation) suite.TestingSuite {
+	return &testingSuite{
+		ctx:              ctx,
+		testInstallation: testInst,
+	}
+}
+
+// SetupSuite runs before all tests in the suite
+func (s *testingSuite) SetupSuite() {
+	// Initialize test manifest mappings
+	s.manifests = map[string][]string{
+		"TestAccessLogWithFileSink": {fileSinkManifest},
+		"TestAccessLogWithGrpcSink": {grpcServiceManifest},
+	}
+
+	// Initialize manifest to objects mapping
+	s.manifestObjects = map[string][]client.Object{
+		fileSinkManifest:    {fileSinkConfig},
+		grpcServiceManifest: {accessLoggerService, accessLoggerDeployment},
+	}
+
+	// Apply core infrastructure
+	err := s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, setupManifest)
+	s.Require().NoError(err)
+
+	// Apply curl pod for testing
+	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, testdefaults.CurlPodManifest)
+	s.Require().NoError(err)
+
+	// Track core objects
+	s.coreObjects = []client.Object{
+		testdefaults.CurlPod,              // curl
+		httpbinDeployment,                 // httpbin
+		gatewayService, gatewayDeployment, // gateway service
+	}
+
+	// Wait for core infrastructure to be ready
+	s.testInstallation.Assertions.EventuallyObjectsExist(s.ctx, s.coreObjects...)
+	s.testInstallation.Assertions.EventuallyPodsRunning(s.ctx, testdefaults.CurlPod.GetNamespace(), metav1.ListOptions{
+		LabelSelector: testdefaults.CurlPodLabelSelector,
+	})
+	s.testInstallation.Assertions.EventuallyPodsRunning(s.ctx, httpbinDeployment.ObjectMeta.GetNamespace(), metav1.ListOptions{
+		LabelSelector: "app=httpbin",
+	})
+	s.testInstallation.Assertions.EventuallyPodsRunning(
+		s.ctx,
+		gatewayDeployment.ObjectMeta.GetNamespace(),
+		metav1.ListOptions{
+			LabelSelector: fmt.Sprintf("app.kubernetes.io/name=%s", gatewayObjectMeta.GetName()),
+		},
+	)
+	s.testInstallation.Assertions.EventuallyHTTPRouteCondition(s.ctx, "httpbin", "httpbin", gwv1.RouteConditionAccepted, metav1.ConditionTrue)
+}
+
+// TearDownSuite cleans up any remaining resources
+func (s *testingSuite) TearDownSuite() {
+	// Clean up core infrastructure
+	err := s.testInstallation.Actions.Kubectl().DeleteFileSafe(s.ctx, setupManifest)
+	s.Require().NoError(err)
+
+	// Clean up curl pod
+	err = s.testInstallation.Actions.Kubectl().DeleteFileSafe(s.ctx, testdefaults.CurlPodManifest)
+	s.Require().NoError(err)
+
+	s.testInstallation.Assertions.EventuallyObjectsNotExist(s.ctx, s.coreObjects...)
+	s.testInstallation.Assertions.EventuallyPodsNotExist(s.ctx, gatewayObjectMeta.GetNamespace(), metav1.ListOptions{
+		LabelSelector: fmt.Sprintf("app.kubernetes.io/name=%s", gatewayObjectMeta.GetName()),
+	})
+	s.testInstallation.Assertions.EventuallyPodsNotExist(s.ctx, httpbinObjectMeta.GetNamespace(), metav1.ListOptions{
+		LabelSelector: "app=httpbin",
+	})
+}
+
+// BeforeTest runs before each test
+func (s *testingSuite) BeforeTest(suiteName, testName string) {
+	manifests := s.manifests[testName]
+	for _, manifest := range manifests {
+		err := s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, manifest)
+		s.Require().NoError(err)
+		s.testInstallation.Assertions.EventuallyObjectsExist(s.ctx, s.manifestObjects[manifest]...)
+	}
+}
+
+// AfterTest runs after each test
+func (s *testingSuite) AfterTest(suiteName, testName string) {
+	manifests := s.manifests[testName]
+	for _, manifest := range manifests {
+		err := s.testInstallation.Actions.Kubectl().DeleteFileSafe(s.ctx, manifest)
+		s.Require().NoError(err)
+		s.testInstallation.Assertions.EventuallyObjectsNotExist(s.ctx, s.manifestObjects[manifest]...)
+	}
+}
+
+// TestAccessLogWithFileSink tests access log with file sink
+func (s *testingSuite) TestAccessLogWithFileSink() {
+	// check access log
+	pods, err := s.testInstallation.Actions.Kubectl().GetPodsInNsWithLabel(
+		s.ctx,
+		gatewayService.ObjectMeta.GetNamespace(),
+		fmt.Sprintf("app.kubernetes.io/name=%s", gatewayObjectMeta.GetName()),
+	)
+	s.Require().NoError(err)
+	s.Require().Len(pods, 1)
+
+	s.sendTestRequest()
+
+	s.Require().EventuallyWithT(func(c *assert.CollectT) {
+		logs, err := s.testInstallation.Actions.Kubectl().GetContainerLogs(s.ctx, gatewayService.ObjectMeta.GetNamespace(), pods[0])
+		s.Require().NoError(err)
+
+		// Verify the log contains the expected JSON pattern
+		assert.Contains(c, logs, `"authority":"www.example.com"`)
+		assert.Contains(c, logs, `"method":"GET"`)
+		assert.Contains(c, logs, `"path":"/status/200"`)
+		assert.Contains(c, logs, `"protocol":"HTTP/1.1"`)
+		assert.Contains(c, logs, `"response_code":200`)
+		assert.Contains(c, logs, `"backendCluster":"kube_httpbin_httpbin_8000"`)
+	}, 5*time.Second, 100*time.Millisecond)
+}
+
+// TestAccessLogWithGrpcSink tests access log with grpc sink
+func (s *testingSuite) TestAccessLogWithGrpcSink() {
+	s.testInstallation.Assertions.EventuallyPodsRunning(
+		s.ctx,
+		accessLoggerDeployment.ObjectMeta.GetNamespace(),
+		metav1.ListOptions{
+			LabelSelector: "kgateway=gateway-proxy-access-logger",
+		},
+	)
+	// check access log
+	pods, err := s.testInstallation.Actions.Kubectl().GetPodsInNsWithLabel(
+		s.ctx,
+		accessLoggerDeployment.ObjectMeta.GetNamespace(),
+		"kgateway=gateway-proxy-access-logger",
+	)
+	s.Require().NoError(err)
+	s.Require().Len(pods, 1)
+
+	s.sendTestRequest()
+
+	s.Require().EventuallyWithT(func(c *assert.CollectT) {
+		logs, err := s.testInstallation.Actions.Kubectl().GetContainerLogs(s.ctx, accessLoggerDeployment.ObjectMeta.GetNamespace(), pods[0])
+		s.Require().NoError(err)
+
+		// Verify the log contains the expected JSON pattern
+		assert.Contains(c, logs, `"logger_name":"test-accesslog-service"`)
+		assert.Contains(c, logs, `"cluster":"kube_httpbin_httpbin_8000"`)
+	}, 5*time.Second, 100*time.Millisecond)
+}
+
+func (s *testingSuite) sendTestRequest() {
+	s.testInstallation.Assertions.AssertEventualCurlResponse(
+		s.ctx,
+		testdefaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(gatewayService.ObjectMeta)),
+			curl.VerboseOutput(),
+			curl.WithHostHeader("www.example.com"),
+			curl.WithPath("/status/200"),
+			curl.WithPort(8080),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusOK,
+		},
+	)
+}
diff --git a/test/kubernetes/e2e/features/accesslog/testdata/filesink.yaml b/test/kubernetes/e2e/features/acesslog/testdata/filesink.yaml
similarity index 100%
rename from test/kubernetes/e2e/features/accesslog/testdata/filesink.yaml
rename to test/kubernetes/e2e/features/acesslog/testdata/filesink.yaml
diff --git a/test/kubernetes/e2e/features/accesslog/testdata/grpc.yaml b/test/kubernetes/e2e/features/acesslog/testdata/grpc.yaml
similarity index 97%
rename from test/kubernetes/e2e/features/accesslog/testdata/grpc.yaml
rename to test/kubernetes/e2e/features/acesslog/testdata/grpc.yaml
index 65e3cf888..e168c8361 100644
--- a/test/kubernetes/e2e/features/accesslog/testdata/grpc.yaml
+++ b/test/kubernetes/e2e/features/acesslog/testdata/grpc.yaml
@@ -50,7 +50,7 @@ spec:
   template:
     metadata:
       labels:
-        app: gateway-proxy-access-logger
+        app: kgateway
         kgateway: gateway-proxy-access-logger
     spec:
       containers:
diff --git a/test/kubernetes/e2e/features/accesslog/testdata/setup.yaml b/test/kubernetes/e2e/features/acesslog/testdata/setup.yaml
similarity index 100%
rename from test/kubernetes/e2e/features/accesslog/testdata/setup.yaml
rename to test/kubernetes/e2e/features/acesslog/testdata/setup.yaml
diff --git a/test/kubernetes/e2e/features/accesslog/types.go b/test/kubernetes/e2e/features/acesslog/types.go
similarity index 51%
rename from test/kubernetes/e2e/features/accesslog/types.go
rename to test/kubernetes/e2e/features/acesslog/types.go
index 58cbf96cd..c06b71cc0 100644
--- a/test/kubernetes/e2e/features/accesslog/types.go
+++ b/test/kubernetes/e2e/features/acesslog/types.go
@@ -1,4 +1,4 @@
-package accesslog
+package acesslog
 
 import (
 	"path/filepath"
@@ -6,12 +6,9 @@ import (
 	appsv1 "k8s.io/api/apps/v1"
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"sigs.k8s.io/controller-runtime/pkg/client"
 
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/fsutils"
-	e2edefaults "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/tests/base"
 )
 
 var (
@@ -19,8 +16,6 @@ var (
 	setupManifest       = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup.yaml")
 	fileSinkManifest    = filepath.Join(fsutils.MustGetThisDir(), "testdata", "filesink.yaml")
 	grpcServiceManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "grpc.yaml")
-	oTelManifest        = filepath.Join(fsutils.MustGetThisDir(), "testdata", "otel.yaml")
-
 	// Core infrastructure objects that we need to track
 	gatewayObjectMeta = metav1.ObjectMeta{
 		Name:      "gw",
@@ -29,60 +24,24 @@ var (
 	gatewayService    = &corev1.Service{ObjectMeta: gatewayObjectMeta}
 	gatewayDeployment = &appsv1.Deployment{ObjectMeta: gatewayObjectMeta}
 
+	accessLoggerObjectMeta = metav1.ObjectMeta{
+		Name:      "gateway-proxy-access-logger",
+		Namespace: "default",
+	}
+	accessLoggerDeployment = &appsv1.Deployment{ObjectMeta: accessLoggerObjectMeta}
+	accessLoggerService    = &corev1.Service{ObjectMeta: accessLoggerObjectMeta}
+
 	httpbinObjectMeta = metav1.ObjectMeta{
 		Name:      "httpbin",
 		Namespace: "httpbin",
 	}
 	httpbinDeployment = &appsv1.Deployment{ObjectMeta: httpbinObjectMeta}
 
-	// TestAccessLogWithFileSink
+	// HTTPListenerPolicy objects
 	fileSinkConfig = &v1alpha1.HTTPListenerPolicy{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      "access-logs",
 			Namespace: "default",
 		},
 	}
-
-	// TestAccessLogWithGrpcSink
-	accessLoggerObjectMeta = metav1.ObjectMeta{
-		Name:      "gateway-proxy-access-logger",
-		Namespace: "default",
-	}
-	accessLoggerDeployment = &appsv1.Deployment{ObjectMeta: accessLoggerObjectMeta}
-	accessLoggerService    = &corev1.Service{ObjectMeta: accessLoggerObjectMeta}
-
-	// TestAccessLogWithOTelSink
-	otelCollectorPod = &corev1.Pod{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "otel-collector",
-			Namespace: "default",
-		},
-	}
-
-	setup = base.SimpleTestCase{
-		Manifests: []string{e2edefaults.CurlPodManifest, setupManifest},
-		Resources: []client.Object{e2edefaults.CurlPod, httpbinDeployment, gatewayService, gatewayDeployment},
-	}
-
-	// test cases
-	testCases = map[string]*base.TestCase{
-		"TestAccessLogWithFileSink": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{fileSinkManifest},
-				Resources: []client.Object{fileSinkConfig},
-			},
-		},
-		"TestAccessLogWithGrpcSink": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{grpcServiceManifest},
-				Resources: []client.Object{accessLoggerService, accessLoggerDeployment},
-			},
-		},
-		"TestAccessLogWithOTelSink": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{oTelManifest},
-				Resources: []client.Object{otelCollectorPod},
-			},
-		},
-	}
 )
diff --git a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
index ef5d3ed02..77a249b4b 100644
--- a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
+++ b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
@@ -6,6 +6,9 @@ spec:
   kube:
     agentGateway:
       enabled: true
+      logLevel: debug
+      image:
+        tag: bc92714
 ---
 kind: GatewayClass
 apiVersion: gateway.networking.k8s.io/v1
@@ -26,15 +29,26 @@ metadata:
 spec:
   gatewayClassName: agentgateway
   listeners:
-    - protocol: kgateway.dev/mcp
+    - protocol: HTTP
       port: 8080
-      name: mcp
+      name: http
       allowedRoutes:
         namespaces:
           from: All
-    - protocol: kgateway.dev/a2a
-      port: 9090
-      name: a2a
-      allowedRoutes:
-        namespaces:
-          from: All
\ No newline at end of file
+---
+apiVersion: gateway.networking.k8s.io/v1
+kind: HTTPRoute
+metadata:
+  name: httpbin
+  labels:
+    example: httpbin-route
+spec:
+  parentRefs:
+    - name: agent-gateway
+      namespace: default
+  hostnames:
+    - "www.example.com"
+  rules:
+    - backendRefs:
+        - name: httpbin
+          port: 8000
\ No newline at end of file
diff --git a/test/kubernetes/e2e/features/aiextension/suite.go b/test/kubernetes/e2e/features/aiextension/suite.go
index c85670c5b..51083d456 100644
--- a/test/kubernetes/e2e/features/aiextension/suite.go
+++ b/test/kubernetes/e2e/features/aiextension/suite.go
@@ -55,7 +55,6 @@ func NewSuite(
 
 func (s *tsuite) SetupSuite() {
 	s.manifests = map[string][]string{
-		"TestTracing":                 {tracingManifest},
 		"TestRouting":                 {commonManifest, backendManifest, routesBasicManifest},
 		"TestRoutingPassthrough":      {commonManifest, backendPassthroughManifest, routesBasicManifest},
 		"TestRoutingOverrideProvider": {commonManifest, backendPassthroughManifest, routesBasicManifest},
@@ -108,27 +107,6 @@ func (s *tsuite) AfterTest(suiteName, testName string) {
 	}
 }
 
-// TODO: Test that spans generated after traffic passes through the AI extension are correctly sent to the backend storage (Tempo).
-func (s *tsuite) TestTracing() {
-	tracingConfig := &corev1.ConfigMap{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "ai-gateway",
-			Namespace: s.testInst.Metadata.InstallNamespace,
-		},
-	}
-
-	s.testInst.Assertions.EventuallyObjectsExist(s.ctx, tracingConfig)
-
-	s.Require().EventuallyWithT(func(c *assert.CollectT) {
-		err := s.testInst.ClusterContext.Client.Get(
-			s.ctx,
-			types.NamespacedName{Name: tracingConfig.Name, Namespace: tracingConfig.Namespace},
-			tracingConfig,
-		)
-		assert.NoErrorf(c, err, "failed to get configMap %s/%s", tracingConfig.Namespace, tracingConfig.Name)
-	}, 30*time.Second, 1*time.Second)
-}
-
 func (s *tsuite) TestRouting() {
 	s.invokePytest("routing.py")
 }
diff --git a/test/kubernetes/e2e/features/aiextension/testdata/tracing.yaml b/test/kubernetes/e2e/features/aiextension/testdata/tracing.yaml
deleted file mode 100644
index 8f91a6429..000000000
--- a/test/kubernetes/e2e/features/aiextension/testdata/tracing.yaml
+++ /dev/null
@@ -1,43 +0,0 @@
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: GatewayParameters
-metadata:
-  name: kgateway-gateway-override
-  namespace: ai-test
-spec:
-  kube:
-    aiExtension:
-      enabled: true
-      ports:
-        - name: ai-monitoring
-          containerPort: 9092
-      tracing:
-        endpoint: "http://my-otel-collector.svc.cluster.local:4317"
-        sampler:
-          type: "traceidratio"
-          arg: "0.5"
-        timeout: "100s"
-        protocol: "grpc"
-        transportSecurity: "insecure"
-      env:
-        - name: LOG_LEVEL
-          value: DEBUG
----
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: ai-gateway
-  namespace: ai-test
-spec:
-  gatewayClassName: kgateway
-  infrastructure:
-    parametersRef:
-      name: kgateway-gateway-override
-      group: gateway.kgateway.dev
-      kind: GatewayParameters
-  listeners:
-    - protocol: HTTP
-      port: 8080
-      name: http
-      allowedRoutes:
-        namespaces:
-          from: All
diff --git a/test/kubernetes/e2e/features/aiextension/types.go b/test/kubernetes/e2e/features/aiextension/types.go
index 3e762ecef..5d9c39ada 100644
--- a/test/kubernetes/e2e/features/aiextension/types.go
+++ b/test/kubernetes/e2e/features/aiextension/types.go
@@ -10,8 +10,6 @@ var (
 	// common setup manifest (Gateway and Curl pod)
 	commonManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "common.yaml")
 
-	tracingManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "tracing.yaml")
-
 	// backends with Token Auth
 	backendManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "backend-token.yaml")
 
diff --git a/test/kubernetes/e2e/features/backendtls/inputs/base.yaml b/test/kubernetes/e2e/features/backendtls/inputs/base.yaml
index fccdd1943..6b6ea8951 100644
--- a/test/kubernetes/e2e/features/backendtls/inputs/base.yaml
+++ b/test/kubernetes/e2e/features/backendtls/inputs/base.yaml
@@ -26,20 +26,6 @@ spec:
     - name: nginx
       port: 8443
 ---
-apiVersion: gateway.networking.k8s.io/v1beta1
-kind: HTTPRoute
-metadata:
-  name: nginx2-route
-spec:
-  parentRefs:
-  - name: gw
-  hostnames:
-  - "example2.com"
-  rules:
-  - backendRefs:
-    - name: nginx2
-      port: 8443
----
 apiVersion: gateway.networking.k8s.io/v1alpha3
 kind: BackendTLSPolicy
 metadata:
@@ -49,9 +35,6 @@ spec:
   - group: ""
     kind: Service
     name: nginx
-  - group: ""
-    kind: Service
-    name: nginx2
   validation:
     hostname: "example.com"
     caCertificateRefs:
diff --git a/test/kubernetes/e2e/features/backendtls/inputs/configmap.yaml b/test/kubernetes/e2e/features/backendtls/inputs/configmap.yaml
index 5e94549b3..00d8d7131 100644
--- a/test/kubernetes/e2e/features/backendtls/inputs/configmap.yaml
+++ b/test/kubernetes/e2e/features/backendtls/inputs/configmap.yaml
@@ -4,23 +4,23 @@ apiVersion: v1
 data:
   ca.crt: |
     -----BEGIN CERTIFICATE-----
-    MIIDFTCCAf2gAwIBAgIUG9Mdv3nOQ2i7v68OgjArU4lhBikwDQYJKoZIhvcNAQEL
-    BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjUwNzA3MTA0MDQwWhcNMjYw
-    NzA3MTA0MDQwWjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN
-    AQEBBQADggEPADCCAQoCggEBANueqwfAApjTfg+nxIoKVK4sK/YlNICvdoEq1UEL
-    StE9wfTv0J27uNIsfpMqCx0Ni9Rjt1hzjunc8HUJDeobMNxGaZmryQofrdJWJ7Uu
-    t5jeLW/w0MelPOfFLsDiM5REy4WuPm2X6v1Z1N3N5GR3UNDOtDtsbjS1momvooLO
-    9WxPIr2cfmPqr81fyyD2ReZsMC/8lVs0PkA9XBplMzpSU53DWl5/Nyh2d1W5ENK0
-    Zw1l5Ze4UGUeohQMa5cD5hmZcBjOeJF8MuSTi3167KSopoqfgHTvC5IsBeWXAyZF
-    81ihFYAq+SbhUZeUlsxc1wveuAdBRzafcYkK47gYmbq1K60CAwEAAaNbMFkwFgYD
+    MIIDFTCCAf2gAwIBAgIUNrmDuzMzk7Fj5/qq6FdxOyhmYUIwDQYJKoZIhvcNAQEL
+    BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjUwNjA1MTkyNjQ2WhcNMjUw
+    NzA1MTkyNjQ2WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN
+    AQEBBQADggEPADCCAQoCggEBAKQE/tTuc2YkRdvtQeavYXWn7vMaZlN7CVdHz77L
+    TbkQqgY9jW8z+fytLNezn+rRz2+Egyn+EZkZY/r5KfYKHcGbrYZym9P3roJUNkcv
+    fx541TCmzVWb5NTBpyWfVRWmmvHIPRN6vzpUAy8IBV6Vi6drgYEfVLq80sTKI3xW
+    JGq/tuIMRf4Vxsney0BTiH2R9EuxEd4yRVmZuXHnmRAd1Lvzj8AUPnRwGp3iDExb
+    lLrf9atIubVK5wbeVayuqhZlA/vJI2ds2DwWk9GbXjTCsNdhNFxzScufuSslRCwc
+    VEZywk0z/1d0XajyUwpazr5ZPM/vvfA5px6HlqbidShPZ18CAwEAAaNbMFkwFgYD
     VR0RBA8wDYILZXhhbXBsZS5jb20wCwYDVR0PBAQDAgeAMBMGA1UdJQQMMAoGCCsG
-    AQUFBwMBMB0GA1UdDgQWBBSoa1Zu2o+pQ6sq2HcOjAglZkp01zANBgkqhkiG9w0B
-    AQsFAAOCAQEADZq1EMw/jMl0z2LpPh8cXbP09BnfXhoFbpL4cFrcBNEyig0oPO0j
-    YN1e4bfURNduFVnC/FDnZhR3FlAt8a6ozJAwmJp+nQCYFoDQwotSx12y5Bc9IXwd
-    BRZaLgHYy2NjGp2UgAya2z23BkUnwOJwJNMCzuGw3pOsmDQY0diR8ZWmEYYEPheW
-    6BVkrikzUNXv3tB8LmWzxV9V3eN71fnP5u39IM/UQsOZGRUow/8tvN2/d0W4dHky
-    t/kdgLKhf4gU2wXq/WbeqxlDSpjo7q/emNl59v1FHeR3eITSSjESU+dQgRsYaGEn
-    SWP+58ApfCcURLpMxUmxkO1ayfecNJbmSQ==
+    AQUFBwMBMB0GA1UdDgQWBBQaC/3wAQewXS9TbWN+lejEulC5fDANBgkqhkiG9w0B
+    AQsFAAOCAQEAOyQ7VNO04sjvzfyqXjh0qPXYx7Hyu06yMndr3B0XxG/9AZ396icS
+    B3LZgZ6R7LsAHD4Fw6QsTWxCW0S6mVBRX8972DvtNZuOIB0zb1A5qORJ0DajzwAh
+    l4wTra0oG6sFI1FSwl/I5poRiLMVUaoIzdW4HObhKIGe5F/J/iXtdAxFxLKtStQx
+    M9sP76Nw3FgzsXmMd04of7hGYSwrpANvyd49JO/mIzVfy4MRtbn5m4XKtahtT8vv
+    NGZZF13q6tdnAUptWWAvPShEeNj4xSw6Vam0JIbGcpH2Ch9ltOfDEDByELgdu7a/
+    /vAjhVKjL51vkbtmRxRSYbJZmyp4gNUKcQ==
     -----END CERTIFICATE-----
 
 kind: ConfigMap
diff --git a/test/kubernetes/e2e/features/backendtls/inputs/nginx.yaml b/test/kubernetes/e2e/features/backendtls/inputs/nginx.yaml
index 278a67d1a..acb10d608 100644
--- a/test/kubernetes/e2e/features/backendtls/inputs/nginx.yaml
+++ b/test/kubernetes/e2e/features/backendtls/inputs/nginx.yaml
@@ -15,26 +15,9 @@ spec:
       targetPort: https-web-svc
       name: https
 ---
-apiVersion: v1
-kind: Service
-metadata:
-  name: nginx2
-spec:
-  selector:
-    app.kubernetes.io/name: nginx2
-  ports:
-    - protocol: TCP
-      port: 8080
-      targetPort: http-web-svc
-      name: http
-    - protocol: TCP
-      port: 8443
-      targetPort: https-web-svc
-      name: https
----
 # nginx cert and key generated via:
 # openssl req -x509 -out ex.crt -keyout ex.key \
-#   -newkey rsa:2048 -days 365 -nodes -sha256 \
+#   -newkey rsa:2048 -nodes -sha256 \
 #   -subj '/CN=example.com' -extensions EXT -config <( \
 #    printf "[dn]\nCN=example.com\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:example.com\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth")
 apiVersion: v1
@@ -64,53 +47,53 @@ data:
     }
   example.crt: |
     -----BEGIN CERTIFICATE-----
-    MIIDFTCCAf2gAwIBAgIUG9Mdv3nOQ2i7v68OgjArU4lhBikwDQYJKoZIhvcNAQEL
-    BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjUwNzA3MTA0MDQwWhcNMjYw
-    NzA3MTA0MDQwWjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN
-    AQEBBQADggEPADCCAQoCggEBANueqwfAApjTfg+nxIoKVK4sK/YlNICvdoEq1UEL
-    StE9wfTv0J27uNIsfpMqCx0Ni9Rjt1hzjunc8HUJDeobMNxGaZmryQofrdJWJ7Uu
-    t5jeLW/w0MelPOfFLsDiM5REy4WuPm2X6v1Z1N3N5GR3UNDOtDtsbjS1momvooLO
-    9WxPIr2cfmPqr81fyyD2ReZsMC/8lVs0PkA9XBplMzpSU53DWl5/Nyh2d1W5ENK0
-    Zw1l5Ze4UGUeohQMa5cD5hmZcBjOeJF8MuSTi3167KSopoqfgHTvC5IsBeWXAyZF
-    81ihFYAq+SbhUZeUlsxc1wveuAdBRzafcYkK47gYmbq1K60CAwEAAaNbMFkwFgYD
+    MIIDFTCCAf2gAwIBAgIUNrmDuzMzk7Fj5/qq6FdxOyhmYUIwDQYJKoZIhvcNAQEL
+    BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjUwNjA1MTkyNjQ2WhcNMjUw
+    NzA1MTkyNjQ2WjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN
+    AQEBBQADggEPADCCAQoCggEBAKQE/tTuc2YkRdvtQeavYXWn7vMaZlN7CVdHz77L
+    TbkQqgY9jW8z+fytLNezn+rRz2+Egyn+EZkZY/r5KfYKHcGbrYZym9P3roJUNkcv
+    fx541TCmzVWb5NTBpyWfVRWmmvHIPRN6vzpUAy8IBV6Vi6drgYEfVLq80sTKI3xW
+    JGq/tuIMRf4Vxsney0BTiH2R9EuxEd4yRVmZuXHnmRAd1Lvzj8AUPnRwGp3iDExb
+    lLrf9atIubVK5wbeVayuqhZlA/vJI2ds2DwWk9GbXjTCsNdhNFxzScufuSslRCwc
+    VEZywk0z/1d0XajyUwpazr5ZPM/vvfA5px6HlqbidShPZ18CAwEAAaNbMFkwFgYD
     VR0RBA8wDYILZXhhbXBsZS5jb20wCwYDVR0PBAQDAgeAMBMGA1UdJQQMMAoGCCsG
-    AQUFBwMBMB0GA1UdDgQWBBSoa1Zu2o+pQ6sq2HcOjAglZkp01zANBgkqhkiG9w0B
-    AQsFAAOCAQEADZq1EMw/jMl0z2LpPh8cXbP09BnfXhoFbpL4cFrcBNEyig0oPO0j
-    YN1e4bfURNduFVnC/FDnZhR3FlAt8a6ozJAwmJp+nQCYFoDQwotSx12y5Bc9IXwd
-    BRZaLgHYy2NjGp2UgAya2z23BkUnwOJwJNMCzuGw3pOsmDQY0diR8ZWmEYYEPheW
-    6BVkrikzUNXv3tB8LmWzxV9V3eN71fnP5u39IM/UQsOZGRUow/8tvN2/d0W4dHky
-    t/kdgLKhf4gU2wXq/WbeqxlDSpjo7q/emNl59v1FHeR3eITSSjESU+dQgRsYaGEn
-    SWP+58ApfCcURLpMxUmxkO1ayfecNJbmSQ==
+    AQUFBwMBMB0GA1UdDgQWBBQaC/3wAQewXS9TbWN+lejEulC5fDANBgkqhkiG9w0B
+    AQsFAAOCAQEAOyQ7VNO04sjvzfyqXjh0qPXYx7Hyu06yMndr3B0XxG/9AZ396icS
+    B3LZgZ6R7LsAHD4Fw6QsTWxCW0S6mVBRX8972DvtNZuOIB0zb1A5qORJ0DajzwAh
+    l4wTra0oG6sFI1FSwl/I5poRiLMVUaoIzdW4HObhKIGe5F/J/iXtdAxFxLKtStQx
+    M9sP76Nw3FgzsXmMd04of7hGYSwrpANvyd49JO/mIzVfy4MRtbn5m4XKtahtT8vv
+    NGZZF13q6tdnAUptWWAvPShEeNj4xSw6Vam0JIbGcpH2Ch9ltOfDEDByELgdu7a/
+    /vAjhVKjL51vkbtmRxRSYbJZmyp4gNUKcQ==
     -----END CERTIFICATE-----
 
   example.key: |
     -----BEGIN PRIVATE KEY-----
-    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDbnqsHwAKY034P
-    p8SKClSuLCv2JTSAr3aBKtVBC0rRPcH079Cdu7jSLH6TKgsdDYvUY7dYc47p3PB1
-    CQ3qGzDcRmmZq8kKH63SVie1LreY3i1v8NDHpTznxS7A4jOURMuFrj5tl+r9WdTd
-    zeRkd1DQzrQ7bG40tZqJr6KCzvVsTyK9nH5j6q/NX8sg9kXmbDAv/JVbND5APVwa
-    ZTM6UlOdw1pefzcodndVuRDStGcNZeWXuFBlHqIUDGuXA+YZmXAYzniRfDLkk4t9
-    euykqKaKn4B07wuSLAXllwMmRfNYoRWAKvkm4VGXlJbMXNcL3rgHQUc2n3GJCuO4
-    GJm6tSutAgMBAAECggEACHMi3nH3R5z/gSexyqPaHTdq25YT3o2hsBePS+jc0I8h
-    OsTNUHxMAJ4gopXgBpaiViIeCEOt8HaFM+OMywCP0THOV1DCM+cDH5AcB/8LplCK
-    DAAGcF/9p2cxRM+PL3m0IOkS0tGhA21k4MHOs0TZ8aa6TXz/An0oPHrq9EB1Nd0F
-    V5ZDnk818uNolViDHpA4wTz49f81dUvSbWBM3WE4t+0wZM0LKgyYO/w/DRv7xyS2
-    hItA6dcFjniy6CuFQcgteY659qOMHwq46imIKHJGFimQ6+O16OInRzsiLQmGsnYi
-    eWTf0u9pP/uZ+92aH7EmoMc6Nwqq03AxSED1jamQewKBgQDyYp3ZAA2wBLlvigOD
-    tlZE4JPn4LJBL1JJFvuh+1O7NfaI7vpAg24SAiZzAcYTS7JfwmV/9P1g9RCeXAbW
-    5Jyp6MxNRv+veJvGcdrDLxjhWSkMt72A+FDHHQTKVLtsuD3PE31UIoYN2TPthHRz
-    et87ZGriWwhX8+PQ9/t2tfyr+wKBgQDn9LIS7hwFaJGzLnepJ17VfGm5NT/MLi4p
-    LUTkRtqlFM+t2foHCCXCUSNW3Q9VuTmFmqoHtbuv8DRdT3QbaQbMnFE0pSYWbHDL
-    TRCsBmWIIZvoMeKf6X9y0+Z/qrzCBV+TbgN2o3nbLodyqatfUrvwYkfz1L/GXuJ4
-    LmXzfdSOdwKBgArTSrd5YCMfYuTPZi7IwvuaiCCQEYYFxggLpbtrTScMVvFwsu6U
-    sCLPw8XZK26LL/FE7mGToIlnCJH6DDgmx7Ry+ETvSdYdbd+kECAth0/xOnsd7bHH
-    5VuvORqMRD6rz97iwPM0A4a0z7Po+YZ602OErZ1kcW/0LZWUrb90i09nAoGAcqCv
-    O8Gl4Vpa3mSxR8uoBvJzwM461+lecITpjbIiLQCK3UxiTgVNu6ijQTL/eAqQDaFw
-    M10xAnI/PnmcVEtjy8vYKZ8Ponc2ipFsEscad9q8FFRKvWID1Lg5KZAzteI36ECu
-    v3tsJc/pqdWFVhcpv1KiYjIaD6smWeP8CAd/+mMCgYEA7vZGKGnppmY2yFofukla
-    S0kgtXgeJrdwHf0X5c6pW+iveTUNj7zX0mdUhC0V4GXkbCXoWrLJc/dA/HW2D18Q
-    fcaJ8lpO3/VNiPx0mhGgCRVX2gRnz1qZ9EekIw1+TCqNSMVr04nQej6e24nUtNCO
-    tok7r0XhLeoEMoxJZwlanJk=
+    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCkBP7U7nNmJEXb
+    7UHmr2F1p+7zGmZTewlXR8++y025EKoGPY1vM/n8rSzXs5/q0c9vhIMp/hGZGWP6
+    +Sn2Ch3Bm62GcpvT966CVDZHL38eeNUwps1Vm+TUwacln1UVpprxyD0Ter86VAMv
+    CAVelYuna4GBH1S6vNLEyiN8ViRqv7biDEX+FcbJ3stAU4h9kfRLsRHeMkVZmblx
+    55kQHdS784/AFD50cBqd4gxMW5S63/WrSLm1SucG3lWsrqoWZQP7ySNnbNg8FpPR
+    m140wrDXYTRcc0nLn7krJUQsHFRGcsJNM/9XdF2o8lMKWs6+WTzP773wOaceh5am
+    4nUoT2dfAgMBAAECggEAC7M7hm74Fmox/Y1ALTeHiUAQgJD6iav2L560yBRyl+gD
+    aOyNIUig5ZBo6X4rwzFyTa8zOBSiprwz8JxDjQSNuNjlGPkl+onpjex57rwJol/W
+    PWE4tomnWjHyPXHPPPskhGjXSoNwDrYdgAZfc67RRoEZvN9CSQvdMSKGQ4FVmbO0
+    AgnKdJFeHciCLeCWIwkK2I2qJUVcH8n/0ANTPFzj2bDFGlGQRmdZb3zOwjIHn4oL
+    tAvhVIY1M66RNMSbcog6O/JtS5RbwNvQP5kLdNlfOOtL0HwJspn+qSKx2+MF4wcS
+    NnwOoqkWlQ6eFMau9u5vaZXYiCMD0olNHJ3eamEAmQKBgQDdlrzwvN4P+0n+P6I/
+    AtRS04iuo90aG1XKtxNQD4rIHzkUQ7hWt26PsIBRIswndu6QOftUeScGbmSwhKxE
+    S5vW9/QWn7AjWJF7sEk+trU+6XmOaxau5cBSSNvbuuORX0l9yvNZ/IRnmb9m27jS
+    rcZN4yGUKApXKViiAaL6W6xg5QKBgQC9fZcKbw+XwAkqnr2pcEWaz5SbzD0boO9Z
+    5Khox54nW5XqGEb0Y7bOEjiz7xa/Q4Xj7oFJZSAdKl3jZjnpbQ49fOx5Qhaock0f
+    1CYX8QB2kWNPN0wq00V1f18z12i+MN6eEI6r4xWRS1BSH14m6FvTmVaB8gu4kpwc
+    PbL3JPDW8wKBgQC/U+dCCiHHNNd302P4+i1wcrui51QCtbWG+jqPt0vCbcswJyTk
+    oy+wm9q/s8cJEFT+bUIIdy9uCyWfkH7Z3Vrq619zpWBFtLSxUs57evDWKGvPv8Fv
+    NGux4L0NZboWjGr9VZ53hWShu4wbeP6F0ovWNpaIwWXkSowAHl+lwj/9zQKBgAws
+    7K6T8kmK4kvlxUQE3cQTwHW+StLipV5+Tb/ly6i1vs064BxF5/IXw6L0It8JRKof
+    ohkIMWcOWNgKsn/oLPkQdNVZxMDwDzqTVBtHtgLoVpw5bmB2EMl69LANEELgOv2n
+    DLPItJMQZsnQECmp1nSjLqbM2anzaap64Gv26K63AoGAbC4c2u+mcnaZu0nwbEuj
+    3kUzotboXZnHyrQ0YvJAFDqFuGVqnkbKk9o6tvw2enh5q0srmkLZqFT/qDNSPqJe
+    oThbSJHIyRV9ZmN3z7W/TTPi9le/wz/xD/LJHqEmUbdA7UlSEgj5xAPEta9bVWHw
+    PYigje+A6GaAnmdNC3LY64E=
     -----END PRIVATE KEY-----
 ---
 apiVersion: v1
@@ -144,35 +127,3 @@ spec:
         path: example.crt
       - key: example.key
         path: example.key
----
-apiVersion: v1
-kind: Pod
-metadata:
-  name: nginx2
-  labels:
-    app.kubernetes.io/name: nginx2
-spec:
-  terminationGracePeriodSeconds: 0
-  containers:
-  - name: nginx
-    image: nginx:stable
-    ports:
-    - containerPort: 80
-      name: http-web-svc
-    - containerPort: 443
-      name: https-web-svc
-    volumeMounts:
-    - name: nginx-conf
-      mountPath: /etc/nginx/
-      readOnly: true
-  volumes:
-  - name: nginx-conf
-    configMap:
-      name: nginx-conf
-      items:
-      - key: nginx.conf
-        path: nginx.conf
-      - key: example.crt
-        path: example.crt
-      - key: example.key
-        path: example.key
diff --git a/test/kubernetes/e2e/features/backendtls/suite.go b/test/kubernetes/e2e/features/backendtls/suite.go
index 6631f359d..6501ba6c6 100644
--- a/test/kubernetes/e2e/features/backendtls/suite.go
+++ b/test/kubernetes/e2e/features/backendtls/suite.go
@@ -60,10 +60,6 @@ var (
 		Name:      "nginx",
 		Namespace: "default",
 	}
-	nginx2Meta = metav1.ObjectMeta{
-		Name:      "nginx2",
-		Namespace: "default",
-	}
 	svcGroup = ""
 	svcKind  = "Service"
 )
@@ -106,39 +102,23 @@ func (s *clientTlsTestingSuite) TestBackendTLSPolicyAndStatus() {
 	s.testInstallation.Assertions.EventuallyPodsRunning(s.ctx, nginxMeta.GetNamespace(), metav1.ListOptions{
 		LabelSelector: "app.kubernetes.io/name=nginx",
 	})
-	s.testInstallation.Assertions.EventuallyPodsRunning(s.ctx, nginx2Meta.GetNamespace(), metav1.ListOptions{
-		LabelSelector: "app.kubernetes.io/name=nginx2",
-	})
 	s.testInstallation.Assertions.EventuallyPodsRunning(s.ctx, proxyObjMeta.GetNamespace(), metav1.ListOptions{
 		LabelSelector: "app.kubernetes.io/name=gw",
 	})
 
-	tt := []struct {
-		host string
-	}{
-		{
-			host: "example.com",
+	s.testInstallation.Assertions.AssertEventualCurlResponse(
+		s.ctx,
+		defaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(proxyService.ObjectMeta)),
+			curl.WithHostHeader("example.com"),
+			curl.WithPath("/"),
 		},
-		{
-			host: "example2.com",
+		&matchers.HttpResponse{
+			StatusCode: http.StatusOK,
+			Body:       gomega.ContainSubstring(defaults.NginxResponse),
 		},
-	}
-	for _, tc := range tt {
-		s.testInstallation.Assertions.AssertEventualCurlResponse(
-			s.ctx,
-			defaults.CurlPodExecOpt,
-			[]curl.Option{
-				curl.WithHost(kubeutils.ServiceFQDN(proxyService.ObjectMeta)),
-				curl.WithHostHeader(tc.host),
-				curl.WithPath("/"),
-			},
-			&matchers.HttpResponse{
-				StatusCode: http.StatusOK,
-				Body:       gomega.ContainSubstring(defaults.NginxResponse),
-			},
-		)
-	}
-
+	)
 	s.testInstallation.Assertions.AssertEventualCurlResponse(
 		s.ctx,
 		defaults.CurlPodExecOpt,
@@ -183,34 +163,23 @@ func (s *clientTlsTestingSuite) assertPolicyStatus(inCondition metav1.Condition)
 		err := s.testInstallation.ClusterContext.Client.Get(s.ctx, objKey, tlsPol)
 		g.Expect(err).NotTo(gomega.HaveOccurred(), "failed to get BackendTLSPolicy %s", objKey)
 
-		g.Expect(tlsPol.Status.Ancestors).To(gomega.HaveLen(2), "ancestors didn't have length of 2")
-
-		expectedAncestorRefs := []gwv1a2.ParentReference{
-			{
-				Group:     (*gwv1.Group)(&svcGroup),
-				Kind:      (*gwv1.Kind)(&svcKind),
-				Namespace: ptr.To(gwv1.Namespace(nginxMeta.Namespace)),
-				Name:      gwv1.ObjectName(nginxMeta.Name),
-			},
-			{
-				Group:     (*gwv1.Group)(&svcGroup),
-				Kind:      (*gwv1.Kind)(&svcKind),
-				Namespace: ptr.To(gwv1.Namespace(nginx2Meta.Namespace)),
-				Name:      gwv1.ObjectName(nginx2Meta.Name),
-			},
-		}
+		g.Expect(tlsPol.Status.Ancestors).To(gomega.HaveLen(1), "ancestors didn't have length of 1")
+		ancestor := tlsPol.Status.Ancestors[0]
 
-		for i, ancestor := range tlsPol.Status.Ancestors {
-			expectedRef := expectedAncestorRefs[i]
-			g.Expect(ancestor.AncestorRef).To(gomega.BeEquivalentTo(expectedRef))
-
-			g.Expect(ancestor.Conditions).To(gomega.HaveLen(1), "ancestors conditions wasn't length of 1")
-			cond := meta.FindStatusCondition(ancestor.Conditions, inCondition.Type)
-			g.Expect(cond).NotTo(gomega.BeNil(), "policy should have accepted condition")
-			g.Expect(cond.Status).To(gomega.Equal(inCondition.Status), "policy accepted condition should be true")
-			g.Expect(cond.Reason).To(gomega.Equal(inCondition.Reason), "policy reason should be accepted")
-			g.Expect(cond.Message).To(gomega.Equal(inCondition.Message))
-			g.Expect(cond.ObservedGeneration).To(gomega.Equal(inCondition.ObservedGeneration))
+		expectedAncestorRef := gwv1a2.ParentReference{
+			Group:     (*gwv1.Group)(&svcGroup),
+			Kind:      (*gwv1.Kind)(&svcKind),
+			Namespace: ptr.To(gwv1.Namespace(nginxMeta.Namespace)),
+			Name:      gwv1.ObjectName(nginxMeta.Name),
 		}
+		g.Expect(ancestor.AncestorRef).To(gomega.BeEquivalentTo(expectedAncestorRef))
+
+		g.Expect(ancestor.Conditions).To(gomega.HaveLen(1), "ancestors conditions wasn't length of 1")
+		cond := meta.FindStatusCondition(ancestor.Conditions, inCondition.Type)
+		g.Expect(cond).NotTo(gomega.BeNil(), "policy should have accepted condition")
+		g.Expect(cond.Status).To(gomega.Equal(inCondition.Status), "policy accepted condition should be true")
+		g.Expect(cond.Reason).To(gomega.Equal(inCondition.Reason), "policy reason should be accepted")
+		g.Expect(cond.Message).To(gomega.Equal(inCondition.Message))
+		g.Expect(cond.ObservedGeneration).To(gomega.Equal(inCondition.ObservedGeneration))
 	}, currentTimeout, pollingInterval).Should(gomega.Succeed())
 }
diff --git a/test/kubernetes/e2e/features/cors/suite.go b/test/kubernetes/e2e/features/cors/suite.go
index f8e96e1ef..78a6bd3b5 100644
--- a/test/kubernetes/e2e/features/cors/suite.go
+++ b/test/kubernetes/e2e/features/cors/suite.go
@@ -4,7 +4,6 @@ import (
 	"context"
 	"fmt"
 	"net/http"
-	"testing"
 
 	"github.com/stretchr/testify/suite"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
@@ -99,105 +98,25 @@ func (s *testingSuite) TearDownSuite() {
 }
 
 // Test cors on specific route in a traffic policy
-// The policy has the following allowOrigins:
-// - https://notexample.com
-// - https://a.b.*
-// - https://*.edu
 func (s *testingSuite) TestTrafficPolicyCorsForRoute() {
 	s.setupTest([]string{httpRoutesManifest, routeCorsTrafficPolicyManifest}, []client.Object{route, route2, routeCorsTrafficPolicy})
-
-	testCases := []struct {
-		name   string
-		origin string
-	}{
-		{
-			name:   "exact_match_origin",
-			origin: "https://notexample.com",
-		},
-		{
-			name:   "prefix_match_origin",
-			origin: "https://a.b.c.d",
-		},
-		{
-			name:   "regex_match_origin",
-			origin: "https://test.cors.edu",
-		},
+	requestHeaders := map[string]string{
+		"Origin":                        "https://notexample.com",
+		"Access-Control-Request-Method": "GET",
 	}
 
-	for _, tc := range testCases {
-		s.T().Run(tc.name, func(t *testing.T) {
-			requestHeaders := map[string]string{
-				"Origin":                        tc.origin,
-				"Access-Control-Request-Method": "GET",
-			}
-
-			expectedHeaders := map[string]any{
-				"Access-Control-Allow-Origin":  tc.origin,
-				"Access-Control-Allow-Methods": "GET, POST, DELETE",
-				"Access-Control-Allow-Headers": "x-custom-header",
-			}
-
-			// Verify that the route with cors is responding to the OPTIONS request with the expected cors headers
-			s.assertResponse("/path1", http.StatusOK, requestHeaders, expectedHeaders, []string{})
-
-			// Verify that the route without cors is not affected by the cors traffic policy (i.e. no cors headers are returned)
-			s.assertResponse("/path2", http.StatusOK, requestHeaders, nil, []string{
-				"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
-		})
+	expectedHeaders := map[string]any{
+		"Access-Control-Allow-Origin":  "https://notexample.com",
+		"Access-Control-Allow-Methods": "GET, POST, DELETE",
+		"Access-Control-Allow-Headers": "x-custom-header",
 	}
 
-	// Negative test cases - origins that should NOT match the patterns
-	negativeTestCases := []struct {
-		name   string
-		origin string
-	}{
-		{
-			name:   "wildcard_subdomain_should_not_match_different_domain",
-			origin: "https://notedu.com",
-		},
-		{
-			name:   "wildcard_subdomain_should_not_match_different_tld",
-			origin: "https://api.example.org",
-		},
-		{
-			name:   "wildcard_subdomain_should_not_match_without_subdomain",
-			origin: "https://edu",
-		},
-		{
-			name:   "prefix_match_should_not_match_different_scheme",
-			origin: "http://a.b.c.d",
-		},
-		{
-			name:   "exact_match_should_not_match_similar_domain",
-			origin: "https://notexample.org",
-		},
-		{
-			name:   "exact_match_should_not_match_with_subdomain",
-			origin: "https://api.notexample.com",
-		},
-		{
-			name:   "prefix_match_should_not_match_invalid_url",
-			origin: "https:/a.b",
-		},
-	}
+	// Verify that the route with cors is responding to the OPTIONS request with the expected cors headers
+	s.assertResponse("/path1", http.StatusOK, requestHeaders, expectedHeaders, []string{})
 
-	for _, tc := range negativeTestCases {
-		s.T().Run("negative_"+tc.name, func(t *testing.T) {
-			requestHeaders := map[string]string{
-				"Origin":                        tc.origin,
-				"Access-Control-Request-Method": "GET",
-			}
-
-			// For negative cases, we expect no CORS headers to be returned
-			// since the origin doesn't match any of the allowed patterns
-			s.assertResponse("/path1", http.StatusOK, requestHeaders, nil, []string{
-				"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
-
-			// Verify that the route without cors is also not affected
-			s.assertResponse("/path2", http.StatusOK, requestHeaders, nil, []string{
-				"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
-		})
-	}
+	// Verify that the route without cors is not affected by the cors traffic policy (i.e. no cors headers are returned)
+	s.assertResponse("/path2", http.StatusOK, requestHeaders, nil, []string{
+		"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
 }
 
 // Test cors at the gateway level which configures cors policy in the virtual host and therefore affects all routes
@@ -246,104 +165,26 @@ func (s *testingSuite) TestTrafficPolicyRouteCorsOverrideGwCors() {
 }
 
 // Test cors in route rules of a HTTPRoute
-// The route has the following allowOrigins:
-// - https://notexample.com
-// - https://a.b.*
-// - https://*.edu
 func (s *testingSuite) TestHttpRouteCorsInRouteRules() {
 	s.setupTest([]string{httpRoutesManifest, corsHttpRoutesManifest}, []client.Object{route, route2})
 
-	testCases := []struct {
-		name   string
-		origin string
-	}{
-		{
-			name:   "exact_match_origin",
-			origin: "https://notexample.com",
-		},
-		{
-			name:   "prefix_match_origin",
-			origin: "https://a.b.c.d",
-		},
-		{
-			name:   "regex_match_origin",
-			origin: "https://test.cors.edu",
-		},
+	requestHeaders := map[string]string{
+		"Origin":                        "https://notexample.com",
+		"Access-Control-Request-Method": "GET",
 	}
 
-	for _, tc := range testCases {
-		s.T().Run(tc.name, func(t *testing.T) {
-			requestHeaders := map[string]string{
-				"Origin":                        tc.origin,
-				"Access-Control-Request-Method": "GET",
-			}
-
-			expectedHeaders := map[string]any{
-				"Access-Control-Allow-Origin":  tc.origin,
-				"Access-Control-Allow-Methods": "GET",
-				"Access-Control-Allow-Headers": "x-custom-header",
-			}
-
-			// Verify that the route with cors is responding to the OPTIONS request with the expected cors headers
-			s.assertResponse("/path1", http.StatusOK, requestHeaders, expectedHeaders, []string{})
-
-			// Verify that the route without cors is not affected by the cors in the HTTPRoute (i.e. no cors headers are returned)
-			s.assertResponse("/path2", http.StatusOK, requestHeaders, nil, []string{"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
-		})
+	// HTTPRoute for /path1 should have this cors response headers
+	expectedHeaders := map[string]any{
+		"Access-Control-Allow-Origin":  "https://notexample.com",
+		"Access-Control-Allow-Methods": "GET",
+		"Access-Control-Allow-Headers": "x-custom-header",
 	}
 
-	// Negative test cases - origins that should NOT match the patterns
-	negativeTestCases := []struct {
-		name   string
-		origin string
-	}{
-		{
-			name:   "wildcard_subdomain_should_not_match_different_domain",
-			origin: "https://notedu.com",
-		},
-		{
-			name:   "wildcard_subdomain_should_not_match_different_tld",
-			origin: "https://api.example.org",
-		},
-		{
-			name:   "wildcard_subdomain_should_not_match_without_subdomain",
-			origin: "https://edu",
-		},
-		{
-			name:   "prefix_match_should_not_match_different_scheme",
-			origin: "http://a.b.c.d",
-		},
-		{
-			name:   "exact_match_should_not_match_similar_domain",
-			origin: "https://notexample.org",
-		},
-		{
-			name:   "exact_match_should_not_match_with_subdomain",
-			origin: "https://api.notexample.com",
-		},
-		{
-			name:   "prefix_match_should_not_match_invalid_url",
-			origin: "https:/a.b",
-		},
-	}
+	// Verify that the route with cors is responding to the OPTIONS request with the expected cors headers
+	s.assertResponse("/path1", http.StatusOK, requestHeaders, expectedHeaders, []string{})
 
-	for _, tc := range negativeTestCases {
-		s.T().Run("negative_"+tc.name, func(t *testing.T) {
-			requestHeaders := map[string]string{
-				"Origin":                        tc.origin,
-				"Access-Control-Request-Method": "GET",
-			}
-
-			// For negative cases, we expect no CORS headers to be returned
-			// since the origin doesn't match any of the allowed patterns
-			s.assertResponse("/path1", http.StatusOK, requestHeaders, nil, []string{
-				"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
-
-			// Verify that the route without cors is also not affected
-			s.assertResponse("/path2", http.StatusOK, requestHeaders, nil, []string{
-				"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
-		})
-	}
+	// Verify that the route without cors is not affected by the cors in the HTTPRoute (i.e. no cors headers are returned)
+	s.assertResponse("/path2", http.StatusOK, requestHeaders, nil, []string{"Access-Control-Allow-Origin", "Access-Control-Allow-Methods", "Access-Control-Allow-Headers"})
 }
 
 // Test a combination of cors in route rules of a HTTPRoute and cors in a traffic policy
diff --git a/test/kubernetes/e2e/features/cors/testdata/httproutes-cors.yaml b/test/kubernetes/e2e/features/cors/testdata/httproutes-cors.yaml
index ba2958771..9195cd78a 100644
--- a/test/kubernetes/e2e/features/cors/testdata/httproutes-cors.yaml
+++ b/test/kubernetes/e2e/features/cors/testdata/httproutes-cors.yaml
@@ -19,8 +19,6 @@ spec:
       - cors:
           allowOrigins:
           - https://notexample.com
-          - https://a.b.*
-          - https://*.edu
           allowMethods:
           - GET
           allowHeaders:
diff --git a/test/kubernetes/e2e/features/cors/testdata/tp-route-cors.yaml b/test/kubernetes/e2e/features/cors/testdata/tp-route-cors.yaml
index fc0517abb..ae2468f8c 100644
--- a/test/kubernetes/e2e/features/cors/testdata/tp-route-cors.yaml
+++ b/test/kubernetes/e2e/features/cors/testdata/tp-route-cors.yaml
@@ -10,8 +10,6 @@ spec:
   cors:
     allowOrigins:
       - https://notexample.com
-      - https://a.b.*
-      - https://*.edu
     allowMethods:
       - GET
       - POST
diff --git a/test/kubernetes/e2e/features/directresponse/suite.go b/test/kubernetes/e2e/features/directresponse/suite.go
index 0d9a2355c..377c3473a 100644
--- a/test/kubernetes/e2e/features/directresponse/suite.go
+++ b/test/kubernetes/e2e/features/directresponse/suite.go
@@ -1,3 +1,5 @@
+//go:build ignore
+
 package directresponse
 
 import (
@@ -15,6 +17,7 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/requestutils/curl"
 	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e"
+	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
 	testdefaults "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
 )
 
@@ -43,10 +46,6 @@ func (s *testingSuite) SetupSuite() {
 	err = s.ti.Actions.Kubectl().ApplyFile(s.ctx, testdefaults.CurlPodManifest)
 	s.NoError(err, "can apply curl pod manifest")
 
-	// Apply the gateway manifest once for the entire test suite
-	err = s.ti.Actions.Kubectl().ApplyFile(s.ctx, gatewayManifest)
-	s.NoError(err, "can apply gateway manifest")
-
 	// Check that istio injection is successful and httpbin is running
 	s.ti.Assertions.EventuallyObjectsExist(s.ctx, httpbinDeployment)
 	// httpbin can take a while to start up with Istio sidecar
@@ -57,29 +56,24 @@ func (s *testingSuite) SetupSuite() {
 		LabelSelector: "app.kubernetes.io/name=curl",
 	})
 
-	// Wait for the gateway and proxy to be ready
-	s.ti.Assertions.EventuallyObjectsExist(s.ctx, proxyService, proxyDeployment)
-	s.ti.Assertions.EventuallyPodsRunning(s.ctx, proxyDeployment.ObjectMeta.GetNamespace(), metav1.ListOptions{
-		LabelSelector: "app.kubernetes.io/name=gw",
-	})
-
-	// Only include functional test manifests - negative test cases moved to gateway translator suite
+	// include gateway manifests for the tests, so we recreate it for each test run
 	s.manifests = map[string][]string{
-		"TestBasicDirectResponse": {basicDirectResponseManifests},
-		"TestDelegation":          {basicDelegationManifests},
-		// "TestInvalidDelegationConflictingFilters": {invalidDelegationConflictingFiltersManifests},
-		// "TestInvalidMultipleRouteActions":         {invalidMultipleRouteActionsManifests},
+		"TestBasicDirectResponse":                 {gatewayManifest, basicDirectResposeManifests},
+		"TestDelegation":                          {gatewayManifest, basicDelegationManifests},
+		"TestInvalidDelegationConflictingFilters": {gatewayManifest, invalidDelegationConflictingFiltersManifests},
+		"TestInvalidMissingRef":                   {gatewayManifest, invalidMissingRefManifests},
+		"TestInvalidOverlappingFilters":           {gatewayManifest, invalidOverlappingFiltersManifests},
+		"TestInvalidMultipleRouteActions":         {gatewayManifest, invalidMultipleRouteActionsManifests},
+		"TestInvalidBackendRefFilter":             {gatewayManifest, invalidBackendRefFilterManifests},
 	}
 }
 
 func (s *testingSuite) TearDownSuite() {
-	err := s.ti.Actions.Kubectl().DeleteFileSafe(s.ctx, gatewayManifest)
-	s.NoError(err, "can delete gateway manifest")
-	err = s.ti.Actions.Kubectl().DeleteFileSafe(s.ctx, setupManifest)
+	err := s.ti.Actions.Kubectl().DeleteFileSafe(s.ctx, setupManifest)
 	s.NoError(err, "can delete setup manifest")
 	err = s.ti.Actions.Kubectl().DeleteFileSafe(s.ctx, testdefaults.CurlPodManifest)
 	s.NoError(err, "can delete curl pod manifest")
-	s.ti.Assertions.EventuallyObjectsNotExist(s.ctx, proxyService, proxyDeployment, httpbinDeployment)
+	s.ti.Assertions.EventuallyObjectsNotExist(s.ctx, httpbinDeployment)
 }
 
 func (s *testingSuite) BeforeTest(suiteName, testName string) {
@@ -91,6 +85,13 @@ func (s *testingSuite) BeforeTest(suiteName, testName string) {
 		err := s.ti.Actions.Kubectl().ApplyFile(s.ctx, manifest)
 		s.Assert().NoError(err, "can apply manifest "+manifest)
 	}
+
+	// we recreate the `Gateway` resource (and thus dynamically provision the proxy pod) for each test run
+	// so let's assert the proxy svc and pod is ready before moving on
+	s.ti.Assertions.EventuallyObjectsExist(s.ctx, proxyService, proxyDeployment)
+	s.ti.Assertions.EventuallyPodsRunning(s.ctx, proxyDeployment.ObjectMeta.GetNamespace(), metav1.ListOptions{
+		LabelSelector: "app.kubernetes.io/name=gw",
+	})
 }
 
 func (s *testingSuite) AfterTest(suiteName, testName string) {
@@ -104,16 +105,19 @@ func (s *testingSuite) AfterTest(suiteName, testName string) {
 		s.ti.Assertions.ExpectObjectDeleted(manifest, err, output)
 	}
 
-	s.ti.Assertions.EventuallyObjectTypesNotExist(s.ctx, &gwv1.HTTPRouteList{}, &v1alpha1.DirectResponseList{})
+	// make sure the dynamically provisioned proxy resources are cleaned up
+	s.ti.Assertions.EventuallyObjectsNotExist(s.ctx, proxyService, proxyDeployment)
+	// make sure all the resources created by the tests are cleaned up (we just pass the list types to avoid needing to enumerate each object)
+	s.ti.Assertions.EventuallyObjectTypesNotExist(s.ctx, &gwv1.GatewayList{}, &gwv1.HTTPRouteList{}, &v1alpha1.DirectResponseList{})
 }
 
 func (s *testingSuite) TestBasicDirectResponse() {
 	// verify that a direct response route works as expected
 	s.ti.Assertions.AssertEventualCurlResponse(
 		s.ctx,
-		testdefaults.CurlPodExecOpt,
+		defaults.CurlPodExecOpt,
 		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(proxyObjectMeta)),
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
 			curl.WithHostHeader("www.example.com"),
 			curl.WithPath("/robots.txt"),
 		},
@@ -129,9 +133,9 @@ func (s *testingSuite) TestDelegation() {
 	// verify the regular child route works as expected.
 	s.ti.Assertions.AssertEventualCurlResponse(
 		s.ctx,
-		testdefaults.CurlPodExecOpt,
+		defaults.CurlPodExecOpt,
 		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(proxyObjectMeta)),
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
 			curl.WithHostHeader("www.example.com"),
 			curl.WithPath("/headers"),
 		},
@@ -145,9 +149,9 @@ func (s *testingSuite) TestDelegation() {
 	// verify the parent's DR works as expected.
 	s.ti.Assertions.AssertEventualCurlResponse(
 		s.ctx,
-		testdefaults.CurlPodExecOpt,
+		defaults.CurlPodExecOpt,
 		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(proxyObjectMeta)),
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
 			curl.WithHostHeader("www.example.com"),
 			curl.WithPath("/parent"),
 		},
@@ -161,9 +165,9 @@ func (s *testingSuite) TestDelegation() {
 	// verify that the child's DR works as expected.
 	s.ti.Assertions.AssertEventualCurlResponse(
 		s.ctx,
-		testdefaults.CurlPodExecOpt,
+		defaults.CurlPodExecOpt,
 		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(proxyObjectMeta)),
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
 			curl.WithHostHeader("www.example.com"),
 			curl.WithPath("/child"),
 		},
@@ -175,51 +179,106 @@ func (s *testingSuite) TestDelegation() {
 	)
 }
 
-// TODO: This test is commented out due to conflicting route actions in the parent HTTPRoute.
-// TODO: Re-enable this test once the issue with conflicting filters is resolved or the expected behavior is clarified.
-// TODO: When re-enabling, move this test to the gateway translator suite.
-// func (s *testingSuite) TestInvalidDelegationConflictingFilters() {
-// 	// the parent httproute both 1) specifies a direct response and 2) delegates to another httproute which routes to a service.
-// 	// since these route actions are conflicting, we should get a 500 here
-// 	s.ti.Assertions.AssertEventualCurlResponse(
-// 		s.ctx,
-// 		defaults.CurlPodExecOpt,
-// 		[]curl.Option{
-// 			curl.WithHost(kubeutils.ServiceFQDN(proxyObjectMeta)),
-// 			curl.WithHostHeader("www.example.com"),
-// 			curl.WithPath("/headers"),
-// 		},
-// 		&matchers.HttpResponse{
-// 			StatusCode: http.StatusInternalServerError,
-// 		},
-// 		time.Minute,
-// 	)
-
-// 	// the parent should show an error in its status
-// 	s.ti.Assertions.EventuallyHTTPRouteStatusContainsReason(s.ctx, gwRouteMeta.Name, gwRouteMeta.Namespace,
-// 		string(gwv1.RouteReasonIncompatibleFilters), 10*time.Second, 1*time.Second)
-// }
-
-// TODO: This test is commented out due to conflicting route actions in the parent HTTPRoute.
-// TODO: Re-enable this test once the issue with conflicting filters is resolved or the expected behavior is clarified.
-// TODO: When re-enabling, move this test to the gateway translator suite.
-// func (s *testingSuite) TestInvalidMultipleRouteActions() {
-// 	// the route specifies both a request redirect and a direct response, which is invalid.
-// 	// verify the route was replaced with a 500 direct response due to the
-// 	// invalid configuration.
-// 	s.ti.Assertions.AssertEventualCurlResponse(
-// 		s.ctx,
-// 		defaults.CurlPodExecOpt,
-// 		[]curl.Option{
-// 			curl.WithHost(kubeutils.ServiceFQDN(proxyObjectMeta)),
-// 			curl.WithHostHeader("www.example.com"),
-// 			curl.WithPath("/"),
-// 		},
-// 		&matchers.HttpResponse{
-// 			StatusCode: http.StatusInternalServerError,
-// 		},
-// 		time.Minute,
-// 	)
-// 	s.ti.Assertions.EventuallyHTTPRouteStatusContainsReason(s.ctx, httpbinMeta.Name, httpbinMeta.Namespace,
-// 		string(gwv1.RouteReasonIncompatibleFilters), 10*time.Second, 1*time.Second)
-// }
+func (s *testingSuite) TestInvalidDelegationConflictingFilters() {
+	// the parent httproute both 1) specifies a direct response and 2) delegates to another httproute which routes to a service.
+	// since these route actions are conflicting, we should get a 500 here
+	s.ti.Assertions.AssertEventualCurlResponse(
+		s.ctx,
+		defaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
+			curl.WithHostHeader("www.example.com"),
+			curl.WithPath("/headers"),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusInternalServerError,
+		},
+		time.Minute,
+	)
+
+	// the parent should show an error in its status
+	s.ti.Assertions.EventuallyHTTPRouteStatusContainsReason(s.ctx, gwRouteMeta.Name, gwRouteMeta.Namespace,
+		string(gwv1.RouteReasonIncompatibleFilters), 10*time.Second, 1*time.Second)
+}
+
+func (s *testingSuite) TestInvalidMissingRef() {
+	// the route points to a DR that doesn't exist, so this should error
+	s.ti.Assertions.AssertEventualCurlResponse(
+		s.ctx,
+		defaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
+			curl.WithHostHeader("www.example.com"),
+			curl.WithPath("/non-existent"),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusInternalServerError,
+		},
+		time.Minute,
+	)
+
+	s.ti.Assertions.EventuallyHTTPRouteStatusContainsReason(s.ctx, httpbinMeta.Name, httpbinMeta.Namespace,
+		string(gwv1.RouteReasonBackendNotFound), 10*time.Second, 1*time.Second)
+}
+
+func (s *testingSuite) TestInvalidOverlappingFilters() {
+	// the route specifies 2 different DRs, which is invalid.
+	// verify that the route was replaced with a 500 direct response due to the
+	// invalid configuration.
+	s.ti.Assertions.AssertEventualCurlResponse(
+		s.ctx,
+		defaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
+			curl.WithHostHeader("www.example.com"),
+			curl.WithPath("/"),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusInternalServerError,
+		},
+		time.Minute,
+	)
+
+	s.ti.Assertions.EventuallyHTTPRouteStatusContainsReason(s.ctx, httpbinMeta.Name, httpbinMeta.Namespace,
+		string(gwv1.RouteReasonIncompatibleFilters), 10*time.Second, 1*time.Second)
+}
+
+func (s *testingSuite) TestInvalidMultipleRouteActions() {
+	// the route specifies both a request redirect and a direct response, which is invalid.
+	// verify the route was replaced with a 500 direct response due to the
+	// invalid configuration.
+	s.ti.Assertions.AssertEventualCurlResponse(
+		s.ctx,
+		defaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
+			curl.WithHostHeader("www.example.com"),
+			curl.WithPath("/"),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusInternalServerError,
+		},
+		time.Minute,
+	)
+	s.ti.Assertions.EventuallyHTTPRouteStatusContainsReason(s.ctx, httpbinMeta.Name, httpbinMeta.Namespace,
+		string(gwv1.RouteReasonIncompatibleFilters), 10*time.Second, 1*time.Second)
+}
+
+func (s *testingSuite) TestInvalidBackendRefFilter() {
+	// verify that configuring a DR with a backendRef filter results in a 404 as
+	// this configuration is not supported / ignored by the direct response plugin.
+	s.ti.Assertions.AssertEventualCurlResponse(
+		s.ctx,
+		defaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(glooProxyObjectMeta)),
+			curl.WithHostHeader("www.example.com"),
+			curl.WithPath("/not-implemented"),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusNotFound,
+			Body:       ContainSubstring(`Not Found (go-httpbin does not handle the path /not-implemented)`),
+		},
+		time.Minute,
+	)
+}
diff --git a/test/kubernetes/e2e/features/directresponse/types.go b/test/kubernetes/e2e/features/directresponse/types.go
index 74cf846a3..de76b3eec 100644
--- a/test/kubernetes/e2e/features/directresponse/types.go
+++ b/test/kubernetes/e2e/features/directresponse/types.go
@@ -1,3 +1,5 @@
+//go:build ignore
+
 package directresponse
 
 import (
@@ -6,28 +8,37 @@ import (
 	appsv1 "k8s.io/api/apps/v1"
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/fsutils"
 )
 
 var (
-	setupManifest                = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup.yaml")
-	gatewayManifest              = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gateway.yaml")
-	basicDirectResponseManifests = filepath.Join(fsutils.MustGetThisDir(), "testdata", "basic-direct-response.yaml")
-	basicDelegationManifests     = filepath.Join(fsutils.MustGetThisDir(), "testdata", "basic-delegation-direct-response.yaml")
-	// TODO: Re-enable this test once the issue with conflicting filters is resolved or the expected behavior is clarified.
-	// invalidDelegationConflictingFiltersManifests = filepath.Join(fsutils.MustGetThisDir(), "testdata", "invalid-delegation-conflicting-filters.yaml")
-	// invalidMultipleRouteActionsManifests         = filepath.Join(fsutils.MustGetThisDir(), "testdata", "invalid-multiple-route-actions.yaml")
+	setupManifest                                = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup.yaml")
+	gatewayManifest                              = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gateway.yaml")
+	basicDirectResposeManifests                  = filepath.Join(fsutils.MustGetThisDir(), "testdata", "basic-direct-response.yaml")
+	basicDelegationManifests                     = filepath.Join(fsutils.MustGetThisDir(), "testdata", "basic-delegation-direct-response.yaml")
+	invalidDelegationConflictingFiltersManifests = filepath.Join(fsutils.MustGetThisDir(), "testdata", "invalid-delegation-conflicting-filters.yaml")
+	invalidMissingRefManifests                   = filepath.Join(fsutils.MustGetThisDir(), "testdata", "invalid-missing-ref-direct-response.yaml")
+	invalidOverlappingFiltersManifests           = filepath.Join(fsutils.MustGetThisDir(), "testdata", "invalid-overlapping-filters.yaml")
+	invalidMultipleRouteActionsManifests         = filepath.Join(fsutils.MustGetThisDir(), "testdata", "invalid-multiple-route-actions.yaml")
+	invalidBackendRefFilterManifests             = filepath.Join(fsutils.MustGetThisDir(), "testdata", "invalid-backendRef-filter.yaml")
 
-	proxyObjectMeta = metav1.ObjectMeta{
+	glooProxyObjectMeta = metav1.ObjectMeta{
 		Name:      "gw",
 		Namespace: "default",
 	}
+	gwRouteMeta = metav1.ObjectMeta{
+		Name:      "gateway",
+		Namespace: "default",
+	}
 	httpbinMeta = metav1.ObjectMeta{
 		Name:      "httpbin",
 		Namespace: "httpbin",
 	}
-	proxyDeployment   = &appsv1.Deployment{ObjectMeta: proxyObjectMeta}
-	proxyService      = &corev1.Service{ObjectMeta: proxyObjectMeta}
+	proxyDeployment   = &appsv1.Deployment{ObjectMeta: glooProxyObjectMeta}
+	proxyService      = &corev1.Service{ObjectMeta: glooProxyObjectMeta}
 	httpbinDeployment = &appsv1.Deployment{ObjectMeta: httpbinMeta}
+
+	gwRoute = &gwv1.HTTPRoute{ObjectMeta: gwRouteMeta}
 )
diff --git a/test/kubernetes/e2e/features/extproc/suite.go b/test/kubernetes/e2e/features/extproc/suite.go
index e81406a37..384833852 100644
--- a/test/kubernetes/e2e/features/extproc/suite.go
+++ b/test/kubernetes/e2e/features/extproc/suite.go
@@ -104,58 +104,58 @@ func (s *testingSuite) TearDownTest() {
 	}
 }
 
-// TestExtProcWithGatewayTargetRef tests ExtProc with targetRef to Gateway
-func (s *testingSuite) TestExtProcWithGatewayTargetRef() {
-	s.activeManifests = []string{gatewayTargetRefManifest}
-	err := s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, gatewayTargetRefManifest)
-	s.Require().NoError(err)
-
-	// Test that ExtProc is applied to all routes through the Gateway
-	// First route - should have ExtProc applied
-	s.testInstallation.Assertions.AssertEventualCurlResponse(
-		s.ctx,
-		testdefaults.CurlPodExecOpt,
-		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(gatewayService.ObjectMeta)),
-			curl.VerboseOutput(),
-			curl.WithHostHeader("www.example.com"),
-			curl.WithPort(8080),
-			curl.WithHeader("instructions", getInstructionsJson(instructions{
-				AddHeaders: map[string]string{"extproctest": "true"},
-			})),
-		},
-		&testmatchers.HttpResponse{
-			StatusCode: http.StatusOK,
-			Body: gomega.WithTransform(transforms.WithJsonBody(),
-				gomega.And(
-					gomega.HaveKeyWithValue("headers", gomega.HaveKey("Extproctest")),
-				),
-			),
-		})
-
-	// Second route - should also have ExtProc applied
-	s.testInstallation.Assertions.AssertEventualCurlResponse(
-		s.ctx,
-		testdefaults.CurlPodExecOpt,
-		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(gatewayService.ObjectMeta)),
-			curl.VerboseOutput(),
-			curl.WithHostHeader("www.example.com"),
-			curl.WithPath("/myapp"),
-			curl.WithPort(8080),
-			curl.WithHeader("instructions", getInstructionsJson(instructions{
-				AddHeaders: map[string]string{"extproctest": "true"},
-			})),
-		},
-		&testmatchers.HttpResponse{
-			StatusCode: http.StatusOK,
-			Body: gomega.WithTransform(transforms.WithJsonBody(),
-				gomega.And(
-					gomega.HaveKeyWithValue("headers", gomega.HaveKey("Extproctest")),
-				),
-			),
-		})
-}
+// // TestExtProcWithGatewayTargetRef tests ExtProc with targetRef to Gateway
+// func (s *testingSuite) TestExtProcWithGatewayTargetRef() {
+// 	s.activeManifests = []string{gatewayTargetRefManifest}
+// 	err := s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, gatewayTargetRefManifest)
+// 	s.Require().NoError(err)
+
+// 	// Test that ExtProc is applied to all routes through the Gateway
+// 	// First route - should have ExtProc applied
+// 	s.testInstallation.Assertions.AssertEventualCurlResponse(
+// 		s.ctx,
+// 		testdefaults.CurlPodExecOpt,
+// 		[]curl.Option{
+// 			curl.WithHost(kubeutils.ServiceFQDN(gatewayService.ObjectMeta)),
+// 			curl.VerboseOutput(),
+// 			curl.WithHostHeader("www.example.com"),
+// 			curl.WithPort(8080),
+// 			curl.WithHeader("instructions", getInstructionsJson(instructions{
+// 				AddHeaders: map[string]string{"extproctest": "true"},
+// 			})),
+// 		},
+// 		&testmatchers.HttpResponse{
+// 			StatusCode: http.StatusOK,
+// 			Body: gomega.WithTransform(transforms.WithJsonBody(),
+// 				gomega.And(
+// 					gomega.HaveKeyWithValue("headers", gomega.HaveKey("Extproctest")),
+// 				),
+// 			),
+// 		})
+
+// 	// Second route - should also have ExtProc applied
+// 	s.testInstallation.Assertions.AssertEventualCurlResponse(
+// 		s.ctx,
+// 		testdefaults.CurlPodExecOpt,
+// 		[]curl.Option{
+// 			curl.WithHost(kubeutils.ServiceFQDN(gatewayService.ObjectMeta)),
+// 			curl.VerboseOutput(),
+// 			curl.WithHostHeader("www.example.com"),
+// 			curl.WithPath("/myapp"),
+// 			curl.WithPort(8080),
+// 			curl.WithHeader("instructions", getInstructionsJson(instructions{
+// 				AddHeaders: map[string]string{"extproctest": "true"},
+// 			})),
+// 		},
+// 		&testmatchers.HttpResponse{
+// 			StatusCode: http.StatusOK,
+// 			Body: gomega.WithTransform(transforms.WithJsonBody(),
+// 				gomega.And(
+// 					gomega.HaveKeyWithValue("headers", gomega.HaveKey("Extproctest")),
+// 				),
+// 			),
+// 		})
+// }
 
 // TestExtProcWithHTTPRouteTargetRef tests ExtProc with targetRef to HTTPRoute
 func (s *testingSuite) TestExtProcWithHTTPRouteTargetRef() {
diff --git a/test/kubernetes/e2e/features/extproc/types.go b/test/kubernetes/e2e/features/extproc/types.go
index 6f41c56d7..43f61e3a9 100644
--- a/test/kubernetes/e2e/features/extproc/types.go
+++ b/test/kubernetes/e2e/features/extproc/types.go
@@ -12,8 +12,8 @@ import (
 
 var (
 	// manifests
-	setupManifest              = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup.yaml")
-	gatewayTargetRefManifest   = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gateway-targetref.yaml")
+	setupManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup.yaml")
+	// gatewayTargetRefManifest   = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gateway-targetref.yaml")
 	httpRouteTargetRefManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "httproute-targetref.yaml")
 	singleRouteManifest        = filepath.Join(fsutils.MustGetThisDir(), "testdata", "single-route.yaml")
 	backendFilterManifest      = filepath.Join(fsutils.MustGetThisDir(), "testdata", "backend-filter.yaml")
diff --git a/test/kubernetes/e2e/features/path_matching/suite.go b/test/kubernetes/e2e/features/path_matching/suite.go
deleted file mode 100644
index 44f1251d9..000000000
--- a/test/kubernetes/e2e/features/path_matching/suite.go
+++ /dev/null
@@ -1,166 +0,0 @@
-package path_matching
-
-import (
-	"context"
-	"net/http"
-
-	"github.com/stretchr/testify/suite"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/kubeutils"
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/requestutils/curl"
-	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/tests/base"
-)
-
-var _ e2e.NewSuiteFunc = NewTestingSuite
-
-type testingSuite struct {
-	*base.BaseTestingSuite
-}
-
-func NewTestingSuite(ctx context.Context, testInst *e2e.TestInstallation) suite.TestingSuite {
-	return &testingSuite{
-		base.NewBaseTestingSuite(ctx, testInst, setup, testCases),
-	}
-}
-
-// BeforeTest runs before each test in the suite
-func (s *testingSuite) BeforeTest(suiteName, testName string) {
-	s.BaseTestingSuite.BeforeTest(suiteName, testName)
-
-	s.TestInstallation.Assertions.EventuallyHTTPRouteCondition(s.Ctx, "httpbin", "httpbin", gwv1.RouteConditionAccepted, metav1.ConditionTrue)
-}
-
-// TestExactMatch tests an HTTPRoute with a path match of type Exact
-func (s *testingSuite) TestExactMatch() {
-	// expected path works
-	s.assertStatus("anything/justme", http.StatusOK)
-
-	// all other paths do not
-	s.assertStatus("anything/nope", http.StatusNotFound)
-
-	s.assertStatus("anything/justmea", http.StatusNotFound)
-	s.assertStatus("anything/justm", http.StatusNotFound)
-	s.assertStatus("anything/justma", http.StatusNotFound)
-	s.assertStatus("anything/ajustme", http.StatusNotFound)
-	s.assertStatus("anything/ustme", http.StatusNotFound)
-	s.assertStatus("anything/austme", http.StatusNotFound)
-
-	s.assertStatus("anything/justme/", http.StatusNotFound)
-	s.assertStatus("anything/justme/nope", http.StatusNotFound)
-	s.assertStatus("anything/nope/justme", http.StatusNotFound)
-}
-
-// TestPrefixMatch tests an HTTPRoute with a path match of type PathPrefix
-func (s *testingSuite) TestPrefixMatch() {
-	// prefix path works
-	s.assertStatus("anything/pre", http.StatusOK)
-
-	// additional characters including or after a slash work
-	s.assertStatus("anything/pre/", http.StatusOK)
-	s.assertStatus("anything/pre/plus", http.StatusOK)
-	s.assertStatus("anything/pre/plus/more", http.StatusOK)
-
-	// all other paths do not
-	s.assertStatus("anything/nope", http.StatusNotFound)
-
-	s.assertStatus("anything/prea", http.StatusNotFound)
-	s.assertStatus("anything/pr", http.StatusNotFound)
-	s.assertStatus("anything/pra", http.StatusNotFound)
-	s.assertStatus("anything/apre", http.StatusNotFound)
-	s.assertStatus("anything/re", http.StatusNotFound)
-	s.assertStatus("anything/are", http.StatusNotFound)
-
-	s.assertStatus("anything/nope/pre", http.StatusNotFound)
-}
-
-// TestRegexMatch tests an HTTPRoute with a path match of type RegularExpression
-// regex: /anything/plus/(this|that)/[^/]+?/\d[.]/(1.)/(.+)/end
-func (s *testingSuite) TestRegexMatch() {
-	// paths matching regex work
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/stuff/end", http.StatusOK)
-	s.assertStatus("anything/plus/that/what3v3r/4./1a/stuff/end", http.StatusOK)
-	s.assertStatus("anything/plus/this/!@$*&().a-b_c~'+4,;0=:sdf/4./1a/stuff/end", http.StatusOK) // unusual chars
-	s.assertStatus("anything/plus/this/what3v3r/0./1a/stuff/end", http.StatusOK)
-	s.assertStatus("anything/plus/this/what3v3r/4./15/stuff/end", http.StatusOK)
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/plus/more/stuff/end", http.StatusOK) // additional path elements where permitted
-
-	// all other paths do not
-	s.assertStatus("anything/this/what3v3r/4./1a/stuff/end", http.StatusNotFound)     // missing early path element
-	s.assertStatus("anything/plus/this/what3v3r4./1a/stuff/end", http.StatusNotFound) // merging path elements
-	s.assertStatus("anything/plus/this/what3v3r/4.1a/stuff/end", http.StatusNotFound) // merging path elements
-	s.assertStatus("anything/plus/this/what3v3r/4./1astuff/end", http.StatusNotFound) // merging path elements
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/stuffend", http.StatusNotFound) // merging path elements
-
-	s.assertStatus("anything/plus/thus/what3v3r/4./1a/stuff/end", http.StatusNotFound)        // not this or that
-	s.assertStatus("anything/plus/this|that/what3v3r/4./1a/stuff/end", http.StatusNotFound)   // literal this or that
-	s.assertStatus("anything/plus/(this|that)/what3v3r/4./1a/stuff/end", http.StatusNotFound) // literal this or that
-	s.assertStatus("anything/plus//what3v3r/4./1a/stuff/end", http.StatusNotFound)            // missing this or that
-	s.assertStatus("anything/plus/what3v3r/4./1a/stuff/end", http.StatusNotFound)             // missing this or that
-
-	s.assertStatus("anything/plus/this/what/3v3r/4./1a/stuff/end", http.StatusNotFound) // 2 path elements where 1 is expected
-	s.assertStatus("anything/plus/this//4./1a/stuff/end", http.StatusNotFound)          // 0 path elements where 1 is expected
-	s.assertStatus("anything/plus/this/4./1a/stuff/end", http.StatusNotFound)           // 0 path elements where 1 is expected
-
-	s.assertStatus("anything/plus/this/what3v3r/12./1a/stuff/end", http.StatusNotFound) // 2 digits where 1 is expected
-	s.assertStatus("anything/plus/this/what3v3r/./1a/stuff/end", http.StatusNotFound)   // 0 digits where 1 is expected
-	s.assertStatus("anything/plus/this/what3v3r/a./1a/stuff/end", http.StatusNotFound)  // letter where digit is expected
-	s.assertStatus("anything/plus/this/what3v3r/4../1a/stuff/end", http.StatusNotFound) // 2 dots where 1 is expected
-	s.assertStatus("anything/plus/this/what3v3r/4/1a/stuff/end", http.StatusNotFound)   // 0 dots where 1 is expected
-	s.assertStatus("anything/plus/this/what3v3r/4a/1a/stuff/end", http.StatusNotFound)  // letter where dot is expected
-	s.assertStatus("anything/plus/this/what3v3r/a4./1a/stuff/end", http.StatusNotFound) // extra char
-	s.assertStatus("anything/plus/this/what3v3r/4.a/1a/stuff/end", http.StatusNotFound) // extra char
-
-	s.assertStatus("anything/plus/this/what3v3r/4./11a/stuff/end", http.StatusNotFound) // 2 '1's where 1 is expected
-	s.assertStatus("anything/plus/this/what3v3r/4./a/stuff/end", http.StatusNotFound)   // 0 '1's where 1 is expected
-	s.assertStatus("anything/plus/this/what3v3r/4./0a/stuff/end", http.StatusNotFound)  // 0 where '1' is expected
-	s.assertStatus("anything/plus/this/what3v3r/4./1/stuff/end", http.StatusNotFound)   // missing char
-	s.assertStatus("anything/plus/this/what3v3r/4./1ab/stuff/end", http.StatusNotFound) // extra char
-
-	s.assertStatus("anything/plus/this/what3v3r/4./1a//end", http.StatusNotFound) // missing path element content where expected
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/end", http.StatusNotFound)  // missing path element where expected
-
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/stuff/en", http.StatusNotFound)       // missing char
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/stuff/nd", http.StatusNotFound)       // missing char
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/stuff/ends", http.StatusNotFound)     // extra char
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/stuff/end/", http.StatusNotFound)     // extra slash
-	s.assertStatus("anything/plus/this/what3v3r/4./1a/stuff/end/more", http.StatusNotFound) // extra path element
-}
-
-// TestPrefixRewrite tests an HTTPRoute with a path match of type PathPrefix
-// which also uses the URLRewrite filter to drop that prefix
-func (s *testingSuite) TestPrefixRewrite() {
-	// paths matching prefix drop it and work
-	s.assertStatus("el360/bi/v1/anything", http.StatusOK)
-	s.assertStatus("el360/bi/v1/status/200", http.StatusOK)
-	s.assertStatus("el360/bi/v1/status/418", http.StatusTeapot)
-
-	// all other paths do not work
-	s.assertStatus("el360/bi/v1anything/whatever", http.StatusNotFound)
-	s.assertStatus("el360/bi/anything/whatever", http.StatusNotFound)
-	s.assertStatus("l360/bi/v1/anything/whatever", http.StatusNotFound)
-	s.assertStatus("bi/v1/anything/whatever", http.StatusNotFound)
-	s.assertStatus("anything/whatever", http.StatusNotFound)
-	s.assertStatus("status/200", http.StatusNotFound)
-	s.assertStatus("anything/el360/bi/v1/anything/whatever", http.StatusNotFound)
-}
-
-func (s *testingSuite) assertStatus(path string, status int) {
-	s.TestInstallation.Assertions.AssertEventualCurlResponse(
-		s.Ctx,
-		defaults.CurlPodExecOpt,
-		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(gatewayService.ObjectMeta)),
-			curl.WithHostHeader("www.example.com"),
-			curl.WithPort(8080),
-			curl.WithPath(path),
-		},
-		&matchers.HttpResponse{
-			StatusCode: status,
-		},
-	)
-}
diff --git a/test/kubernetes/e2e/features/path_matching/testdata/exact.yaml b/test/kubernetes/e2e/features/path_matching/testdata/exact.yaml
deleted file mode 100644
index 25fed74a0..000000000
--- a/test/kubernetes/e2e/features/path_matching/testdata/exact.yaml
+++ /dev/null
@@ -1,21 +0,0 @@
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: httpbin
-  namespace: httpbin
-  labels:
-    example: httpbin-route
-spec:
-  parentRefs:
-    - name: gw
-      namespace: default
-  hostnames:
-    - "www.example.com"
-  rules:
-    - backendRefs:
-        - name: httpbin
-          port: 8000
-      matches:
-        - path:
-            type: Exact
-            value: /anything/justme
\ No newline at end of file
diff --git a/test/kubernetes/e2e/features/path_matching/testdata/prefix-rewrite.yaml b/test/kubernetes/e2e/features/path_matching/testdata/prefix-rewrite.yaml
deleted file mode 100644
index 659249d1a..000000000
--- a/test/kubernetes/e2e/features/path_matching/testdata/prefix-rewrite.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: httpbin
-  namespace: httpbin
-  labels:
-    example: httpbin-route
-spec:
-  parentRefs:
-    - name: gw
-      namespace: default
-  hostnames:
-    - "www.example.com"
-  rules:
-    - backendRefs:
-        - name: httpbin
-          port: 8000
-      matches:
-        - path:
-            type: PathPrefix
-            value: /el360/bi/v1/
-      filters:
-        - type: URLRewrite
-          urlRewrite:
-            path:
-              type: ReplacePrefixMatch
-              replacePrefixMatch: /
\ No newline at end of file
diff --git a/test/kubernetes/e2e/features/path_matching/testdata/prefix.yaml b/test/kubernetes/e2e/features/path_matching/testdata/prefix.yaml
deleted file mode 100644
index e008e3602..000000000
--- a/test/kubernetes/e2e/features/path_matching/testdata/prefix.yaml
+++ /dev/null
@@ -1,21 +0,0 @@
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: httpbin
-  namespace: httpbin
-  labels:
-    example: httpbin-route
-spec:
-  parentRefs:
-    - name: gw
-      namespace: default
-  hostnames:
-    - "www.example.com"
-  rules:
-    - backendRefs:
-        - name: httpbin
-          port: 8000
-      matches:
-        - path:
-            type: PathPrefix
-            value: /anything/pre
\ No newline at end of file
diff --git a/test/kubernetes/e2e/features/path_matching/testdata/regex.yaml b/test/kubernetes/e2e/features/path_matching/testdata/regex.yaml
deleted file mode 100644
index ed810a86d..000000000
--- a/test/kubernetes/e2e/features/path_matching/testdata/regex.yaml
+++ /dev/null
@@ -1,21 +0,0 @@
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: httpbin
-  namespace: httpbin
-  labels:
-    example: httpbin-route
-spec:
-  parentRefs:
-    - name: gw
-      namespace: default
-  hostnames:
-    - "www.example.com"
-  rules:
-    - backendRefs:
-        - name: httpbin
-          port: 8000
-      matches:
-        - path:
-            type: RegularExpression
-            value: /anything/plus/(this|that)/[^/]+?/\d[.]/(1.)/(.+)/end
\ No newline at end of file
diff --git a/test/kubernetes/e2e/features/path_matching/testdata/setup.yaml b/test/kubernetes/e2e/features/path_matching/testdata/setup.yaml
deleted file mode 100644
index 11560095c..000000000
--- a/test/kubernetes/e2e/features/path_matching/testdata/setup.yaml
+++ /dev/null
@@ -1,78 +0,0 @@
-apiVersion: v1
-kind: Namespace
-metadata:
-  name: httpbin
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  name: httpbin
-  namespace: httpbin
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: httpbin
-  namespace: httpbin
-  labels:
-    app: httpbin
-    service: httpbin
-spec:
-  ports:
-    - name: http
-      port: 8000
-      targetPort: 8080
-    - name: tcp
-      port: 9000
-  selector:
-    app: httpbin
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  name: httpbin
-  namespace: httpbin
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: httpbin
-      version: v1
-  template:
-    metadata:
-      labels:
-        app: httpbin
-        version: v1
-    spec:
-      serviceAccountName: httpbin
-      containers:
-        - image: docker.io/mccutchen/go-httpbin:v2.6.0
-          imagePullPolicy: IfNotPresent
-          name: httpbin
-          command: [ go-httpbin ]
-          args:
-            - "-port"
-            - "8080"
-            - "-max-duration"
-            - "600s" # override default 10s
-          ports:
-            - containerPort: 8080
-          resources:
-            requests:
-              cpu: "100m"
-            limits:
-              cpu: "200m"
----
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: gw
-spec:
-  gatewayClassName: kgateway
-  listeners:
-    - protocol: HTTP
-      port: 8080
-      name: http
-      allowedRoutes:
-        namespaces:
-          from: All
\ No newline at end of file
diff --git a/test/kubernetes/e2e/features/path_matching/types.go b/test/kubernetes/e2e/features/path_matching/types.go
deleted file mode 100644
index 1983d2c9e..000000000
--- a/test/kubernetes/e2e/features/path_matching/types.go
+++ /dev/null
@@ -1,78 +0,0 @@
-package path_matching
-
-import (
-	"path/filepath"
-
-	appsv1 "k8s.io/api/apps/v1"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"sigs.k8s.io/controller-runtime/pkg/client"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/fsutils"
-	e2edefaults "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/tests/base"
-)
-
-var (
-	// manifests
-	setupManifest         = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup.yaml")
-	exactManifest         = filepath.Join(fsutils.MustGetThisDir(), "testdata", "exact.yaml")
-	prefixManifest        = filepath.Join(fsutils.MustGetThisDir(), "testdata", "prefix.yaml")
-	regexManifest         = filepath.Join(fsutils.MustGetThisDir(), "testdata", "regex.yaml")
-	prefixRewriteManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "prefix-rewrite.yaml")
-
-	// Core infrastructure objects that we need to track
-	gatewayObjectMeta = metav1.ObjectMeta{
-		Name:      "gw",
-		Namespace: "default",
-	}
-	gatewayService    = &corev1.Service{ObjectMeta: gatewayObjectMeta}
-	gatewayDeployment = &appsv1.Deployment{ObjectMeta: gatewayObjectMeta}
-
-	httpbinObjectMeta = metav1.ObjectMeta{
-		Name:      "httpbin",
-		Namespace: "httpbin",
-	}
-	httpbinDeployment = &appsv1.Deployment{ObjectMeta: httpbinObjectMeta}
-
-	route = &gwv1.HTTPRoute{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "httpbin",
-			Namespace: "httpbin",
-		},
-	}
-
-	setup = base.SimpleTestCase{
-		Manifests: []string{e2edefaults.CurlPodManifest, setupManifest},
-		Resources: []client.Object{e2edefaults.CurlPod, httpbinDeployment, gatewayService, gatewayDeployment},
-	}
-
-	// test cases
-	testCases = map[string]*base.TestCase{
-		"TestExactMatch": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{exactManifest},
-				Resources: []client.Object{route},
-			},
-		},
-		"TestPrefixMatch": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{prefixManifest},
-				Resources: []client.Object{route},
-			},
-		},
-		"TestRegexMatch": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{regexManifest},
-				Resources: []client.Object{route},
-			},
-		},
-		"TestPrefixRewrite": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{prefixRewriteManifest},
-				Resources: []client.Object{route},
-			},
-		},
-	}
-)
diff --git a/test/kubernetes/e2e/features/policyselector/suite.go b/test/kubernetes/e2e/features/policyselector/suite.go
index 99c5cd484..73f9feaa5 100644
--- a/test/kubernetes/e2e/features/policyselector/suite.go
+++ b/test/kubernetes/e2e/features/policyselector/suite.go
@@ -1,17 +1,13 @@
 package policyselector
 
 import (
-	"bytes"
 	"context"
 	"fmt"
 	"net/http"
-	"os"
-	"strings"
 	"time"
 
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/suite"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/requestutils/curl"
@@ -31,53 +27,36 @@ type tsuite struct {
 	ti *e2e.TestInstallation
 
 	// maps test name to a list of manifests to apply before the test
-	commonManifests []string
-	testManifests   map[string][]string
+	manifests map[string][]string
 
 	manifestObjects map[string][]client.Object
 }
 
 func NewTestingSuite(ctx context.Context, testInst *e2e.TestInstallation) suite.TestingSuite {
 	return &tsuite{
-		ctx:             ctx,
-		ti:              testInst,
-		commonManifests: []string{labelSelectorManifest, defaults.CurlPodManifest, defaults.HttpbinManifest},
-		testManifests:   map[string][]string{},
+		ctx: ctx,
+		ti:  testInst,
 	}
 }
 
 func (s *tsuite) SetupSuite() {
-	for _, manifest := range s.commonManifests {
-		content, err := os.ReadFile(manifest)
-		s.Require().NoError(err, manifest)
-		yamlStr := strings.ReplaceAll(string(content), "$INSTALL_NAMESPACE", s.ti.Metadata.InstallNamespace)
-
-		out := new(bytes.Buffer)
-		err = s.ti.Actions.Kubectl().WithReceiver(out).Apply(s.T().Context(), []byte(yamlStr))
-		s.Require().NoErrorf(err, "manifest %s, out: %s", manifest, out.String())
+	s.manifests = map[string][]string{
+		"TestLabelSelector": {labelSelectorManifest, defaults.CurlPodManifest},
+	}
+	// Not every resource that is applied needs to be verified. We are not testing `kubectl apply`,
+	// but the below code demonstrates how it can be done if necessary
+	s.manifestObjects = map[string][]client.Object{
+		labelSelectorManifest:    {gateway, httpbinRoute, httpbinDeployment},
+		defaults.CurlPodManifest: {defaults.CurlPod},
 	}
-
-	s.ti.Assertions.EventuallyPodsRunning(s.ctx, defaults.CurlPod.Namespace, metav1.ListOptions{
-		LabelSelector: defaults.CurlPodLabelSelector,
-	})
-	s.ti.Assertions.EventuallyPodsRunning(s.ctx, defaults.HttpbinPod.Namespace, metav1.ListOptions{
-		LabelSelector: defaults.HttpbinLabelSelector,
-	})
-	s.ti.Assertions.EventuallyPodsRunning(s.ctx, gateway.Namespace, metav1.ListOptions{
-		LabelSelector: defaults.WellKnownAppLabel + "=" + gateway.Name,
-	})
 }
 
 func (s *tsuite) TearDownSuite() {
-	for i := len(s.commonManifests) - 1; i >= 0; i-- {
-		manifest := s.commonManifests[i]
-		err := s.ti.Actions.Kubectl().DeleteFileSafe(s.ctx, manifest)
-		s.NoError(err, manifest)
-	}
 }
 
 func (s *tsuite) BeforeTest(suiteName, testName string) {
-	for _, manifest := range s.testManifests[testName] {
+	manifests := s.manifests[testName]
+	for _, manifest := range manifests {
 		err := s.ti.Actions.Kubectl().ApplyFile(s.ctx, manifest)
 		s.Require().NoError(err)
 		s.ti.Assertions.EventuallyObjectsExist(s.ctx, s.manifestObjects[manifest]...)
@@ -85,9 +64,10 @@ func (s *tsuite) BeforeTest(suiteName, testName string) {
 }
 
 func (s *tsuite) AfterTest(suiteName, testName string) {
-	for _, manifest := range s.testManifests[testName] {
+	manifests := s.manifests[testName]
+	for _, manifest := range manifests {
 		err := s.ti.Actions.Kubectl().DeleteFileSafe(s.ctx, manifest)
-		s.NoError(err)
+		s.Require().NoError(err)
 		s.ti.Assertions.EventuallyObjectsNotExist(s.ctx, s.manifestObjects[manifest]...)
 	}
 }
@@ -115,24 +95,3 @@ func (s *tsuite) TestLabelSelector() {
 		assert.Contains(c, logs, `"backendCluster":"kube_default_httpbin_8000"`)
 	}, 5*time.Second, 100*time.Millisecond)
 }
-
-func (s *tsuite) TestGlobalPolicy() {
-	requestHeaders := map[string]string{
-		"Origin":                        "https://example.com",
-		"Access-Control-Request-Method": "GET",
-	}
-	wantResponseHeaders := map[string]any{
-		"Access-Control-Allow-Origin":  "https://example.com",
-		"Access-Control-Allow-Methods": "GET, POST, DELETE",
-		"Access-Control-Allow-Headers": "x-custom-header",
-	}
-
-	// Verify cors policy defined in Settings.GlobalPolicyNamespace (kgateway-system) is applied
-	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt,
-		[]curl.Option{curl.WithHostPort(proxyHostPort), curl.WithPath("/get"), curl.WithHeaders(requestHeaders), curl.WithMethod(http.MethodOptions)},
-		&testmatchers.HttpResponse{
-			StatusCode: http.StatusOK,
-			Headers:    wantResponseHeaders,
-		},
-	)
-}
diff --git a/test/kubernetes/e2e/features/policyselector/testdata/label_selector.yaml b/test/kubernetes/e2e/features/policyselector/testdata/label_selector.yaml
index 84b5efe0f..6bc1f1a91 100644
--- a/test/kubernetes/e2e/features/policyselector/testdata/label_selector.yaml
+++ b/test/kubernetes/e2e/features/policyselector/testdata/label_selector.yaml
@@ -43,7 +43,7 @@ spec:
           request_id: "%REQ(X-REQUEST-ID)%"
           authority: "%REQ(:AUTHORITY)%"
           backendHost: "%UPSTREAM_HOST%"
-          backendCluster: "%UPSTREAM_CLUSTER%"
+          backendCluster: "%UPSTREAM_CLUSTER%"        
 ---
 apiVersion: gateway.networking.k8s.io/v1
 kind: HTTPRoute
@@ -51,7 +51,6 @@ metadata:
   name: httpbin
   labels:
     route: httpbin-app
-    global-policy: cors
 spec:
   parentRefs:
   - name: http-gw
@@ -74,25 +73,54 @@ spec:
     response:
       add:
       - name: x-foo
-        value: bar
+        value: bar        
 ---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: TrafficPolicy
+apiVersion: v1
+kind: Service
 metadata:
-  name: global-cors
-  namespace: $INSTALL_NAMESPACE
+  name: httpbin
+  labels:
+    app: httpbin
 spec:
-  targetSelectors:
-  - group: gateway.networking.k8s.io
-    kind: HTTPRoute
+  ports:
+  - name: http
+    port: 8000
+    targetPort: 8080
+  selector:
+    app: httpbin
+---
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: httpbin
+spec:
+  replicas: 1
+  selector:
     matchLabels:
-      global-policy: cors
-  cors:
-    allowOrigins:
-      - https://example.com
-    allowMethods:
-      - GET
-      - POST
-      - DELETE
-    allowHeaders:
-      - x-custom-header
\ No newline at end of file
+      app: httpbin
+      version: v1
+  template:
+    metadata:
+      labels:
+        app: httpbin
+        version: v1
+    spec:
+      containers:
+      - image: docker.io/kennethreitz/httpbin
+        imagePullPolicy: IfNotPresent
+        name: httpbin
+        command:
+        - gunicorn
+        - -b
+        - 0.0.0.0:8080
+        - httpbin:app
+        - -k
+        - gevent
+        env:
+        # Tells pipenv to use a writable directory instead of $HOME
+        - name: WORKON_HOME
+          value: /tmp
+        ports:
+        - containerPort: 8080
+---
+
diff --git a/test/kubernetes/e2e/features/policyselector/types.go b/test/kubernetes/e2e/features/policyselector/types.go
index 02b829cd5..30d60daa5 100644
--- a/test/kubernetes/e2e/features/policyselector/types.go
+++ b/test/kubernetes/e2e/features/policyselector/types.go
@@ -4,6 +4,7 @@ import (
 	"fmt"
 	"path/filepath"
 
+	appsv1 "k8s.io/api/apps/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
@@ -25,4 +26,18 @@ var (
 			Namespace: "default",
 		},
 	}
+
+	httpbinRoute = &gwv1.HTTPRoute{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      "httpbin",
+			Namespace: "default",
+		},
+	}
+
+	httpbinDeployment = &appsv1.Deployment{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      "httpbin",
+			Namespace: "default",
+		},
+	}
 )
diff --git a/test/kubernetes/e2e/features/route_delegation/suite.go b/test/kubernetes/e2e/features/route_delegation/suite.go
index 8308340a8..8e1d39381 100644
--- a/test/kubernetes/e2e/features/route_delegation/suite.go
+++ b/test/kubernetes/e2e/features/route_delegation/suite.go
@@ -165,9 +165,9 @@ func (s *tsuite) TestCyclic() {
 	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt, []curl.Option{curl.WithHostPort(proxyHostPort), curl.WithPath(pathTeam1)},
 		&testmatchers.HttpResponse{StatusCode: http.StatusOK, Body: ContainSubstring(pathTeam1)})
 
-	// Assert traffic to team2 route fails with HTTP 500 as it is a cyclic route
+	// Assert traffic to team2 route fails with HTTP 404 as it is a cyclic route
 	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt, []curl.Option{curl.WithHostPort(proxyHostPort), curl.WithPath(pathTeam2)},
-		&testmatchers.HttpResponse{StatusCode: http.StatusInternalServerError})
+		&testmatchers.HttpResponse{StatusCode: http.StatusNotFound})
 
 	s.ti.Assertions.EventuallyHTTPRouteStatusContainsMessage(s.ctx, routeTeam2.Name, routeTeam2.Namespace,
 		"cyclic reference detected", 10*time.Second, 1*time.Second)
@@ -178,9 +178,9 @@ func (s *tsuite) TestInvalidChild() {
 	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt, []curl.Option{curl.WithHostPort(proxyHostPort), curl.WithPath(pathTeam1)},
 		&testmatchers.HttpResponse{StatusCode: http.StatusOK, Body: ContainSubstring(pathTeam1)})
 
-	// Assert traffic to team2 route fails with HTTP 500 as the route is invalid due to specifying a hostname on the child route
+	// Assert traffic to team2 route fails with HTTP 404 as the route is invalid due to specifying a hostname on the child route
 	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt, []curl.Option{curl.WithHostPort(proxyHostPort), curl.WithPath(pathTeam2)},
-		&testmatchers.HttpResponse{StatusCode: http.StatusInternalServerError})
+		&testmatchers.HttpResponse{StatusCode: http.StatusNotFound})
 
 	s.ti.Assertions.EventuallyHTTPRouteStatusContainsMessage(s.ctx, routeTeam2.Name, routeTeam2.Namespace,
 		"spec.hostnames must be unset", 10*time.Second, 1*time.Second)
@@ -197,7 +197,7 @@ func (s *tsuite) TestHeaderQueryMatch() {
 		},
 		&testmatchers.HttpResponse{StatusCode: http.StatusOK, Body: ContainSubstring(pathTeam1)})
 
-	// Assert traffic to team2 child route fails with HTTP 404 as it does not match the parent's header and query parameters
+	// Assert traffic to team2 route fails with HTTP 404 as it does not match the parent's header and query parameters
 	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt,
 		[]curl.Option{
 			curl.WithHostPort(proxyHostPort), curl.WithPath(pathTeam2),
@@ -205,15 +205,6 @@ func (s *tsuite) TestHeaderQueryMatch() {
 			curl.WithQueryParameters(map[string]string{"queryX": "valX"}),
 		},
 		&testmatchers.HttpResponse{StatusCode: http.StatusNotFound})
-
-	// Assert traffic to team2 parent route fails with HTTP 500 due to unresolved child route
-	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt,
-		[]curl.Option{
-			curl.WithHostPort(proxyHostPort), curl.WithPath(pathTeam2),
-			curl.WithHeader("header2", "val2"),
-			curl.WithQueryParameters(map[string]string{"query2": "val2"}),
-		},
-		&testmatchers.HttpResponse{StatusCode: http.StatusInternalServerError})
 }
 
 func (s *tsuite) TestMultipleParents() {
@@ -251,7 +242,7 @@ func (s *tsuite) TestMultipleParents() {
 			curl.WithPath(pathTeam2),
 			curl.WithHostHeader(routeParent2Host),
 		},
-		&testmatchers.HttpResponse{StatusCode: http.StatusInternalServerError})
+		&testmatchers.HttpResponse{StatusCode: http.StatusNotFound})
 }
 
 func (s *tsuite) TestInvalidChildValidStandalone() {
@@ -264,14 +255,14 @@ func (s *tsuite) TestInvalidChildValidStandalone() {
 		},
 		&testmatchers.HttpResponse{StatusCode: http.StatusOK, Body: ContainSubstring(pathTeam1)})
 
-	// Assert traffic to team2 route on parent hostname fails with HTTP 500 as the route is invalid due to specifying a hostname on the child route
+	// Assert traffic to team2 route on parent hostname fails with HTTP 404 as the route is invalid due to specifying a hostname on the child route
 	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt,
 		[]curl.Option{
 			curl.WithHostPort(proxyTestHostPort),
 			curl.WithPath(pathTeam2),
 			curl.WithHostHeader(routeParentHost),
 		},
-		&testmatchers.HttpResponse{StatusCode: http.StatusInternalServerError})
+		&testmatchers.HttpResponse{StatusCode: http.StatusNotFound})
 
 	// Assert traffic to team2 route on standalone host succeeds
 	s.ti.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, defaults.CurlPodExecOpt,
diff --git a/test/kubernetes/e2e/features/tracing/suite.go b/test/kubernetes/e2e/features/tracing/suite.go
index efd78b3e0..bc543f8f3 100644
--- a/test/kubernetes/e2e/features/tracing/suite.go
+++ b/test/kubernetes/e2e/features/tracing/suite.go
@@ -1,97 +1,242 @@
+//go:build ignore
+
 package tracing
 
 import (
 	"context"
-	"fmt"
-	"math/rand"
-	"strings"
+	"net/http"
 	"time"
 
-	"github.com/onsi/gomega"
+	"github.com/solo-io/solo-kit/pkg/api/v1/clients"
+	"github.com/solo-io/solo-kit/pkg/api/v1/resources"
+	"github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
+	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/suite"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
+	gloo_defaults "github.com/kgateway-dev/kgateway/v2/internal/gloo/pkg/defaults"
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/kubeutils"
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/requestutils/curl"
 	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/tests/base"
+	testdefaults "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
 )
 
 var _ e2e.NewSuiteFunc = NewTestingSuite
 
 type testingSuite struct {
-	*base.BaseTestingSuite
+	suite.Suite
+
+	ctx context.Context
+
+	testInstallation *e2e.TestInstallation
 }
 
-func NewTestingSuite(ctx context.Context, testInst *e2e.TestInstallation) suite.TestingSuite {
+func NewTestingSuite(
+	ctx context.Context,
+	testInst *e2e.TestInstallation,
+) suite.TestingSuite {
 	return &testingSuite{
-		base.NewBaseTestingSuite(ctx, testInst, setup, testCases),
+		ctx:              ctx,
+		testInstallation: testInst,
 	}
 }
 
-func (s *testingSuite) TestOTelTracing() {
-	s.testOTelTracing()
+/*
+Overview of tracing tests:
+
+1. install echo-server (upstream) and curl in SetupSuite (this can be done
+once)
+
+2. install/reinstall otelcol in BeforeTest - this avoids contamination between
+tests by ensuring the console output is clean for each test.
+
+3. send requests to the gateway-proxy so envoy sends traces to otelcol
+
+4. parse stdout from otelcol to see if the trace contains the data that we want
+*/
+
+func (s *testingSuite) SetupSuite() {
+	var err error
+
+	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, testdefaults.CurlPodManifest)
+	s.NoError(err, "can apply CurlPodManifest")
+	s.testInstallation.Assertions.EventuallyPodsRunning(
+		s.ctx,
+		testdefaults.CurlPod.GetObjectMeta().GetNamespace(),
+		metav1.ListOptions{
+			LabelSelector: "app.kubernetes.io/name=curl",
+		},
+	)
+
+	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, testdefaults.HttpEchoPodManifest)
+	s.NoError(err, "can apply HttpEchoPodManifest")
+	s.testInstallation.Assertions.EventuallyPodsRunning(
+		s.ctx,
+		testdefaults.HttpEchoPod.GetObjectMeta().GetNamespace(),
+		metav1.ListOptions{
+			LabelSelector: "app.kubernetes.io/name=http-echo",
+		},
+	)
+
+	// Previously, we would create/delete the Service for each test. However, this would occasionally lead to:
+	// * Hostname gateway-proxy-tracing.gloo-gateway-edge-test.svc.cluster.local was found in DNS cache
+	//*   Trying 10.96.181.139:18080...
+	//* Connection timed out after 3001 milliseconds
+	//
+	// The suspicion is that the rotation of the Service meant that the DNS cache became out of date,
+	// and we would curl the old IP.
+	// The workaround to that is to create the service just once at the beginning of the suite.
+	// This mirrors how Services are typically managed in Gloo Gateway, where they are tied
+	// to an installation, and not dynamically updated
+	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, gatewayProxyServiceManifest,
+		"-n", s.testInstallation.Metadata.InstallNamespace)
+	s.NoError(err, "can apply service/gateway-proxy-tracing")
 }
 
-func (s *testingSuite) TestOTelTracingSecure() {
-	s.testOTelTracing()
+func (s *testingSuite) TearDownSuite() {
+	var err error
+
+	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, testdefaults.CurlPodManifest)
+	s.Assertions.NoError(err, "can delete curl pod")
+
+	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, testdefaults.HttpEchoPodManifest)
+	s.Assertions.NoError(err, "can delete echo server")
+
+	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, gatewayProxyServiceManifest,
+		"-n", s.testInstallation.Metadata.InstallNamespace)
+	s.NoError(err, "can delete service/gateway-proxy-tracing")
 }
 
-// testOTelTracing makes a request to the httpbin service
-// and checks if the collector pod logs contain the expected lines
-func (s *testingSuite) testOTelTracing() {
-	s.TestInstallation.Assertions.EventuallyHTTPListenerPolicyCondition(s.Ctx, "tracing-policy", "default", gwv1.GatewayConditionAccepted, metav1.ConditionTrue)
-
-	// The headerValue passed is used to differentiate between multiple calls by identifying a unique trace per call
-	headerValue := fmt.Sprintf("%v", rand.Intn(10000))
-	s.TestInstallation.Assertions.Gomega.Eventually(func(g gomega.Gomega) {
-		// make curl request to httpbin service with the custom header
-		s.TestInstallation.Assertions.AssertEventualCurlResponse(
-			s.Ctx,
-			defaults.CurlPodExecOpt,
-			[]curl.Option{
-				curl.WithHostHeader("www.example.com"),
-				curl.WithHeader("x-header-tag", headerValue),
-				curl.WithPath("/status/200"),
-				curl.WithHost(kubeutils.ServiceFQDN(proxyService.ObjectMeta)),
-			},
-			&matchers.HttpResponse{
-				StatusCode: 200,
-			},
-			20*time.Second,
-			2*time.Second,
-		)
-
-		// Example trace found in the otel-collector logs
-		// {"level":"info","ts":"2025-06-20T17:58:58.513Z","msg":"ResourceSpans #0\nResource SchemaURL: \nResource attributes:\n     -> service.name: Str(my:service)\n     -> telemetry.sdk.language: Str(cpp)\n     -> telemetry.sdk.name: Str(envoy)\n     -> telemetry.sdk.version: Str(a152096e910205ccf09863f93fc66150dc5438aa/1.34.1/Distribution/RELEASE/BoringSSL)\nScopeSpans #0\nScopeSpans SchemaURL: \nInstrumentationScope envoy a152096e910205ccf09863f93fc66150dc5438aa/1.34.1/Distribution/RELEASE/BoringSSL\nSpan #0\n    Trace ID       : 3771968e2d941a83f41517dd052fbfdb\n    Parent ID      : \n    ID             : 8d10646806636467\n    Name           : ingress\n    Kind           : Server\n    Start time     : 2025-06-20 17:58:55.73679 +0000 UTC\n    End time       : 2025-06-20 17:58:55.759439 +0000 UTC\n    Status code    : Unset\n    Status message : \nAttributes:\n     -> node_id: Str(gw-7fc7dbd6fc-fb24g.default)\n     -> zone: Str()\n     -> guid:x-request-id: Str(b5fa5226-ad2f-90a1-bd3a-e02d834301cd)\n     -> http.url: Str(http://www.example.com/status/200)\n     -> http.method: Str(GET)\n     -> downstream_cluster: Str(-)\n     -> user_agent: Str(curl/7.83.1-DEV)\n     -> http.protocol: Str(HTTP/1.1)\n     -> peer.address: Str(10.244.0.21)\n     -> request_size: Str(0)\n     -> response_size: Str(0)\n     -> component: Str(proxy)\n     -> upstream_cluster: Str(kube_httpbin_httpbin_8000)\n     -> upstream_cluster.name: Str(kube_httpbin_httpbin_8000)\n     -> http.status_code: Str(200)\n     -> response_flags: Str(-)\n     -> custom: Str(literal)\n     -> request: Str(value)\n","kind":"exporter","data_type":"traces","name":"debug"}
-		expectedLines := []string{
-			`-> http.url: Str(http://www.example.com/status/200)`,
-			`-> http.method: Str(GET)`,
-			`-> http.status_code: Str(200)`,
-			`-> upstream_cluster: Str(kube_httpbin_httpbin_8000)`,
-			// Resource attributes specified via the environmentResourceDetector
-			`-> environment: Str(detector)`,
-			`-> resource: Str(attribute)`,
-			// Custom tag passed in the config
-			`-> custom: Str(literal)`,
-			// Custom tag fetched from the request header
-			fmt.Sprintf("-> request: Str(%s)", headerValue),
-		}
-
-		// fetch the collector pod logs
-		logs, err := s.TestInstallation.Actions.Kubectl().GetContainerLogs(s.Ctx, "default", "otel-collector")
-		g.Expect(err).NotTo(gomega.HaveOccurred(), "Failed to get pod logs")
-
-		// check if the logs match the patterns
-		allMatched := true
-		for _, line := range expectedLines {
-			if !strings.Contains(logs, line) {
-				allMatched = false
-			}
-		}
-		g.Expect(allMatched).To(gomega.BeTrue(), "lines not found in logs")
-	}, time.Second*60, time.Second*15, "should find traces in collector pod logs").Should(gomega.Succeed())
+func (s *testingSuite) BeforeTest(string, string) {
+	var err error
+
+	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, setupOtelcolManifest)
+	s.NoError(err, "can apply opentelemetry collector")
+	s.testInstallation.Assertions.EventuallyPodsRunning(
+		s.ctx,
+		otelcolPod.GetObjectMeta().GetNamespace(),
+		otelcolSelector,
+	)
+
+	// Technical Debt!!
+	// https://github.com/kgateway-dev/kgateway/issues/10293
+	// There is a bug in the Control Plane that results in an Error reported on the status
+	// when the Upstream of the Tracing Collector is not found. This results in the VirtualService
+	// that references that Upstream being rejected. What should occur is a Warning is reported,
+	// and the resource is accepted since validation.allowWarnings=true is set.
+	// We have plans to fix this in the code itself. But for a short-term solution, to reduce the
+	// noise in CI/CD of this test flaking, we perform some simple retry logic here.
+	s.EventuallyWithT(func(c *assert.CollectT) {
+		err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, tracingConfigManifest)
+		assert.NoError(c, err, "can apply gloo tracing resources")
+	}, time.Second*5, time.Second*1, "can apply tracing resources")
+
+	// accept the upstream
+	// Upstreams no longer report status if they have not been translated at all to avoid conflicting with
+	// other syncers that have translated them, so we can only detect that the objects exist here
+	s.testInstallation.Assertions.EventuallyResourceExists(
+		func() (resources.Resource, error) {
+			return s.testInstallation.ResourceClients.UpstreamClient().Read(
+				otelcolUpstream.Namespace, otelcolUpstream.Name, clients.ReadOpts{Ctx: s.ctx})
+		},
+	)
+
+	// accept the virtual service
+	s.testInstallation.Assertions.EventuallyResourceStatusMatchesState(
+		func() (resources.InputResource, error) {
+			return s.testInstallation.ResourceClients.VirtualServiceClient().Read(
+				tracingVs.Namespace, tracingVs.Name, clients.ReadOpts{Ctx: s.ctx})
+		},
+		core.Status_Accepted,
+		gloo_defaults.GlooReporter,
+	)
+
+	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, gatewayConfigManifest,
+		"-n", s.testInstallation.Metadata.InstallNamespace)
+	s.NoError(err, "can create gateway and service")
+	s.testInstallation.Assertions.EventuallyResourceStatusMatchesState(
+		func() (resources.InputResource, error) {
+			return s.testInstallation.ResourceClients.GatewayClient().Read(
+				s.testInstallation.Metadata.InstallNamespace, "gateway-proxy-tracing", clients.ReadOpts{Ctx: s.ctx})
+		},
+		core.Status_Accepted,
+		gloo_defaults.GlooReporter,
+	)
+}
+
+func (s *testingSuite) AfterTest(string, string) {
+	var err error
+	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, setupOtelcolManifest)
+	s.Assertions.NoError(err, "can delete otel collector")
+
+	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, tracingConfigManifest)
+	s.Assertions.NoError(err, "can delete gloo tracing config")
+
+	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, gatewayConfigManifest,
+		"-n", s.testInstallation.Metadata.InstallNamespace)
+	s.Assertions.NoError(err, "can delete gateway config")
+}
+
+func (s *testingSuite) TestSpanNameTransformationsWithoutRouteDecorator() {
+	testHostname := "test-really-cool-hostname.com"
+	s.testInstallation.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, testdefaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(metav1.ObjectMeta{
+				Name:      gatewayProxyHost,
+				Namespace: s.testInstallation.Metadata.InstallNamespace,
+			})),
+			curl.WithHostHeader(testHostname),
+			curl.WithPort(gatewayProxyPort),
+			curl.WithPath(pathWithoutRouteDescriptor),
+			// We are asserting that a request is consistent. To prevent flakes with that assertion,
+			// we should have some basic retries built into the request
+			curl.WithRetryConnectionRefused(true),
+			curl.WithRetries(3, 0, 10),
+			curl.Silent(),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusOK,
+		},
+		5*time.Second, 30*time.Second,
+	)
+
+	s.EventuallyWithT(func(c *assert.CollectT) {
+		logs, err := s.testInstallation.Actions.Kubectl().GetContainerLogs(s.ctx, otelcolPod.ObjectMeta.GetNamespace(), otelcolPod.ObjectMeta.GetName())
+		assert.NoError(c, err, "can get otelcol logs")
+		// Looking for a line like this:
+		// Name       : <value of host header>
+		assert.Regexp(c, "Name *: "+testHostname, logs)
+	}, time.Second*30, time.Second*3, "otelcol logs contain span with name == hostname")
+}
+
+func (s *testingSuite) TestSpanNameTransformationsWithRouteDecorator() {
+	s.testInstallation.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, testdefaults.CurlPodExecOpt,
+		[]curl.Option{
+			curl.WithHost(kubeutils.ServiceFQDN(metav1.ObjectMeta{
+				Name:      gatewayProxyHost,
+				Namespace: s.testInstallation.Metadata.InstallNamespace,
+			})),
+			curl.WithHostHeader("example.com"),
+			curl.WithPort(gatewayProxyPort),
+			curl.WithPath(pathWithRouteDescriptor),
+			// We are asserting that a request is consistent. To prevent flakes with that assertion,
+			// we should have some basic retries built into the request
+			curl.WithRetryConnectionRefused(true),
+			curl.WithRetries(3, 0, 10),
+			curl.Silent(),
+		},
+		&matchers.HttpResponse{
+			StatusCode: http.StatusOK,
+		},
+		5*time.Second, 30*time.Second,
+	)
+
+	s.EventuallyWithT(func(c *assert.CollectT) {
+		logs, err := s.testInstallation.Actions.Kubectl().GetContainerLogs(s.ctx, otelcolPod.ObjectMeta.GetNamespace(), otelcolPod.ObjectMeta.GetName())
+		assert.NoError(c, err, "can get otelcol logs")
+		// Looking for a line like this:
+		// Name       : <value of routeDescriptorSpanName>
+		assert.Regexp(c, "Name *: "+routeDescriptorSpanName, logs)
+	}, time.Second*30, time.Second*3, "otelcol logs contain span with name == routeDescriptor")
 }
diff --git a/test/kubernetes/e2e/features/tracing_legacy/testdata/gateway.yaml b/test/kubernetes/e2e/features/tracing/testdata/gateway.yaml
similarity index 100%
rename from test/kubernetes/e2e/features/tracing_legacy/testdata/gateway.yaml
rename to test/kubernetes/e2e/features/tracing/testdata/gateway.yaml
diff --git a/test/kubernetes/e2e/features/tracing_legacy/testdata/gw-proxy-tracing-service.yaml b/test/kubernetes/e2e/features/tracing/testdata/gw-proxy-tracing-service.yaml
similarity index 100%
rename from test/kubernetes/e2e/features/tracing_legacy/testdata/gw-proxy-tracing-service.yaml
rename to test/kubernetes/e2e/features/tracing/testdata/gw-proxy-tracing-service.yaml
diff --git a/test/kubernetes/e2e/features/tracing/testdata/otel-collector-secure.yaml b/test/kubernetes/e2e/features/tracing/testdata/otel-collector-secure.yaml
deleted file mode 100644
index 106e6220f..000000000
--- a/test/kubernetes/e2e/features/tracing/testdata/otel-collector-secure.yaml
+++ /dev/null
@@ -1,190 +0,0 @@
----
-apiVersion: v1
-kind: ConfigMap
-metadata:
-  name: otel-collector-conf
-  labels:
-    app: otel-collector
-    component: otel-collector-conf
-data:
-  otel-collector-config: |
-    receivers:
-      otlp:
-        protocols:
-          grpc:
-            include_metadata: true
-            endpoint: 0.0.0.0:4317
-            tls:
-              cert_file: /conf/collector.crt
-              key_file: /conf/collector.key
-    processors:
-    exporters:
-      debug:
-        verbosity: detailed
-    service:
-      extensions: []
-      pipelines:
-        logs:
-          receivers: [otlp]
-          processors: []
-          exporters: [debug]
-        traces:
-          receivers: [otlp]
-          processors: []
-          exporters: [debug]
-      telemetry:
-        logs:
-          level: "DEBUG"
-          development: true
-          encoding: "json"
-  collector.crt: |
-    -----BEGIN CERTIFICATE-----
-    MIIDFTCCAf2gAwIBAgIUG9Mdv3nOQ2i7v68OgjArU4lhBikwDQYJKoZIhvcNAQEL
-    BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjUwNzA3MTA0MDQwWhcNMjYw
-    NzA3MTA0MDQwWjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN
-    AQEBBQADggEPADCCAQoCggEBANueqwfAApjTfg+nxIoKVK4sK/YlNICvdoEq1UEL
-    StE9wfTv0J27uNIsfpMqCx0Ni9Rjt1hzjunc8HUJDeobMNxGaZmryQofrdJWJ7Uu
-    t5jeLW/w0MelPOfFLsDiM5REy4WuPm2X6v1Z1N3N5GR3UNDOtDtsbjS1momvooLO
-    9WxPIr2cfmPqr81fyyD2ReZsMC/8lVs0PkA9XBplMzpSU53DWl5/Nyh2d1W5ENK0
-    Zw1l5Ze4UGUeohQMa5cD5hmZcBjOeJF8MuSTi3167KSopoqfgHTvC5IsBeWXAyZF
-    81ihFYAq+SbhUZeUlsxc1wveuAdBRzafcYkK47gYmbq1K60CAwEAAaNbMFkwFgYD
-    VR0RBA8wDYILZXhhbXBsZS5jb20wCwYDVR0PBAQDAgeAMBMGA1UdJQQMMAoGCCsG
-    AQUFBwMBMB0GA1UdDgQWBBSoa1Zu2o+pQ6sq2HcOjAglZkp01zANBgkqhkiG9w0B
-    AQsFAAOCAQEADZq1EMw/jMl0z2LpPh8cXbP09BnfXhoFbpL4cFrcBNEyig0oPO0j
-    YN1e4bfURNduFVnC/FDnZhR3FlAt8a6ozJAwmJp+nQCYFoDQwotSx12y5Bc9IXwd
-    BRZaLgHYy2NjGp2UgAya2z23BkUnwOJwJNMCzuGw3pOsmDQY0diR8ZWmEYYEPheW
-    6BVkrikzUNXv3tB8LmWzxV9V3eN71fnP5u39IM/UQsOZGRUow/8tvN2/d0W4dHky
-    t/kdgLKhf4gU2wXq/WbeqxlDSpjo7q/emNl59v1FHeR3eITSSjESU+dQgRsYaGEn
-    SWP+58ApfCcURLpMxUmxkO1ayfecNJbmSQ==
-    -----END CERTIFICATE-----
-  collector.key: |
-    -----BEGIN PRIVATE KEY-----
-    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDbnqsHwAKY034P
-    p8SKClSuLCv2JTSAr3aBKtVBC0rRPcH079Cdu7jSLH6TKgsdDYvUY7dYc47p3PB1
-    CQ3qGzDcRmmZq8kKH63SVie1LreY3i1v8NDHpTznxS7A4jOURMuFrj5tl+r9WdTd
-    zeRkd1DQzrQ7bG40tZqJr6KCzvVsTyK9nH5j6q/NX8sg9kXmbDAv/JVbND5APVwa
-    ZTM6UlOdw1pefzcodndVuRDStGcNZeWXuFBlHqIUDGuXA+YZmXAYzniRfDLkk4t9
-    euykqKaKn4B07wuSLAXllwMmRfNYoRWAKvkm4VGXlJbMXNcL3rgHQUc2n3GJCuO4
-    GJm6tSutAgMBAAECggEACHMi3nH3R5z/gSexyqPaHTdq25YT3o2hsBePS+jc0I8h
-    OsTNUHxMAJ4gopXgBpaiViIeCEOt8HaFM+OMywCP0THOV1DCM+cDH5AcB/8LplCK
-    DAAGcF/9p2cxRM+PL3m0IOkS0tGhA21k4MHOs0TZ8aa6TXz/An0oPHrq9EB1Nd0F
-    V5ZDnk818uNolViDHpA4wTz49f81dUvSbWBM3WE4t+0wZM0LKgyYO/w/DRv7xyS2
-    hItA6dcFjniy6CuFQcgteY659qOMHwq46imIKHJGFimQ6+O16OInRzsiLQmGsnYi
-    eWTf0u9pP/uZ+92aH7EmoMc6Nwqq03AxSED1jamQewKBgQDyYp3ZAA2wBLlvigOD
-    tlZE4JPn4LJBL1JJFvuh+1O7NfaI7vpAg24SAiZzAcYTS7JfwmV/9P1g9RCeXAbW
-    5Jyp6MxNRv+veJvGcdrDLxjhWSkMt72A+FDHHQTKVLtsuD3PE31UIoYN2TPthHRz
-    et87ZGriWwhX8+PQ9/t2tfyr+wKBgQDn9LIS7hwFaJGzLnepJ17VfGm5NT/MLi4p
-    LUTkRtqlFM+t2foHCCXCUSNW3Q9VuTmFmqoHtbuv8DRdT3QbaQbMnFE0pSYWbHDL
-    TRCsBmWIIZvoMeKf6X9y0+Z/qrzCBV+TbgN2o3nbLodyqatfUrvwYkfz1L/GXuJ4
-    LmXzfdSOdwKBgArTSrd5YCMfYuTPZi7IwvuaiCCQEYYFxggLpbtrTScMVvFwsu6U
-    sCLPw8XZK26LL/FE7mGToIlnCJH6DDgmx7Ry+ETvSdYdbd+kECAth0/xOnsd7bHH
-    5VuvORqMRD6rz97iwPM0A4a0z7Po+YZ602OErZ1kcW/0LZWUrb90i09nAoGAcqCv
-    O8Gl4Vpa3mSxR8uoBvJzwM461+lecITpjbIiLQCK3UxiTgVNu6ijQTL/eAqQDaFw
-    M10xAnI/PnmcVEtjy8vYKZ8Ponc2ipFsEscad9q8FFRKvWID1Lg5KZAzteI36ECu
-    v3tsJc/pqdWFVhcpv1KiYjIaD6smWeP8CAd/+mMCgYEA7vZGKGnppmY2yFofukla
-    S0kgtXgeJrdwHf0X5c6pW+iveTUNj7zX0mdUhC0V4GXkbCXoWrLJc/dA/HW2D18Q
-    fcaJ8lpO3/VNiPx0mhGgCRVX2gRnz1qZ9EekIw1+TCqNSMVr04nQej6e24nUtNCO
-    tok7r0XhLeoEMoxJZwlanJk=
-    -----END PRIVATE KEY-----
----
-apiVersion: v1
-kind: Pod
-metadata:
-  name: otel-collector
-  labels:
-    app: otel-collector
-    component: otel-collector
-    app.kubernetes.io/name: otel-collector
-spec:
-  containers:
-  - command:
-      - "/otelcol-contrib"
-      - "--config"
-      - "/conf/otel-collector-config.yaml"
-    image: otel/opentelemetry-collector-contrib:0.116.1
-    name: otel-collector
-    resources:
-      limits:
-        cpu: 1
-        memory: 2Gi
-      requests:
-        cpu: 200m
-        memory: 400Mi
-    ports: # Comment out ports for platforms as needed.
-    - containerPort: 4317 # Default gRPC endpoint for OpenTelemetry receiver.
-    volumeMounts:
-    - name: otel-collector-config-vol
-      mountPath: /conf
-  volumes:
-    - name: otel-collector-config-vol
-      configMap:
-        name: otel-collector-conf
-        items:
-          - key: otel-collector-config
-            path: otel-collector-config.yaml
-          - key: collector.crt
-            path: collector.crt
-          - key: collector.key
-            path: collector.key
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: otel-collector
-  labels:
-    app: otel-collector
-    component: otel-collector
-    app.kubernetes.io/name: opentelemetry
-spec:
-  ports:
-  - name: otlp-grpc # Default endpoint for OpenTelemetry gRPC receiver.
-    port: 4317
-    protocol: TCP
-    targetPort: 4317
-    appProtocol: grpc
-  selector:
-    app.kubernetes.io/name: otel-collector
----
-apiVersion: v1
-kind: ConfigMap
-metadata:
-  name: ca
-data:
-  ca.crt: |
-    -----BEGIN CERTIFICATE-----
-    MIIDFTCCAf2gAwIBAgIUG9Mdv3nOQ2i7v68OgjArU4lhBikwDQYJKoZIhvcNAQEL
-    BQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wHhcNMjUwNzA3MTA0MDQwWhcNMjYw
-    NzA3MTA0MDQwWjAWMRQwEgYDVQQDDAtleGFtcGxlLmNvbTCCASIwDQYJKoZIhvcN
-    AQEBBQADggEPADCCAQoCggEBANueqwfAApjTfg+nxIoKVK4sK/YlNICvdoEq1UEL
-    StE9wfTv0J27uNIsfpMqCx0Ni9Rjt1hzjunc8HUJDeobMNxGaZmryQofrdJWJ7Uu
-    t5jeLW/w0MelPOfFLsDiM5REy4WuPm2X6v1Z1N3N5GR3UNDOtDtsbjS1momvooLO
-    9WxPIr2cfmPqr81fyyD2ReZsMC/8lVs0PkA9XBplMzpSU53DWl5/Nyh2d1W5ENK0
-    Zw1l5Ze4UGUeohQMa5cD5hmZcBjOeJF8MuSTi3167KSopoqfgHTvC5IsBeWXAyZF
-    81ihFYAq+SbhUZeUlsxc1wveuAdBRzafcYkK47gYmbq1K60CAwEAAaNbMFkwFgYD
-    VR0RBA8wDYILZXhhbXBsZS5jb20wCwYDVR0PBAQDAgeAMBMGA1UdJQQMMAoGCCsG
-    AQUFBwMBMB0GA1UdDgQWBBSoa1Zu2o+pQ6sq2HcOjAglZkp01zANBgkqhkiG9w0B
-    AQsFAAOCAQEADZq1EMw/jMl0z2LpPh8cXbP09BnfXhoFbpL4cFrcBNEyig0oPO0j
-    YN1e4bfURNduFVnC/FDnZhR3FlAt8a6ozJAwmJp+nQCYFoDQwotSx12y5Bc9IXwd
-    BRZaLgHYy2NjGp2UgAya2z23BkUnwOJwJNMCzuGw3pOsmDQY0diR8ZWmEYYEPheW
-    6BVkrikzUNXv3tB8LmWzxV9V3eN71fnP5u39IM/UQsOZGRUow/8tvN2/d0W4dHky
-    t/kdgLKhf4gU2wXq/WbeqxlDSpjo7q/emNl59v1FHeR3eITSSjESU+dQgRsYaGEn
-    SWP+58ApfCcURLpMxUmxkO1ayfecNJbmSQ==
-    -----END CERTIFICATE-----
----
-apiVersion: gateway.networking.k8s.io/v1alpha3
-kind: BackendTLSPolicy
-metadata:
-  name: otel-collector-tls-policy
-  labels:
-    app: otel-collector
-spec:
-  targetRefs:
-  - group: ""
-    kind: Service
-    name: otel-collector
-  validation:
-    hostname: "example.com"
-    caCertificateRefs:
-    - group: ""
-      kind: ConfigMap
-      name: ca
diff --git a/test/kubernetes/e2e/features/tracing/testdata/otel-collector.yaml b/test/kubernetes/e2e/features/tracing/testdata/otel-collector.yaml
deleted file mode 100644
index 421a2d796..000000000
--- a/test/kubernetes/e2e/features/tracing/testdata/otel-collector.yaml
+++ /dev/null
@@ -1,90 +0,0 @@
----
-apiVersion: v1
-kind: ConfigMap
-metadata:
-  name: otel-collector-conf
-  labels:
-    app: otel-collector
-    component: otel-collector-conf
-data:
-  otel-collector-config: |
-    receivers:
-      otlp:
-        protocols:
-          grpc:
-            include_metadata: true
-            endpoint: 0.0.0.0:4317
-    processors:
-    exporters:
-      debug:
-        verbosity: detailed
-    service:
-      extensions: []
-      pipelines:
-        logs:
-          receivers: [otlp]
-          processors: []
-          exporters: [debug]
-        traces:
-          receivers: [otlp]
-          processors: []
-          exporters: [debug]
-      telemetry:
-        logs:
-          level: "DEBUG"
-          development: true
-          encoding: "json"
----
-apiVersion: v1
-kind: Pod
-metadata:
-  name: otel-collector
-  labels:
-    app: otel-collector
-    component: otel-collector
-    app.kubernetes.io/name: otel-collector
-spec:
-  containers:
-  - command:
-      - "/otelcol-contrib"
-      - "--config"
-      - "/conf/otel-collector-config.yaml"
-    image: otel/opentelemetry-collector-contrib:0.116.1
-    name: otel-collector
-    resources:
-      limits:
-        cpu: 1
-        memory: 2Gi
-      requests:
-        cpu: 200m
-        memory: 400Mi
-    ports: # Comment out ports for platforms as needed.
-    - containerPort: 4317 # Default gRPC endpoint for OpenTelemetry receiver.
-    volumeMounts:
-    - name: otel-collector-config-vol
-      mountPath: /conf
-  volumes:
-    - name: otel-collector-config-vol
-      configMap:
-        name: otel-collector-conf
-        items:
-          - key: otel-collector-config
-            path: otel-collector-config.yaml
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: otel-collector
-  labels:
-    app: otel-collector
-    component: otel-collector
-    app.kubernetes.io/name: opentelemetry
-spec:
-  ports:
-  - name: otlp-grpc # Default endpoint for OpenTelemetry gRPC receiver.
-    port: 4317
-    protocol: TCP
-    targetPort: 4317
-    appProtocol: grpc
-  selector:
-    app.kubernetes.io/name: otel-collector
diff --git a/test/kubernetes/e2e/features/tracing_legacy/testdata/setup-otelcol.yaml b/test/kubernetes/e2e/features/tracing/testdata/setup-otelcol.yaml
similarity index 100%
rename from test/kubernetes/e2e/features/tracing_legacy/testdata/setup-otelcol.yaml
rename to test/kubernetes/e2e/features/tracing/testdata/setup-otelcol.yaml
diff --git a/test/kubernetes/e2e/features/tracing/testdata/setup.yaml b/test/kubernetes/e2e/features/tracing/testdata/setup.yaml
deleted file mode 100644
index 7a29e924b..000000000
--- a/test/kubernetes/e2e/features/tracing/testdata/setup.yaml
+++ /dev/null
@@ -1,114 +0,0 @@
-apiVersion: v1
-kind: Namespace
-metadata:
-  name: httpbin
----
-apiVersion: v1
-kind: ServiceAccount
-metadata:
-  name: httpbin
-  namespace: httpbin
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: httpbin
-  namespace: httpbin
-  labels:
-    app: httpbin
-    service: httpbin
-spec:
-  ports:
-    - name: http
-      port: 8000
-      targetPort: 8080
-    - name: tcp
-      port: 9000
-  selector:
-    app: httpbin
----
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  name: httpbin
-  namespace: httpbin
-spec:
-  replicas: 1
-  selector:
-    matchLabels:
-      app: httpbin
-      version: v1
-  template:
-    metadata:
-      labels:
-        app: httpbin
-        version: v1
-    spec:
-      serviceAccountName: httpbin
-      containers:
-        - image: docker.io/mccutchen/go-httpbin:v2.6.0
-          imagePullPolicy: IfNotPresent
-          name: httpbin
-          command: [ go-httpbin ]
-          args:
-            - "-port"
-            - "8080"
-            - "-max-duration"
-            - "600s" # override default 10s
-          ports:
-            - containerPort: 8080
-          resources:
-            requests:
-              cpu: "100m"
-            limits:
-              cpu: "200m"
----
-# Custom GWP to define OTEL_RESOURCE_ATTRIBUTES required for the environment detector
-kind: GatewayParameters
-apiVersion: gateway.kgateway.dev/v1alpha1
-metadata:
-  name: tracing-params
-spec:
-  kube:
-    envoyContainer:
-      env:
-      - name: OTEL_RESOURCE_ATTRIBUTES
-        value: "environment=detector,resource=attribute"
----
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: gw
-spec:
-  gatewayClassName: kgateway
-  infrastructure:
-    parametersRef:
-      name: tracing-params
-      group: gateway.kgateway.dev
-      kind: GatewayParameters
-  listeners:
-    - protocol: HTTP
-      port: 8080
-      name: http
-      allowedRoutes:
-        namespaces:
-          from: All
----
-apiVersion: gateway.networking.k8s.io/v1
-kind: HTTPRoute
-metadata:
-  name: httpbin
-  namespace: httpbin
-  labels:
-    example: httpbin-route
-spec:
-  parentRefs:
-    - name: gw
-      namespace: default
-  hostnames:
-    - "www.example.com"
-  rules:
-    - backendRefs:
-        - name: httpbin
-          port: 8000
----
\ No newline at end of file
diff --git a/test/kubernetes/e2e/features/tracing/testdata/tracing-policy.yaml b/test/kubernetes/e2e/features/tracing/testdata/tracing-policy.yaml
deleted file mode 100644
index a37845c80..000000000
--- a/test/kubernetes/e2e/features/tracing/testdata/tracing-policy.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: HTTPListenerPolicy
-metadata:
-  name: tracing-policy
-  namespace: default
-spec:
-  targetRefs:
-  - group: gateway.networking.k8s.io
-    kind: Gateway
-    name: gw
-  tracing:
-    provider:
-      openTelemetry:
-        serviceName: "my:service"
-        resourceDetectors:
-        - environmentResourceDetector: {}
-        grpcService:
-          authority: "example.com"
-          backendRef:
-            name: otel-collector
-            namespace: default
-            port: 4317
-    spawnUpstreamSpan: true
-    attributes:
-      - name: custom
-        literal:
-          value: literal
-      - name: request
-        requestHeader:
-          name: x-header-tag
diff --git a/test/kubernetes/e2e/features/tracing/types.go b/test/kubernetes/e2e/features/tracing/types.go
index b2674fe3d..279d04772 100644
--- a/test/kubernetes/e2e/features/tracing/types.go
+++ b/test/kubernetes/e2e/features/tracing/types.go
@@ -1,80 +1,42 @@
+//go:build ignore
+
 package tracing
 
 import (
 	"path/filepath"
 
-	appsv1 "k8s.io/api/apps/v1"
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"sigs.k8s.io/controller-runtime/pkg/client"
 
-	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/fsutils"
-	e2edefaults "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/tests/base"
 )
 
-var (
-	// manifests
-	setupManifest               = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup.yaml")
-	otelCollectorManifest       = filepath.Join(fsutils.MustGetThisDir(), "testdata", "otel-collector.yaml")
-	otelCollectorSecureManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "otel-collector-secure.yaml")
-	policyManifest              = filepath.Join(fsutils.MustGetThisDir(), "testdata", "tracing-policy.yaml")
-
-	// setup objects
-	proxyObjectMeta = metav1.ObjectMeta{
-		Name:      "gw",
-		Namespace: "default",
-	}
-	proxyDeployment = &appsv1.Deployment{ObjectMeta: proxyObjectMeta}
-	proxyService    = &corev1.Service{ObjectMeta: proxyObjectMeta}
+const (
+	pathWithRouteDescriptor    = "/path/with/route/descriptor"
+	pathWithoutRouteDescriptor = "/path/without/route/descriptor"
+	routeDescriptorSpanName    = "THISISAROUTEDESCRIPTOR"
+	gatewayProxyHost           = "gateway-proxy-tracing"
+	gatewayProxyPort           = 18080
+)
 
-	httpbinSvc = &corev1.Service{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "httpbin",
-			Namespace: "httpbin",
-		},
-	}
-	httpbinDeployment = &appsv1.Deployment{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "httpbin",
-			Namespace: "httpbin",
-		},
-	}
+var (
+	setupOtelcolManifest        = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup-otelcol.yaml")
+	tracingConfigManifest       = filepath.Join(fsutils.MustGetThisDir(), "testdata", "tracing.yaml")
+	gatewayConfigManifest       = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gateway.yaml")
+	gatewayProxyServiceManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gw-proxy-tracing-service.yaml")
 
-	// otelCollector objects
-	otelCollectorPod = &corev1.Pod{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "otel-collector",
-			Namespace: "default",
-		},
+	otelcolPod = &corev1.Pod{
+		ObjectMeta: metav1.ObjectMeta{Name: "otel-collector", Namespace: "default"},
 	}
-
-	tracingPolicy = &v1alpha1.HTTPListenerPolicy{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "tracing-policy",
-			Namespace: "default",
-		},
+	otelcolSelector = metav1.ListOptions{
+		LabelSelector: "app.kubernetes.io/name=otel-collector",
 	}
-
-	setup = base.SimpleTestCase{
-		Manifests: []string{e2edefaults.CurlPodManifest, setupManifest},
-		Resources: []client.Object{e2edefaults.CurlPod, proxyDeployment, proxyService, httpbinSvc, httpbinDeployment},
+	otelcolUpstream = &metav1.ObjectMeta{
+		Name:      "opentelemetry-collector",
+		Namespace: "default",
 	}
-
-	// test cases
-	testCases = map[string]*base.TestCase{
-		"TestOTelTracing": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{otelCollectorManifest, policyManifest},
-				Resources: []client.Object{otelCollectorPod, tracingPolicy},
-			},
-		},
-		"TestOTelTracingSecure": {
-			SimpleTestCase: base.SimpleTestCase{
-				Manifests: []string{otelCollectorSecureManifest, policyManifest},
-				Resources: []client.Object{otelCollectorPod, tracingPolicy},
-			},
-		},
+	tracingVs = &metav1.ObjectMeta{
+		Name:      "virtual-service",
+		Namespace: "default",
 	}
 )
diff --git a/test/kubernetes/e2e/features/tracing_legacy/suite.go b/test/kubernetes/e2e/features/tracing_legacy/suite.go
deleted file mode 100644
index bc543f8f3..000000000
--- a/test/kubernetes/e2e/features/tracing_legacy/suite.go
+++ /dev/null
@@ -1,242 +0,0 @@
-//go:build ignore
-
-package tracing
-
-import (
-	"context"
-	"net/http"
-	"time"
-
-	"github.com/solo-io/solo-kit/pkg/api/v1/clients"
-	"github.com/solo-io/solo-kit/pkg/api/v1/resources"
-	"github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/suite"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
-	gloo_defaults "github.com/kgateway-dev/kgateway/v2/internal/gloo/pkg/defaults"
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/kubeutils"
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/requestutils/curl"
-	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e"
-	testdefaults "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/defaults"
-)
-
-var _ e2e.NewSuiteFunc = NewTestingSuite
-
-type testingSuite struct {
-	suite.Suite
-
-	ctx context.Context
-
-	testInstallation *e2e.TestInstallation
-}
-
-func NewTestingSuite(
-	ctx context.Context,
-	testInst *e2e.TestInstallation,
-) suite.TestingSuite {
-	return &testingSuite{
-		ctx:              ctx,
-		testInstallation: testInst,
-	}
-}
-
-/*
-Overview of tracing tests:
-
-1. install echo-server (upstream) and curl in SetupSuite (this can be done
-once)
-
-2. install/reinstall otelcol in BeforeTest - this avoids contamination between
-tests by ensuring the console output is clean for each test.
-
-3. send requests to the gateway-proxy so envoy sends traces to otelcol
-
-4. parse stdout from otelcol to see if the trace contains the data that we want
-*/
-
-func (s *testingSuite) SetupSuite() {
-	var err error
-
-	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, testdefaults.CurlPodManifest)
-	s.NoError(err, "can apply CurlPodManifest")
-	s.testInstallation.Assertions.EventuallyPodsRunning(
-		s.ctx,
-		testdefaults.CurlPod.GetObjectMeta().GetNamespace(),
-		metav1.ListOptions{
-			LabelSelector: "app.kubernetes.io/name=curl",
-		},
-	)
-
-	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, testdefaults.HttpEchoPodManifest)
-	s.NoError(err, "can apply HttpEchoPodManifest")
-	s.testInstallation.Assertions.EventuallyPodsRunning(
-		s.ctx,
-		testdefaults.HttpEchoPod.GetObjectMeta().GetNamespace(),
-		metav1.ListOptions{
-			LabelSelector: "app.kubernetes.io/name=http-echo",
-		},
-	)
-
-	// Previously, we would create/delete the Service for each test. However, this would occasionally lead to:
-	// * Hostname gateway-proxy-tracing.gloo-gateway-edge-test.svc.cluster.local was found in DNS cache
-	//*   Trying 10.96.181.139:18080...
-	//* Connection timed out after 3001 milliseconds
-	//
-	// The suspicion is that the rotation of the Service meant that the DNS cache became out of date,
-	// and we would curl the old IP.
-	// The workaround to that is to create the service just once at the beginning of the suite.
-	// This mirrors how Services are typically managed in Gloo Gateway, where they are tied
-	// to an installation, and not dynamically updated
-	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, gatewayProxyServiceManifest,
-		"-n", s.testInstallation.Metadata.InstallNamespace)
-	s.NoError(err, "can apply service/gateway-proxy-tracing")
-}
-
-func (s *testingSuite) TearDownSuite() {
-	var err error
-
-	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, testdefaults.CurlPodManifest)
-	s.Assertions.NoError(err, "can delete curl pod")
-
-	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, testdefaults.HttpEchoPodManifest)
-	s.Assertions.NoError(err, "can delete echo server")
-
-	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, gatewayProxyServiceManifest,
-		"-n", s.testInstallation.Metadata.InstallNamespace)
-	s.NoError(err, "can delete service/gateway-proxy-tracing")
-}
-
-func (s *testingSuite) BeforeTest(string, string) {
-	var err error
-
-	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, setupOtelcolManifest)
-	s.NoError(err, "can apply opentelemetry collector")
-	s.testInstallation.Assertions.EventuallyPodsRunning(
-		s.ctx,
-		otelcolPod.GetObjectMeta().GetNamespace(),
-		otelcolSelector,
-	)
-
-	// Technical Debt!!
-	// https://github.com/kgateway-dev/kgateway/issues/10293
-	// There is a bug in the Control Plane that results in an Error reported on the status
-	// when the Upstream of the Tracing Collector is not found. This results in the VirtualService
-	// that references that Upstream being rejected. What should occur is a Warning is reported,
-	// and the resource is accepted since validation.allowWarnings=true is set.
-	// We have plans to fix this in the code itself. But for a short-term solution, to reduce the
-	// noise in CI/CD of this test flaking, we perform some simple retry logic here.
-	s.EventuallyWithT(func(c *assert.CollectT) {
-		err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, tracingConfigManifest)
-		assert.NoError(c, err, "can apply gloo tracing resources")
-	}, time.Second*5, time.Second*1, "can apply tracing resources")
-
-	// accept the upstream
-	// Upstreams no longer report status if they have not been translated at all to avoid conflicting with
-	// other syncers that have translated them, so we can only detect that the objects exist here
-	s.testInstallation.Assertions.EventuallyResourceExists(
-		func() (resources.Resource, error) {
-			return s.testInstallation.ResourceClients.UpstreamClient().Read(
-				otelcolUpstream.Namespace, otelcolUpstream.Name, clients.ReadOpts{Ctx: s.ctx})
-		},
-	)
-
-	// accept the virtual service
-	s.testInstallation.Assertions.EventuallyResourceStatusMatchesState(
-		func() (resources.InputResource, error) {
-			return s.testInstallation.ResourceClients.VirtualServiceClient().Read(
-				tracingVs.Namespace, tracingVs.Name, clients.ReadOpts{Ctx: s.ctx})
-		},
-		core.Status_Accepted,
-		gloo_defaults.GlooReporter,
-	)
-
-	err = s.testInstallation.Actions.Kubectl().ApplyFile(s.ctx, gatewayConfigManifest,
-		"-n", s.testInstallation.Metadata.InstallNamespace)
-	s.NoError(err, "can create gateway and service")
-	s.testInstallation.Assertions.EventuallyResourceStatusMatchesState(
-		func() (resources.InputResource, error) {
-			return s.testInstallation.ResourceClients.GatewayClient().Read(
-				s.testInstallation.Metadata.InstallNamespace, "gateway-proxy-tracing", clients.ReadOpts{Ctx: s.ctx})
-		},
-		core.Status_Accepted,
-		gloo_defaults.GlooReporter,
-	)
-}
-
-func (s *testingSuite) AfterTest(string, string) {
-	var err error
-	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, setupOtelcolManifest)
-	s.Assertions.NoError(err, "can delete otel collector")
-
-	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, tracingConfigManifest)
-	s.Assertions.NoError(err, "can delete gloo tracing config")
-
-	err = s.testInstallation.Actions.Kubectl().DeleteFile(s.ctx, gatewayConfigManifest,
-		"-n", s.testInstallation.Metadata.InstallNamespace)
-	s.Assertions.NoError(err, "can delete gateway config")
-}
-
-func (s *testingSuite) TestSpanNameTransformationsWithoutRouteDecorator() {
-	testHostname := "test-really-cool-hostname.com"
-	s.testInstallation.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, testdefaults.CurlPodExecOpt,
-		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(metav1.ObjectMeta{
-				Name:      gatewayProxyHost,
-				Namespace: s.testInstallation.Metadata.InstallNamespace,
-			})),
-			curl.WithHostHeader(testHostname),
-			curl.WithPort(gatewayProxyPort),
-			curl.WithPath(pathWithoutRouteDescriptor),
-			// We are asserting that a request is consistent. To prevent flakes with that assertion,
-			// we should have some basic retries built into the request
-			curl.WithRetryConnectionRefused(true),
-			curl.WithRetries(3, 0, 10),
-			curl.Silent(),
-		},
-		&matchers.HttpResponse{
-			StatusCode: http.StatusOK,
-		},
-		5*time.Second, 30*time.Second,
-	)
-
-	s.EventuallyWithT(func(c *assert.CollectT) {
-		logs, err := s.testInstallation.Actions.Kubectl().GetContainerLogs(s.ctx, otelcolPod.ObjectMeta.GetNamespace(), otelcolPod.ObjectMeta.GetName())
-		assert.NoError(c, err, "can get otelcol logs")
-		// Looking for a line like this:
-		// Name       : <value of host header>
-		assert.Regexp(c, "Name *: "+testHostname, logs)
-	}, time.Second*30, time.Second*3, "otelcol logs contain span with name == hostname")
-}
-
-func (s *testingSuite) TestSpanNameTransformationsWithRouteDecorator() {
-	s.testInstallation.Assertions.AssertEventuallyConsistentCurlResponse(s.ctx, testdefaults.CurlPodExecOpt,
-		[]curl.Option{
-			curl.WithHost(kubeutils.ServiceFQDN(metav1.ObjectMeta{
-				Name:      gatewayProxyHost,
-				Namespace: s.testInstallation.Metadata.InstallNamespace,
-			})),
-			curl.WithHostHeader("example.com"),
-			curl.WithPort(gatewayProxyPort),
-			curl.WithPath(pathWithRouteDescriptor),
-			// We are asserting that a request is consistent. To prevent flakes with that assertion,
-			// we should have some basic retries built into the request
-			curl.WithRetryConnectionRefused(true),
-			curl.WithRetries(3, 0, 10),
-			curl.Silent(),
-		},
-		&matchers.HttpResponse{
-			StatusCode: http.StatusOK,
-		},
-		5*time.Second, 30*time.Second,
-	)
-
-	s.EventuallyWithT(func(c *assert.CollectT) {
-		logs, err := s.testInstallation.Actions.Kubectl().GetContainerLogs(s.ctx, otelcolPod.ObjectMeta.GetNamespace(), otelcolPod.ObjectMeta.GetName())
-		assert.NoError(c, err, "can get otelcol logs")
-		// Looking for a line like this:
-		// Name       : <value of routeDescriptorSpanName>
-		assert.Regexp(c, "Name *: "+routeDescriptorSpanName, logs)
-	}, time.Second*30, time.Second*3, "otelcol logs contain span with name == routeDescriptor")
-}
diff --git a/test/kubernetes/e2e/features/tracing_legacy/types.go b/test/kubernetes/e2e/features/tracing_legacy/types.go
deleted file mode 100644
index 279d04772..000000000
--- a/test/kubernetes/e2e/features/tracing_legacy/types.go
+++ /dev/null
@@ -1,42 +0,0 @@
-//go:build ignore
-
-package tracing
-
-import (
-	"path/filepath"
-
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/fsutils"
-)
-
-const (
-	pathWithRouteDescriptor    = "/path/with/route/descriptor"
-	pathWithoutRouteDescriptor = "/path/without/route/descriptor"
-	routeDescriptorSpanName    = "THISISAROUTEDESCRIPTOR"
-	gatewayProxyHost           = "gateway-proxy-tracing"
-	gatewayProxyPort           = 18080
-)
-
-var (
-	setupOtelcolManifest        = filepath.Join(fsutils.MustGetThisDir(), "testdata", "setup-otelcol.yaml")
-	tracingConfigManifest       = filepath.Join(fsutils.MustGetThisDir(), "testdata", "tracing.yaml")
-	gatewayConfigManifest       = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gateway.yaml")
-	gatewayProxyServiceManifest = filepath.Join(fsutils.MustGetThisDir(), "testdata", "gw-proxy-tracing-service.yaml")
-
-	otelcolPod = &corev1.Pod{
-		ObjectMeta: metav1.ObjectMeta{Name: "otel-collector", Namespace: "default"},
-	}
-	otelcolSelector = metav1.ListOptions{
-		LabelSelector: "app.kubernetes.io/name=otel-collector",
-	}
-	otelcolUpstream = &metav1.ObjectMeta{
-		Name:      "opentelemetry-collector",
-		Namespace: "default",
-	}
-	tracingVs = &metav1.ObjectMeta{
-		Name:      "virtual-service",
-		Namespace: "default",
-	}
-)
diff --git a/test/kubernetes/e2e/test.go b/test/kubernetes/e2e/test.go
index 545c78978..3c66d2a6e 100644
--- a/test/kubernetes/e2e/test.go
+++ b/test/kubernetes/e2e/test.go
@@ -182,7 +182,6 @@ func (i *TestInstallation) InstallKgatewayCoreFromLocalChart(ctx context.Context
 			ValuesFiles:     []string{i.Metadata.ProfileValuesManifestFile, i.Metadata.ValuesManifestFile},
 			ReleaseName:     helmutils.ChartName,
 			ChartUri:        chartUri,
-			ExtraArgs:       i.Metadata.ExtraHelmArgs,
 		})
 	i.Assertions.Require.NoError(err)
 	i.Assertions.EventuallyKgatewayInstallSucceeded(ctx)
diff --git a/test/kubernetes/e2e/tests/api_validation_test.go b/test/kubernetes/e2e/tests/api_validation_test.go
index 6379148a2..39c0b04e8 100644
--- a/test/kubernetes/e2e/tests/api_validation_test.go
+++ b/test/kubernetes/e2e/tests/api_validation_test.go
@@ -65,150 +65,6 @@ spec:
 `,
 			wantError: "at most one of the fields in [http1ProtocolOptions http2ProtocolOptions] may be set",
 		},
-		{
-			name: "BackendConfigPolicy: valid target references",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: BackendConfigPolicy
-metadata:
-  name: backend-config-valid-targets
-spec:
-  targetRefs:
-  - group: ""
-    kind: Service
-    name: test-service
-  - group: gateway.kgateway.dev
-    kind: Backend
-    name: test-backend
-  targetSelectors:
-  - group: ""
-    kind: Service
-    matchLabels:
-      app: myapp
-  http1ProtocolOptions:
-    enableTrailers: true
-`,
-		},
-		{
-			name: "BackendConfigPolicy: invalid target reference",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: BackendConfigPolicy
-metadata:
-  name: backend-config-invalid-target
-spec:
-  targetRefs:
-  - group: apps
-    kind: Deployment
-    name: test-deployment
-`,
-			wantError: "TargetRefs must reference either a Kubernetes Service or a Backend API",
-		},
-		{
-			name: "BackendConfigPolicy: invalid target selector",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: BackendConfigPolicy
-metadata:
-  name: backend-config-invalid-selector
-spec:
-  targetSelectors:
-  - group: apps
-    kind: Deployment
-    matchLabels:
-      app: myapp
-`,
-			wantError: "TargetSelectors must reference either a Kubernetes Service or a Backend API",
-		},
-		{
-			name: "TrafficPolicy: valid target references",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: TrafficPolicy
-metadata:
-  name: traffic-policy-valid-targets
-spec:
-  targetRefs:
-  - group: gateway.networking.k8s.io
-    kind: Gateway
-    name: test-gateway
-  - group: gateway.networking.k8s.io
-    kind: HTTPRoute
-    name: test-route
-  - group: gateway.networking.x-k8s.io
-    kind: XListenerSet
-    name: test-listener
-  targetSelectors:
-  - group: gateway.networking.k8s.io
-    kind: Gateway
-    matchLabels:
-      app: myapp
-`,
-		},
-		{
-			name: "TrafficPolicy: invalid target reference",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: TrafficPolicy
-metadata:
-  name: traffic-policy-invalid-target
-spec:
-  targetRefs:
-  - group: apps
-    kind: Deployment
-    name: test-deployment
-`,
-			wantError: "targetRefs may only reference Gateway, HTTPRoute, or XListenerSet resources",
-		},
-		{
-			name: "HTTPListenerPolicy: valid target references",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: HTTPListenerPolicy
-metadata:
-  name: http-listener-policy-valid-targets
-spec:
-  targetRefs:
-  - group: gateway.networking.k8s.io
-    kind: Gateway
-    name: test-gateway
-  targetSelectors:
-  - group: gateway.networking.k8s.io
-    kind: Gateway
-    matchLabels:
-      app: myapp
-`,
-		},
-		{
-			name: "HTTPListenerPolicy: invalid target reference - HTTPRoute not allowed",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: HTTPListenerPolicy
-metadata:
-  name: http-listener-policy-invalid-target-httproute
-spec:
-  targetRefs:
-  - group: gateway.networking.k8s.io
-    kind: HTTPRoute
-    name: test-route
-`,
-			wantError: "targetRefs may only reference Gateway resources",
-		},
-		{
-			name: "HTTPListenerPolicy: invalid target reference - wrong resource type",
-			input: `---
-apiVersion: gateway.kgateway.dev/v1alpha1
-kind: HTTPListenerPolicy
-metadata:
-  name: http-listener-policy-invalid-target
-spec:
-  targetRefs:
-  - group: gateway.networking.x-k8s.io
-    kind: XListenerSet
-    name: test-listener
-`,
-			wantError: "targetRefs may only reference Gateway resources",
-		},
 	}
 
 	t.Cleanup(func() {
diff --git a/test/kubernetes/e2e/tests/base/base_suite.go b/test/kubernetes/e2e/tests/base/base_suite.go
index 630bd5004..45eb4948a 100644
--- a/test/kubernetes/e2e/tests/base/base_suite.go
+++ b/test/kubernetes/e2e/tests/base/base_suite.go
@@ -8,7 +8,6 @@ import (
 
 	"github.com/onsi/gomega"
 	"github.com/stretchr/testify/suite"
-	appsv1 "k8s.io/api/apps/v1"
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"sigs.k8s.io/controller-runtime/pkg/client"
@@ -168,21 +167,7 @@ func (s *BaseTestingSuite) BeforeTest(suiteName, testName string) {
 		if pod, ok := resource.(*corev1.Pod); ok {
 			s.TestInstallation.Assertions.EventuallyPodsRunning(s.Ctx, pod.Namespace, metav1.ListOptions{
 				LabelSelector: fmt.Sprintf("app.kubernetes.io/name=%s", pod.Name),
-				// Provide a longer timeout as the pod needs to be pulled and pass HCs
-			}, time.Second*60, time.Second*2)
-		}
-		if deployment, ok := resource.(*appsv1.Deployment); ok {
-			if len(deployment.Labels) != 0 {
-				s.TestInstallation.Assertions.EventuallyPodsRunning(s.Ctx, deployment.Namespace, metav1.ListOptions{
-					LabelSelector: fmt.Sprintf("app=%s", deployment.Name),
-					// Provide a longer timeout as the pod needs to be pulled and pass HCs
-				}, time.Second*60, time.Second*2)
-			} else {
-				s.TestInstallation.Assertions.EventuallyPodsRunning(s.Ctx, deployment.Namespace, metav1.ListOptions{
-					LabelSelector: fmt.Sprintf("app.kubernetes.io/name=%s", deployment.Name),
-					// Provide a longer timeout as the pod needs to be pulled and pass HCs
-				}, time.Second*60, time.Second*2)
-			}
+			})
 		}
 	}
 }
diff --git a/test/kubernetes/e2e/tests/kgateway_test.go b/test/kubernetes/e2e/tests/kgateway_test.go
index 1b386eae5..70aa28a0f 100644
--- a/test/kubernetes/e2e/tests/kgateway_test.go
+++ b/test/kubernetes/e2e/tests/kgateway_test.go
@@ -21,9 +21,6 @@ func TestKgateway(t *testing.T) {
 			InstallNamespace:          installNs,
 			ProfileValuesManifestFile: e2e.CommonRecommendationManifest,
 			ValuesManifestFile:        e2e.EmptyValuesManifestPath,
-			ExtraHelmArgs: []string{
-				"--set", "controller.extraEnv.KGW_GLOBAL_POLICY_NAMESPACE=" + installNs,
-			},
 		},
 	)
 
diff --git a/test/kubernetes/e2e/tests/kgateway_tests.go b/test/kubernetes/e2e/tests/kgateway_tests.go
index f9d18e2d9..6d129a682 100644
--- a/test/kubernetes/e2e/tests/kgateway_tests.go
+++ b/test/kubernetes/e2e/tests/kgateway_tests.go
@@ -2,7 +2,7 @@ package tests
 
 import (
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/accesslog"
+	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/acesslog"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/backendconfigpolicy"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/backends"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/backendtls"
@@ -11,14 +11,12 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/csrf"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/deployer"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/dfp"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/directresponse"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/extauth"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/extproc"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/http_listener_policy"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/lambda"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/local_rate_limit"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/metrics"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/path_matching"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/policyselector"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/rate_limit"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/route_delegation"
@@ -26,10 +24,10 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/services/httproute"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/services/tcproute"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/services/tlsroute"
-	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/tracing"
 	"github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/transformation"
 	// "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/admin_server"
 	// "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/crd_categories"
+	// "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/directresponse"
 	// "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/headless_svc"
 	// "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/http_listener_options"
 	// "github.com/kgateway-dev/kgateway/v2/test/kubernetes/e2e/features/listener_options"
@@ -42,7 +40,7 @@ import (
 func KubeGatewaySuiteRunner() e2e.SuiteRunner {
 	kubeGatewaySuiteRunner := e2e.NewSuiteRunner(false)
 	kubeGatewaySuiteRunner.Register("ExtAuth", extauth.NewTestingSuite)
-	kubeGatewaySuiteRunner.Register("AccessLog", accesslog.NewTestingSuite)
+	kubeGatewaySuiteRunner.Register("AccessLog", acesslog.NewTestingSuite)
 	kubeGatewaySuiteRunner.Register("Backends", backends.NewTestingSuite)
 	kubeGatewaySuiteRunner.Register("BackendTLSPolicies", backendtls.NewTestingSuite)
 	kubeGatewaySuiteRunner.Register("BasicRouting", basicrouting.NewTestingSuite)
@@ -64,9 +62,6 @@ func KubeGatewaySuiteRunner() e2e.SuiteRunner {
 	kubeGatewaySuiteRunner.Register("BackendConfigPolicy", backendconfigpolicy.NewTestingSuite)
 	kubeGatewaySuiteRunner.Register("Metrics", metrics.NewTestingSuite)
 	kubeGatewaySuiteRunner.Register("CSRF", csrf.NewTestingSuite)
-	kubeGatewaySuiteRunner.Register("Tracing", tracing.NewTestingSuite)
-	kubeGatewaySuiteRunner.Register("DirectResponse", directresponse.NewTestingSuite)
-	kubeGatewaySuiteRunner.Register("PathMatching", path_matching.NewTestingSuite)
 
 	// kubeGatewaySuiteRunner.Register("HttpListenerOptions", http_listener_options.NewTestingSuite)
 	// kubeGatewaySuiteRunner.Register("ListenerOptions", listener_options.NewTestingSuite)
diff --git a/test/kubernetes/e2e/tests/manifests/ai-extension-helm.yaml b/test/kubernetes/e2e/tests/manifests/ai-extension-helm.yaml
index 250310a8d..c814be023 100644
--- a/test/kubernetes/e2e/tests/manifests/ai-extension-helm.yaml
+++ b/test/kubernetes/e2e/tests/manifests/ai-extension-helm.yaml
@@ -1,4 +1,4 @@
-# This file defines the minimal configuration for a user who wants to run kgateway with ai extensions and observability tracing enabled.
+# This file defines the minimal configuration for a user who wants to run kgateway with ai extnesions enabled.
 # These should be reviewed and tested before being adopted.
 
 image:
@@ -10,4 +10,4 @@ controller:
 
 gateway:
   aiExtension:
-    enabled: true
+    enabled: true
\ No newline at end of file
diff --git a/test/kubernetes/testutils/assertions/status.go b/test/kubernetes/testutils/assertions/status.go
index d6c509187..894337f90 100644
--- a/test/kubernetes/testutils/assertions/status.go
+++ b/test/kubernetes/testutils/assertions/status.go
@@ -15,7 +15,6 @@ import (
 	gwv1a2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gwxv1a1 "sigs.k8s.io/gateway-api/apisx/v1alpha1"
 
-	"github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	"github.com/kgateway-dev/kgateway/v2/test/gomega/matchers"
 	"github.com/kgateway-dev/kgateway/v2/test/helpers"
 )
@@ -423,32 +422,3 @@ func getListener(listeners []gwxv1a1.ListenerEntryStatus, name string) *gwxv1a1.
 	}
 	return nil
 }
-
-// EventuallyHTTPListenerPolicyCondition checks that provided HTTPListenerPolicy condition is set to expect.
-func (p *Provider) EventuallyHTTPListenerPolicyCondition(
-	ctx context.Context,
-	name string,
-	namespace string,
-	cond gwv1.GatewayConditionType,
-	expect metav1.ConditionStatus,
-	timeout ...time.Duration,
-) {
-	ginkgo.GinkgoHelper()
-	currentTimeout, pollingInterval := helpers.GetTimeouts(timeout...)
-	p.Gomega.Eventually(func(g gomega.Gomega) {
-		hlp := &v1alpha1.HTTPListenerPolicy{}
-		err := p.clusterContext.Client.Get(ctx, types.NamespacedName{Name: name, Namespace: namespace}, hlp)
-		g.Expect(err).NotTo(gomega.HaveOccurred(), "failed to get HTTPListenerPolicy %s/%s", namespace, name)
-
-		var conditionFound bool
-		for _, parentStatus := range hlp.Status.Ancestors {
-			condition := getConditionByType(parentStatus.Conditions, string(cond))
-			if condition != nil && condition.Status == expect {
-				conditionFound = true
-				break
-			}
-		}
-		g.Expect(conditionFound).To(gomega.BeTrue(), fmt.Sprintf("%v condition is not %v for any parent of HTTPListenerPolicy %s/%s",
-			cond, expect, namespace, name))
-	}, currentTimeout, pollingInterval).Should(gomega.Succeed())
-}
diff --git a/test/kubernetes/testutils/helper/install.go b/test/kubernetes/testutils/helper/install.go
index cf2a97277..d9f1dd411 100644
--- a/test/kubernetes/testutils/helper/install.go
+++ b/test/kubernetes/testutils/helper/install.go
@@ -4,6 +4,7 @@ import (
 	"fmt"
 	"path/filepath"
 
+	"github.com/pkg/errors"
 	"github.com/solo-io/go-utils/log"
 	"helm.sh/helm/v3/pkg/repo"
 
@@ -27,7 +28,7 @@ func GetLocalChartPath(chartName string) (string, error) {
 
 	version, err := getChartVersion(testAssetDir, chartName)
 	if err != nil {
-		return "", fmt.Errorf("getting Helm chart version: %w", err)
+		return "", errors.Wrapf(err, "getting Helm chart version")
 	}
 	return filepath.Join(testAssetDir, fmt.Sprintf("%s-%s.tgz", chartName, version)), nil
 }
@@ -38,7 +39,7 @@ func getChartVersion(testAssetDir string, chartName string) (string, error) {
 	helmIndexPath := filepath.Join(testAssetDir, HelmRepoIndexFileName)
 	helmIndex, err := repo.LoadIndexFile(helmIndexPath)
 	if err != nil {
-		return "", fmt.Errorf("parsing Helm index file: %w", err)
+		return "", errors.Wrapf(err, "parsing Helm index file")
 	}
 	log.Printf("found Helm index file at: %s", helmIndexPath)
 
diff --git a/test/kubernetes/testutils/install/context.go b/test/kubernetes/testutils/install/context.go
index 363c6e946..4f751cbf9 100644
--- a/test/kubernetes/testutils/install/context.go
+++ b/test/kubernetes/testutils/install/context.go
@@ -14,9 +14,6 @@ type Context struct {
 
 	// ValuesManifestFile points to the file that contains the set of Helm values that are unique to this test
 	ValuesManifestFile string
-
-	// ExtraHelmArgs are additional Helm arguments
-	ExtraHelmArgs []string
 }
 
 // ValidateInstallContext returns an error if the provided Context is invalid
diff --git a/test/services/docker.go b/test/services/docker.go
index 9b5ea79b4..0c78f7407 100644
--- a/test/services/docker.go
+++ b/test/services/docker.go
@@ -15,6 +15,7 @@ import (
 	. "github.com/onsi/gomega"
 
 	"github.com/onsi/ginkgo/v2"
+	"github.com/pkg/errors"
 )
 
 const (
@@ -39,7 +40,7 @@ func RunContainer(containerName string, args []string) error {
 	cmd.Stderr = ginkgo.GinkgoWriter
 	err := cmd.Run()
 	if err != nil {
-		return fmt.Errorf("Unable to start %s container: %w", containerName, err)
+		return errors.Wrap(err, "Unable to start "+containerName+" container")
 	}
 	return nil
 }
@@ -60,7 +61,7 @@ func ExecOnContainer(containerName string, args []string) ([]byte, error) {
 	cmd := exec.Command("docker", arguments...)
 	out, err := cmd.CombinedOutput()
 	if err != nil {
-		return nil, fmt.Errorf("Unable to execute command %v on [%s] container [%s]: %w", arguments, containerName, out, err)
+		return nil, errors.Wrapf(err, "Unable to execute command %v on [%s] container [%s]", arguments, containerName, out)
 	}
 	return out, nil
 }
@@ -97,7 +98,7 @@ func WaitUntilContainerRemoved(containerName string) error {
 		inspectErr := exec.Command("docker", "inspect", containerName).Run()
 		if inspectErr == nil {
 			// If there is no error, it means the container still exists, so we want to retry
-			return fmt.Errorf("container %s still exists", containerName)
+			return errors.Errorf("container %s still exists", containerName)
 		}
 		return nil
 	},
diff --git a/test/testutils/version/changelog.go b/test/testutils/version/changelog.go
index 79a6507e1..bdcda39d1 100644
--- a/test/testutils/version/changelog.go
+++ b/test/testutils/version/changelog.go
@@ -3,12 +3,11 @@
 package version
 
 import (
-	"errors"
-	"fmt"
 	"os"
 	"path/filepath"
 	"sort"
 
+	"github.com/pkg/errors"
 	"github.com/solo-io/go-utils/changelogutils"
 	"github.com/solo-io/go-utils/versionutils"
 
@@ -43,7 +42,7 @@ func ChangelogDirForLatestRelease[T namedEntry](files ...T) (
 	currentRelease *versionutils.Version, unreleasedVersion *versionutils.Version, err error) {
 
 	if len(files) < 3 {
-		return nil, nil, fmt.Errorf("Could not get sufficient versions from files: %v\n", files)
+		return nil, nil, errors.Errorf("Could not get sufficient versions from files: %v\n", files)
 	}
 
 	versions := make([]*versionutils.Version, 0, len(files))
@@ -57,7 +56,7 @@ func ChangelogDirForLatestRelease[T namedEntry](files ...T) (
 		}
 	}
 	if len(versions) < 2 {
-		return nil, nil, fmt.Errorf("Could not get sufficient valid versions from files: %v\n", files)
+		return nil, nil, errors.Errorf("Could not get sufficient valid versions from files: %v\n", files)
 	}
 
 	sort.Sort(sortableVersionSlice(versions))
diff --git a/test/translator/file_loader.go b/test/translator/file_loader.go
index 551710894..0edd8492d 100644
--- a/test/translator/file_loader.go
+++ b/test/translator/file_loader.go
@@ -4,7 +4,6 @@ import (
 	"bytes"
 	"context"
 	"encoding/json"
-	"errors"
 	"fmt"
 	"io/fs"
 	"log/slog"
@@ -18,6 +17,7 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/pkg/utils/protoutils"
 
 	"github.com/ghodss/yaml"
+	"github.com/pkg/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/runtime/schema"
@@ -65,7 +65,7 @@ func LoadFromFiles(ctx context.Context, filename string, scheme *runtime.Scheme)
 		for _, obj := range objs {
 			clientObj, ok := obj.(client.Object)
 			if !ok {
-				return nil, fmt.Errorf("cannot convert runtime.Object to client.Object: %+v", obj)
+				return nil, errors.Errorf("cannot convert runtime.Object to client.Object: %+v", obj)
 			}
 
 			_, isGwc := clientObj.(*gwv1.GatewayClass)
diff --git a/test/translator/test.go b/test/translator/test.go
index 848bcf6a3..b76299995 100644
--- a/test/translator/test.go
+++ b/test/translator/test.go
@@ -350,14 +350,8 @@ func ReadYamlFile(file string, out interface{}) error {
 	return UnmarshalAnyYaml(data, out)
 }
 
-func GetHTTPRouteStatusError(
-	reportsMap reports.ReportMap,
-	route *types.NamespacedName,
-) error {
+func AreReportsSuccess(gwNN types.NamespacedName, reportsMap reports.ReportMap) error {
 	for nns, routeReport := range reportsMap.HTTPRoutes {
-		if route != nil && nns != *route {
-			continue
-		}
 		for ref, parentRefReport := range routeReport.Parents {
 			for _, c := range parentRefReport.Conditions {
 				// most route conditions true is good, except RouteConditionPartiallyInvalid
@@ -369,15 +363,6 @@ func GetHTTPRouteStatusError(
 			}
 		}
 	}
-	return nil
-}
-
-func AreReportsSuccess(gwNN types.NamespacedName, reportsMap reports.ReportMap) error {
-	err := GetHTTPRouteStatusError(reportsMap, nil)
-	if err != nil {
-		return err
-	}
-
 	for nns, routeReport := range reportsMap.TCPRoutes {
 		for ref, parentRefReport := range routeReport.Parents {
 			for _, c := range parentRefReport.Conditions {
