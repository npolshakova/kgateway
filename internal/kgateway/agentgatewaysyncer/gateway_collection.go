package agentgatewaysyncer

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/agentgateway/agentgateway/go/api"
	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
	"istio.io/istio/pkg/kube/krt"
	"k8s.io/apimachinery/pkg/types"
)

var gatewayLogger = logging.New("agentgateway/gateway-collection")

// AgentGatewayResource represents a translated gateway resource for agentgateway
type AgentGatewayResource struct {
	types.NamespacedName
	Bind     *Bind
	Listener *Listener
	Routes   []*Route
	Valid    bool
}

func (r AgentGatewayResource) ResourceName() string {
	return fmt.Sprintf("%s/%s", r.Namespace, r.Name)
}

func (r AgentGatewayResource) Equals(other AgentGatewayResource) bool {
	if r.NamespacedName != other.NamespacedName || r.Valid != other.Valid {
		return false
	}
	if r.Bind == nil && other.Bind != nil || r.Bind != nil && other.Bind == nil {
		return false
	}
	if r.Bind != nil && !r.Bind.Equals(*other.Bind) {
		return false
	}
	if r.Listener == nil && other.Listener != nil || r.Listener != nil && other.Listener == nil {
		return false
	}
	if r.Listener != nil && !r.Listener.Equals(*other.Listener) {
		return false
	}
	if len(r.Routes) != len(other.Routes) {
		return false
	}
	for i, route := range r.Routes {
		if !route.Equals(*other.Routes[i]) {
			return false
		}
	}
	return true
}

// Bind represents an agentgateway bind resource
type Bind struct {
	*api.Bind
}

func (b Bind) ResourceName() string {
	return b.Key
}

func (b Bind) Equals(other Bind) bool {
	return b.Key == other.Key && b.Port == other.Port
}

// Listener represents an agentgateway listener resource
type Listener struct {
	*api.Listener
}

func (l Listener) ResourceName() string {
	return l.Key
}

func (l Listener) Equals(other Listener) bool {
	return l.Key == other.Key && l.Name == other.Name && l.BindKey == other.BindKey &&
		l.GatewayName == other.GatewayName && l.Protocol == other.Protocol
}

// Route represents an agentgateway route resource
type Route struct {
	*api.Route
}

func (r Route) ResourceName() string {
	return r.Key
}

func (r Route) Equals(other Route) bool {
	return r.Key == other.Key && r.ListenerKey == other.ListenerKey &&
		r.RuleName == other.RuleName && r.RouteName == other.RouteName
}

// ServiceBackend represents a service backend for routing
type ServiceBackend struct {
	Name      string
	Namespace string
	Port      int32
	Weight    int32
	Protocol  string
}

// Helper to map string to api.AppProtocol enum
func toAgentGatewayAppProtocol(proto string) api.AppProtocol {
	switch proto {
	case "http/1.1":
		return api.AppProtocol_HTTP11
	case "http2":
		return api.AppProtocol_HTTP2
	case "grpc":
		return api.AppProtocol_GRPC
	default:
		return api.AppProtocol_UNKNOWN
	}
}

// AgentGatewayCollection creates a collection that translates Gateway resources to agentgateway resources
func AgentGatewayCollection(
	gateways krt.Collection[ir.Gateway],
	services krt.Collection[ServiceInfo],
	krtopts krtutil.KrtOptions,
) krt.Collection[AgentGatewayResource] {
	return krt.NewCollection(gateways, func(kctx krt.HandlerContext, gw ir.Gateway) *AgentGatewayResource {
		if gw.Obj.Spec.GatewayClassName != wellknown.AgentGatewayClassName {
			return nil
		}

		// Group listeners by port
		portToListeners := make(map[int][]ir.Listener)
		for _, listener := range gw.Listeners {
			// Support any protocol that's configured
			portToListeners[int(listener.Port)] = append(portToListeners[int(listener.Port)], listener)
		}

		// For now, we'll create resources for the first port only
		// In the future, this could be extended to handle multiple ports
		var firstPort int
		var firstListeners []ir.Listener
		for port, listeners := range portToListeners {
			firstPort = port
			firstListeners = listeners
			break
		}

		if len(firstListeners) == 0 {
			gatewayLogger.Warn("no valid listeners found for gateway", "gateway", gw.Name)
			return &AgentGatewayResource{
				NamespacedName: types.NamespacedName{Namespace: gw.Namespace, Name: gw.Name},
				Valid:          false,
			}
		}

		// Create bind resource
		bindKey := fmt.Sprintf("bind-%s-%d", gw.Name, firstPort)
		bind := &Bind{
			Bind: &api.Bind{
				Key:  bindKey,
				Port: uint32(firstPort),
			},
		}

		// Create listener resource
		listenerKey := fmt.Sprintf("listener-%s-%d", gw.Name, firstPort)
		listener := &Listener{
			Listener: &api.Listener{
				Key:         listenerKey,
				Name:        "default",
				BindKey:     bindKey,
				GatewayName: gw.Name,
				Protocol:    api.Protocol_HTTP,
			},
		}

		// Routes will be generated by the route collection
		return &AgentGatewayResource{
			NamespacedName: types.NamespacedName{Namespace: gw.Namespace, Name: gw.Name},
			Bind:           bind,
			Listener:       listener,
			Routes:         []*Route{}, // Empty - routes will be added by route collection
			Valid:          true,
		}
	}, krtopts.ToOptions("agentgateway-gateway-collection")...)
}

// getTargetName sanitizes the given resource name to ensure it matches the AgentGateway required pattern:
// ^[a-zA-Z0-9-]+$ by replacing slashes and removing invalid characters.
func getTargetName(resourceName string) string {
	var (
		invalidCharsRegex      = regexp.MustCompile(`[^a-zA-Z0-9-]+`)
		consecutiveDashesRegex = regexp.MustCompile(`-+`)
	)

	// Replace all invalid characters with dashes
	sanitized := invalidCharsRegex.ReplaceAllString(resourceName, "-")

	// Remove leading/trailing dashes and collapse consecutive dashes
	sanitized = strings.Trim(sanitized, "-")
	sanitized = consecutiveDashesRegex.ReplaceAllString(sanitized, "-")

	return sanitized
}
