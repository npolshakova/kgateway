From 15224362e06d33bbb4d6e2ff822367bc68198d21 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Sun, 29 Jun 2025 21:11:26 -0700
Subject: [PATCH 01/17] wip

---
 go.mod                                        |   73 +-
 go.sum                                        |   66 +-
 internal/kgateway/agentgatewaysyncer/const.go |   14 +-
 .../agentgatewaysyncer/gateway/adp.go         |  245 ++
 .../agentgatewaysyncer/gateway/conditions.go  |  378 +++
 .../gateway/conditions_test.go                |  124 +
 .../agentgatewaysyncer/gateway/context.go     |  160 ++
 .../agentgatewaysyncer/gateway/controller.go  |  677 +++++
 .../gateway/controller_test.go                |  137 +
 .../agentgatewaysyncer/gateway/conversion.go  | 2404 +++++++++++++++++
 .../gateway/conversion_test.go                | 1560 +++++++++++
 .../gateway/deploymentcontroller.go           |  952 +++++++
 .../gateway/deploymentcontroller_test.go      |  683 +++++
 .../gateway/gateway_collection.go             |  294 ++
 .../gateway/gatewayclass.go                   |  118 +
 .../gateway/gatewayclass_collection.go        |   67 +
 .../gateway/gatewayclass_test.go              |   93 +
 .../agentgatewaysyncer/gateway/leak_test.go   |   25 +
 .../agentgatewaysyncer/gateway/model.go       |   15 +
 .../gateway/references_collection.go          |  164 ++
 .../gateway/route_collections.go              |  686 +++++
 .../agentgatewaysyncer/gateway/status.go      |   90 +
 .../agentgatewaysyncer/gateway/status_test.go |  104 +
 .../gateway/supported_features.go             |   21 +
 .../kgateway/agentgatewaysyncer/syncer.go     |  305 +--
 .../agentgatewaysyncer/syncer_test.go         |  219 +-
 internal/kgateway/setup/agentgateway_test.go  |  321 ---
 internal/kgateway/setup/setup_test.go         |  190 +-
 28 files changed, 9142 insertions(+), 1043 deletions(-)
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/adp.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/conditions.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/context.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/controller.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/controller_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/conversion.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/leak_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/model.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/status.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/status_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/supported_features.go

diff --git a/go.mod b/go.mod
index 54e744d98..0d9a91942 100644
--- a/go.mod
+++ b/go.mod
@@ -21,8 +21,9 @@ require (
 	github.com/kelseyhightower/envconfig v1.4.0
 	github.com/mitchellh/hashstructure v1.0.0
 	github.com/onsi/ginkgo/v2 v2.23.3
-	github.com/onsi/gomega v1.37.0
+	github.com/onsi/gomega v1.36.3
 	github.com/pkg/errors v0.9.1
+	github.com/rotisserie/eris v0.5.4
 	github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966
 	github.com/solo-io/go-list-licenses v0.1.4
 	github.com/solo-io/go-utils v0.27.3
@@ -32,17 +33,17 @@ require (
 	go.opencensus.io v0.24.0
 	go.uber.org/zap v1.27.0
 	golang.org/x/exp v0.0.0-20241215155358-4a5509556b9e
-	golang.org/x/net v0.41.0
+	golang.org/x/net v0.40.0
 	google.golang.org/grpc v1.72.0
 	google.golang.org/protobuf v1.36.6
 	helm.sh/helm/v3 v3.17.3
 	istio.io/api v1.25.0-alpha.0.0.20250210220544-0b64afd2de85
 	istio.io/client-go v1.25.0-alpha.0.0.20250210220843-5a4065fded65
 	istio.io/istio v0.0.0-20250212203644-c2ac935c5888
-	k8s.io/api v0.33.2
-	k8s.io/apiextensions-apiserver v0.33.2
-	k8s.io/apimachinery v0.33.2
-	k8s.io/client-go v0.33.2
+	k8s.io/api v0.32.3
+	k8s.io/apiextensions-apiserver v0.32.3
+	k8s.io/apimachinery v0.32.3
+	k8s.io/client-go v0.32.3
 	k8s.io/klog/v2 v2.130.1
 	k8s.io/kube-openapi v0.0.0-20250318190949-c8a335a9a2ff
 	k8s.io/utils v0.0.0-20241210054802-24370beab758
@@ -62,13 +63,20 @@ require (
 	github.com/dlclark/regexp2 v1.11.5 // indirect
 	github.com/elliotchance/orderedmap v1.8.0 // indirect
 	github.com/goccy/go-yaml v1.17.1 // indirect
+	github.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc // indirect
+	github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3 // indirect
 	github.com/jinzhu/copier v0.4.0 // indirect
 	github.com/manuelarte/funcorder v0.2.1 // indirect
 	github.com/mikefarah/yq/v4 v4.45.4 // indirect
-	github.com/rotisserie/eris v0.5.4 // indirect
+	github.com/openshift/api v0.0.0-20250122093221-e6cc8f6fd74c // indirect
+	github.com/prometheus/prometheus v0.301.0 // indirect
+	github.com/yl2chen/cidranger v1.0.2 // indirect
 	github.com/yuin/gopher-lua v1.1.1 // indirect
 	go.augendre.info/fatcontext v0.8.0 // indirect
+	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.34.0 // indirect
+	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.34.0 // indirect
 	gopkg.in/op/go-logging.v1 v1.0.0-20160211212156-b2cb9fa56473 // indirect
+	sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.1 // indirect
 )
 
 require (
@@ -96,8 +104,8 @@ require (
 	github.com/Antonboom/nilnil v1.1.0 // indirect
 	github.com/Antonboom/testifylint v1.6.1 // indirect
 	github.com/Azure/azure-sdk-for-go v68.0.0+incompatible // indirect
-	github.com/Azure/azure-sdk-for-go/sdk/azcore v1.14.0 // indirect
-	github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.7.0 // indirect
+	github.com/Azure/azure-sdk-for-go/sdk/azcore v1.16.0 // indirect
+	github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.0 // indirect
 	github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0 // indirect
 	github.com/Azure/azure-sdk-for-go/sdk/keyvault/azkeys v0.10.0 // indirect
 	github.com/Azure/azure-sdk-for-go/sdk/keyvault/internal v0.7.1 // indirect
@@ -295,7 +303,7 @@ require (
 	github.com/goccy/go-json v0.10.5 // indirect
 	github.com/gofrs/flock v0.12.1 // indirect
 	github.com/gogo/protobuf v1.3.2 // indirect
-	github.com/golang-jwt/jwt/v4 v4.5.2 // indirect
+	github.com/golang-jwt/jwt/v4 v4.5.1 // indirect
 	github.com/golang-jwt/jwt/v5 v5.2.1 // indirect
 	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
 	github.com/golang/protobuf v1.5.4 // indirect
@@ -309,11 +317,12 @@ require (
 	github.com/golangci/revgrep v0.8.0 // indirect
 	github.com/golangci/unconvert v0.0.0-20250410112200-a129a6e6413e // indirect
 	github.com/google/btree v1.1.3 // indirect
-	github.com/google/cel-go v0.23.2 // indirect
+	github.com/google/cel-go v0.22.1 // indirect
 	github.com/google/gnostic-models v0.6.9 // indirect
 	github.com/google/go-containerregistry v0.20.3 // indirect
 	github.com/google/go-github/v68 v68.0.0 // indirect
 	github.com/google/go-querystring v1.1.0 // indirect
+	github.com/google/gofuzz v1.2.0 // indirect
 	github.com/google/ko v0.17.1 // indirect
 	github.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad // indirect
 	github.com/google/rpmpack v0.6.1-0.20240329070804-c2247cbb881a // indirect
@@ -330,7 +339,7 @@ require (
 	github.com/goreleaser/goreleaser/v2 v2.5.1 // indirect
 	github.com/goreleaser/nfpm/v2 v2.41.1 // indirect
 	github.com/gorilla/mux v1.8.1 // indirect
-	github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674 // indirect
+	github.com/gorilla/websocket v1.5.3 // indirect
 	github.com/gostaticanalysis/analysisutil v0.7.1 // indirect
 	github.com/gostaticanalysis/comment v1.5.0 // indirect
 	github.com/gostaticanalysis/forcetypeassert v0.2.0 // indirect
@@ -340,7 +349,7 @@ require (
 	github.com/hashicorp/errwrap v1.1.0 // indirect
 	github.com/hashicorp/go-cleanhttp v0.5.2 // indirect
 	github.com/hashicorp/go-immutable-radix/v2 v2.1.0 // indirect
-	github.com/hashicorp/go-multierror v1.1.1 // indirect
+	github.com/hashicorp/go-multierror v1.1.1
 	github.com/hashicorp/go-retryablehttp v0.7.7 // indirect
 	github.com/hashicorp/go-version v1.7.0 // indirect
 	github.com/hashicorp/golang-lru v1.0.2 // indirect
@@ -378,7 +387,7 @@ require (
 	github.com/kevinburke/ssh_config v1.2.0 // indirect
 	github.com/kisielk/errcheck v1.9.0 // indirect
 	github.com/kkHAIKE/contextcheck v1.1.6 // indirect
-	github.com/klauspost/compress v1.18.0 // indirect
+	github.com/klauspost/compress v1.17.11 // indirect
 	github.com/klauspost/cpuid/v2 v2.2.7 // indirect
 	github.com/klauspost/pgzip v1.2.6 // indirect
 	github.com/kulti/thelper v0.6.3 // indirect
@@ -463,8 +472,8 @@ require (
 	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
 	github.com/polydawn/refmt v0.89.1-0.20221221234430-40501e09de1f // indirect
 	github.com/polyfloyd/go-errorlint v1.8.0 // indirect
-	github.com/prometheus/client_golang v1.22.0
-	github.com/prometheus/client_model v0.6.2
+	github.com/prometheus/client_golang v1.21.1 // indirect
+	github.com/prometheus/client_model v0.6.2 // indirect
 	github.com/prometheus/common v0.62.0 // indirect
 	github.com/prometheus/procfs v0.15.1 // indirect
 	github.com/prometheus/statsd_exporter v0.25.0 // indirect
@@ -484,6 +493,7 @@ require (
 	github.com/ryanrolds/sqlclosecheck v0.5.1 // indirect
 	github.com/sagikazarmark/locafero v0.6.0 // indirect
 	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
+	github.com/saiskee/gettercheck v0.0.0-20210820204958-38443d06ebe0 // indirect
 	github.com/sanposhiho/wastedassign/v2 v2.1.0 // indirect
 	github.com/santhosh-tekuri/jsonschema/v6 v6.0.1 // indirect
 	github.com/sashamelentyev/interfacebloat v1.1.0 // indirect
@@ -563,20 +573,20 @@ require (
 	go.opentelemetry.io/otel/sdk/metric v1.34.0 // indirect
 	go.opentelemetry.io/otel/trace v1.34.0 // indirect
 	go.opentelemetry.io/proto/otlp v1.6.0 // indirect
-	go.uber.org/atomic v1.11.0 // indirect
+	go.uber.org/atomic v1.11.0
 	go.uber.org/automaxprocs v1.6.0 // indirect
 	go.uber.org/multierr v1.11.0 // indirect
 	gocloud.dev v0.40.0 // indirect
-	golang.org/x/crypto v0.39.0 // indirect
+	golang.org/x/crypto v0.38.0 // indirect
 	golang.org/x/exp/typeparams v0.0.0-20250210185358-939b2ce775ac // indirect
-	golang.org/x/mod v0.25.0 // indirect
+	golang.org/x/mod v0.24.0 // indirect
 	golang.org/x/oauth2 v0.28.0 // indirect
-	golang.org/x/sync v0.15.0 // indirect
+	golang.org/x/sync v0.14.0 // indirect
 	golang.org/x/sys v0.33.0 // indirect
 	golang.org/x/term v0.32.0 // indirect
-	golang.org/x/text v0.26.0 // indirect
+	golang.org/x/text v0.25.0 // indirect
 	golang.org/x/time v0.11.0 // indirect
-	golang.org/x/tools v0.34.0 // indirect
+	golang.org/x/tools v0.32.0 // indirect
 	golang.org/x/xerrors v0.0.0-20240716161551-93cc26a95ae9 // indirect
 	gomodules.xyz/jsonpatch/v2 v2.4.0 // indirect
 	google.golang.org/api v0.228.0 // indirect
@@ -592,18 +602,18 @@ require (
 	gopkg.in/yaml.v2 v2.4.0 // indirect
 	gopkg.in/yaml.v3 v3.0.1 // indirect
 	honnef.co/go/tools v0.6.1 // indirect
-	k8s.io/apiserver v0.33.2 // indirect
+	k8s.io/apiserver v0.32.3 // indirect
 	k8s.io/cli-runtime v0.32.3 // indirect
-	k8s.io/code-generator v0.33.2 // indirect
-	k8s.io/component-base v0.33.2 // indirect
-	k8s.io/gengo/v2 v2.0.0-20250207200755-1244d31929d7 // indirect
+	k8s.io/code-generator v0.32.3 // indirect
+	k8s.io/component-base v0.32.3 // indirect
+	k8s.io/gengo/v2 v2.0.0-20240911193312-2b36238f13e9 // indirect
 	k8s.io/kubectl v0.32.3 // indirect
 	lukechampine.com/blake3 v1.2.1 // indirect
 	mvdan.cc/gofumpt v0.8.0 // indirect
 	mvdan.cc/unparam v0.0.0-20250301125049-0df0534333a4 // indirect
 	oras.land/oras-go v1.2.5 // indirect
 	sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235 // indirect
-	sigs.k8s.io/controller-tools v0.18.1-0.20250625175829-8d11ce77f347 // indirect
+	sigs.k8s.io/controller-tools v0.17.3 // indirect
 	sigs.k8s.io/json v0.0.0-20241014173422-cfa47c3a1cc8 // indirect
 	sigs.k8s.io/kind v0.27.0 // indirect
 	sigs.k8s.io/kustomize/api v0.18.0 // indirect
@@ -613,10 +623,10 @@ require (
 	software.sslmate.com/src/go-pkcs12 v0.5.0 // indirect
 )
 
-// Remove once https://github.com/kubernetes-sigs/controller-tools/pull/1224 merges
-replace sigs.k8s.io/controller-tools => github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132
-
-replace github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
+replace (
+	github.com/agentgateway/agentgateway => github.com/solo-io/agentgateway-enterprise v0.0.0-20250625151206-94c5ea602e02
+	github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
+)
 
 // Use a patched version of gengo to produce consistent zz_generated.openapi.go
 // Ref: https://github.com/kubernetes/gengo/issues/292
@@ -628,6 +638,7 @@ tool (
 	github.com/goreleaser/goreleaser/v2
 	github.com/mikefarah/yq/v4
 	github.com/onsi/ginkgo/v2/ginkgo
+	github.com/saiskee/gettercheck
 	golang.org/x/tools/cmd/goimports
 	helm.sh/helm/v3/cmd/helm
 	k8s.io/code-generator/cmd/applyconfiguration-gen
diff --git a/go.sum b/go.sum
index a314c8192..57183d0f2 100644
--- a/go.sum
+++ b/go.sum
@@ -104,10 +104,12 @@ github.com/Antonboom/testifylint v1.6.1 h1:6ZSytkFWatT8mwZlmRCHkWz1gPi+q6UBSbiej
 github.com/Antonboom/testifylint v1.6.1/go.mod h1:k+nEkathI2NFjKO6HvwmSrbzUcQ6FAnbZV+ZRrnXPLI=
 github.com/Azure/azure-sdk-for-go v68.0.0+incompatible h1:fcYLmCpyNYRnvJbPerq7U0hS+6+I79yEDJBqVNcqUzU=
 github.com/Azure/azure-sdk-for-go v68.0.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=
-github.com/Azure/azure-sdk-for-go/sdk/azcore v1.14.0 h1:nyQWyZvwGTvunIMxi1Y9uXkcyr+I7TeNrr/foo4Kpk8=
-github.com/Azure/azure-sdk-for-go/sdk/azcore v1.14.0/go.mod h1:l38EPgmsp71HHLq9j7De57JcKOWPyhrsW1Awm1JS6K0=
-github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.7.0 h1:tfLQ34V6F7tVSwoTf/4lH5sE0o6eCJuNDTmH09nDpbc=
-github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.7.0/go.mod h1:9kIvujWAA58nmPmWB1m23fyWic1kYZMxD9CxaWn4Qpg=
+github.com/Azure/azure-sdk-for-go/sdk/azcore v1.16.0 h1:JZg6HRh6W6U4OLl6lk7BZ7BLisIzM9dG1R50zUk9C/M=
+github.com/Azure/azure-sdk-for-go/sdk/azcore v1.16.0/go.mod h1:YL1xnZ6QejvQHWJrX/AvhFl4WW4rqHVoKspWNVwFk0M=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.0 h1:B/dfvscEQtew9dVuoxqxrUKKv8Ih2f55PydknDamU+g=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.0/go.mod h1:fiPSssYvltE08HJchL04dOy+RD4hgrjph0cwGGMntdI=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity/cache v0.3.0 h1:+m0M/LFxN43KvULkDNfdXOgrjtg6UYJPFBJyuEcRCAw=
+github.com/Azure/azure-sdk-for-go/sdk/azidentity/cache v0.3.0/go.mod h1:PwOyop78lveYMRs6oCxjiVyBdyCgIYH6XHIVZO9/SFQ=
 github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0 h1:ywEEhmNahHBihViHepv3xPBn1663uRv2t2q/ESv9seY=
 github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0/go.mod h1:iZDifYGJTIgIIkYRNWPENUnqx6bJ2xnSDFI2tjwZNuY=
 github.com/Azure/azure-sdk-for-go/sdk/keyvault/azkeys v0.10.0 h1:m/sWOGCREuSBqg2htVQTBY8nOZpyajYztF0vUvSZTuM=
@@ -149,6 +151,8 @@ github.com/Azure/go-autorest/logger v0.2.1 h1:IG7i4p/mDa2Ce4TRyAO8IHnVhAVF3RFU+Z
 github.com/Azure/go-autorest/logger v0.2.1/go.mod h1:T9E3cAhj2VqvPOtCYAvby9aBXkZmbF5NWuPV8+WeEW8=
 github.com/Azure/go-autorest/tracing v0.6.0 h1:TYi4+3m5t6K48TGI9AUdb+IzbnSxvnvUMfuitfgcfuo=
 github.com/Azure/go-autorest/tracing v0.6.0/go.mod h1:+vhtPC754Xsa23ID7GlGsrdKBpUA79WCAKPPZVC2DeU=
+github.com/AzureAD/microsoft-authentication-extensions-for-go/cache v0.1.1 h1:WJTmL004Abzc5wDB5VtZG2PJk5ndYDgVacGqfirKxjM=
+github.com/AzureAD/microsoft-authentication-extensions-for-go/cache v0.1.1/go.mod h1:tCcJZ0uHAmvjsVYzEFivsRTN00oz5BEsRgQHu5JZ9WE=
 github.com/AzureAD/microsoft-authentication-library-for-go v1.2.2 h1:XHOnouVk1mxXfQidrMEnLlPk9UMeRtyBTnEFtxkV0kU=
 github.com/AzureAD/microsoft-authentication-library-for-go v1.2.2/go.mod h1:wP83P5OoQ5p6ip3ScPr0BAq0BvuPAvacpEuSzyouqAI=
 github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
@@ -214,9 +218,9 @@ github.com/a8m/envsubst v1.4.3 h1:kDF7paGK8QACWYaQo6KtyYBozY2jhQrTuNNuUxQkhJY=
 github.com/a8m/envsubst v1.4.3/go.mod h1:4jjHWQlZoaXPoLQUb7H2qT4iLkZDdmEQiOUogdUmqVU=
 github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d h1:licZJFw2RwpHMqeKTCYkitsPqHNxTmd4SNR5r94FGM8=
 github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d/go.mod h1:asat636LX7Bqt5lYEZ27JNDcqxfjdBQuJ/MM4CN/Lzo=
-github.com/agentgateway/agentgateway v0.4.31-0.20250519135723-61536c2b3fa0 h1:4THComsdsccCKRdO3lFinPZId6/ISSk6ijEiO44KJps=
-github.com/agentgateway/agentgateway v0.4.31-0.20250519135723-61536c2b3fa0/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/alcortesm/tgz v0.0.0-20161220082320-9c5fe88206d7/go.mod h1:6zEj6s6u/ghQa61ZWa/C2Aw3RkjiTBOix7dkqa1VLIs=
+github.com/alecholmes/xfccparser v0.4.0 h1:IFB4bP34oorjcV3n8utZtBhEwlAw9rZ43pb4LgT23Vo=
+github.com/alecholmes/xfccparser v0.4.0/go.mod h1:J9fzzUOtjw74IwNdGVbjnOVj1UDlwGQj1zZzgQRlRDY=
 github.com/alecthomas/assert/v2 v2.11.0 h1:2Q9r3ki8+JYXvGsDyBXwH3LcJ+WK5D0gc5E8vS6K3D0=
 github.com/alecthomas/assert/v2 v2.11.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=
 github.com/alecthomas/chroma/v2 v2.17.2 h1:Rm81SCZ2mPoH+Q8ZCc/9YvzPUN/E7HgPiPJD8SLV6GI=
@@ -468,8 +472,13 @@ github.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkE
 github.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
 github.com/coreos/etcd v3.3.13+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
 github.com/coreos/go-oidc v2.1.0+incompatible/go.mod h1:CgnwVTmzoESiwO9qyAFEMiHoZ1nMCKZlZ9V6mm3/LKc=
+github.com/coreos/go-oidc v2.2.1+incompatible h1:mh48q/BqXqgjVHpy2ZY7WnWAbenxRjsz9N1i1YxjHAk=
+github.com/coreos/go-oidc/v3 v3.12.0 h1:sJk+8G2qq94rDI6ehZ71Bol3oUHy63qNYmkiSjrc/Jo=
+github.com/coreos/go-oidc/v3 v3.12.0/go.mod h1:gE3LgjOgFoHi9a4ce4/tJczr0Ai2/BoDhf0r5lltWI0=
 github.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
 github.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
+github.com/coreos/go-semver v0.3.1 h1:yi21YpKnrx1gt5R+la8n5WgS0kCrsPp33dmEyHReZr4=
+github.com/coreos/go-semver v0.3.1/go.mod h1:irMmmIw/7yzSRPWryHsK7EYSg09caPQL03VsM8rvUec=
 github.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
 github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e h1:Wf6HqHfScWJN9/ZjdUKyjop4mf3Qdd+1TvvltAvM3m8=
 github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
@@ -781,6 +790,7 @@ github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69
 github.com/golang-jwt/jwt/v4 v4.0.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=
 github.com/golang-jwt/jwt/v4 v4.2.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=
 github.com/golang-jwt/jwt/v4 v4.5.0/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
+github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
 github.com/golang-jwt/jwt/v4 v4.5.2 h1:YtQM7lnr8iZ+j5q71MGKkNw9Mn7AjHM68uc9g5fXeUI=
 github.com/golang-jwt/jwt/v4 v4.5.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
 github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
@@ -856,6 +866,7 @@ github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Z
 github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
 github.com/google/btree v1.1.3 h1:CVpQJjYgC4VbzxeGVHfvZrv1ctoYCAI8vbl07Fcxlyg=
 github.com/google/btree v1.1.3/go.mod h1:qOPhT0dTNdNzV6Z/lhRX0YXUafgPLFUh+gZMl761Gm4=
+github.com/google/cel-go v0.22.1/go.mod h1:BuznPXXfQDpXKWQ9sPW3TzlAJN5zzFe+i9tIs0yC4s8=
 github.com/google/cel-go v0.23.2 h1:UdEe3CvQh3Nv+E/j9r1Y//WO0K0cSyD7/y0bzyLIMI4=
 github.com/google/cel-go v0.23.2/go.mod h1:52Pb6QsDbC5kvgxvZhiL9QX1oZEkcUF/ZqaPx1J5Wwo=
 github.com/google/gnostic-models v0.6.9 h1:MU/8wDLif2qCXZmzncUQ/BOfxWfthHi63KqpoNbWqVw=
@@ -975,6 +986,7 @@ github.com/gorilla/sessions v1.2.1/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/z
 github.com/gorilla/websocket v0.0.0-20170926233335-4201258b820c/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
 github.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
 github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
+github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
 github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674 h1:JeSE6pjso5THxAzdVpqr6/geYxZytqFMBCOtn/ujyeo=
 github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674/go.mod h1:r4w70xmWCQKmi1ONH4KIaBptdivuRPyosB9RmPlGEwA=
 github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=
@@ -992,6 +1004,8 @@ github.com/gostaticanalysis/testutil v0.5.0 h1:Dq4wT1DdTwTGCQQv3rl3IvD5Ld0E6HiY+
 github.com/gostaticanalysis/testutil v0.5.0/go.mod h1:OLQSbuM6zw2EvCcXTz1lVq5unyoNft372msDY0nY5Hs=
 github.com/gosuri/uitable v0.0.4 h1:IG2xLKRvErL3uhY6e1BylFzG+aJiwQviDDTfOKeKTpY=
 github.com/gosuri/uitable v0.0.4/go.mod h1:tKR86bXuXPZazfOTG1FIzvjIdXzd0mo4Vtn16vt0PJo=
+github.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc h1:GN2Lv3MGO7AS6PrRoT6yV5+wkrOpcszoIsO4+4ds248=
+github.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc/go.mod h1:+JKpmjMGhpgPL+rXZ5nsZieVzvarn86asRlBg4uNGnk=
 github.com/gregjones/httpcache v0.0.0-20180305231024-9cad4c3443a7/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=
 github.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79 h1:+ngKgrYPPJrOjhax5N+uePQ0Fh1Z7PheYoUI/0nzkPA=
 github.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=
@@ -999,11 +1013,11 @@ github.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmg
 github.com/grpc-ecosystem/go-grpc-middleware v1.0.1-0.20190118093823-f849b5445de4/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=
 github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 h1:UH//fgunKIs4JdUbpDl1VZCDaL56wXCB/5+wF6uHfaI=
 github.com/grpc-ecosystem/go-grpc-middleware v1.4.0/go.mod h1:g5qyo/la0ALbONm6Vbp88Yd8NsDy6rZz+RcrMPxvld8=
+github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=
 github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
 github.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
 github.com/grpc-ecosystem/grpc-gateway v1.9.5/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
 github.com/grpc-ecosystem/grpc-gateway v1.14.6/go.mod h1:zdiPV4Yse/1gnckTHtghG4GkDEdKCRJduHpTxT3/jcw=
-github.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=
 github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
 github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3 h1:5ZPtiqj0JL5oKWmcsq4VMaAW5ukBEgSGXEN89zeH1Jo=
 github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3/go.mod h1:ndYquD05frm2vACXE1nsccT4oJzjhw2arTS2cpUD1PI=
@@ -1161,6 +1175,8 @@ github.com/kelseyhightower/envconfig v1.4.0/go.mod h1:cccZRl6mQpaq41TPp5QxidR+Sa
 github.com/kevinburke/ssh_config v0.0.0-20180830205328-81db2a75821e/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=
 github.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=
 github.com/kevinburke/ssh_config v1.2.0/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=
+github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6 h1:IsMZxCuZqKuao2vNdfD82fjjgPLfyHLpR41Z88viRWs=
+github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6/go.mod h1:3VeWNIJaW+O5xpRQbPp0Ybqu1vJd/pm7s2F473HRrkw=
 github.com/kgateway-dev/gengo/v2 v2.0.0-20250512195215-4fa0a9df2978 h1:UHfLeZ4Sj1OBRE4V4nSlanqC1FQnT2bg1vnu4N24Scw=
 github.com/kgateway-dev/gengo/v2 v2.0.0-20250512195215-4fa0a9df2978/go.mod h1:EJykeLsmFC60UQbYJezXkEsG2FLrt0GPNkU5iK5GWxU=
 github.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=
@@ -1172,6 +1188,7 @@ github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+o
 github.com/kkHAIKE/contextcheck v1.1.6 h1:7HIyRcnyzxL9Lz06NGhiKvenXq7Zw6Q0UQu/ttjfJCE=
 github.com/kkHAIKE/contextcheck v1.1.6/go.mod h1:3dDbMRNBFaq8HFXWC1JyvDSPm43CmE6IuHam8Wr0rkg=
 github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
+github.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
 github.com/klauspost/compress v1.18.0 h1:c/Cqfb0r+Yi+JtIEq73FWXVkRonBlf0CRNYc8Zttxdo=
 github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=
 github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=
@@ -1406,6 +1423,7 @@ github.com/onsi/gomega v1.7.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1Cpa
 github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
 github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
 github.com/onsi/gomega v1.16.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=
+github.com/onsi/gomega v1.36.3/go.mod h1:8D9+Txp43QWKhM24yyOBEdpkzN8FvJyAwecBgsU4KU0=
 github.com/onsi/gomega v1.37.0 h1:CdEG8g0S133B4OswTDC/5XPSzE1OeP29QOioj2PID2Y=
 github.com/onsi/gomega v1.37.0/go.mod h1:8D9+Txp43QWKhM24yyOBEdpkzN8FvJyAwecBgsU4KU0=
 github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
@@ -1414,6 +1432,8 @@ github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQ
 github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
 github.com/opencontainers/runc v1.1.14 h1:rgSuzbmgz5DUJjeSnw337TxDbRuqjs6iqQck/2weR6w=
 github.com/opencontainers/runc v1.1.14/go.mod h1:E4C2z+7BxR7GHXp0hAY53mek+x49X1LjPNeMTfRGvOA=
+github.com/openshift/api v0.0.0-20250122093221-e6cc8f6fd74c h1:45L32MUt1dn8TyHT1SN61srou4D5/EmFPCTPhnPhxz4=
+github.com/openshift/api v0.0.0-20250122093221-e6cc8f6fd74c/go.mod h1:Shkl4HanLwDiiBzakv+con/aMGnVE2MAGvoKp5oyYUo=
 github.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=
 github.com/opentracing/opentracing-go v1.2.0 h1:uEJPy/1a5RIPAJ0Ov+OIO8OxWu77jEv+1B0VhjKrZUs=
 github.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=
@@ -1481,6 +1501,7 @@ github.com/prometheus/client_golang v1.11.0/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqr
 github.com/prometheus/client_golang v1.12.1/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=
 github.com/prometheus/client_golang v1.12.2/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=
 github.com/prometheus/client_golang v1.13.0/go.mod h1:vTeo+zgvILHsnnj/39Ou/1fPN5nJFOEMgftOUOmlvYQ=
+github.com/prometheus/client_golang v1.21.1/go.mod h1:U9NM32ykUErtVBxdvD3zfi+EuFkkaBvMb09mIfe0Zgg=
 github.com/prometheus/client_golang v1.22.0 h1:rb93p9lokFEsctTys46VnV1kLCDpVZ0a/Y92Vm0Zc6Q=
 github.com/prometheus/client_golang v1.22.0/go.mod h1:R7ljNsLXhuQXYZYtw6GAE9AZg8Y7vEW5scdCXrWRXC0=
 github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
@@ -1517,6 +1538,8 @@ github.com/prometheus/procfs v0.7.3/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1
 github.com/prometheus/procfs v0.8.0/go.mod h1:z7EfXMXOkbkqb9IINtpCn86r/to3BnA0uaxHdg830/4=
 github.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=
 github.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=
+github.com/prometheus/prometheus v0.301.0 h1:0z8dgegmILivNomCd79RKvVkIols8vBGPKmcIBc7OyY=
+github.com/prometheus/prometheus v0.301.0/go.mod h1:BJLjWCKNfRfjp7Q48DrAjARnCi7GhfUVvUFEAWTssZM=
 github.com/prometheus/statsd_exporter v0.21.0/go.mod h1:rbT83sZq2V+p73lHhPZfMc3MLCHmSHelCh9hSGYNLTQ=
 github.com/prometheus/statsd_exporter v0.22.7/go.mod h1:N/TevpjkIh9ccs6nuzY3jQn9dFqnUakOjnEuMPJJJnI=
 github.com/prometheus/statsd_exporter v0.25.0 h1:gpVF1TMf1UqMJmBDpzBYrEaGOFMpbMBYYYUDwM38Y/I=
@@ -1570,10 +1593,13 @@ github.com/ryancurrah/gomodguard v1.4.1/go.mod h1:qnMJwV1hX9m+YJseXEBhd2s90+1Xn6
 github.com/ryanrolds/sqlclosecheck v0.5.1 h1:dibWW826u0P8jNLsLN+En7+RqWWTYrjCB9fJfSfdyCU=
 github.com/ryanrolds/sqlclosecheck v0.5.1/go.mod h1:2g3dUjoS6AL4huFdv6wn55WpLIDjY7ZgUR4J8HOO/XQ=
 github.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=
+github.com/ryanuber/go-glob v1.0.0 h1:iQh3xXAumdQ+4Ufa5b25cRpC5TYKlno6hsv6Cb3pkBk=
+github.com/ryanuber/go-glob v1.0.0/go.mod h1:807d1WSdnB0XRJzKNil9Om6lcp/3a0v4qIHxIXzX/Yc=
 github.com/sagikazarmark/locafero v0.6.0 h1:ON7AQg37yzcRPU69mt7gwhFEBwxI6P9T4Qu3N51bwOk=
 github.com/sagikazarmark/locafero v0.6.0/go.mod h1:77OmuIc6VTraTXKXIs/uvUxKGUXjE1GbemJYHqdNjX0=
 github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6gto+ugjYE=
 github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
+github.com/saiskee/gettercheck v0.0.0-20210820204958-38443d06ebe0/go.mod h1:sa2CuStAMG5wPJQV6wdN8WFZ0A4Kj9on3oyoxGRbCAs=
 github.com/sanposhiho/wastedassign/v2 v2.1.0 h1:crurBF7fJKIORrV85u9UUpePDYGWnwvv3+A96WvwXT0=
 github.com/sanposhiho/wastedassign/v2 v2.1.0/go.mod h1:+oSmSC+9bQ+VUAxA66nBb0Z7N8CK7mscKTDYC6aIek4=
 github.com/santhosh-tekuri/jsonschema/v6 v6.0.1 h1:PKK9DyHxif4LZo+uQSgXNqs0jj5+xZwwfKHgph2lxBw=
@@ -1636,6 +1662,8 @@ github.com/smartystreets/goconvey v1.7.2/go.mod h1:Vw0tHAZW6lzCRk3xgdin6fKYcG+G3
 github.com/smartystreets/goconvey v1.8.1 h1:qGjIddxOk4grTu9JPOU31tVfq3cNdBlNa5sSznIX1xY=
 github.com/smartystreets/goconvey v1.8.1/go.mod h1:+/u4qLyY6x1jReYOp7GOM2FSt8aP9CzCZL03bI28W60=
 github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
+github.com/solo-io/agentgateway-enterprise v0.0.0-20250625151206-94c5ea602e02 h1:fneENV02KnjbI74pZQqHebBWQ7oanPA/5qQx/RuUrQk=
+github.com/solo-io/agentgateway-enterprise v0.0.0-20250625151206-94c5ea602e02/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966 h1:MavIqMAvo9dxhcuN0/m7Ok830e7htfhR+JWRDqs3qj4=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966/go.mod h1:27GcajR+wxZ34COPvLp1+4hxGN66/GSx7SSjVn8LySY=
 github.com/solo-io/go-list-licenses v0.1.4 h1:u4xh1OUORT4iSWuAp3Q4NsfHcDaeUV8QRDH8ACQqbxw=
@@ -1797,6 +1825,8 @@ github.com/yeya24/promlinter v0.3.0 h1:JVDbMp08lVCP7Y6NP3qHroGAO6z2yGKQtS5Jsjqto
 github.com/yeya24/promlinter v0.3.0/go.mod h1:cDfJQQYv9uYciW60QT0eeHlFodotkYZlL+YcPQN+mW4=
 github.com/ykadowak/zerologlint v0.1.5 h1:Gy/fMz1dFQN9JZTPjv1hxEk+sRWm05row04Yoolgdiw=
 github.com/ykadowak/zerologlint v0.1.5/go.mod h1:KaUskqF3e/v59oPmdq1U1DnKcuHokl2/K1U4pmIELKg=
+github.com/yl2chen/cidranger v1.0.2 h1:lbOWZVCG1tCRX4u24kuM1Tb4nHqWkDxwLdoS+SevawU=
+github.com/yl2chen/cidranger v1.0.2/go.mod h1:9U1yz7WPYDwf0vpNWFaeRh0bjwz5RVgRy/9UEQfHl0g=
 github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
 github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
 github.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
@@ -1825,7 +1855,14 @@ go.augendre.info/fatcontext v0.8.0/go.mod h1:oVJfMgwngMsHO+KB2MdgzcO+RvtNdiCEOlW
 go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
 go.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
 go.etcd.io/bbolt v1.3.5/go.mod h1:G5EMThwa9y8QZGBClrRx5EY+Yw9kAhnjy3bSjsnlVTQ=
+go.etcd.io/etcd v0.5.0-alpha.5.0.20200910180754-dd1b699fc489 h1:1JFLBqwIgdyHN1ZtgjTBwO+blA6gVOmZurpiMEsETKo=
 go.etcd.io/etcd v0.5.0-alpha.5.0.20200910180754-dd1b699fc489/go.mod h1:yVHk9ub3CSBatqGNg7GRmsnfLWtoW60w4eDYfh7vHDg=
+go.etcd.io/etcd/api/v3 v3.5.16 h1:WvmyJVbjWqK4R1E+B12RRHz3bRGy9XVfh++MgbN+6n0=
+go.etcd.io/etcd/api/v3 v3.5.16/go.mod h1:1P4SlIP/VwkDmGo3OlOD7faPeP8KDIFhqvciH5EfN28=
+go.etcd.io/etcd/client/pkg/v3 v3.5.16 h1:ZgY48uH6UvB+/7R9Yf4x574uCO3jIx0TRDyetSfId3Q=
+go.etcd.io/etcd/client/pkg/v3 v3.5.16/go.mod h1:V8acl8pcEK0Y2g19YlOV9m9ssUe6MgiDSobSoaBAM0E=
+go.etcd.io/etcd/client/v3 v3.5.16 h1:sSmVYOAHeC9doqi0gv7v86oY/BTld0SEFGaxsU9eRhE=
+go.etcd.io/etcd/client/v3 v3.5.16/go.mod h1:X+rExSGkyqxvu276cr2OwPLBaeqFu1cIl4vmRjAD/50=
 go.mongodb.org/mongo-driver v1.14.0 h1:P98w8egYRjYe3XDjxhYJagTokP/H6HzlsnojRgZRd80=
 go.mongodb.org/mongo-driver v1.14.0/go.mod h1:Vzb0Mk/pa7e6cWw85R4F/endUC3u0U9jGcNU603k65c=
 go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
@@ -1949,6 +1986,7 @@ golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliY
 golang.org/x/crypto v0.14.0/go.mod h1:MVFd36DqK4CsrnJYDkBA3VC4m2GkXAM0PvzMCn4JQf4=
 golang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=
 golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
+golang.org/x/crypto v0.38.0/go.mod h1:MvrbAqul58NNYPKnOra203SB9vpuZW0e+RRZV+Ggqjw=
 golang.org/x/crypto v0.39.0 h1:SHs+kF4LP+f+p14esP5jAoDpHU8Gu/v9lFRK6IT5imM=
 golang.org/x/crypto v0.39.0/go.mod h1:L+Xg3Wf6HoL4Bn4238Z6ft6KfEpN0tJGo53AAPC632U=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
@@ -2002,6 +2040,7 @@ golang.org/x/mod v0.9.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
 golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
 golang.org/x/mod v0.13.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
 golang.org/x/mod v0.14.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
+golang.org/x/mod v0.24.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
 golang.org/x/mod v0.25.0 h1:n7a+ZbQKQA/Ysbyb0/6IbB1H/X41mKgbhfv7AfG/44w=
 golang.org/x/mod v0.25.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
@@ -2067,6 +2106,7 @@ golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
 golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=
 golang.org/x/net v0.16.0/go.mod h1:NxSsAGuq816PNPmqtQdLE42eU2Fs7NoRIZrHJAlaCOE=
 golang.org/x/net v0.20.0/go.mod h1:z8BVo6PvndSri0LbOE3hAn0apkU+1YvI6E70E9jsnvY=
+golang.org/x/net v0.40.0/go.mod h1:y0hY0exeL2Pku80/zKK7tpntoX23cqL3Oa6njdgRtds=
 golang.org/x/net v0.41.0 h1:vBTly1HeNPEn3wtREYfy4GZ/NECgw2Cnl+nK6Nz3uvw=
 golang.org/x/net v0.41.0/go.mod h1:B/K4NNqkfmg07DQYrbwvSluqCJOOXwUjeb/5lOisjbA=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
@@ -2106,6 +2146,7 @@ golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.4.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
+golang.org/x/sync v0.14.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
 golang.org/x/sync v0.15.0 h1:KWH3jNZsfyT6xfAfKiz6MRNmd46ByHDYaZ7KSkCtdW8=
 golang.org/x/sync v0.15.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
 golang.org/x/sys v0.0.0-20180606202747-9527bec2660b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
@@ -2233,6 +2274,7 @@ golang.org/x/text v0.8.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
 golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
 golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
 golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
+golang.org/x/text v0.25.0/go.mod h1:WEdwpYrmk1qmdHvhkSTNPm3app7v4rsT8F2UD6+VHIA=
 golang.org/x/text v0.26.0 h1:P42AVeLghgTYr4+xUnTRKDMqpar+PtX7KWuNQL21L8M=
 golang.org/x/text v0.26.0/go.mod h1:QK15LZJUUQVJxhz7wXgxSy/CJaTFjd0G+YLonydOVQA=
 golang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
@@ -2324,6 +2366,7 @@ golang.org/x/tools v0.7.0/go.mod h1:4pg6aUX35JBAogB10C9AtvVL+qowtN4pT3CGSQex14s=
 golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
 golang.org/x/tools v0.14.0/go.mod h1:uYBEerGOWcJyEORxN+Ek8+TT266gXkNlHdJBwexUsBg=
 golang.org/x/tools v0.17.0/go.mod h1:xsh6VxdV005rRVaS6SSAf9oiAqljS7UZUacMZ8Bnsps=
+golang.org/x/tools v0.32.0/go.mod h1:ZxrU41P/wAbZD8EDa6dDCa6XfpkhJ7HFMjHJXfBDu8s=
 golang.org/x/tools v0.34.0 h1:qIpSLOxeCYGg9TrcJokLBG4KFA6d795g0xkBkiESGlo=
 golang.org/x/tools v0.34.0/go.mod h1:pAP9OwEaY1CAW3HOmg3hLZC5Z0CCmzjAF2UQMSqNARg=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
@@ -2564,26 +2607,33 @@ istio.io/client-go v1.25.0-alpha.0.0.20250210220843-5a4065fded65/go.mod h1:40cl7
 istio.io/istio v0.0.0-20250212203644-c2ac935c5888 h1:4uIAapZvWqD/Vo8uLecH1hxC3EAE2aqUmq8rOzaXJws=
 istio.io/istio v0.0.0-20250212203644-c2ac935c5888/go.mod h1:k9mWJfHRkdIya53hz/BzKfKmVRk2/aiA2H1AF0KmDC0=
 k8s.io/api v0.21.4/go.mod h1:fTVGP+M4D8+00FN2cMnJqk/eb/GH53bvmNs2SVTmpFk=
+k8s.io/api v0.32.3/go.mod h1:2wEDTXADtm/HA7CCMD8D8bK4yuBUptzaRhYcYEEYA3k=
 k8s.io/api v0.33.2 h1:YgwIS5jKfA+BZg//OQhkJNIfie/kmRsO0BmNaVSimvY=
 k8s.io/api v0.33.2/go.mod h1:fhrbphQJSM2cXzCWgqU29xLDuks4mu7ti9vveEnpSXs=
 k8s.io/apiextensions-apiserver v0.21.4/go.mod h1:OoC8LhI9LnV+wKjZkXIBbLUwtnOGJiTRE33qctH5CIk=
+k8s.io/apiextensions-apiserver v0.32.3/go.mod h1:8YwcvVRMVzw0r1Stc7XfGAzB/SIVLunqApySV5V7Dss=
 k8s.io/apiextensions-apiserver v0.33.2 h1:6gnkIbngnaUflR3XwE1mCefN3YS8yTD631JXQhsU6M8=
 k8s.io/apiextensions-apiserver v0.33.2/go.mod h1:IvVanieYsEHJImTKXGP6XCOjTwv2LUMos0YWc9O+QP8=
 k8s.io/apimachinery v0.21.4/go.mod h1:H/IM+5vH9kZRNJ4l3x/fXP/5bOPJaVP/guptnZPeCFI=
+k8s.io/apimachinery v0.32.3/go.mod h1:GpHVgxoKlTxClKcteaeuF1Ul/lDVb74KpZcxcmLDElE=
 k8s.io/apimachinery v0.33.2 h1:IHFVhqg59mb8PJWTLi8m1mAoepkUNYmptHsV+Z1m5jY=
 k8s.io/apimachinery v0.33.2/go.mod h1:BHW0YOu7n22fFv/JkYOEfkUYNRN0fj0BlvMFWA7b+SM=
 k8s.io/apiserver v0.21.4/go.mod h1:SErUuFBBPZUcD2nsUU8hItxoYheqyYr2o/pCINEPW8g=
+k8s.io/apiserver v0.32.3/go.mod h1:q1x9B8E/WzShF49wh3ADOh6muSfpmFL0I2t+TG0Zdgc=
 k8s.io/apiserver v0.33.2 h1:KGTRbxn2wJagJowo29kKBp4TchpO1DRO3g+dB/KOJN4=
 k8s.io/apiserver v0.33.2/go.mod h1:9qday04wEAMLPWWo9AwqCZSiIn3OYSZacDyu/AcoM/M=
 k8s.io/cli-runtime v0.32.3 h1:khLF2ivU2T6Q77H97atx3REY9tXiA3OLOjWJxUrdvss=
 k8s.io/cli-runtime v0.32.3/go.mod h1:vZT6dZq7mZAca53rwUfdFSZjdtLyfF61mkf/8q+Xjak=
 k8s.io/client-go v0.21.4/go.mod h1:t0/eMKyUAq/DoQ7vW8NVVA00/nomlwC+eInsS8PxSew=
+k8s.io/client-go v0.32.3/go.mod h1:3v0+3k4IcT9bXTc4V2rt+d2ZPPG700Xy6Oi0Gdl2PaY=
 k8s.io/client-go v0.33.2 h1:z8CIcc0P581x/J1ZYf4CNzRKxRvQAwoAolYPbtQes+E=
 k8s.io/client-go v0.33.2/go.mod h1:9mCgT4wROvL948w6f6ArJNb7yQd7QsvqavDeZHvNmHo=
 k8s.io/code-generator v0.21.4/go.mod h1:K3y0Bv9Cz2cOW2vXUrNZlFbflhuPvuadW6JdnN6gGKo=
+k8s.io/code-generator v0.32.3/go.mod h1:+mbiYID5NLsBuqxjQTygKM/DAdKpAjvBzrJd64NU1G8=
 k8s.io/code-generator v0.33.2 h1:PCJ0Y6viTCxxJHMOyGqYwWEteM4q6y1Hqo2rNpl6jF4=
 k8s.io/code-generator v0.33.2/go.mod h1:hBjCA9kPMpjLWwxcr75ReaQfFXY8u+9bEJJ7kRw3J8c=
 k8s.io/component-base v0.21.4/go.mod h1:ZKG0eHVX+tUDcaoIGpU3Vtk4TIjMddN9uhEWDmW6Nyg=
+k8s.io/component-base v0.32.3/go.mod h1:LWi9cR+yPAv7cu2X9rZanTiFKB2kHA+JjmhkKjCZRpI=
 k8s.io/component-base v0.33.2 h1:sCCsn9s/dG3ZrQTX/Us0/Sx2R0G5kwa0wbZFYoVp/+0=
 k8s.io/component-base v0.33.2/go.mod h1:/41uw9wKzuelhN+u+/C59ixxf4tYQKW7p32ddkYNe2k=
 k8s.io/gengo v0.0.0-20200413195148-3a45101e95ac/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
@@ -2619,12 +2669,14 @@ rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8
 rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
 rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.22/go.mod h1:LEScyzhFmoF5pso/YSeBstl57mOzx9xlU9n85RGrDQg=
+sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.1/go.mod h1:Ve9uj1L+deCXFrPOk1LpFXqTg7LCFzFso6PA48q/XZw=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2 h1:jpcvIRr3GLoUoEKRkHKSmGjxb6lWwrBlJsXc+eUYQHM=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2/go.mod h1:Ve9uj1L+deCXFrPOk1LpFXqTg7LCFzFso6PA48q/XZw=
 sigs.k8s.io/controller-runtime v0.20.4 h1:X3c+Odnxz+iPTRobG4tp092+CvBU9UK0t/bRf+n0DGU=
 sigs.k8s.io/controller-runtime v0.20.4/go.mod h1:xg2XB0K5ShQzAgsoujxuKN4LNXR2LfwwHsPj7Iaw+XY=
 sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235 h1:GRdpo0LC7QBPh9HefY30G1xmap2Q5U/KCBqeIZymDMo=
 sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235/go.mod h1:TF/lVLWS+JNNaVqJuDDictY2hZSXSsIHCx4FClMvqFg=
+sigs.k8s.io/controller-tools v0.17.3/go.mod h1:1ii+oXcYZkxcBXzwv3YZBlzjt1fvkrCGjVF73blosJI=
 sigs.k8s.io/gateway-api v1.3.0 h1:q6okN+/UKDATola4JY7zXzx40WO4VISk7i9DIfOvr9M=
 sigs.k8s.io/gateway-api v1.3.0/go.mod h1:d8NV8nJbaRbEKem+5IuxkL8gJGOZ+FJ+NvOIltV8gDk=
 sigs.k8s.io/gateway-api-inference-extension v0.2.0 h1:AqENYqi2OHjAhBhTKARNcM7G5L/gsRIxZGS4P8CNqAI=
diff --git a/internal/kgateway/agentgatewaysyncer/const.go b/internal/kgateway/agentgatewaysyncer/const.go
index 48365f1c5..d52aef6d2 100644
--- a/internal/kgateway/agentgatewaysyncer/const.go
+++ b/internal/kgateway/agentgatewaysyncer/const.go
@@ -1,16 +1,6 @@
 package agentgatewaysyncer
 
 const (
-	TargetTypeA2AUrl      = "type.googleapis.com/agentgateway.dev.a2a.target.Target"
-	TargetTypeMcpUrl      = "type.googleapis.com/agentgateway.dev.mcp.target.Target"
-	TargetTypeListenerUrl = "type.googleapis.com/agentgateway.dev.listener.Listener"
-
-	MCPProtocol = "kgateway.dev/mcp"
-	A2AProtocol = "kgateway.dev/a2a"
-
-	MCPPathAnnotation = "kgateway.dev/mcp-path"
-	A2APathAnnotation = "kgateway.dev/a2a-path"
-
-	// Needs to match agentgateway role configured here: https://github.com/agentgateway/agentgateway/blob/main/crates/agentgateway/src/xds/client.rs#L293
-	OwnerNodeId = "agentgateway-api"
+	TargetTypeResourceUrl = "type.googleapis.com/istio.adp.Resource"
+	TargetTypeAddressUrl  = "type.googleapis.com/istio.workload.Address"
 )
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/adp.go b/internal/kgateway/agentgatewaysyncer/gateway/adp.go
new file mode 100644
index 000000000..a4fb3bcbf
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/adp.go
@@ -0,0 +1,245 @@
+package gateway
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"istio.io/istio/pkg/config"
+	k8s "sigs.k8s.io/gateway-api/apis/v1"
+
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/workloadapi"
+)
+
+func createADPMethodMatch(match k8s.HTTPRouteMatch) (*api.MethodMatch, *ConfigError) {
+	if match.Method == nil {
+		return nil, nil
+	}
+	return &workloadapi.MethodMatch{
+		Exact: string(*match.Method),
+	}, nil
+}
+
+func createADPQueryMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.QueryMatch, *ConfigError) {
+	res := []*workloadapi.QueryMatch{}
+	for _, header := range match.QueryParams {
+		tp := k8s.QueryParamMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case k8s.QueryParamMatchExact:
+			res = append(res, &workloadapi.QueryMatch{
+				Name:  string(header.Name),
+				Value: &workloadapi.QueryMatch_Exact{Exact: header.Value},
+			})
+		case k8s.QueryParamMatchRegularExpression:
+			res = append(res, &workloadapi.QueryMatch{
+				Name:  string(header.Name),
+				Value: &workloadapi.QueryMatch_Regex{Regex: header.Value},
+			})
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported QueryMatch type", tp)}
+		}
+	}
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createADPPathMatch(match k8s.HTTPRouteMatch) (*workloadapi.PathMatch, *ConfigError) {
+	tp := k8s.PathMatchPathPrefix
+	if match.Path.Type != nil {
+		tp = *match.Path.Type
+	}
+	dest := "/"
+	if match.Path.Value != nil {
+		dest = *match.Path.Value
+	}
+	switch tp {
+	case k8s.PathMatchPathPrefix:
+		// "When specified, a trailing `/` is ignored."
+		if dest != "/" {
+			dest = strings.TrimSuffix(dest, "/")
+		}
+		return &workloadapi.PathMatch{Kind: &workloadapi.PathMatch_PathPrefix{
+			PathPrefix: dest,
+		}}, nil
+	case k8s.PathMatchExact:
+		return &workloadapi.PathMatch{Kind: &workloadapi.PathMatch_Exact{
+			Exact: dest,
+		}}, nil
+	case k8s.PathMatchRegularExpression:
+		return &workloadapi.PathMatch{Kind: &workloadapi.PathMatch_Regex{
+			Regex: dest,
+		}}, nil
+	default:
+		// Should never happen, unless a new field is added
+		return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+	}
+}
+
+func createADPHeadersMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.HeaderMatch, *ConfigError) {
+	res := []*workloadapi.HeaderMatch{}
+	for _, header := range match.Headers {
+		tp := k8s.HeaderMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case k8s.HeaderMatchExact:
+			res = append(res, &workloadapi.HeaderMatch{
+				Name:  string(header.Name),
+				Value: &workloadapi.HeaderMatch_Exact{Exact: header.Value},
+			})
+		case k8s.HeaderMatchRegularExpression:
+			res = append(res, &workloadapi.HeaderMatch{
+				Name:  string(header.Name),
+				Value: &workloadapi.HeaderMatch_Regex{Regex: header.Value},
+			})
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createADPHeadersFilter(filter *k8s.HTTPHeaderFilter) *workloadapi.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+	return &workloadapi.RouteFilter{
+		Kind: &workloadapi.RouteFilter_RequestHeaderModifier{
+			RequestHeaderModifier: &workloadapi.HeaderModifier{
+				Add:    headerListToADP(filter.Add),
+				Set:    headerListToADP(filter.Set),
+				Remove: filter.Remove,
+			},
+		},
+	}
+}
+
+func createADPResponseHeadersFilter(filter *k8s.HTTPHeaderFilter) *workloadapi.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+	return &workloadapi.RouteFilter{
+		Kind: &workloadapi.RouteFilter_ResponseHeaderModifier{
+			ResponseHeaderModifier: &workloadapi.HeaderModifier{
+				Add:    headerListToADP(filter.Add),
+				Set:    headerListToADP(filter.Set),
+				Remove: filter.Remove,
+			},
+		},
+	}
+}
+
+func createADPRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *workloadapi.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+	ff := &workloadapi.UrlRewrite{
+		Host: string(ptr.OrEmpty(filter.Hostname)),
+	}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case k8s.PrefixMatchHTTPPathModifier:
+			ff.Path = &workloadapi.UrlRewrite_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
+		case k8s.FullPathHTTPPathModifier:
+			ff.Path = &workloadapi.UrlRewrite_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
+		}
+	}
+	return &workloadapi.RouteFilter{
+		Kind: &workloadapi.RouteFilter_UrlRewrite{
+			UrlRewrite: ff,
+		},
+	}
+}
+
+func createADPMirrorFilter(
+	ctx RouteContext,
+	filter *k8s.HTTPRequestMirrorFilter,
+	ns string,
+	enforceRefGrant bool,
+	k config.GroupVersionKind,
+) (*workloadapi.RouteFilter, *ConfigError) {
+	if filter == nil {
+		return nil, nil
+	}
+	var weightOne int32 = 1
+	dst, err := buildADPDestination(ctx, k8s.HTTPBackendRef{
+		BackendRef: k8s.BackendRef{
+			BackendObjectReference: filter.BackendRef,
+			Weight:                 &weightOne,
+		},
+	}, ns, enforceRefGrant, k)
+	if err != nil {
+		return nil, err
+	}
+	var percent float64
+	if f := filter.Fraction; f != nil {
+		percent = (100 * float64(f.Numerator)) / float64(ptr.OrDefault(f.Denominator, int32(100)))
+	} else if p := filter.Percent; p != nil {
+		percent = float64(*p)
+	} else {
+		percent = 100
+	}
+	if percent == 0 {
+		return nil, nil
+	}
+	rm := &workloadapi.RequestMirror{
+		Kind:       nil,
+		Percentage: percent,
+		Port:       dst.Port,
+	}
+	switch dk := dst.Kind.(type) {
+	case *workloadapi.RouteBackend_Service:
+		rm.Kind = &workloadapi.RequestMirror_Service{
+			Service: dk.Service,
+		}
+	}
+	return &workloadapi.RouteFilter{Kind: &workloadapi.RouteFilter_RequestMirror{RequestMirror: rm}}, nil
+}
+
+func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *workloadapi.RouteFilter {
+	if filter == nil {
+		return nil
+	}
+	ff := &workloadapi.RequestRedirect{
+		Scheme: ptr.OrEmpty(filter.Scheme),
+		Host:   string(ptr.OrEmpty(filter.Hostname)),
+		Port:   uint32(ptr.OrEmpty(filter.Port)),
+		Status: uint32(ptr.OrEmpty(filter.StatusCode)),
+	}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case k8s.PrefixMatchHTTPPathModifier:
+			ff.Path = &workloadapi.RequestRedirect_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
+		case k8s.FullPathHTTPPathModifier:
+			ff.Path = &workloadapi.RequestRedirect_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
+		}
+	}
+	return &workloadapi.RouteFilter{
+		Kind: &workloadapi.RouteFilter_RequestRedirect{
+			RequestRedirect: ff,
+		},
+	}
+}
+
+func headerListToADP(hl []k8s.HTTPHeader) []*workloadapi.Header {
+	return slices.Map(hl, func(hl k8s.HTTPHeader) *workloadapi.Header {
+		return &workloadapi.Header{
+			Name:  string(hl.Name),
+			Value: hl.Value,
+		}
+	})
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conditions.go b/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
new file mode 100644
index 000000000..16570fcdb
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
@@ -0,0 +1,378 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"fmt"
+	"sort"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	k8s "sigs.k8s.io/gateway-api/apis/v1"
+	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model/kstatus"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/maps"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/sets"
+)
+
+// RouteParentResult holds the result of a route for a specific parent
+type RouteParentResult struct {
+	// OriginalReference contains the original reference
+	OriginalReference k8s.ParentReference
+	// DeniedReason, if present, indicates why the reference was not valid
+	DeniedReason *ParentError
+	// RouteError, if present, indicates why the reference was not valid
+	RouteError *ConfigError
+	// WaypointError, if present, indicates why the reference was does not have a waypoint
+	WaypointError *WaypointError
+}
+
+func createRouteStatus(parentResults []RouteParentResult, generation int64, currentParents []k8s.RouteParentStatus) []k8s.RouteParentStatus {
+	parents := make([]k8s.RouteParentStatus, 0, len(parentResults))
+	// Fill in all the gateways that are already present but not owned by us. This is non-trivial as there may be multiple
+	// gateway controllers that are exposing their status on the same route. We need to attempt to manage ours properly (including
+	// removing gateway references when they are removed), without mangling other Controller's status.
+	for _, r := range currentParents {
+		if r.ControllerName != k8s.GatewayController(features.ManagedGatewayController) {
+			// We don't own this status, so keep it around
+			parents = append(parents, r)
+		}
+	}
+	// Collect all of our unique parent references. There may be multiple when we have a route without section name,
+	// but reference a parent with multiple sections.
+	// While we process these internally for-each sectionName, in the status we are just supposed to report one merged entry
+	seen := map[k8s.ParentReference][]RouteParentResult{}
+	seenReasons := sets.New[ParentErrorReason]()
+	successCount := map[k8s.ParentReference]int{}
+	for _, incoming := range parentResults {
+		// We will append it if it is our first occurrence, or the existing one has an error. This means
+		// if *any* section has no errors, we will declare Admitted
+		if incoming.DeniedReason == nil {
+			successCount[incoming.OriginalReference]++
+		}
+		seen[incoming.OriginalReference] = append(seen[incoming.OriginalReference], incoming)
+		if incoming.DeniedReason != nil {
+			seenReasons.Insert(incoming.DeniedReason.Reason)
+		} else {
+			seenReasons.Insert(ParentNoError)
+		}
+	}
+
+	const (
+		rankParentNoErrors = iota
+		rankParentErrorNotAllowed
+		rankParentErrorNoHostname
+		rankParentErrorParentRefConflict
+		rankParentErrorNotAccepted
+	)
+
+	rankParentError := func(result RouteParentResult) int {
+		if result.DeniedReason == nil {
+			return rankParentNoErrors
+		}
+		switch result.DeniedReason.Reason {
+		case ParentErrorNotAllowed:
+			return rankParentErrorNotAllowed
+		case ParentErrorNoHostname:
+			return rankParentErrorNoHostname
+		case ParentErrorParentRefConflict:
+			return rankParentErrorParentRefConflict
+		case ParentErrorNotAccepted:
+			return rankParentErrorNotAccepted
+		}
+		return rankParentNoErrors
+	}
+
+	// Next we want to collapse these. We need to report 1 type of error, or none.
+	report := map[k8s.ParentReference]RouteParentResult{}
+	for ref, results := range seen {
+		if len(results) == 0 {
+			continue
+		}
+
+		toReport := results[0]
+		mostSevereRankSeen := rankParentError(toReport)
+
+		for _, result := range results[1:] {
+			resultRank := rankParentError(result)
+			// lower number means more severe
+			if resultRank < mostSevereRankSeen {
+				mostSevereRankSeen = resultRank
+				toReport = result
+			} else if resultRank == mostSevereRankSeen {
+				// join the error messages
+				if toReport.DeniedReason == nil {
+					toReport.DeniedReason = result.DeniedReason
+				} else {
+					toReport.DeniedReason.Message += "; " + result.DeniedReason.Message
+				}
+			}
+		}
+
+		report[ref] = toReport
+	}
+
+	// Now we fill in all the parents we do own
+	for k, gw := range report {
+		msg := "Route was valid"
+		if successCount[k] > 1 {
+			msg = fmt.Sprintf("Route was valid, bound to %d parents", successCount[k])
+		}
+		conds := map[string]*condition{
+			string(k8s.RouteConditionAccepted): {
+				reason:  string(k8s.RouteReasonAccepted),
+				message: msg,
+			},
+			string(k8s.RouteConditionResolvedRefs): {
+				reason:  string(k8s.RouteReasonResolvedRefs),
+				message: "All references resolved",
+			},
+		}
+		if gw.RouteError != nil {
+			// Currently, the spec is not clear on where errors should be reported. The provided resources are:
+			// * Accepted - used to describe errors binding to parents
+			// * ResolvedRefs - used to describe errors about binding to objects
+			// But no general errors
+			// For now, we will treat all general route errors as "Ref" errors.
+			conds[string(k8s.RouteConditionResolvedRefs)].error = gw.RouteError
+		}
+		if gw.DeniedReason != nil {
+			conds[string(k8s.RouteConditionAccepted)].error = &ConfigError{
+				Reason:  ConfigErrorReason(gw.DeniedReason.Reason),
+				Message: gw.DeniedReason.Message,
+			}
+		}
+
+		// when ambient is enabled, report the waypoints resolved condition
+		if features.EnableAmbient {
+			cond := &condition{
+				reason:  string(RouteReasonResolvedWaypoints),
+				message: "All waypoints resolved",
+			}
+			if gw.WaypointError != nil {
+				cond.message = gw.WaypointError.Message
+			}
+			conds[string(RouteConditionResolvedWaypoints)] = cond
+		}
+
+		var currentConditions []metav1.Condition
+		currentStatus := slices.FindFunc(currentParents, func(s k8s.RouteParentStatus) bool {
+			return parentRefString(s.ParentRef) == parentRefString(gw.OriginalReference) &&
+				s.ControllerName == k8s.GatewayController(features.ManagedGatewayController)
+		})
+		if currentStatus != nil {
+			currentConditions = currentStatus.Conditions
+		}
+		parents = append(parents, k8s.RouteParentStatus{
+			ParentRef:      gw.OriginalReference,
+			ControllerName: k8s.GatewayController(features.ManagedGatewayController),
+			Conditions:     setConditions(generation, currentConditions, conds),
+		})
+	}
+	// Ensure output is deterministic.
+	// TODO: will we fight over other controllers doing similar (but not identical) ordering?
+	sort.SliceStable(parents, func(i, j int) bool {
+		return parentRefString(parents[i].ParentRef) > parentRefString(parents[j].ParentRef)
+	})
+	return parents
+}
+
+type ParentErrorReason string
+
+const (
+	ParentErrorNotAccepted       = ParentErrorReason(k8s.RouteReasonNoMatchingParent)
+	ParentErrorNotAllowed        = ParentErrorReason(k8s.RouteReasonNotAllowedByListeners)
+	ParentErrorNoHostname        = ParentErrorReason(k8s.RouteReasonNoMatchingListenerHostname)
+	ParentErrorParentRefConflict = ParentErrorReason("ParentRefConflict")
+	ParentNoError                = ParentErrorReason("")
+)
+
+type ConfigErrorReason = string
+
+const (
+	// InvalidDestination indicates an issue with the destination
+	InvalidDestination ConfigErrorReason = "InvalidDestination"
+	InvalidAddress     ConfigErrorReason = ConfigErrorReason(k8s.GatewayReasonUnsupportedAddress)
+	// InvalidDestinationPermit indicates a destination was not permitted
+	InvalidDestinationPermit ConfigErrorReason = ConfigErrorReason(k8s.RouteReasonRefNotPermitted)
+	// InvalidDestinationKind indicates an issue with the destination kind
+	InvalidDestinationKind ConfigErrorReason = ConfigErrorReason(k8s.RouteReasonInvalidKind)
+	// InvalidDestinationNotFound indicates a destination does not exist
+	InvalidDestinationNotFound ConfigErrorReason = ConfigErrorReason(k8s.RouteReasonBackendNotFound)
+	// InvalidFilter indicates an issue with the filters
+	InvalidFilter ConfigErrorReason = "InvalidFilter"
+	// InvalidTLS indicates an issue with TLS settings
+	InvalidTLS ConfigErrorReason = ConfigErrorReason(k8s.ListenerReasonInvalidCertificateRef)
+	// InvalidListenerRefNotPermitted indicates a listener reference was not permitted
+	InvalidListenerRefNotPermitted ConfigErrorReason = ConfigErrorReason(k8s.ListenerReasonRefNotPermitted)
+	// InvalidConfiguration indicates a generic error for all other invalid configurations
+	InvalidConfiguration ConfigErrorReason = "InvalidConfiguration"
+	DeprecateFieldUsage  ConfigErrorReason = "DeprecatedField"
+)
+
+const (
+	// This condition indicates whether a route's parent reference has
+	// a waypoint configured by resolving the "istio.io/use-waypoint" label
+	// on either the referenced parent or the parent's namespace.
+	RouteConditionResolvedWaypoints k8s.RouteConditionType   = "ResolvedWaypoints"
+	RouteReasonResolvedWaypoints    k8s.RouteConditionReason = "ResolvedWaypoints"
+)
+
+type WaypointErrorReason string
+
+const (
+	WaypointErrorReasonMissingLabel     = WaypointErrorReason("MissingUseWaypointLabel")
+	WaypointErrorMsgMissingLabel        = "istio.io/use-waypoint label missing from parent and parent namespace; in ambient mode, route will not be respected"
+	WaypointErrorReasonNoMatchingParent = WaypointErrorReason("NoMatchingParent")
+	WaypointErrorMsgNoMatchingParent    = "parent not found"
+)
+
+// ParentError represents that a parent could not be referenced
+type ParentError struct {
+	Reason  ParentErrorReason
+	Message string
+}
+
+// ConfigError represents an invalid configuration that will be reported back to the user.
+type ConfigError struct {
+	Reason  ConfigErrorReason
+	Message string
+}
+
+type WaypointError struct {
+	Reason  WaypointErrorReason
+	Message string
+}
+
+type condition struct {
+	// reason defines the reason to report on success. Ignored if error is set
+	reason string
+	// message defines the message to report on success. Ignored if error is set
+	message string
+	// status defines the status to report on success. The inverse will be set if error is set
+	// If not set, will default to StatusTrue
+	status metav1.ConditionStatus
+	// error defines an error state; the reason and message will be replaced with that of the error and
+	// the status inverted
+	error *ConfigError
+	// setOnce, if enabled, will only set the condition if it is not yet present or set to this reason
+	setOnce string
+}
+
+// setConditions sets the existingConditions with the new conditions
+func setConditions(generation int64, existingConditions []metav1.Condition, conditions map[string]*condition) []metav1.Condition {
+	// Sort keys for deterministic ordering
+	for _, k := range slices.Sort(maps.Keys(conditions)) {
+		cond := conditions[k]
+		setter := kstatus.UpdateConditionIfChanged
+		if cond.setOnce != "" {
+			setter = func(conditions []metav1.Condition, condition metav1.Condition) []metav1.Condition {
+				return kstatus.CreateCondition(conditions, condition, cond.setOnce)
+			}
+		}
+		// A condition can be "negative polarity" (ex: ListenerInvalid) or "positive polarity" (ex:
+		// ListenerValid), so in order to determine the status we should set each `condition` defines its
+		// default positive status. When there is an error, we will invert that. Example: If we have
+		// condition ListenerInvalid, the status will be set to StatusFalse. If an error is reported, it
+		// will be inverted to StatusTrue to indicate listeners are invalid. See
+		// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties
+		// for more information
+		if cond.error != nil {
+			existingConditions = setter(existingConditions, metav1.Condition{
+				Type:               k,
+				Status:             kstatus.InvertStatus(cond.status),
+				ObservedGeneration: generation,
+				LastTransitionTime: metav1.Now(),
+				Reason:             cond.error.Reason,
+				Message:            cond.error.Message,
+			})
+		} else {
+			status := cond.status
+			if status == "" {
+				status = kstatus.StatusTrue
+			}
+			existingConditions = setter(existingConditions, metav1.Condition{
+				Type:               k,
+				Status:             status,
+				ObservedGeneration: generation,
+				LastTransitionTime: metav1.Now(),
+				Reason:             cond.reason,
+				Message:            cond.message,
+			})
+		}
+	}
+	return existingConditions
+}
+
+func reportListenerCondition(index int, l k8s.Listener, obj *k8sbeta.Gateway,
+	gs *k8sbeta.GatewayStatus, conditions map[string]*condition,
+) {
+	for index >= len(gs.Listeners) {
+		gs.Listeners = append(gs.Listeners, k8s.ListenerStatus{})
+	}
+	cond := gs.Listeners[index].Conditions
+	supported, valid := generateSupportedKinds(l)
+	if !valid {
+		conditions[string(k8s.ListenerConditionResolvedRefs)] = &condition{
+			reason:  string(k8s.ListenerReasonInvalidRouteKinds),
+			status:  metav1.ConditionFalse,
+			message: "Invalid route kinds",
+		}
+	}
+	gs.Listeners[index] = k8s.ListenerStatus{
+		Name:           l.Name,
+		AttachedRoutes: 0, // this will be reported later
+		SupportedKinds: supported,
+		Conditions:     setConditions(obj.Generation, cond, conditions),
+	}
+}
+
+func generateSupportedKinds(l k8s.Listener) ([]k8s.RouteGroupKind, bool) {
+	supported := []k8s.RouteGroupKind{}
+	switch l.Protocol {
+	case k8s.HTTPProtocolType, k8s.HTTPSProtocolType:
+		// Only terminate allowed, so its always HTTP
+		supported = []k8s.RouteGroupKind{
+			toRouteKind(gvk.HTTPRoute),
+			toRouteKind(gvk.GRPCRoute),
+		}
+	case k8s.TCPProtocolType:
+		supported = []k8s.RouteGroupKind{toRouteKind(gvk.TCPRoute)}
+	case k8s.TLSProtocolType:
+		if l.TLS != nil && l.TLS.Mode != nil && *l.TLS.Mode == k8s.TLSModePassthrough {
+			supported = []k8s.RouteGroupKind{toRouteKind(gvk.TLSRoute)}
+		} else {
+			supported = []k8s.RouteGroupKind{toRouteKind(gvk.TCPRoute)}
+		}
+		// UDP route not support
+	}
+	if l.AllowedRoutes != nil && len(l.AllowedRoutes.Kinds) > 0 {
+		// We need to filter down to only ones we actually support
+		intersection := []k8s.RouteGroupKind{}
+		for _, s := range supported {
+			for _, kind := range l.AllowedRoutes.Kinds {
+				if routeGroupKindEqual(s, kind) {
+					intersection = append(intersection, s)
+					break
+				}
+			}
+		}
+		return intersection, len(intersection) == len(l.AllowedRoutes.Kinds)
+	}
+	return supported, true
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go b/internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go
new file mode 100644
index 000000000..5d91e1b65
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go
@@ -0,0 +1,124 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"reflect"
+	"testing"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	k8s "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/gvk"
+)
+
+func TestCreateRouteStatus(t *testing.T) {
+	lastTransitionTime := metav1.Now()
+	parentRef := httpRouteSpec.ParentRefs[0]
+	parentStatus := []k8s.RouteParentStatus{
+		{
+			ParentRef:      parentRef,
+			ControllerName: k8s.GatewayController("another-gateway-controller"),
+			Conditions: []metav1.Condition{
+				{Type: "foo", Status: "bar"},
+			},
+		},
+		{
+			ParentRef:      parentRef,
+			ControllerName: k8s.GatewayController(features.ManagedGatewayController),
+			Conditions: []metav1.Condition{
+				{
+					Type:               string(k8s.RouteReasonAccepted),
+					Status:             metav1.ConditionTrue,
+					ObservedGeneration: 1,
+					LastTransitionTime: lastTransitionTime,
+					Message:            "Route was valid",
+				},
+				{
+					Type:               string(k8s.RouteConditionResolvedRefs),
+					Status:             metav1.ConditionTrue,
+					ObservedGeneration: 1,
+					LastTransitionTime: lastTransitionTime,
+					Message:            "All references resolved",
+				},
+				{
+					Type:               string(RouteConditionResolvedWaypoints),
+					Status:             metav1.ConditionTrue,
+					ObservedGeneration: 1,
+					LastTransitionTime: lastTransitionTime,
+					Message:            "All waypoints resolved",
+				},
+			},
+		},
+	}
+
+	httpRoute := config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: gvk.HTTPRoute,
+			Namespace:        "foo",
+			Name:             "bar",
+			Generation:       1,
+		},
+		Spec: &httpRouteSpec,
+		Status: &k8s.HTTPRouteStatus{
+			RouteStatus: k8s.RouteStatus{
+				Parents: parentStatus,
+			},
+		},
+	}
+
+	type args struct {
+		gateways []RouteParentResult
+		obj      config.Config
+		current  []k8s.RouteParentStatus
+	}
+	tests := []struct {
+		name      string
+		args      args
+		wantEqual bool
+	}{
+		{
+			name: "no error",
+			args: args{
+				gateways: []RouteParentResult{{OriginalReference: parentRef}},
+				obj:      httpRoute,
+				current:  parentStatus,
+			},
+			wantEqual: true,
+		},
+		{
+			name: "route status error",
+			args: args{
+				gateways: []RouteParentResult{{OriginalReference: parentRef, RouteError: &ConfigError{
+					Reason: ConfigErrorReason(k8s.RouteReasonRefNotPermitted),
+				}}},
+				obj:     httpRoute,
+				current: parentStatus,
+			},
+			wantEqual: false,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got := createRouteStatus(tt.args.gateways, tt.args.obj.Generation, tt.args.current)
+			equal := reflect.DeepEqual(got, tt.args.current)
+			if equal != tt.wantEqual {
+				t.Errorf("route status: old: %+v, new: %+v", tt.args.current, got)
+			}
+		})
+	}
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/context.go b/internal/kgateway/agentgatewaysyncer/gateway/context.go
new file mode 100644
index 000000000..50190ea21
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/context.go
@@ -0,0 +1,160 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"fmt"
+	"sort"
+	"strconv"
+	"strings"
+
+	corev1 "k8s.io/api/core/v1"
+
+	"istio.io/api/label"
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/util/sets"
+)
+
+// GatewayContext contains a minimal subset of push context functionality to be exposed to GatewayAPIControllers
+type GatewayContext struct {
+	ps      *model.PushContext
+	cluster cluster.ID
+}
+
+func NewGatewayContext(ps *model.PushContext, cluster cluster.ID) GatewayContext {
+	return GatewayContext{ps, cluster}
+}
+
+// ResolveGatewayInstances attempts to resolve all instances that a gateway will be exposed on.
+// Note: this function considers *all* instances of the service; its possible those instances will not actually be properly functioning
+// gateways, so this is not 100% accurate, but sufficient to expose intent to users.
+// The actual configuration generation is done on a per-workload basis and will get the exact set of matched instances for that workload.
+// Four sets are exposed:
+// * Internal addresses (eg istio-ingressgateway.istio-system.svc.cluster.local:80).
+// * Internal IP addresses (eg 1.2.3.4). This comes from ClusterIP.
+// * External addresses (eg 1.2.3.4), this comes from LoadBalancer services. There may be multiple in some cases (especially multi cluster).
+// * Pending addresses (eg istio-ingressgateway.istio-system.svc), are LoadBalancer-type services with pending external addresses.
+// * Warnings for references that could not be resolved. These are intended to be user facing.
+func (gc GatewayContext) ResolveGatewayInstances(
+	namespace string,
+	gwsvcs []string,
+	servers []*networking.Server,
+) (internal, internalIP, external, pending, warns []string, allUsable bool) {
+	ports := map[int]struct{}{}
+	for _, s := range servers {
+		ports[int(s.Port.Number)] = struct{}{}
+	}
+	foundInternal := sets.New[string]()
+	foundInternalIP := sets.New[string]()
+	foundExternal := sets.New[string]()
+	foundPending := sets.New[string]()
+	warnings := []string{}
+	foundUnusable := false
+	log.Debugf("Resolving gateway instances for %v in namespace %s", gwsvcs, namespace)
+	for _, g := range gwsvcs {
+		svc, f := gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(g)][namespace]
+		if !f {
+			otherNamespaces := []string{}
+			for ns := range gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(g)] {
+				otherNamespaces = append(otherNamespaces, `"`+ns+`"`) // Wrap in quotes for output
+			}
+			if len(otherNamespaces) > 0 {
+				sort.Strings(otherNamespaces)
+				warnings = append(warnings, fmt.Sprintf("hostname %q not found in namespace %q, but it was found in namespace(s) %v",
+					g, namespace, strings.Join(otherNamespaces, ", ")))
+			} else {
+				warnings = append(warnings, fmt.Sprintf("hostname %q not found", g))
+			}
+			foundUnusable = true
+			continue
+		}
+		svcKey := svc.Key()
+		for port := range ports {
+			instances := gc.ps.ServiceEndpointsByPort(svc, port, nil)
+			if len(instances) > 0 {
+				foundInternal.Insert(fmt.Sprintf("%s:%d", g, port))
+				dummyProxy := &model.Proxy{Metadata: &model.NodeMetadata{ClusterID: gc.cluster}}
+				dummyProxy.SetIPMode(model.Dual)
+				foundInternalIP.InsertAll(svc.GetAllAddressesForProxy(dummyProxy)...)
+				if svc.Attributes.ClusterExternalAddresses.Len() > 0 {
+					// Fetch external IPs from all clusters
+					svc.Attributes.ClusterExternalAddresses.ForEach(func(c cluster.ID, externalIPs []string) {
+						foundExternal.InsertAll(externalIPs...)
+					})
+				} else if corev1.ServiceType(svc.Attributes.Type) == corev1.ServiceTypeLoadBalancer {
+					if !foundPending.Contains(g) {
+						warnings = append(warnings, fmt.Sprintf("address pending for hostname %q", g))
+						foundPending.Insert(g)
+					}
+				}
+			} else {
+				instancesByPort := gc.ps.ServiceEndpoints(svcKey)
+				if instancesEmpty(instancesByPort) {
+					warnings = append(warnings, fmt.Sprintf("no instances found for hostname %q", g))
+				} else {
+					hintPort := sets.New[string]()
+					for servicePort, instances := range instancesByPort {
+						for _, i := range instances {
+							if i.EndpointPort == uint32(port) {
+								hintPort.Insert(strconv.Itoa(servicePort))
+							}
+						}
+					}
+					if hintPort.Len() > 0 {
+						warnings = append(warnings, fmt.Sprintf(
+							"port %d not found for hostname %q (hint: the service port should be specified, not the workload port. Did you mean one of these ports: %v?)",
+							port, g, sets.SortedList(hintPort)))
+						foundUnusable = true
+					} else {
+						_, isManaged := svc.Attributes.Labels[label.GatewayManaged.Name]
+						var portExistsOnService bool
+						for _, p := range svc.Ports {
+							if p.Port == port {
+								portExistsOnService = true
+								break
+							}
+						}
+						// If this is a managed gateway, the only possible explanation for no instances for the port
+						// is a delay in endpoint sync. Therefore, we don't want to warn/change the Programmed condition
+						// in this case as long as the port exists on the `Service` object.
+						if !isManaged || !portExistsOnService {
+							warnings = append(warnings, fmt.Sprintf("port %d not found for hostname %q", port, g))
+							foundUnusable = true
+						}
+					}
+				}
+			}
+		}
+	}
+	sort.Strings(warnings)
+	return sets.SortedList(foundInternal), sets.SortedList(foundInternalIP), sets.SortedList(foundExternal), sets.SortedList(foundPending),
+		warnings, !foundUnusable
+}
+
+func (gc GatewayContext) GetService(hostname, namespace string) *model.Service {
+	return gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(hostname)][namespace]
+}
+
+func instancesEmpty(m map[int][]*model.IstioEndpoint) bool {
+	for _, instances := range m {
+		if len(instances) > 0 {
+			return false
+		}
+	}
+	return true
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/controller.go b/internal/kgateway/agentgatewaysyncer/gateway/controller.go
new file mode 100644
index 000000000..9b10c5faf
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/controller.go
@@ -0,0 +1,677 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"fmt"
+	"strconv"
+
+	"go.uber.org/atomic"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	kubesecrets "istio.io/istio/pilot/pkg/credentials/kube"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
+	"istio.io/istio/pilot/pkg/status"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/gvr"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/kclient"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/kube/kubetypes"
+	istiolog "istio.io/istio/pkg/log"
+	"istio.io/istio/pkg/revisions"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/sets"
+	"istio.io/istio/pkg/workloadapi"
+)
+
+var log = istiolog.RegisterScope("gateway", "gateway-api controller")
+
+var errUnsupportedOp = fmt.Errorf("unsupported operation: the gateway config store is a read-only view")
+
+// Controller defines the controller for the gateway-api. The controller reads a variety of resources (Gateway types, as well
+// as adjacent types like Namespace and Service), and through `krt`, translates them into Istio types (Gateway/VirtualService).
+//
+// Most resources are fully "self-contained" with krt, but there are a few usages breaking out of `krt`; these are managed by `krt.RecomputeProtected`.
+// These are recomputed on each new PushContext initialization, which will call Controller.Reconcile().
+//
+// The generated Istio types are not stored in the cluster at all and are purely internal. Calls to List() (from PushContext)
+// will expose these. They can be introspected at /debug/configz.
+//
+// The status on all gateway-api types is also tracked. Each collection emits downstream objects, but also status about the
+// input type. If the status changes, it is queued to asynchronously update the status of the object in Kubernetes.
+type Controller struct {
+	// client for accessing Kubernetes
+	client kube.Client
+
+	// the cluster where the gateway-api controller runs
+	cluster cluster.ID
+	// revision the controller is running under
+	revision string
+
+	// status controls the status writing queue. Status will only be written if statusEnabled is true, which
+	// is only the case when we are the leader.
+	status *StatusCollections
+
+	waitForCRD func(class schema.GroupVersionResource, stop <-chan struct{}) bool
+
+	// gatewayContext exposes us to the internal Istio service registry. This is outside krt knowledge (currently), so,
+	// so we wrap it in a RecomputeProtected.
+	// Most usages in the API are directly referenced typed objects (Service, ServiceEntry, etc) so this is not needed typically.
+	gatewayContext krt.RecomputeProtected[*atomic.Pointer[GatewayContext]]
+	// tagWatcher allows us to check which tags are ours. Unlike most Istio codepaths, we read istio.io/rev=<tag> and not just
+	// revisions for Gateways. This is because a Gateway is sort of a mix of a Deployment and Config.
+	// Since the TagWatcher is not yet krt-aware, we wrap this in RecomputeProtected.
+	tagWatcher krt.RecomputeProtected[revisions.TagWatcher]
+
+	stop chan struct{}
+
+	xdsUpdater model.XDSUpdater
+
+	// Handlers tracks all registered handlers, so that syncing can be detected
+	handlers []krt.HandlerRegistration
+
+	// outputs contains all the output collections for this controller.
+	// Currently, the only usage of this controller is from non-krt things (PushContext) so this is not exposed directly.
+	// If desired in the future, it could be.
+	outputs Outputs
+}
+
+func (c *Controller) Collection() krt.Collection[model.ADPResource] {
+	return c.outputs.ADPResources
+}
+
+type ParentInfo struct {
+	Key  parentKey
+	Info parentInfo
+}
+
+func (pi ParentInfo) ResourceName() string {
+	return pi.Key.Name // TODO!!!! more infoi and section name
+}
+
+type TypedResource struct {
+	Kind config.GroupVersionKind
+	Name types.NamespacedName
+}
+
+type Outputs struct {
+	Gateways        krt.Collection[Gateway]
+	VirtualServices krt.Collection[*config.Config]
+	ReferenceGrants ReferenceGrants
+
+	ADPResources krt.Collection[model.ADPResource]
+}
+
+type Inputs struct {
+	Namespaces krt.Collection[*corev1.Namespace]
+
+	Services krt.Collection[*corev1.Service]
+	Secrets  krt.Collection[*corev1.Secret]
+
+	GatewayClasses  krt.Collection[*gateway.GatewayClass]
+	Gateways        krt.Collection[*gateway.Gateway]
+	HTTPRoutes      krt.Collection[*gateway.HTTPRoute]
+	GRPCRoutes      krt.Collection[*gatewayv1.GRPCRoute]
+	TCPRoutes       krt.Collection[*gatewayalpha.TCPRoute]
+	TLSRoutes       krt.Collection[*gatewayalpha.TLSRoute]
+	ReferenceGrants krt.Collection[*gateway.ReferenceGrant]
+	ServiceEntries  krt.Collection[*networkingclient.ServiceEntry]
+	InferencePools  krt.Collection[*inf.InferencePool]
+}
+
+var _ model.GatewayController = &Controller{}
+
+func NewController(
+	kc kube.Client,
+	waitForCRD func(class schema.GroupVersionResource, stop <-chan struct{}) bool,
+	options controller.Options,
+	xdsUpdater model.XDSUpdater,
+) *Controller {
+	stop := make(chan struct{})
+	opts := krt.NewOptionsBuilder(stop, "gateway", options.KrtDebugger)
+
+	tw := revisions.NewTagWatcher(kc, options.Revision)
+	c := &Controller{
+		client:         kc,
+		cluster:        options.ClusterID,
+		revision:       options.Revision,
+		status:         &StatusCollections{},
+		tagWatcher:     krt.NewRecomputeProtected(tw, false, opts.WithName("tagWatcher")...),
+		waitForCRD:     waitForCRD,
+		gatewayContext: krt.NewRecomputeProtected(atomic.NewPointer[GatewayContext](nil), false, opts.WithName("gatewayContext")...),
+		stop:           stop,
+		xdsUpdater:     xdsUpdater,
+	}
+	tw.AddHandler(func(s sets.String) {
+		c.tagWatcher.TriggerRecomputation()
+	})
+
+	inputs := Inputs{
+		Namespaces: krt.NewInformer[*corev1.Namespace](kc, opts.WithName("informer/Namespaces")...),
+		Secrets: krt.WrapClient[*corev1.Secret](
+			kclient.NewFiltered[*corev1.Secret](kc, kubetypes.Filter{
+				FieldSelector: kubesecrets.SecretsFieldSelector,
+				ObjectFilter:  kc.ObjectFilter(),
+			}),
+			opts.WithName("informer/Secrets")...,
+		),
+		Services: krt.WrapClient[*corev1.Service](
+			kclient.NewFiltered[*corev1.Service](kc, kubetypes.Filter{ObjectFilter: kc.ObjectFilter()}),
+			opts.WithName("informer/Services")...,
+		),
+		GatewayClasses: buildClient[*gateway.GatewayClass](c, kc, gvr.GatewayClass, opts, "informer/GatewayClasses"),
+		Gateways:       buildClient[*gateway.Gateway](c, kc, gvr.KubernetesGateway, opts, "informer/Gateways"),
+		HTTPRoutes:     buildClient[*gateway.HTTPRoute](c, kc, gvr.HTTPRoute, opts, "informer/HTTPRoutes"),
+		GRPCRoutes:     buildClient[*gatewayv1.GRPCRoute](c, kc, gvr.GRPCRoute, opts, "informer/GRPCRoutes"),
+
+		ReferenceGrants: buildClient[*gateway.ReferenceGrant](c, kc, gvr.ReferenceGrant, opts, "informer/ReferenceGrants"),
+		ServiceEntries:  buildClient[*networkingclient.ServiceEntry](c, kc, gvr.ServiceEntry, opts, "informer/ServiceEntries"),
+		InferencePools:  buildClient[*inf.InferencePool](c, kc, gvr.InferencePool, opts, "informer/InferencePools"),
+	}
+	if features.EnableAlphaGatewayAPI {
+		inputs.TCPRoutes = buildClient[*gatewayalpha.TCPRoute](c, kc, gvr.TCPRoute, opts, "informer/TCPRoutes")
+		inputs.TLSRoutes = buildClient[*gatewayalpha.TLSRoute](c, kc, gvr.TLSRoute, opts, "informer/TLSRoutes")
+	} else {
+		// If disabled, still build a collection but make it always empty
+		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, nil, opts.WithName("disable/TCPRoutes")...)
+		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, nil, opts.WithName("disable/TLSRoutes")...)
+	}
+
+	handlers := []krt.HandlerRegistration{}
+
+	GatewayClassStatus, GatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, opts)
+	registerStatus(c, GatewayClassStatus)
+
+	ReferenceGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, opts))
+
+	// GatewaysStatus cannot is not fully complete until its join with route attachments to report attachedRoutes.
+	// Do not register yet.
+	GatewaysStatus, Gateways := GatewayCollection(
+		inputs.Gateways,
+		GatewayClasses,
+		inputs.Namespaces,
+		ReferenceGrants,
+		inputs.Secrets,
+		options.DomainSuffix,
+		c.gatewayContext,
+		c.tagWatcher,
+		opts,
+	)
+	ports := krt.NewIndex(Gateways, func(o Gateway) []string {
+		return []string{fmt.Sprint(o.parentInfo.Port)}
+	}).AsCollection(opts.WithName("PortBindings")...)
+	Binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object krt.IndexObject[string, Gateway]) []model.ADPResource {
+		port, _ := strconv.Atoi(object.Key)
+		uniq := sets.New[types.NamespacedName]()
+		for _, gw := range object.Objects {
+			uniq.Insert(types.NamespacedName{
+				Namespace: gw.parent.Namespace,
+				Name:      gw.parent.Name,
+			})
+		}
+		return slices.Map(uniq.UnsortedList(), func(e types.NamespacedName) model.ADPResource {
+			bind := Bind{
+				Bind: &workloadapi.Bind{
+					Key:  object.Key + "/" + e.String(),
+					Port: uint32(port),
+				},
+			}
+			return toResource(e, bind)
+		})
+	}, opts.WithName("Binds")...)
+	WaypointBinds := krt.NewCollection(inputs.Gateways, func(ctx krt.HandlerContext, gw *gateway.Gateway) *model.ADPResource {
+		if gw.Spec.GatewayClassName != "istio-waypoint" {
+			return nil
+		}
+		port := 15008
+		e := config.NamespacedName(gw)
+		bind := Bind{
+			Bind: &workloadapi.Bind{
+				Key:  "waypoint/" + e.String(),
+				Port: uint32(port),
+			},
+		}
+		return toResourcep(e, bind)
+	}, opts.WithName("WaypointBinds")...)
+	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *model.ADPResource {
+		l := &workloadapi.Listener{
+			Key:         obj.ResourceName(),
+			Name:        string(obj.parentInfo.SectionName),
+			BindKey:     fmt.Sprint(obj.parentInfo.Port) + "/" + obj.parent.Namespace + "/" + obj.parent.Name,
+			GatewayName: obj.parent.Namespace + "/" + obj.parent.Name,
+			Hostname:    obj.parentInfo.OriginalHostname,
+		}
+
+		switch obj.parentInfo.Protocol {
+		case gatewayv1.HTTPProtocolType:
+			l.Protocol = workloadapi.Protocol_HTTP
+		case gatewayv1.HTTPSProtocolType:
+			l.Protocol = workloadapi.Protocol_HTTPS
+			if obj.TLSInfo == nil {
+				return nil
+			}
+			l.Tls = &workloadapi.TLSConfig{
+				Cert:       obj.TLSInfo.Cert,
+				PrivateKey: obj.TLSInfo.Key,
+			}
+		case gatewayv1.TLSProtocolType:
+			l.Protocol = workloadapi.Protocol_TLS
+			if obj.TLSInfo == nil {
+				return nil
+			}
+			l.Tls = &workloadapi.TLSConfig{
+				Cert:       obj.TLSInfo.Cert,
+				PrivateKey: obj.TLSInfo.Key,
+			}
+		case gatewayv1.TCPProtocolType:
+			l.Protocol = workloadapi.Protocol_TCP
+		default:
+			return nil
+		}
+		return toResourcep(types.NamespacedName{
+			Namespace: obj.parent.Namespace,
+			Name:      obj.parent.Name,
+		}, ADPListener{l})
+	}, opts.WithName("Listeners")...)
+	WaypointListeners := krt.NewCollection(inputs.Gateways, func(ctx krt.HandlerContext, gw *gateway.Gateway) *model.ADPResource {
+		if gw.Spec.GatewayClassName != "istio-waypoint" {
+			return nil
+		}
+
+		e := config.NamespacedName(gw)
+		bind := ADPListener{
+			Listener: &workloadapi.Listener{
+				Key:         "waypoint/" + e.String(),
+				Name:        "waypoint/" + e.String(),
+				BindKey:     "waypoint/" + e.String(),
+				GatewayName: e.String(),
+				Hostname:    "",
+				Protocol:    workloadapi.Protocol_HBONE,
+				Tls:         nil,
+			},
+		}
+		return toResourcep(e, bind)
+	}, opts.WithName("WaypointListeners")...)
+
+	RouteParents := BuildRouteParents(Gateways)
+
+	routeInputs := RouteContextInputs{
+		Grants:          ReferenceGrants,
+		RouteParents:    RouteParents,
+		DomainSuffix:    options.DomainSuffix,
+		Services:        inputs.Services,
+		Namespaces:      inputs.Namespaces,
+		ServiceEntries:  inputs.ServiceEntries,
+		InferencePools:  inputs.InferencePools,
+		internalContext: c.gatewayContext,
+	}
+	ADPRoutes := ADPRouteCollection(
+		inputs.HTTPRoutes,
+		routeInputs,
+		opts,
+	)
+	//tcpRoutes := TCPRouteCollection(
+	//	inputs.TCPRoutes,
+	//	routeInputs,
+	//	opts,
+	//)
+	//registerStatus(c, tcpRoutes.Status)
+	//tlsRoutes := TLSRouteCollection(
+	//	inputs.TLSRoutes,
+	//	routeInputs,
+	//	opts,
+	//)
+	//registerStatus(c, tlsRoutes.Status)
+	httpRoutes := HTTPRouteCollection(
+		inputs.HTTPRoutes,
+		routeInputs,
+		opts,
+	)
+	registerStatus(c, httpRoutes.Status)
+	status, _ := krt.NewStatusCollection(inputs.InferencePools, func(krtctx krt.HandlerContext, obj *inf.InferencePool) (
+		*inf.InferencePoolStatus,
+		*any,
+	) {
+		status := obj.Status.DeepCopy()
+		myGws := sets.New[types.NamespacedName]()
+		allGws := sets.New[types.NamespacedName]() // this is dumb but https://github.com/kubernetes-sigs/gateway-api-inference-extension/issues/942...
+		allGwsRaw := krt.Fetch(krtctx, inputs.Gateways)
+		for _, g := range allGwsRaw {
+			allGws.Insert(config.NamespacedName(g))
+			if string(g.Spec.GatewayClassName) == features.GatewayAPIDefaultGatewayClass {
+				myGws.Insert(config.NamespacedName(g))
+			}
+		}
+		seen := sets.New[types.NamespacedName]()
+		np := []inf.PoolStatus{}
+		for _, s := range status.Parents {
+			k := types.NamespacedName{
+				Name:      s.GatewayRef.Name,
+				Namespace: s.GatewayRef.Namespace,
+			}
+			if !allGws.Contains(k) {
+				// Even if it's not ours, delete stale ref. Shrug.
+				continue
+			}
+			if s.GatewayRef.Kind != gvk.KubernetesGateway.Kind {
+				np = append(np, s)
+				continue
+			}
+			if seen.Contains(k) {
+				continue
+			}
+			if !myGws.Contains(k) {
+				np = append(np, s)
+				continue
+			}
+			myGws.Delete(k)
+			seen.Insert(k)
+			conds := map[string]*condition{
+				string(inf.InferencePoolConditionAccepted): {
+					reason:  string(inf.InferencePoolReasonAccepted),
+					message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
+				},
+			}
+			np = append(np, inf.PoolStatus{
+				GatewayRef: corev1.ObjectReference{
+					APIVersion: gatewayv1.GroupVersion.String(),
+					Kind:       gvk.KubernetesGateway.Kind,
+					Namespace:  k.Namespace,
+					Name:       k.Name,
+				},
+				Conditions: setConditions(obj.Generation, s.Conditions, conds),
+			})
+		}
+		for _, k := range myGws.UnsortedList() {
+			conds := map[string]*condition{
+				string(inf.InferencePoolConditionAccepted): {
+					reason:  string(inf.InferencePoolReasonAccepted),
+					message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
+				},
+			}
+			np = append(np, inf.PoolStatus{
+				GatewayRef: corev1.ObjectReference{
+					APIVersion: gatewayv1.GroupVersion.String(),
+					Kind:       gvk.KubernetesGateway.Kind,
+					Namespace:  k.Namespace,
+					Name:       k.Name,
+				},
+				Conditions: setConditions(obj.Generation, nil, conds),
+			})
+		}
+		status.Parents = np
+		return status, nil
+	}, opts.WithName("InferencePools")...)
+	registerStatus(c, status)
+	//grpcRoutes := GRPCRouteCollection(
+	//	inputs.GRPCRoutes,
+	//	routeInputs,
+	//	opts,
+	//)
+	//registerStatus(c, grpcRoutes.Status)
+
+	RouteAttachments := krt.JoinCollection([]krt.Collection[*RouteAttachment]{
+		// tcpRoutes.RouteAttachments,
+		// tlsRoutes.RouteAttachments,
+		httpRoutes.RouteAttachments,
+		// grpcRoutes.RouteAttachments,
+	}, opts.WithName("RouteAttachments")...)
+	RouteAttachmentsIndex := krt.NewIndex(RouteAttachments, func(o *RouteAttachment) []GatewayAndListener {
+		return []GatewayAndListener{{
+			ListenerName: o.ListenerName,
+			To:           o.To,
+		}}
+	})
+
+	GatewayFinalStatus := FinalGatewayStatusCollection(GatewaysStatus, RouteAttachments, RouteAttachmentsIndex, opts)
+	registerStatus(c, GatewayFinalStatus)
+
+	VirtualServices := krt.JoinCollection([]krt.Collection[*config.Config]{
+		// tcpRoutes.VirtualServices,
+		// tlsRoutes.VirtualServices,
+		httpRoutes.VirtualServices,
+		// grpcRoutes.VirtualServices,
+	}, opts.WithName("DerivedVirtualServices")...)
+
+	ADPResources := krt.JoinCollection([]krt.Collection[model.ADPResource]{Binds, WaypointBinds, Listeners, WaypointListeners, ADPRoutes}, opts.WithName("ADPResources")...)
+
+	outputs := Outputs{
+		ReferenceGrants: ReferenceGrants,
+		Gateways:        Gateways,
+		VirtualServices: VirtualServices,
+
+		ADPResources: ADPResources,
+	}
+	c.outputs = outputs
+
+	handlers = append(handlers,
+		outputs.VirtualServices.RegisterBatch(pushXds(xdsUpdater,
+			func(t *config.Config) model.ConfigKey {
+				return model.ConfigKey{
+					Kind:      kind.VirtualService,
+					Name:      t.Name,
+					Namespace: t.Namespace,
+				}
+			}), false),
+		outputs.ADPResources.RegisterBatch(pushXds(xdsUpdater,
+			func(t model.ADPResource) model.ConfigKey {
+				return model.ConfigKey{
+					Kind: kind.ADP,
+					Name: t.ResourceName(),
+				}
+			}), false),
+		outputs.Gateways.RegisterBatch(pushXds(xdsUpdater,
+			func(t Gateway) model.ConfigKey {
+				return model.ConfigKey{
+					Kind:      kind.Gateway,
+					Name:      t.Name,
+					Namespace: t.Namespace,
+				}
+			}), false),
+		outputs.ReferenceGrants.collection.RegisterBatch(pushXds(xdsUpdater,
+			func(t ReferenceGrant) model.ConfigKey {
+				return model.ConfigKey{
+					Kind:      kind.KubernetesGateway,
+					Name:      t.Source.Name,
+					Namespace: t.Source.Namespace,
+				}
+			}), false))
+	c.handlers = handlers
+
+	return c
+}
+
+// buildClient is a small wrapper to build a krt collection based on a delayed informer.
+func buildClient[I controllers.ComparableObject](
+	c *Controller,
+	kc kube.Client,
+	res schema.GroupVersionResource,
+	opts krt.OptionsBuilder,
+	name string,
+) krt.Collection[I] {
+	filter := kclient.Filter{
+		ObjectFilter: kubetypes.ComposeFilters(kc.ObjectFilter(), c.inRevision),
+	}
+
+	// all other types are filtered by revision, but for gateways we need to select tags as well
+	if res == gvr.KubernetesGateway {
+		filter.ObjectFilter = kc.ObjectFilter()
+	}
+
+	cc := kclient.NewDelayedInformer[I](kc, res, kubetypes.StandardInformer, filter)
+	return krt.WrapClient[I](cc, opts.WithName(name)...)
+}
+
+func (c *Controller) Schemas() collection.Schemas {
+	return collection.SchemasFor(
+		collections.VirtualService,
+		collections.Gateway,
+	)
+}
+
+func (c *Controller) Get(typ config.GroupVersionKind, name, namespace string) *config.Config {
+	return nil
+}
+
+func (c *Controller) List(typ config.GroupVersionKind, namespace string) []config.Config {
+	switch typ {
+	case gvk.Gateway:
+		res := slices.MapFilter(c.outputs.Gateways.List(), func(g Gateway) *config.Config {
+			if g.Valid {
+				return g.Config
+			}
+			return nil
+		})
+		return res
+	case gvk.VirtualService:
+		return slices.Map(c.outputs.VirtualServices.List(), func(e *config.Config) config.Config {
+			return *e
+		})
+	default:
+		return nil
+	}
+}
+
+func (c *Controller) SetStatusWrite(enabled bool, statusManager *status.Manager) {
+	if enabled && features.EnableGatewayAPIStatus && statusManager != nil {
+		var q status.Queue = statusManager.CreateGenericController(func(status status.Manipulator, context any) {
+			status.SetInner(context)
+		})
+		c.status.SetQueue(q)
+	} else {
+		c.status.UnsetQueue()
+	}
+}
+
+// Reconcile is called each time the `gatewayContext` may change. We use this to mark it as updated.
+func (c *Controller) Reconcile(ps *model.PushContext) {
+	ctx := NewGatewayContext(ps, c.cluster)
+	c.gatewayContext.Modify(func(i **atomic.Pointer[GatewayContext]) {
+		(*i).Store(&ctx)
+	})
+	c.gatewayContext.MarkSynced()
+}
+
+func (c *Controller) Create(config config.Config) (revision string, err error) {
+	return "", errUnsupportedOp
+}
+
+func (c *Controller) Update(config config.Config) (newRevision string, err error) {
+	return "", errUnsupportedOp
+}
+
+func (c *Controller) UpdateStatus(config config.Config) (newRevision string, err error) {
+	return "", errUnsupportedOp
+}
+
+func (c *Controller) Patch(orig config.Config, patchFn config.PatchFunc) (string, error) {
+	return "", errUnsupportedOp
+}
+
+func (c *Controller) Delete(typ config.GroupVersionKind, name, namespace string, _ *string) error {
+	return errUnsupportedOp
+}
+
+func (c *Controller) RegisterEventHandler(typ config.GroupVersionKind, handler model.EventHandler) {
+}
+
+func (c *Controller) Run(stop <-chan struct{}) {
+	if features.EnableGatewayAPIGatewayClassController {
+		go func() {
+			if c.waitForCRD(gvr.GatewayClass, stop) {
+				gcc := NewClassController(c.client)
+				c.client.RunAndWait(stop)
+				gcc.Run(stop)
+			}
+		}()
+	}
+
+	tw := c.tagWatcher.AccessUnprotected()
+	go tw.Run(stop)
+	go func() {
+		kube.WaitForCacheSync("gateway tag watcher", stop, tw.HasSynced)
+		c.tagWatcher.MarkSynced()
+	}()
+
+	<-stop
+	close(c.stop)
+}
+
+func (c *Controller) HasSynced() bool {
+	if !(c.outputs.VirtualServices.HasSynced() &&
+		c.outputs.Gateways.HasSynced() &&
+		c.outputs.ReferenceGrants.collection.HasSynced()) {
+		return false
+	}
+	for _, h := range c.handlers {
+		if !h.HasSynced() {
+			return false
+		}
+	}
+	return true
+}
+
+func (c *Controller) SecretAllowed(resourceName string, namespace string) bool {
+	return c.outputs.ReferenceGrants.SecretAllowed(nil, resourceName, namespace)
+}
+
+func pushXds[T any](xds model.XDSUpdater, f func(T) model.ConfigKey) func(events []krt.Event[T]) {
+	return func(events []krt.Event[T]) {
+		if xds == nil {
+			return
+		}
+		cu := sets.New[model.ConfigKey]()
+		for _, e := range events {
+			for _, i := range e.Items() {
+				c := f(i)
+				if c != (model.ConfigKey{}) {
+					cu.Insert(c)
+				}
+			}
+		}
+		if len(cu) == 0 {
+			return
+		}
+		xds.ConfigUpdate(&model.PushRequest{
+			Full:           true,
+			ConfigsUpdated: cu,
+			Reason:         model.NewReasonStats(model.ConfigUpdate),
+		})
+	}
+}
+
+func (c *Controller) inRevision(obj any) bool {
+	object := controllers.ExtractObject(obj)
+	if object == nil {
+		return false
+	}
+	return config.LabelsInRevision(object.GetLabels(), c.revision)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/controller_test.go b/internal/kgateway/agentgatewaysyncer/gateway/controller_test.go
new file mode 100644
index 000000000..c5cb489e8
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/controller_test.go
@@ -0,0 +1,137 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"testing"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	k8s "sigs.k8s.io/gateway-api/apis/v1"
+	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/networking/core"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/util/assert"
+)
+
+var (
+	gatewayClassSpec = &k8s.GatewayClassSpec{
+		ControllerName: k8s.GatewayController(features.ManagedGatewayController),
+	}
+	gatewaySpec = &k8s.GatewaySpec{
+		GatewayClassName: "gwclass",
+		Listeners: []k8s.Listener{
+			{
+				Name:          "default",
+				Port:          9009,
+				Protocol:      "HTTP",
+				AllowedRoutes: &k8s.AllowedRoutes{Namespaces: &k8s.RouteNamespaces{From: func() *k8s.FromNamespaces { x := k8s.NamespacesFromAll; return &x }()}},
+			},
+		},
+	}
+	httpRouteSpec = &k8s.HTTPRouteSpec{
+		CommonRouteSpec: k8s.CommonRouteSpec{ParentRefs: []k8s.ParentReference{{
+			Name: "gwspec",
+		}}},
+		Hostnames: []k8s.Hostname{"test.cluster.local"},
+	}
+
+	expectedgw = &networking.Gateway{
+		Servers: []*networking.Server{
+			{
+				Port: &networking.Port{
+					Number:   9009,
+					Name:     "default",
+					Protocol: "HTTP",
+				},
+				Hosts: []string{"*/*"},
+			},
+		},
+	}
+)
+
+var AlwaysReady = func(class schema.GroupVersionResource, stop <-chan struct{}) bool {
+	return true
+}
+
+func setupController(t *testing.T, objs ...runtime.Object) *Controller {
+	kc := kube.NewFakeClient(objs...)
+	setupClientCRDs(t, kc)
+	stop := test.NewStop(t)
+	controller := NewController(
+		kc,
+		AlwaysReady,
+		controller.Options{KrtDebugger: krt.GlobalDebugHandler},
+		nil)
+	kc.RunAndWait(stop)
+	go controller.Run(stop)
+	cg := core.NewConfigGenTest(t, core.TestOptions{})
+	controller.Reconcile(cg.PushContext())
+	kube.WaitForCacheSync("test", stop, controller.HasSynced)
+
+	return controller
+}
+
+func TestListInvalidGroupVersionKind(t *testing.T) {
+	controller := setupController(t)
+
+	typ := config.GroupVersionKind{Kind: "wrong-kind"}
+	c := controller.List(typ, "ns1")
+	assert.Equal(t, len(c), 0)
+}
+
+func TestListGatewayResourceType(t *testing.T) {
+	controller := setupController(t,
+		&k8sbeta.GatewayClass{
+			ObjectMeta: metav1.ObjectMeta{
+				Name: "gwclass",
+			},
+			Spec: *gatewayClassSpec,
+		},
+		&k8sbeta.Gateway{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "gwspec",
+				Namespace: "ns1",
+			},
+			Spec: *gatewaySpec,
+		},
+		&k8sbeta.HTTPRoute{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "http-route",
+				Namespace: "ns1",
+			},
+			Spec: *httpRouteSpec,
+		})
+
+	dumpOnFailure(t, krt.GlobalDebugHandler)
+	cfg := controller.List(gvk.Gateway, "ns1")
+	assert.Equal(t, len(cfg), 1)
+	for _, c := range cfg {
+		assert.Equal(t, c.GroupVersionKind, gvk.Gateway)
+		assert.Equal(t, c.Name, "gwspec"+"-"+constants.KubernetesGatewayName+"-default")
+		assert.Equal(t, c.Namespace, "ns1")
+		assert.Equal(t, c.Spec, any(expectedgw))
+	}
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conversion.go b/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
new file mode 100644
index 000000000..f0f23a3a2
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
@@ -0,0 +1,2404 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"cmp"
+	"crypto/tls"
+	"fmt"
+	"net"
+	"net/netip"
+	"sort"
+	"strconv"
+	"strings"
+	"time"
+
+	"google.golang.org/protobuf/types/known/durationpb"
+	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	klabels "k8s.io/apimachinery/pkg/labels"
+	k8s "sigs.k8s.io/gateway-api/apis/v1"
+	k8salpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"istio.io/api/annotation"
+	"istio.io/api/label"
+	istio "istio.io/api/networking/v1alpha3"
+	kubecreds "istio.io/istio/pilot/pkg/credentials/kube"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	creds "istio.io/istio/pilot/pkg/model/credentials"
+	"istio.io/istio/pilot/pkg/model/kstatus"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/schema/collections"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/kind"
+	schematypes "istio.io/istio/pkg/config/schema/kubetypes"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/sets"
+	"istio.io/istio/pkg/workloadapi"
+)
+
+const (
+	gatewayTLSTerminateModeKey = "gateway.istio.io/tls-terminate-mode"
+	addressTypeOverride        = "networking.istio.io/address-type"
+	gatewayClassDefaults       = "gateway.istio.io/defaults-for-class"
+)
+
+func sortConfigByCreationTime(configs []config.Config) {
+	sort.Slice(configs, func(i, j int) bool {
+		if r := configs[i].CreationTimestamp.Compare(configs[j].CreationTimestamp); r != 0 {
+			return r == -1 // -1 means i is less than j, so return true
+		}
+		if r := cmp.Compare(configs[i].Namespace, configs[j].Namespace); r != 0 {
+			return r == -1
+		}
+		return cmp.Compare(configs[i].Name, configs[j].Name) == -1
+	})
+}
+
+func sortRoutesByCreationTime(configs []RouteWithKey) {
+	sort.Slice(configs, func(i, j int) bool {
+		if r := configs[i].CreationTimestamp.Compare(configs[j].CreationTimestamp); r != 0 {
+			return r == -1 // -1 means i is less than j, so return true
+		}
+		if r := cmp.Compare(configs[i].Namespace, configs[j].Namespace); r != 0 {
+			return r == -1
+		}
+		return cmp.Compare(configs[i].Name, configs[j].Name) == -1
+	})
+}
+
+func sortedConfigByCreationTime(configs []config.Config) []config.Config {
+	sortConfigByCreationTime(configs)
+	return configs
+}
+
+func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
+	obj *k8sbeta.HTTPRoute, pos int, matchPos int, enforceRefGrant bool,
+) (*workloadapi.Route, *ConfigError) {
+	res := &workloadapi.Route{
+		Key:         obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) + "." + strconv.Itoa(matchPos),
+		RouteName:   obj.Namespace + "/" + obj.Name,
+		ListenerKey: "",
+		RuleName:    defaultString(r.Name, ""),
+	}
+
+	for _, match := range r.Matches {
+		path, err := createADPPathMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		headers, err := createADPHeadersMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		method, err := createADPMethodMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		query, err := createADPQueryMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		res.Matches = append(res.Matches, &workloadapi.RouteMatch{
+			Path:        path,
+			Headers:     headers,
+			Method:      method,
+			QueryParams: query,
+		})
+	}
+	filters, err := buildADPFilters(ctx, obj.Namespace, enforceRefGrant, r.Filters)
+	if err != nil {
+		return nil, err
+	}
+	res.Filters = filters
+
+	if r.Timeouts != nil {
+		res.TrafficPolicy = &workloadapi.TrafficPolicy{}
+		if r.Timeouts.Request != nil {
+			request, _ := time.ParseDuration(string(*r.Timeouts.Request))
+			if request > 0 {
+				res.TrafficPolicy.RequestTimeout = durationpb.New(request)
+			}
+		}
+		if r.Timeouts.BackendRequest != nil {
+			request, _ := time.ParseDuration(string(*r.Timeouts.BackendRequest))
+			if request > 0 {
+				res.TrafficPolicy.RequestTimeout = durationpb.New(request)
+			}
+		}
+	}
+
+	// Retry: todo
+	route, backendErr, err := buildADPHTTPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant)
+	if err != nil {
+		return nil, err
+	}
+	res.Backends = route
+	res.Hostnames = slices.Map(obj.Spec.Hostnames, func(e k8s.Hostname) string {
+		return string(e)
+	})
+	return res, backendErr
+}
+
+func buildADPFilters(
+	ctx RouteContext,
+	ns string,
+	enforceRefGrant bool,
+	inputFilters []k8s.HTTPRouteFilter,
+) ([]*workloadapi.RouteFilter, *ConfigError) {
+	filters := []*workloadapi.RouteFilter{}
+	var mirrorBackendErr *ConfigError
+	for _, filter := range inputFilters {
+		switch filter.Type {
+		case k8s.HTTPRouteFilterRequestHeaderModifier:
+			h := createADPHeadersFilter(filter.RequestHeaderModifier)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case k8s.HTTPRouteFilterResponseHeaderModifier:
+			h := createADPResponseHeadersFilter(filter.ResponseHeaderModifier)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case k8s.HTTPRouteFilterRequestRedirect:
+			h := createADPRedirectFilter(filter.RequestRedirect)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case k8s.HTTPRouteFilterRequestMirror:
+			h, err := createADPMirrorFilter(ctx, filter.RequestMirror, ns, enforceRefGrant, gvk.HTTPRoute)
+			if err != nil {
+				mirrorBackendErr = err
+			} else {
+				filters = append(filters, h)
+			}
+		case k8s.HTTPRouteFilterURLRewrite:
+			h := createADPRewriteFilter(filter.URLRewrite)
+			if h == nil {
+				continue
+			}
+			filters = append(filters, h)
+		case k8s.HTTPRouteFilterCORS:
+			//return nil, &ConfigError{
+			//	Reason:  InvalidFilter,
+			//	Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
+			//}
+		default:
+			return nil, &ConfigError{
+				Reason:  InvalidFilter,
+				Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
+			}
+		}
+	}
+	return filters, mirrorBackendErr
+}
+
+func buildADPHTTPDestination(
+	ctx RouteContext,
+	forwardTo []k8s.HTTPBackendRef,
+	ns string,
+	enforceRefGrant bool,
+) ([]*workloadapi.RouteBackend, *ConfigError, *ConfigError) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+
+	var invalidBackendErr *ConfigError
+	res := []*workloadapi.RouteBackend{}
+	for _, fwd := range forwardTo {
+		dst, err := buildADPDestination(ctx, fwd, ns, enforceRefGrant, gvk.HTTPRoute)
+		if err != nil {
+			log.Errorf("howardjohn: adp error: %v", err)
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		if dst != nil {
+			filters, err := buildADPFilters(ctx, ns, enforceRefGrant, fwd.Filters)
+			if err != nil {
+				return nil, nil, err
+			}
+			dst.Filters = filters
+		}
+		res = append(res, dst)
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildADPDestination(
+	ctx RouteContext,
+	to k8s.HTTPBackendRef,
+	ns string,
+	enforceRefGrant bool,
+	k config.GroupVersionKind,
+) (*workloadapi.RouteBackend, *ConfigError) {
+	// check if the reference is allowed
+	if enforceRefGrant {
+		if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
+			if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
+				return nil, &ConfigError{
+					Reason:  InvalidDestinationPermit,
+					Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
+				}
+			}
+		}
+	}
+
+	namespace := ptr.OrDefault((*string)(to.Namespace), ns)
+	var invalidBackendErr *ConfigError
+	var hostname string
+	ref := normalizeReference(to.Group, to.Kind, gvk.Service)
+	rb := &workloadapi.RouteBackend{
+		Weight: ptr.OrDefault(to.Weight, 1),
+	}
+	var port *k8s.PortNumber
+	switch ref {
+	case gvk.InferencePool:
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+		log.Errorf("howardjohn: got pool %v for %v", svc, key)
+		if svc == nil {
+			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		} else {
+			port = ptr.Of(k8s.PortNumber(svc.Spec.TargetPortNumber))
+		}
+		rb.Kind = &workloadapi.RouteBackend_Service{Service: namespace + "/" + hostname}
+	case gvk.Service:
+		port = to.Port
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+		rb.Kind = &workloadapi.RouteBackend_Service{Service: namespace + "/" + hostname}
+	default:
+		port = to.Port
+		return nil, &ConfigError{
+			Reason:  InvalidDestinationKind,
+			Message: fmt.Sprintf("referencing unsupported backendRef: group %q kind %q", ptr.OrEmpty(to.Group), ptr.OrEmpty(to.Kind)),
+		}
+	}
+	// All types currently require a Port, so we do this for everything; consider making this per-type if we have future types
+	// that do not require port.
+	if port == nil {
+		// "Port is required when the referent is a Kubernetes Service."
+		return nil, &ConfigError{Reason: InvalidDestination, Message: "port is required in backendRef"}
+	}
+	rb.Port = int32(*port)
+	return rb, invalidBackendErr
+}
+
+func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
+	obj *k8sbeta.HTTPRoute, pos int, enforceRefGrant bool,
+) (*istio.HTTPRoute, *ConfigError) {
+	vs := &istio.HTTPRoute{}
+	if r.Name != nil {
+		vs.Name = string(*r.Name)
+	} else {
+		// Auto-name the route. If upstream defines an explicit name, will use it instead
+		// The position within the route is unique
+		vs.Name = obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) // format: %s.%s.%d
+	}
+
+	for _, match := range r.Matches {
+		uri, err := createURIMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		headers, err := createHeadersMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		qp, err := createQueryParamsMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		method, err := createMethodMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		vs.Match = append(vs.Match, &istio.HTTPMatchRequest{
+			Uri:         uri,
+			Headers:     headers,
+			QueryParams: qp,
+			Method:      method,
+		})
+	}
+	var mirrorBackendErr *ConfigError
+	for _, filter := range r.Filters {
+		switch filter.Type {
+		case k8s.HTTPRouteFilterRequestHeaderModifier:
+			h := createHeadersFilter(filter.RequestHeaderModifier)
+			if h == nil {
+				continue
+			}
+			if vs.Headers == nil {
+				vs.Headers = &istio.Headers{}
+			}
+			vs.Headers.Request = h
+		case k8s.HTTPRouteFilterResponseHeaderModifier:
+			h := createHeadersFilter(filter.ResponseHeaderModifier)
+			if h == nil {
+				continue
+			}
+			if vs.Headers == nil {
+				vs.Headers = &istio.Headers{}
+			}
+			vs.Headers.Response = h
+		case k8s.HTTPRouteFilterRequestRedirect:
+			vs.Redirect = createRedirectFilter(filter.RequestRedirect)
+		case k8s.HTTPRouteFilterRequestMirror:
+			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, enforceRefGrant, gvk.HTTPRoute)
+			if err != nil {
+				mirrorBackendErr = err
+			} else {
+				vs.Mirrors = append(vs.Mirrors, mirror)
+			}
+		case k8s.HTTPRouteFilterURLRewrite:
+			vs.Rewrite = createRewriteFilter(filter.URLRewrite)
+		case k8s.HTTPRouteFilterCORS:
+			vs.CorsPolicy = createCorsFilter(filter.CORS)
+		default:
+			return nil, &ConfigError{
+				Reason:  InvalidFilter,
+				Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
+			}
+		}
+	}
+
+	if r.Retry != nil {
+		// "Implementations SHOULD retry on connection errors (disconnect, reset, timeout,
+		// TCP failure) if a retry stanza is configured."
+		retryOn := []string{"connect-failure", "refused-stream", "unavailable", "cancelled"}
+		for _, codes := range r.Retry.Codes {
+			retryOn = append(retryOn, strconv.Itoa(int(codes)))
+		}
+		vs.Retries = &istio.HTTPRetry{
+			// If unset, default is implementation specific.
+			// VirtualService.retry has no default when set -- users are expected to set it if they customize `retry`.
+			// However, the default retry if none are set is "2", so we use that as the default.
+			Attempts:      int32(ptr.OrDefault(r.Retry.Attempts, 2)),
+			PerTryTimeout: nil,
+			RetryOn:       strings.Join(retryOn, ","),
+		}
+		if vs.Retries.Attempts == 0 {
+			// Invalid to set this when there are no attempts
+			vs.Retries.RetryOn = ""
+		}
+		if r.Retry.Backoff != nil {
+			retrybackOff, _ := time.ParseDuration(string(*r.Retry.Backoff))
+			vs.Retries.Backoff = durationpb.New(retrybackOff)
+		}
+	}
+
+	if r.Timeouts != nil {
+		if r.Timeouts.Request != nil {
+			request, _ := time.ParseDuration(string(*r.Timeouts.Request))
+			if request != 0 {
+				vs.Timeout = durationpb.New(request)
+			}
+		}
+		if r.Timeouts.BackendRequest != nil {
+			backendRequest, _ := time.ParseDuration(string(*r.Timeouts.BackendRequest))
+			if backendRequest != 0 {
+				timeout := durationpb.New(backendRequest)
+				if vs.Retries != nil {
+					vs.Retries.PerTryTimeout = timeout
+				} else {
+					vs.Timeout = timeout
+				}
+			}
+		}
+	}
+	if weightSum(r.BackendRefs) == 0 && vs.Redirect == nil {
+		// The spec requires us to return 500 when there are no >0 weight backends
+		vs.DirectResponse = &istio.HTTPDirectResponse{
+			Status: 500,
+		}
+	} else {
+		route, backendErr, err := buildHTTPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant)
+		if err != nil {
+			return nil, err
+		}
+		vs.Route = route
+		return vs, joinErrors(backendErr, mirrorBackendErr)
+	}
+
+	return vs, mirrorBackendErr
+}
+
+func joinErrors(a *ConfigError, b *ConfigError) *ConfigError {
+	if b == nil {
+		return a
+	}
+	if a == nil {
+		return b
+	}
+	a.Message += "; " + b.Message
+	return a
+}
+
+func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
+	obj *k8s.GRPCRoute, pos int, enforceRefGrant bool,
+) (*istio.HTTPRoute, *ConfigError) {
+	vs := &istio.HTTPRoute{}
+	if r.Name != nil {
+		vs.Name = string(*r.Name)
+	} else {
+		// Auto-name the route. If upstream defines an explicit name, will use it instead
+		// The position within the route is unique
+		vs.Name = obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) // format:%s.%s.%d
+	}
+
+	for _, match := range r.Matches {
+		uri, err := createGRPCURIMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		headers, err := createGRPCHeadersMatch(match)
+		if err != nil {
+			return nil, err
+		}
+		vs.Match = append(vs.Match, &istio.HTTPMatchRequest{
+			Uri:     uri,
+			Headers: headers,
+		})
+	}
+	for _, filter := range r.Filters {
+		switch filter.Type {
+		case k8s.GRPCRouteFilterRequestHeaderModifier:
+			h := createHeadersFilter(filter.RequestHeaderModifier)
+			if h == nil {
+				continue
+			}
+			if vs.Headers == nil {
+				vs.Headers = &istio.Headers{}
+			}
+			vs.Headers.Request = h
+		case k8s.GRPCRouteFilterResponseHeaderModifier:
+			h := createHeadersFilter(filter.ResponseHeaderModifier)
+			if h == nil {
+				continue
+			}
+			if vs.Headers == nil {
+				vs.Headers = &istio.Headers{}
+			}
+			vs.Headers.Response = h
+		case k8s.GRPCRouteFilterRequestMirror:
+			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, enforceRefGrant, gvk.GRPCRoute)
+			if err != nil {
+				return nil, err
+			}
+			vs.Mirrors = append(vs.Mirrors, mirror)
+		default:
+			return nil, &ConfigError{
+				Reason:  InvalidFilter,
+				Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
+			}
+		}
+	}
+
+	if grpcWeightSum(r.BackendRefs) == 0 && vs.Redirect == nil {
+		// The spec requires us to return 500 when there are no >0 weight backends
+		vs.DirectResponse = &istio.HTTPDirectResponse{
+			Status: 500,
+		}
+	} else {
+		route, backendErr, err := buildGRPCDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant)
+		if err != nil {
+			return nil, err
+		}
+		vs.Route = route
+		return vs, backendErr
+	}
+
+	return vs, nil
+}
+
+func parentTypes(rpi []routeParentReference) (mesh, gateway bool) {
+	for _, r := range rpi {
+		if r.IsMesh() {
+			mesh = true
+		} else {
+			gateway = true
+		}
+	}
+	return
+}
+
+func augmentPortMatch(routes []*istio.HTTPRoute, port k8s.PortNumber) []*istio.HTTPRoute {
+	res := make([]*istio.HTTPRoute, 0, len(routes))
+	for _, r := range routes {
+		r = r.DeepCopy()
+		for _, m := range r.Match {
+			m.Port = uint32(port)
+		}
+		if len(r.Match) == 0 {
+			r.Match = []*istio.HTTPMatchRequest{{
+				Port: uint32(port),
+			}}
+		}
+		res = append(res, r)
+	}
+	return res
+}
+
+func augmentTCPPortMatch(routes []*istio.TCPRoute, port k8s.PortNumber) []*istio.TCPRoute {
+	res := make([]*istio.TCPRoute, 0, len(routes))
+	for _, r := range routes {
+		r = r.DeepCopy()
+		for _, m := range r.Match {
+			m.Port = uint32(port)
+		}
+		if len(r.Match) == 0 {
+			r.Match = []*istio.L4MatchAttributes{{
+				Port: uint32(port),
+			}}
+		}
+		res = append(res, r)
+	}
+	return res
+}
+
+func augmentTLSPortMatch(routes []*istio.TLSRoute, port *k8s.PortNumber, parentHosts []string) []*istio.TLSRoute {
+	res := make([]*istio.TLSRoute, 0, len(routes))
+	for _, r := range routes {
+		r = r.DeepCopy()
+		if len(r.Match) == 1 && slices.Equal(r.Match[0].SniHosts, []string{"*"}) {
+			// For mesh, we use parent hosts for SNI if TLSRroute.hostnames were not specified.
+			r.Match[0].SniHosts = parentHosts
+		}
+		for _, m := range r.Match {
+			if port != nil {
+				m.Port = uint32(*port)
+			}
+		}
+		res = append(res, r)
+	}
+	return res
+}
+
+func compatibleRoutesForHost(routes []*istio.TLSRoute, parentHost string) []*istio.TLSRoute {
+	res := make([]*istio.TLSRoute, 0, len(routes))
+	for _, r := range routes {
+		if len(r.Match) == 1 && len(r.Match[0].SniHosts) > 1 {
+			r = r.DeepCopy()
+			sniHosts := []string{}
+			for _, h := range r.Match[0].SniHosts {
+				if host.Name(parentHost).Matches(host.Name(h)) {
+					sniHosts = append(sniHosts, h)
+				}
+			}
+			r.Match[0].SniHosts = sniHosts
+		}
+		res = append(res, r)
+	}
+	return res
+}
+
+func routeMeta(obj controllers.Object) map[string]string {
+	m := parentMeta(obj, nil)
+	m[constants.InternalRouteSemantics] = constants.RouteSemanticsGateway
+	return m
+}
+
+// sortHTTPRoutes sorts generated vs routes to meet gateway-api requirements
+// see https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.HTTPRouteRule
+func sortHTTPRoutes(routes []*istio.HTTPRoute) {
+	sort.SliceStable(routes, func(i, j int) bool {
+		if len(routes[i].Match) == 0 {
+			return false
+		} else if len(routes[j].Match) == 0 {
+			return true
+		}
+		// Only look at match[0], we always generate only one match
+		m1, m2 := routes[i].Match[0], routes[j].Match[0]
+		r1, r2 := getURIRank(m1), getURIRank(m2)
+		len1, len2 := getURILength(m1), getURILength(m2)
+		switch {
+		// 1: Exact/Prefix/Regex
+		case r1 != r2:
+			return r1 > r2
+		case len1 != len2:
+			return len1 > len2
+			// 2: method math
+		case (m1.Method == nil) != (m2.Method == nil):
+			return m1.Method != nil
+			// 3: number of header matches
+		case len(m1.Headers) != len(m2.Headers):
+			return len(m1.Headers) > len(m2.Headers)
+			// 4: number of query matches
+		default:
+			return len(m1.QueryParams) > len(m2.QueryParams)
+		}
+	})
+}
+
+// getURIRank ranks a URI match type. Exact > Prefix > Regex
+func getURIRank(match *istio.HTTPMatchRequest) int {
+	if match.Uri == nil {
+		return -1
+	}
+	switch match.Uri.MatchType.(type) {
+	case *istio.StringMatch_Exact:
+		return 3
+	case *istio.StringMatch_Prefix:
+		return 2
+	case *istio.StringMatch_Regex:
+		return 1
+	}
+	// should not happen
+	return -1
+}
+
+func getURILength(match *istio.HTTPMatchRequest) int {
+	if match.Uri == nil {
+		return 0
+	}
+	switch match.Uri.MatchType.(type) {
+	case *istio.StringMatch_Prefix:
+		return len(match.Uri.GetPrefix())
+	case *istio.StringMatch_Exact:
+		return len(match.Uri.GetExact())
+	case *istio.StringMatch_Regex:
+		return len(match.Uri.GetRegex())
+	}
+	// should not happen
+	return -1
+}
+
+func parentMeta(obj controllers.Object, sectionName *k8s.SectionName) map[string]string {
+	name := fmt.Sprintf("%s/%s.%s", schematypes.GvkFromObject(obj).Kind, obj.GetName(), obj.GetNamespace())
+	if sectionName != nil {
+		name = fmt.Sprintf("%s/%s/%s.%s", schematypes.GvkFromObject(obj).Kind, obj.GetName(), *sectionName, obj.GetNamespace())
+	}
+	return map[string]string{
+		constants.InternalParentNames: name,
+	}
+}
+
+func hostnameToStringList(h []k8s.Hostname) []string {
+	// In the Istio API, empty hostname is not allowed. In the Kubernetes API hosts means "any"
+	if len(h) == 0 {
+		return []string{"*"}
+	}
+	return slices.Map(h, func(e k8s.Hostname) string {
+		return string(e)
+	})
+}
+
+var allowedParentReferences = sets.New(
+	gvk.KubernetesGateway,
+	gvk.Service,
+	gvk.ServiceEntry,
+)
+
+func toInternalParentReference(p k8s.ParentReference, localNamespace string) (parentKey, error) {
+	ref := normalizeReference(p.Group, p.Kind, gvk.KubernetesGateway)
+	if !allowedParentReferences.Contains(ref) {
+		return parentKey{}, fmt.Errorf("unsupported parent: %v/%v", p.Group, p.Kind)
+	}
+	return parentKey{
+		Kind: ref,
+		Name: string(p.Name),
+		// Unset namespace means "same namespace"
+		Namespace: defaultString(p.Namespace, localNamespace),
+	}, nil
+}
+
+// waypointConfigured returns true if a waypoint is configured via expected label's key-value pair.
+func waypointConfigured(labels map[string]string) bool {
+	if val, ok := labels[label.IoIstioUseWaypoint.Name]; ok && len(val) > 0 && !strings.EqualFold(val, "none") {
+		return true
+	}
+	return false
+}
+
+func referenceAllowed(
+	ctx RouteContext,
+	parent *parentInfo,
+	routeKind config.GroupVersionKind,
+	parentRef parentReference,
+	hostnames []k8s.Hostname,
+	localNamespace string,
+) (*ParentError, *WaypointError) {
+	if parentRef.Kind == gvk.Service {
+
+		key := parentRef.Namespace + "/" + parentRef.Name
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+
+		// check that the referenced svc exists
+		if svc == nil {
+			return &ParentError{
+					Reason:  ParentErrorNotAccepted,
+					Message: fmt.Sprintf("parent service: %q not found", parentRef.Name),
+				}, &WaypointError{
+					Reason:  WaypointErrorReasonNoMatchingParent,
+					Message: WaypointErrorMsgNoMatchingParent,
+				}
+		}
+
+		// check that the reference has the use-waypoint label
+		if !waypointConfigured(svc.Labels) {
+			// if reference does not have use-waypoint label, check the namespace of the reference
+			ns := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Namespaces, krt.FilterKey(svc.Namespace)))
+			if ns != nil {
+				if !waypointConfigured(ns.Labels) {
+					return nil, &WaypointError{
+						Reason:  WaypointErrorReasonMissingLabel,
+						Message: WaypointErrorMsgMissingLabel,
+					}
+				}
+			}
+		}
+	} else if parentRef.Kind == gvk.ServiceEntry {
+		// check that the referenced svc entry exists
+		key := parentRef.Namespace + "/" + parentRef.Name
+		svcEntry := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(key)))
+		if svcEntry == nil {
+			return &ParentError{
+					Reason:  ParentErrorNotAccepted,
+					Message: fmt.Sprintf("parent service entry: %q not found", parentRef.Name),
+				}, &WaypointError{
+					Reason:  WaypointErrorReasonNoMatchingParent,
+					Message: WaypointErrorMsgNoMatchingParent,
+				}
+		}
+
+		// check that the reference has the use-waypoint label
+		if !waypointConfigured(svcEntry.Labels) {
+			// if reference does not have use-waypoint label, check the namespace of the reference
+			ns := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Namespaces, krt.FilterKey(parentRef.Namespace)))
+			if ns != nil {
+				if !waypointConfigured(ns.Labels) {
+					return nil, &WaypointError{
+						Reason:  WaypointErrorReasonMissingLabel,
+						Message: WaypointErrorMsgMissingLabel,
+					}
+				}
+			}
+		}
+	} else {
+		// First, check section and port apply. This must come first
+		if parentRef.Port != 0 && parentRef.Port != parent.Port {
+			return &ParentError{
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("port %v not found", parentRef.Port),
+			}, nil
+		}
+		if len(parentRef.SectionName) > 0 && parentRef.SectionName != parent.SectionName {
+			return &ParentError{
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("sectionName %q not found", parentRef.SectionName),
+			}, nil
+		}
+
+		// Next check the hostnames are a match. This is a bi-directional wildcard match. Only one route
+		// hostname must match for it to be allowed (but the others will be filtered at runtime)
+		// If either is empty its treated as a wildcard which always matches
+
+		if len(hostnames) == 0 {
+			hostnames = []k8s.Hostname{"*"}
+		}
+		if len(parent.Hostnames) > 0 {
+			// TODO: the spec actually has a label match, not a string match. That is, *.com does not match *.apple.com
+			// We are doing a string match here
+			matched := false
+			hostMatched := false
+		out:
+			for _, routeHostname := range hostnames {
+				for _, parentHostNamespace := range parent.Hostnames {
+					spl := strings.Split(parentHostNamespace, "/")
+					parentNamespace, parentHostname := spl[0], spl[1]
+					hostnameMatch := host.Name(parentHostname).Matches(host.Name(routeHostname))
+					namespaceMatch := parentNamespace == "*" || parentNamespace == localNamespace
+					hostMatched = hostMatched || hostnameMatch
+					if hostnameMatch && namespaceMatch {
+						matched = true
+						break out
+					}
+				}
+			}
+			if !matched {
+				if hostMatched {
+					return &ParentError{
+						Reason: ParentErrorNotAllowed,
+						Message: fmt.Sprintf(
+							"hostnames matched parent hostname %q, but namespace %q is not allowed by the parent",
+							parent.OriginalHostname, localNamespace,
+						),
+					}, nil
+				}
+				return &ParentError{
+					Reason: ParentErrorNoHostname,
+					Message: fmt.Sprintf(
+						"no hostnames matched parent hostname %q",
+						parent.OriginalHostname,
+					),
+				}, nil
+			}
+		}
+	}
+	// Also make sure this route kind is allowed
+	matched := false
+	for _, ak := range parent.AllowedKinds {
+		if string(ak.Kind) == routeKind.Kind && ptr.OrDefault((*string)(ak.Group), gvk.GatewayClass.Group) == routeKind.Group {
+			matched = true
+			break
+		}
+	}
+	if !matched {
+		return &ParentError{
+			Reason:  ParentErrorNotAllowed,
+			Message: fmt.Sprintf("kind %v is not allowed", routeKind),
+		}, nil
+	}
+	return nil, nil
+}
+
+func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj controllers.Object) []routeParentReference {
+	routeRefs, hostnames, kind := GetCommonRouteInfo(obj)
+	localNamespace := obj.GetNamespace()
+	parentRefs := []routeParentReference{}
+	for _, ref := range routeRefs {
+		ir, err := toInternalParentReference(ref, localNamespace)
+		if err != nil {
+			// Cannot handle the reference. Maybe it is for another controller, so we just ignore it
+			continue
+		}
+		pk := parentReference{
+			parentKey:   ir,
+			SectionName: ptr.OrEmpty(ref.SectionName),
+			Port:        ptr.OrEmpty(ref.Port),
+		}
+		gk := ir
+		if ir.Kind == gvk.Service || ir.Kind == gvk.ServiceEntry {
+			gk = meshParentKey
+		}
+		currentParents := parents.fetch(ctx.Krt, gk)
+		appendParent := func(pr *parentInfo, pk parentReference) {
+			bannedHostnames := sets.New[string]()
+			for _, gw := range currentParents {
+				if gw == pr {
+					continue // do not ban ourself
+				}
+				if gw.Port != pr.Port {
+					// We only care about listeners on the same port
+					continue
+				}
+				if gw.Protocol != pr.Protocol {
+					// We only care about listeners on the same protocol
+					continue
+				}
+				bannedHostnames.Insert(gw.OriginalHostname)
+			}
+			deniedReason, waypointError := referenceAllowed(ctx, pr, kind, pk, hostnames, localNamespace)
+			rpi := routeParentReference{
+				InternalName:      pr.InternalName,
+				InternalKind:      ir.Kind,
+				Hostname:          pr.OriginalHostname,
+				DeniedReason:      deniedReason,
+				OriginalReference: ref,
+				BannedHostnames:   bannedHostnames.Copy().Delete(pr.OriginalHostname),
+				ParentKey:         ir,
+				ParentSection:     pr.SectionName,
+				WaypointError:     waypointError,
+			}
+			parentRefs = append(parentRefs, rpi)
+		}
+		for _, gw := range currentParents {
+			// Append all matches. Note we may be adding mismatch section or ports; this is handled later
+			appendParent(gw, pk)
+		}
+	}
+	// Ensure stable order
+	slices.SortBy(parentRefs, func(a routeParentReference) string {
+		return parentRefString(a.OriginalReference)
+	})
+	return parentRefs
+}
+
+func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TCPRoute, enforceRefGrant bool) (*istio.TCPRoute, *ConfigError) {
+	if tcpWeightSum(r.BackendRefs) == 0 {
+		// The spec requires us to reject connections when there are no >0 weight backends
+		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
+		return &istio.TCPRoute{
+			Route: []*istio.RouteDestination{{
+				Destination: &istio.Destination{
+					Host:   "internal.cluster.local",
+					Subset: "zero-weight",
+					Port:   &istio.PortSelector{Number: 65535},
+				},
+				Weight: 0,
+			}},
+		}, nil
+	}
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant, gvk.TCPRoute)
+	if err != nil {
+		return nil, err
+	}
+	return &istio.TCPRoute{
+		Route: dest,
+	}, backendErr
+}
+
+func convertTLSRoute(ctx RouteContext, r k8salpha.TLSRouteRule, obj *k8salpha.TLSRoute, enforceRefGrant bool) (*istio.TLSRoute, *ConfigError) {
+	if tcpWeightSum(r.BackendRefs) == 0 {
+		// The spec requires us to reject connections when there are no >0 weight backends
+		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
+		return &istio.TLSRoute{
+			Route: []*istio.RouteDestination{{
+				Destination: &istio.Destination{
+					Host:   "internal.cluster.local",
+					Subset: "zero-weight",
+					Port:   &istio.PortSelector{Number: 65535},
+				},
+				Weight: 0,
+			}},
+		}, nil
+	}
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant, gvk.TLSRoute)
+	if err != nil {
+		return nil, err
+	}
+	return &istio.TLSRoute{
+		Match: buildTLSMatch(obj.Spec.Hostnames),
+		Route: dest,
+	}, backendErr
+}
+
+func buildTCPDestination(
+	ctx RouteContext,
+	forwardTo []k8s.BackendRef,
+	ns string,
+	enforceRefGrant bool,
+	k config.GroupVersionKind,
+) ([]*istio.RouteDestination, *ConfigError, *ConfigError) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+
+	weights := []int{}
+	action := []k8s.BackendRef{}
+	for _, w := range forwardTo {
+		wt := int(ptr.OrDefault(w.Weight, 1))
+		if wt == 0 {
+			continue
+		}
+		action = append(action, w)
+		weights = append(weights, wt)
+	}
+	if len(weights) == 1 {
+		weights = []int{0}
+	}
+
+	var invalidBackendErr *ConfigError
+	res := []*istio.RouteDestination{}
+	for i, fwd := range action {
+		dst, err := buildDestination(ctx, fwd, ns, enforceRefGrant, k)
+		if err != nil {
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		res = append(res, &istio.RouteDestination{
+			Destination: dst,
+			Weight:      int32(weights[i]),
+		})
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildTLSMatch(hostnames []k8s.Hostname) []*istio.TLSMatchAttributes {
+	// Currently, the spec only supports extensions beyond hostname, which are not currently implemented by Istio.
+	return []*istio.TLSMatchAttributes{{
+		SniHosts: hostnamesToStringListWithWildcard(hostnames),
+	}}
+}
+
+func hostnamesToStringListWithWildcard(h []k8s.Hostname) []string {
+	if len(h) == 0 {
+		return []string{"*"}
+	}
+	res := make([]string, 0, len(h))
+	for _, i := range h {
+		res = append(res, string(i))
+	}
+	return res
+}
+
+func weightSum(forwardTo []k8s.HTTPBackendRef) int {
+	sum := int32(0)
+	for _, w := range forwardTo {
+		sum += ptr.OrDefault(w.Weight, 1)
+	}
+	return int(sum)
+}
+
+func grpcWeightSum(forwardTo []k8s.GRPCBackendRef) int {
+	sum := int32(0)
+	for _, w := range forwardTo {
+		sum += ptr.OrDefault(w.Weight, 1)
+	}
+	return int(sum)
+}
+
+func tcpWeightSum(forwardTo []k8s.BackendRef) int {
+	sum := int32(0)
+	for _, w := range forwardTo {
+		sum += ptr.OrDefault(w.Weight, 1)
+	}
+	return int(sum)
+}
+
+func buildHTTPDestination(
+	ctx RouteContext,
+	forwardTo []k8s.HTTPBackendRef,
+	ns string,
+	enforceRefGrant bool,
+) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+	weights := []int{}
+	action := []k8s.HTTPBackendRef{}
+	for _, w := range forwardTo {
+		wt := int(ptr.OrDefault(w.Weight, 1))
+		if wt == 0 {
+			continue
+		}
+		action = append(action, w)
+		weights = append(weights, wt)
+	}
+	if len(weights) == 1 {
+		weights = []int{0}
+	}
+
+	var invalidBackendErr *ConfigError
+	res := []*istio.HTTPRouteDestination{}
+	for i, fwd := range action {
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, enforceRefGrant, gvk.HTTPRoute)
+		if err != nil {
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		rd := &istio.HTTPRouteDestination{
+			Destination: dst,
+			Weight:      int32(weights[i]),
+		}
+		for _, filter := range fwd.Filters {
+			switch filter.Type {
+			case k8s.HTTPRouteFilterRequestHeaderModifier:
+				h := createHeadersFilter(filter.RequestHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.Headers == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.Headers.Request = h
+			case k8s.HTTPRouteFilterResponseHeaderModifier:
+				h := createHeadersFilter(filter.ResponseHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.Headers == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.Headers.Response = h
+			default:
+				return nil, nil, &ConfigError{Reason: InvalidFilter, Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
+			}
+		}
+		res = append(res, rd)
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildGRPCDestination(
+	ctx RouteContext,
+	forwardTo []k8s.GRPCBackendRef,
+	ns string,
+	enforceRefGrant bool,
+) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
+	if forwardTo == nil {
+		return nil, nil, nil
+	}
+	weights := []int{}
+	action := []k8s.GRPCBackendRef{}
+	for _, w := range forwardTo {
+		wt := int(ptr.OrDefault(w.Weight, 1))
+		if wt == 0 {
+			continue
+		}
+		action = append(action, w)
+		weights = append(weights, wt)
+	}
+	if len(weights) == 1 {
+		weights = []int{0}
+	}
+
+	var invalidBackendErr *ConfigError
+	res := []*istio.HTTPRouteDestination{}
+	for i, fwd := range action {
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, enforceRefGrant, gvk.GRPCRoute)
+		if err != nil {
+			if isInvalidBackend(err) {
+				invalidBackendErr = err
+				// keep going, we will gracefully drop invalid backends
+			} else {
+				return nil, nil, err
+			}
+		}
+		rd := &istio.HTTPRouteDestination{
+			Destination: dst,
+			Weight:      int32(weights[i]),
+		}
+		for _, filter := range fwd.Filters {
+			switch filter.Type {
+			case k8s.GRPCRouteFilterRequestHeaderModifier:
+				h := createHeadersFilter(filter.RequestHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.Headers == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.Headers.Request = h
+			case k8s.GRPCRouteFilterResponseHeaderModifier:
+				h := createHeadersFilter(filter.ResponseHeaderModifier)
+				if h == nil {
+					continue
+				}
+				if rd.Headers == nil {
+					rd.Headers = &istio.Headers{}
+				}
+				rd.Headers.Response = h
+			default:
+				return nil, nil, &ConfigError{Reason: InvalidFilter, Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
+			}
+		}
+		res = append(res, rd)
+	}
+	return res, invalidBackendErr, nil
+}
+
+func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, enforceRefGrant bool, k config.GroupVersionKind) (*istio.Destination, *ConfigError) {
+	// check if the reference is allowed
+	if enforceRefGrant {
+		if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
+			if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
+				return &istio.Destination{}, &ConfigError{
+					Reason:  InvalidDestinationPermit,
+					Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
+				}
+			}
+		}
+	}
+
+	namespace := ptr.OrDefault((*string)(to.Namespace), ns)
+	var invalidBackendErr *ConfigError
+	var hostname string
+	ref := normalizeReference(to.Group, to.Kind, gvk.Service)
+	switch ref {
+	case gvk.InferencePool: // TODO: add validation
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+	case gvk.Service:
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+	case config.GroupVersionKind{Group: gvk.ServiceEntry.Group, Kind: "Hostname"}:
+		if to.Namespace != nil {
+			return nil, &ConfigError{Reason: InvalidDestination, Message: "namespace may not be set with Hostname type"}
+		}
+		hostname = string(to.Name)
+		if ctx.LookupHostname(hostname, namespace) == nil {
+			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+	case config.GroupVersionKind{Group: features.MCSAPIGroup, Kind: "ServiceImport"}:
+		hostname = fmt.Sprintf("%s.%s.svc.clusterset.local", to.Name, namespace)
+		if !features.EnableMCSHost {
+			// They asked for ServiceImport, but actually don't have full support enabled...
+			// No problem, we can just treat it as Service, which is already cross-cluster in this mode anyways
+			hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
+		}
+		// TODO: currently we are always looking for Service. We should be looking for ServiceImport when features.EnableMCSHost
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
+	default:
+		return &istio.Destination{}, &ConfigError{
+			Reason:  InvalidDestinationKind,
+			Message: fmt.Sprintf("referencing unsupported backendRef: group %q kind %q", ptr.OrEmpty(to.Group), ptr.OrEmpty(to.Kind)),
+		}
+	}
+	// All types currently require a Port, so we do this for everything; consider making this per-type if we have future types
+	// that do not require port.
+	if to.Port == nil {
+		// "Port is required when the referent is a Kubernetes Service."
+		return nil, &ConfigError{Reason: InvalidDestination, Message: "port is required in backendRef"}
+	}
+	return &istio.Destination{
+		Host: hostname,
+		Port: &istio.PortSelector{Number: uint32(*to.Port)},
+	}, invalidBackendErr
+}
+
+// https://github.com/kubernetes-sigs/gateway-api/blob/cea484e38e078a2c1997d8c7a62f410a1540f519/apis/v1beta1/httproute_types.go#L207-L212
+func isInvalidBackend(err *ConfigError) bool {
+	return err.Reason == InvalidDestinationPermit ||
+		err.Reason == InvalidDestinationNotFound ||
+		err.Reason == InvalidDestinationKind
+}
+
+func headerListToMap(hl []k8s.HTTPHeader) map[string]string {
+	if len(hl) == 0 {
+		return nil
+	}
+	res := map[string]string{}
+	for _, e := range hl {
+		k := strings.ToLower(string(e.Name))
+		if _, f := res[k]; f {
+			// "Subsequent entries with an equivalent header name MUST be ignored"
+			continue
+		}
+		res[k] = e.Value
+	}
+	return res
+}
+
+func createMirrorFilter(ctx RouteContext, filter *k8s.HTTPRequestMirrorFilter, ns string,
+	enforceRefGrant bool, k config.GroupVersionKind,
+) (*istio.HTTPMirrorPolicy, *ConfigError) {
+	if filter == nil {
+		return nil, nil
+	}
+	var weightOne int32 = 1
+	dst, err := buildDestination(ctx, k8s.BackendRef{
+		BackendObjectReference: filter.BackendRef,
+		Weight:                 &weightOne,
+	}, ns, enforceRefGrant, k)
+	if err != nil {
+		return nil, err
+	}
+	var percent *istio.Percent
+	if f := filter.Fraction; f != nil {
+		percent = &istio.Percent{Value: (100 * float64(f.Numerator)) / float64(ptr.OrDefault(f.Denominator, int32(100)))}
+	} else if p := filter.Percent; p != nil {
+		percent = &istio.Percent{Value: float64(*p)}
+	}
+	return &istio.HTTPMirrorPolicy{Destination: dst, Percentage: percent}, nil
+}
+
+func createRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *istio.HTTPRewrite {
+	if filter == nil {
+		return nil
+	}
+	rewrite := &istio.HTTPRewrite{}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case k8s.PrefixMatchHTTPPathModifier:
+			rewrite.Uri = strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")
+			if rewrite.Uri == "" {
+				// `/` means removing the prefix
+				rewrite.Uri = "/"
+			}
+		case k8s.FullPathHTTPPathModifier:
+			rewrite.UriRegexRewrite = &istio.RegexRewrite{
+				Match:   "/.*",
+				Rewrite: *filter.Path.ReplaceFullPath,
+			}
+		}
+	}
+	if filter.Hostname != nil {
+		rewrite.Authority = string(*filter.Hostname)
+	}
+	// Nothing done
+	if rewrite.Uri == "" && rewrite.UriRegexRewrite == nil && rewrite.Authority == "" {
+		return nil
+	}
+	return rewrite
+}
+
+func createCorsFilter(filter *k8s.HTTPCORSFilter) *istio.CorsPolicy {
+	if filter == nil {
+		return nil
+	}
+	res := &istio.CorsPolicy{}
+	for _, r := range filter.AllowOrigins {
+		rs := string(r)
+		if len(rs) == 0 {
+			continue // Not valid anyways, but double check
+		}
+
+		// TODO: support wildcards (https://github.com/kubernetes-sigs/gateway-api/issues/3648)
+		res.AllowOrigins = append(res.AllowOrigins, &istio.StringMatch{
+			MatchType: &istio.StringMatch_Exact{Exact: string(r)},
+		})
+	}
+	if filter.AllowCredentials {
+		res.AllowCredentials = wrappers.Bool(true)
+	}
+	for _, r := range filter.AllowMethods {
+		res.AllowMethods = append(res.AllowMethods, string(r))
+	}
+	for _, r := range filter.AllowHeaders {
+		res.AllowHeaders = append(res.AllowHeaders, string(r))
+	}
+	for _, r := range filter.ExposeHeaders {
+		res.ExposeHeaders = append(res.ExposeHeaders, string(r))
+	}
+	if filter.MaxAge > 0 {
+		res.MaxAge = durationpb.New(time.Duration(filter.MaxAge) * time.Second)
+	}
+
+	return res
+}
+
+func createRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *istio.HTTPRedirect {
+	if filter == nil {
+		return nil
+	}
+	resp := &istio.HTTPRedirect{}
+	if filter.StatusCode != nil {
+		// Istio allows 301, 302, 303, 307, 308.
+		// Gateway allows only 301 and 302.
+		resp.RedirectCode = uint32(*filter.StatusCode)
+	}
+	if filter.Hostname != nil {
+		resp.Authority = string(*filter.Hostname)
+	}
+	if filter.Scheme != nil {
+		// Both allow http and https
+		resp.Scheme = *filter.Scheme
+	}
+	if filter.Port != nil {
+		resp.RedirectPort = &istio.HTTPRedirect_Port{Port: uint32(*filter.Port)}
+	} else {
+		// "When empty, port (if specified) of the request is used."
+		// this differs from Istio default
+		if filter.Scheme != nil {
+			resp.RedirectPort = &istio.HTTPRedirect_DerivePort{DerivePort: istio.HTTPRedirect_FROM_PROTOCOL_DEFAULT}
+		} else {
+			resp.RedirectPort = &istio.HTTPRedirect_DerivePort{DerivePort: istio.HTTPRedirect_FROM_REQUEST_PORT}
+		}
+	}
+	if filter.Path != nil {
+		switch filter.Path.Type {
+		case k8s.FullPathHTTPPathModifier:
+			resp.Uri = *filter.Path.ReplaceFullPath
+		case k8s.PrefixMatchHTTPPathModifier:
+			resp.Uri = fmt.Sprintf("%%PREFIX()%%%s", *filter.Path.ReplacePrefixMatch)
+		}
+	}
+	return resp
+}
+
+func createHeadersFilter(filter *k8s.HTTPHeaderFilter) *istio.Headers_HeaderOperations {
+	if filter == nil {
+		return nil
+	}
+	return &istio.Headers_HeaderOperations{
+		Add:    headerListToMap(filter.Add),
+		Remove: filter.Remove,
+		Set:    headerListToMap(filter.Set),
+	}
+}
+
+// nolint: unparam
+func createMethodMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
+	if match.Method == nil {
+		return nil, nil
+	}
+	return &istio.StringMatch{
+		MatchType: &istio.StringMatch_Exact{Exact: string(*match.Method)},
+	}, nil
+}
+
+func createQueryParamsMatch(match k8s.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+	res := map[string]*istio.StringMatch{}
+	for _, qp := range match.QueryParams {
+		tp := k8s.QueryParamMatchExact
+		if qp.Type != nil {
+			tp = *qp.Type
+		}
+		switch tp {
+		case k8s.QueryParamMatchExact:
+			res[string(qp.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Exact{Exact: qp.Value},
+			}
+		case k8s.QueryParamMatchRegularExpression:
+			res[string(qp.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: qp.Value},
+			}
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported QueryParams type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createHeadersMatch(match k8s.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+	res := map[string]*istio.StringMatch{}
+	for _, header := range match.Headers {
+		tp := k8s.HeaderMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case k8s.HeaderMatchExact:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Exact{Exact: header.Value},
+			}
+		case k8s.HeaderMatchRegularExpression:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: header.Value},
+			}
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createGRPCHeadersMatch(match k8s.GRPCRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+	res := map[string]*istio.StringMatch{}
+	for _, header := range match.Headers {
+		tp := k8s.GRPCHeaderMatchExact
+		if header.Type != nil {
+			tp = *header.Type
+		}
+		switch tp {
+		case k8s.GRPCHeaderMatchExact:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Exact{Exact: header.Value},
+			}
+		case k8s.GRPCHeaderMatchRegularExpression:
+			res[string(header.Name)] = &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: header.Value},
+			}
+		default:
+			// Should never happen, unless a new field is added
+			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+		}
+	}
+
+	if len(res) == 0 {
+		return nil, nil
+	}
+	return res, nil
+}
+
+func createURIMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
+	tp := k8s.PathMatchPathPrefix
+	if match.Path.Type != nil {
+		tp = *match.Path.Type
+	}
+	dest := "/"
+	if match.Path.Value != nil {
+		dest = *match.Path.Value
+	}
+	switch tp {
+	case k8s.PathMatchPathPrefix:
+		// "When specified, a trailing `/` is ignored."
+		if dest != "/" {
+			dest = strings.TrimSuffix(dest, "/")
+		}
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Prefix{Prefix: dest},
+		}, nil
+	case k8s.PathMatchExact:
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Exact{Exact: dest},
+		}, nil
+	case k8s.PathMatchRegularExpression:
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Regex{Regex: dest},
+		}, nil
+	default:
+		// Should never happen, unless a new field is added
+		return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+	}
+}
+
+func createGRPCURIMatch(match k8s.GRPCRouteMatch) (*istio.StringMatch, *ConfigError) {
+	m := match.Method
+	if m == nil {
+		return nil, nil
+	}
+	tp := k8s.GRPCMethodMatchExact
+	if m.Type != nil {
+		tp = *m.Type
+	}
+	if m.Method == nil && m.Service == nil {
+		// Should never happen, invalid per spec
+		return nil, &ConfigError{Reason: InvalidConfiguration, Message: "gRPC match must have method or service defined"}
+	}
+	// gRPC format is /<Service>/<Method>. Since we don't natively understand this, convert to various string matches
+	switch tp {
+	case k8s.GRPCMethodMatchExact:
+		if m.Method == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Prefix{Prefix: fmt.Sprintf("/%s/", *m.Service)},
+			}, nil
+		}
+		if m.Service == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/[^/]+/%s", *m.Method)},
+			}, nil
+		}
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Exact{Exact: fmt.Sprintf("/%s/%s", *m.Service, *m.Method)},
+		}, nil
+	case k8s.GRPCMethodMatchRegularExpression:
+		if m.Method == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/%s/.+", *m.Service)},
+			}, nil
+		}
+		if m.Service == nil {
+			return &istio.StringMatch{
+				MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/[^/]+/%s", *m.Method)},
+			}, nil
+		}
+		return &istio.StringMatch{
+			MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/%s/%s", *m.Service, *m.Method)},
+		}, nil
+	default:
+		// Should never happen, unless a new field is added
+		return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+	}
+}
+
+// parentKey holds info about a parentRef (eg route binding to a Gateway). This is a mirror of
+// k8s.ParentReference in a form that can be stored in a map
+type parentKey struct {
+	Kind config.GroupVersionKind
+	// Name is the original name of the resource (eg Kubernetes Gateway name)
+	Name string
+	// Namespace is the namespace of the resource
+	Namespace string
+}
+
+func (p parentKey) String() string {
+	return p.Kind.String() + "/" + p.Namespace + "/" + p.Name
+}
+
+type parentReference struct {
+	parentKey
+
+	SectionName k8s.SectionName
+	Port        k8s.PortNumber
+}
+
+func (p parentReference) String() string {
+	return p.parentKey.String() + "/" + string(p.SectionName) + "/" + fmt.Sprint(p.Port)
+}
+
+var meshGVK = config.GroupVersionKind{
+	Group:   gvk.KubernetesGateway.Group,
+	Version: gvk.KubernetesGateway.Version,
+	Kind:    "Mesh",
+}
+
+var meshParentKey = parentKey{
+	Kind: meshGVK,
+	Name: "istio",
+}
+
+// parentInfo holds info about a "parent" - something that can be referenced as a ParentRef in the API.
+// Today, this is just Gateway and Mesh.
+type parentInfo struct {
+	// InternalName refers to the internal name we can reference it by. For example, "mesh" or "my-ns/my-gateway"
+	InternalName string
+	// AllowedKinds indicates which kinds can be admitted by this parent
+	AllowedKinds []k8s.RouteGroupKind
+	// Hostnames is the hostnames that must be match to reference to the parent. For gateway this is listener hostname
+	// Format is ns/hostname
+	Hostnames []string
+	// OriginalHostname is the unprocessed form of Hostnames; how it appeared in users' config
+	OriginalHostname string
+
+	SectionName k8s.SectionName
+	Port        k8s.PortNumber
+	Protocol    k8s.ProtocolType
+}
+
+// routeParentReference holds information about a route's parent reference
+type routeParentReference struct {
+	// InternalName refers to the internal name of the parent we can reference it by. For example, "mesh" or "my-ns/my-gateway"
+	InternalName string
+	// InternalKind is the Group/Kind of the parent
+	InternalKind config.GroupVersionKind
+	// DeniedReason, if present, indicates why the reference was not valid
+	DeniedReason *ParentError
+	// OriginalReference contains the original reference
+	OriginalReference k8s.ParentReference
+	// Hostname is the hostname match of the parent, if any
+	Hostname        string
+	BannedHostnames sets.Set[string]
+	ParentKey       parentKey
+	ParentSection   k8s.SectionName
+	// WaypointError, if present, indicates why the reference does not have valid configuration for generating a Waypoint
+	WaypointError *WaypointError
+}
+
+func (r routeParentReference) IsMesh() bool {
+	return r.InternalName == "mesh"
+}
+
+func (r routeParentReference) hostnameAllowedByIsolation(rawRouteHost string) bool {
+	routeHost := host.Name(rawRouteHost)
+	ourListener := host.Name(r.Hostname)
+	if len(ourListener) > 0 && !ourListener.IsWildCarded() {
+		// Short circuit: this logic only applies to wildcards
+		// Not required for correctness, just an optimization
+		return true
+	}
+	if len(ourListener) > 0 && !routeHost.Matches(ourListener) {
+		return false
+	}
+	for checkListener := range r.BannedHostnames {
+		// We have 3 hostnames here:
+		// * routeHost, the hostname in the route entry
+		// * ourListener, the hostname of the listener the route is bound to
+		// * checkListener, the hostname of the other listener we are comparing to
+		// We want to return false if checkListener would match the routeHost and it would be a more exact match
+		if len(ourListener) > len(checkListener) {
+			// If our hostname is longer, it must be more exact than the check
+			continue
+		}
+		// Ours is shorter. If it matches the checkListener, then it should ONLY match that one
+		// Note protocol, port, etc are already considered when we construct bannedHostnames
+		if routeHost.SubsetOf(host.Name(checkListener)) {
+			return false
+		}
+	}
+	return true
+}
+
+func filteredReferences(parents []routeParentReference) []routeParentReference {
+	ret := make([]routeParentReference, 0, len(parents))
+	for _, p := range parents {
+		if p.DeniedReason != nil {
+			// We should filter this out
+			continue
+		}
+		ret = append(ret, p)
+	}
+	// To ensure deterministic order, sort them
+	sort.Slice(ret, func(i, j int) bool {
+		return ret[i].InternalName < ret[j].InternalName
+	})
+	return ret
+}
+
+func getDefaultName(name string, kgw *k8s.GatewaySpec, disableNameSuffix bool) string {
+	if disableNameSuffix {
+		return name
+	}
+	return fmt.Sprintf("%v-%v", name, kgw.GatewayClassName)
+}
+
+// Gateway currently requires a listener (https://github.com/kubernetes-sigs/gateway-api/pull/1596).
+// We don't *really* care about the listener, but it may make sense to add a warning if users do not
+// configure it in an expected way so that we have consistency and can make changes in the future as needed.
+// We could completely reject but that seems more likely to cause pain.
+func unexpectedWaypointListener(l k8s.Listener) bool {
+	if l.Port != 15008 {
+		return true
+	}
+	if l.Protocol != k8s.ProtocolType(protocol.HBONE) {
+		return true
+	}
+	return false
+}
+
+func getListenerNames(spec *k8s.GatewaySpec) sets.Set[k8s.SectionName] {
+	res := sets.New[k8s.SectionName]()
+	for _, l := range spec.Listeners {
+		res.Insert(l.Name)
+	}
+	return res
+}
+
+func reportGatewayStatus(
+	r *GatewayContext,
+	obj *k8sbeta.Gateway,
+	gs *k8sbeta.GatewayStatus,
+	classInfo classInfo,
+	gatewayServices []string,
+	servers []*istio.Server,
+	gatewayErr *ConfigError,
+) {
+	// TODO: we lose address if servers is empty due to an error
+	internal, internalIP, external, pending, warnings, allUsable := r.ResolveGatewayInstances(obj.Namespace, gatewayServices, servers)
+
+	// Setup initial conditions to the success state. If we encounter errors, we will update this.
+	// We have two status
+	// Accepted: is the configuration valid. We only have errors in listeners, and the status is not supposed to
+	// be tied to listeners, so this is always accepted
+	// Programmed: is the data plane "ready" (note: eventually consistent)
+	gatewayConditions := map[string]*condition{
+		string(k8s.GatewayConditionAccepted): {
+			reason:  string(k8s.GatewayReasonAccepted),
+			message: "Resource accepted",
+		},
+		string(k8s.GatewayConditionProgrammed): {
+			reason:  string(k8s.GatewayReasonProgrammed),
+			message: "Resource programmed",
+		},
+	}
+
+	if gatewayErr != nil {
+		gatewayConditions[string(k8s.GatewayConditionAccepted)].error = gatewayErr
+	}
+
+	if len(internal) > 0 {
+		msg := fmt.Sprintf("Resource programmed, assigned to service(s) %s", humanReadableJoin(internal))
+		gatewayConditions[string(k8s.GatewayConditionProgrammed)].message = msg
+	}
+
+	if len(gatewayServices) == 0 {
+		gatewayConditions[string(k8s.GatewayConditionProgrammed)].error = &ConfigError{
+			Reason:  InvalidAddress,
+			Message: "Failed to assign to any requested addresses",
+		}
+	} else if len(warnings) > 0 {
+		var msg string
+		var reason string
+		if len(internal) != 0 {
+			msg = fmt.Sprintf("Assigned to service(s) %s, but failed to assign to all requested addresses: %s",
+				humanReadableJoin(internal), strings.Join(warnings, "; "))
+		} else {
+			msg = fmt.Sprintf("Failed to assign to any requested addresses: %s", strings.Join(warnings, "; "))
+		}
+		if allUsable {
+			reason = string(k8s.GatewayReasonAddressNotAssigned)
+		} else {
+			reason = string(k8s.GatewayReasonAddressNotUsable)
+		}
+		gatewayConditions[string(k8s.GatewayConditionProgrammed)].error = &ConfigError{
+			// TODO: this only checks Service ready, we should also check Deployment ready?
+			Reason:  reason,
+			Message: msg,
+		}
+	}
+
+	addressesToReport := external
+	if len(addressesToReport) == 0 {
+		wantAddressType := classInfo.addressType
+		if override, ok := obj.Annotations[addressTypeOverride]; ok {
+			wantAddressType = k8s.AddressType(override)
+		}
+		// There are no external addresses, so report the internal ones
+		// This can be IP, Hostname, or both (indicated by empty wantAddressType)
+		if wantAddressType != k8s.HostnameAddressType {
+			addressesToReport = internalIP
+		}
+		if wantAddressType != k8s.IPAddressType {
+			for _, hostport := range internal {
+				svchost, _, _ := net.SplitHostPort(hostport)
+				if !slices.Contains(pending, svchost) && !slices.Contains(addressesToReport, svchost) {
+					addressesToReport = append(addressesToReport, svchost)
+				}
+			}
+		}
+	}
+	// Do not report an address until we are ready. But once we are ready, never remove the address.
+	if len(addressesToReport) > 0 {
+		gs.Addresses = make([]k8s.GatewayStatusAddress, 0, len(addressesToReport))
+		for _, addr := range addressesToReport {
+			var addrType k8s.AddressType
+			if _, err := netip.ParseAddr(addr); err == nil {
+				addrType = k8s.IPAddressType
+			} else {
+				addrType = k8s.HostnameAddressType
+			}
+			gs.Addresses = append(gs.Addresses, k8s.GatewayStatusAddress{
+				Value: addr,
+				Type:  &addrType,
+			})
+		}
+	}
+	// Prune listeners that have been removed
+	haveListeners := getListenerNames(&obj.Spec)
+	listeners := make([]k8s.ListenerStatus, 0, len(gs.Listeners))
+	for _, l := range gs.Listeners {
+		if haveListeners.Contains(l.Name) {
+			haveListeners.Delete(l.Name)
+			listeners = append(listeners, l)
+		}
+	}
+	gs.Listeners = listeners
+	gs.Conditions = setConditions(obj.Generation, gs.Conditions, gatewayConditions)
+}
+
+// reportUnmanagedGatewayStatus reports a status message for an unmanaged gateway.
+// For these gateways, we don't deploy them. However, all gateways ought to have a status message, even if its basically
+// just to say something read it
+func reportUnmanagedGatewayStatus(
+	status *k8sbeta.GatewayStatus,
+	obj *k8sbeta.Gateway,
+) {
+	gatewayConditions := map[string]*condition{
+		string(k8s.GatewayConditionAccepted): {
+			reason:  string(k8s.GatewayReasonAccepted),
+			message: "Resource accepted",
+		},
+		string(k8s.GatewayConditionProgrammed): {
+			reason: string(k8s.GatewayReasonProgrammed),
+			// Set to true anyway since this is basically declaring it as valid
+			message: "This Gateway is remote; Istio will not program it",
+		},
+	}
+
+	status.Addresses = slices.Map(obj.Spec.Addresses, func(e k8s.GatewaySpecAddress) k8s.GatewayStatusAddress {
+		return k8s.GatewayStatusAddress(e)
+	})
+	status.Listeners = nil
+	status.Conditions = setConditions(obj.Generation, status.Conditions, gatewayConditions)
+}
+
+// IsManaged checks if a Gateway is managed (ie we create the Deployment and Service) or unmanaged.
+// This is based on the address field of the spec. If address is set with a Hostname type, it should point to an existing
+// Service that handles the gateway traffic. If it is not set, or refers to only a single IP, we will consider it managed and provision the Service.
+// If there is an IP, we will set the `loadBalancerIP` type.
+// While there is no defined standard for this in the API yet, it is tracked in https://github.com/kubernetes-sigs/gateway-api/issues/892.
+// So far, this mirrors how out of clusters work (address set means to use existing IP, unset means to provision one),
+// and there has been growing consensus on this model for in cluster deployments.
+//
+// Currently, the supported options are:
+// * 1 Hostname value. This can be short Service name ingress, or FQDN ingress.ns.svc.cluster.local, example.com. If its a non-k8s FQDN it is a ServiceEntry.
+// * 1 IP address. This is managed, with IP explicit
+// * Nothing. This is managed, with IP auto assigned
+//
+// Not supported:
+// Multiple hostname/IP - It is feasible but preference is to create multiple Gateways. This would also break the 1:1 mapping of GW:Service
+// Mixed hostname and IP - doesn't make sense; user should define the IP in service
+// NamedAddress - Service has no concept of named address. For cloud's that have named addresses they can be configured by annotations,
+//
+//	which users can add to the Gateway.
+//
+// If manual deployments are disabled, IsManaged() always returns true.
+func IsManaged(gw *k8s.GatewaySpec) bool {
+	if !features.EnableGatewayAPIManualDeployment {
+		return true
+	}
+	if len(gw.Addresses) == 0 {
+		return true
+	}
+	if len(gw.Addresses) > 1 {
+		return false
+	}
+	if t := gw.Addresses[0].Type; t == nil || *t == k8s.IPAddressType {
+		return true
+	}
+	return false
+}
+
+func extractGatewayServices(domainSuffix string, kgw *k8sbeta.Gateway, info classInfo) ([]string, *ConfigError) {
+	if IsManaged(&kgw.Spec) {
+		name := model.GetOrDefault(kgw.Annotations[annotation.GatewayNameOverride.Name], getDefaultName(kgw.Name, &kgw.Spec, info.disableNameSuffix))
+		return []string{fmt.Sprintf("%s.%s.svc.%v", name, kgw.Namespace, domainSuffix)}, nil
+	}
+	gatewayServices := []string{}
+	skippedAddresses := []string{}
+	for _, addr := range kgw.Spec.Addresses {
+		if addr.Type != nil && *addr.Type != k8s.HostnameAddressType {
+			// We only support HostnameAddressType. Keep track of invalid ones so we can report in status.
+			skippedAddresses = append(skippedAddresses, addr.Value)
+			continue
+		}
+		// TODO: For now we are using Addresses. There has been some discussion of allowing inline
+		// parameters on the class field like a URL, in which case we will probably just use that. See
+		// https://github.com/kubernetes-sigs/gateway-api/pull/614
+		fqdn := addr.Value
+		if !strings.Contains(fqdn, ".") {
+			// Short name, expand it
+			fqdn = fmt.Sprintf("%s.%s.svc.%s", fqdn, kgw.Namespace, domainSuffix)
+		}
+		gatewayServices = append(gatewayServices, fqdn)
+	}
+	if len(skippedAddresses) > 0 {
+		// Give error but return services, this is a soft failure
+		return gatewayServices, &ConfigError{
+			Reason:  InvalidAddress,
+			Message: fmt.Sprintf("only Hostname is supported, ignoring %v", skippedAddresses),
+		}
+	}
+	if _, f := kgw.Annotations[annotation.NetworkingServiceType.Name]; f {
+		// Give error but return services, this is a soft failure
+		// Remove entirely in 1.20
+		return gatewayServices, &ConfigError{
+			Reason:  DeprecateFieldUsage,
+			Message: fmt.Sprintf("annotation %v is deprecated, use Spec.Infrastructure.Routeability", annotation.NetworkingServiceType.Name),
+		}
+	}
+	return gatewayServices, nil
+}
+
+func buildListener(
+	ctx krt.HandlerContext,
+	secrets krt.Collection[*corev1.Secret],
+	grants ReferenceGrants,
+	namespaces krt.Collection[*corev1.Namespace],
+	obj *k8sbeta.Gateway,
+	status *k8sbeta.GatewayStatus,
+	l k8s.Listener,
+	listenerIndex int,
+	controllerName k8s.GatewayController,
+) (*istio.Server, *TLSInfo, bool) {
+	listenerConditions := map[string]*condition{
+		string(k8s.ListenerConditionAccepted): {
+			reason:  string(k8s.ListenerReasonAccepted),
+			message: "No errors found",
+		},
+		string(k8s.ListenerConditionProgrammed): {
+			reason:  string(k8s.ListenerReasonProgrammed),
+			message: "No errors found",
+		},
+		string(k8s.ListenerConditionConflicted): {
+			reason:  string(k8s.ListenerReasonNoConflicts),
+			message: "No errors found",
+			status:  kstatus.StatusFalse,
+		},
+		string(k8s.ListenerConditionResolvedRefs): {
+			reason:  string(k8s.ListenerReasonResolvedRefs),
+			message: "No errors found",
+		},
+	}
+
+	ok := true
+	tls, tlsInfo, err := buildTLS(ctx, secrets, grants, l.TLS, obj, kube.IsAutoPassthrough(obj.Labels, l))
+	if err != nil {
+		listenerConditions[string(k8s.ListenerConditionResolvedRefs)].error = err
+		listenerConditions[string(k8s.GatewayConditionProgrammed)].error = &ConfigError{
+			Reason:  string(k8s.GatewayReasonInvalid),
+			Message: "Bad TLS configuration",
+		}
+		ok = false
+	}
+
+	hostnames := buildHostnameMatch(ctx, obj.Namespace, namespaces, l)
+	protocol, perr := listenerProtocolToIstio(controllerName, l.Protocol)
+	if perr != nil {
+		listenerConditions[string(k8s.ListenerConditionAccepted)].error = &ConfigError{
+			Reason:  string(k8s.ListenerReasonUnsupportedProtocol),
+			Message: perr.Error(),
+		}
+		ok = false
+	}
+	if controllerName == constants.ManagedGatewayMeshController {
+		if unexpectedWaypointListener(l) {
+			listenerConditions[string(k8s.ListenerConditionAccepted)].error = &ConfigError{
+				Reason:  string(k8s.ListenerReasonUnsupportedProtocol),
+				Message: `Expected a single listener on port 15008 with protocol "HBONE"`,
+			}
+		}
+	}
+	server := &istio.Server{
+		Port: &istio.Port{
+			// Name is required. We only have one server per Gateway, so we can just name them all the same
+			Name:     "default",
+			Number:   uint32(l.Port),
+			Protocol: protocol,
+		},
+		Hosts: hostnames,
+		Tls:   tls,
+	}
+
+	reportListenerCondition(listenerIndex, l, obj, status, listenerConditions)
+	return server, tlsInfo, ok
+}
+
+var supportedProtocols = sets.New(
+	k8s.HTTPProtocolType,
+	k8s.HTTPSProtocolType,
+	k8s.TLSProtocolType,
+	k8s.TCPProtocolType,
+	k8s.ProtocolType(protocol.HBONE))
+
+func listenerProtocolToIstio(name k8s.GatewayController, p k8s.ProtocolType) (string, error) {
+	switch p {
+	// Standard protocol types
+	case k8s.HTTPProtocolType:
+		return string(p), nil
+	case k8s.HTTPSProtocolType:
+		return string(p), nil
+	case k8s.TLSProtocolType, k8s.TCPProtocolType:
+		if !features.EnableAlphaGatewayAPI {
+			return "", fmt.Errorf("protocol %q is supported, but only when %v=true is configured", p, features.EnableAlphaGatewayAPIName)
+		}
+		return string(p), nil
+	// Our own custom types
+	case k8s.ProtocolType(protocol.HBONE):
+		if name != constants.ManagedGatewayMeshController {
+			return "", fmt.Errorf("protocol %q is only supported for waypoint proxies", p)
+		}
+		return string(p), nil
+	}
+	up := k8s.ProtocolType(strings.ToUpper(string(p)))
+	if supportedProtocols.Contains(up) {
+		return "", fmt.Errorf("protocol %q is unsupported. hint: %q (uppercase) may be supported", p, up)
+	}
+	// Note: the k8s.UDPProtocolType is explicitly left to hit this path
+	return "", fmt.Errorf("protocol %q is unsupported", p)
+}
+
+func buildTLS(
+	ctx krt.HandlerContext,
+	secrets krt.Collection[*corev1.Secret],
+	grants ReferenceGrants,
+	tls *k8s.GatewayTLSConfig,
+	gw *k8sbeta.Gateway,
+	isAutoPassthrough bool,
+) (*istio.ServerTLSSettings, *TLSInfo, *ConfigError) {
+	if tls == nil {
+		return nil, nil, nil
+	}
+	// Explicitly not supported: file mounted
+	// Not yet implemented: TLS mode, https redirect, max protocol version, SANs, CipherSuites, VerifyCertificate
+	out := &istio.ServerTLSSettings{
+		HttpsRedirect: false,
+	}
+	mode := k8s.TLSModeTerminate
+	if tls.Mode != nil {
+		mode = *tls.Mode
+	}
+	namespace := gw.Namespace
+	switch mode {
+	case k8s.TLSModeTerminate:
+		out.Mode = istio.ServerTLSSettings_SIMPLE
+		if tls.Options != nil {
+			switch tls.Options[gatewayTLSTerminateModeKey] {
+			case "MUTUAL":
+				out.Mode = istio.ServerTLSSettings_MUTUAL
+			case "ISTIO_MUTUAL":
+				out.Mode = istio.ServerTLSSettings_ISTIO_MUTUAL
+				return out, nil, nil
+			}
+		}
+		if len(tls.CertificateRefs) != 1 {
+			// This is required in the API, should be rejected in validation
+			return out, nil, &ConfigError{Reason: InvalidTLS, Message: "exactly 1 certificateRefs should be present for TLS termination"}
+		}
+		cred, tlsInfo, err := buildSecretReference(ctx, tls.CertificateRefs[0], gw, secrets)
+		if err != nil {
+			return out, nil, err
+		}
+		credNs := ptr.OrDefault((*string)(tls.CertificateRefs[0].Namespace), namespace)
+		sameNamespace := credNs == namespace
+		if !sameNamespace && !grants.SecretAllowed(ctx, creds.ToResourceName(cred), namespace) {
+			return out, nil, &ConfigError{
+				Reason: InvalidListenerRefNotPermitted,
+				Message: fmt.Sprintf(
+					"certificateRef %v/%v not accessible to a Gateway in namespace %q (missing a ReferenceGrant?)",
+					tls.CertificateRefs[0].Name, credNs, namespace,
+				),
+			}
+		}
+		out.CredentialName = cred
+		return out, &tlsInfo, nil
+	case k8s.TLSModePassthrough:
+		out.Mode = istio.ServerTLSSettings_PASSTHROUGH
+		if isAutoPassthrough {
+			out.Mode = istio.ServerTLSSettings_AUTO_PASSTHROUGH
+		}
+	}
+	return out, nil, nil
+}
+
+func buildSecretReference(
+	ctx krt.HandlerContext,
+	ref k8s.SecretObjectReference,
+	gw *k8sbeta.Gateway,
+	secrets krt.Collection[*corev1.Secret],
+) (string, TLSInfo, *ConfigError) {
+	if normalizeReference(ref.Group, ref.Kind, gvk.Secret) != gvk.Secret {
+		return "", TLSInfo{}, &ConfigError{Reason: InvalidTLS, Message: fmt.Sprintf("invalid certificate reference %v, only secret is allowed", objectReferenceString(ref))}
+	}
+
+	secret := model.ConfigKey{
+		Kind:      kind.Secret,
+		Name:      string(ref.Name),
+		Namespace: ptr.OrDefault((*string)(ref.Namespace), gw.Namespace),
+	}
+
+	key := secret.Namespace + "/" + secret.Name
+	scrt := ptr.Flatten(krt.FetchOne(ctx, secrets, krt.FilterKey(key)))
+	if scrt == nil {
+		return "", TLSInfo{}, &ConfigError{
+			Reason:  InvalidTLS,
+			Message: fmt.Sprintf("invalid certificate reference %v, secret %v not found", objectReferenceString(ref), key),
+		}
+	}
+	certInfo, err := kubecreds.ExtractCertInfo(scrt)
+	if err != nil {
+		return "", TLSInfo{}, &ConfigError{
+			Reason:  InvalidTLS,
+			Message: fmt.Sprintf("invalid certificate reference %v, %v", objectReferenceString(ref), err),
+		}
+	}
+	if _, err = tls.X509KeyPair(certInfo.Cert, certInfo.Key); err != nil {
+		return "", TLSInfo{}, &ConfigError{
+			Reason:  InvalidTLS,
+			Message: fmt.Sprintf("invalid certificate reference %v, the certificate is malformed: %v", objectReferenceString(ref), err),
+		}
+	}
+	return creds.ToKubernetesGatewayResource(secret.Namespace, secret.Name), TLSInfo{
+		Cert: certInfo.Cert,
+		Key:  certInfo.Key,
+	}, nil
+}
+
+func objectReferenceString(ref k8s.SecretObjectReference) string {
+	return fmt.Sprintf("%s/%s/%s.%s",
+		ptr.OrEmpty(ref.Group),
+		ptr.OrEmpty(ref.Kind),
+		ref.Name,
+		ptr.OrEmpty(ref.Namespace))
+}
+
+func parentRefString(ref k8s.ParentReference) string {
+	return fmt.Sprintf("%s/%s/%s/%s/%d.%s",
+		ptr.OrEmpty(ref.Group),
+		ptr.OrEmpty(ref.Kind),
+		ref.Name,
+		ptr.OrEmpty(ref.SectionName),
+		ptr.OrEmpty(ref.Port),
+		ptr.OrEmpty(ref.Namespace))
+}
+
+// buildHostnameMatch generates a Gateway.spec.servers.hosts section from a listener
+func buildHostnameMatch(ctx krt.HandlerContext, localNamespace string, namespaces krt.Collection[*corev1.Namespace], l k8s.Listener) []string {
+	// We may allow all hostnames or a specific one
+	hostname := "*"
+	if l.Hostname != nil {
+		hostname = string(*l.Hostname)
+	}
+
+	resp := []string{}
+	for _, ns := range namespacesFromSelector(ctx, localNamespace, namespaces, l.AllowedRoutes) {
+		// This check is necessary to prevent adding a hostname with an invalid empty namespace
+		if len(ns) > 0 {
+			resp = append(resp, fmt.Sprintf("%s/%s", ns, hostname))
+		}
+	}
+
+	// If nothing matched use ~ namespace (match nothing). We need this since its illegal to have an
+	// empty hostname list, but we still need the Gateway provisioned to ensure status is properly set and
+	// SNI matches are established; we just don't want to actually match any routing rules (yet).
+	if len(resp) == 0 {
+		return []string{"~/" + hostname}
+	}
+	return resp
+}
+
+// namespacesFromSelector determines a list of allowed namespaces for a given AllowedRoutes
+func namespacesFromSelector(ctx krt.HandlerContext, localNamespace string, namespaceCol krt.Collection[*corev1.Namespace], lr *k8s.AllowedRoutes) []string {
+	// Default is to allow only the same namespace
+	if lr == nil || lr.Namespaces == nil || lr.Namespaces.From == nil || *lr.Namespaces.From == k8s.NamespacesFromSame {
+		return []string{localNamespace}
+	}
+	if *lr.Namespaces.From == k8s.NamespacesFromAll {
+		return []string{"*"}
+	}
+
+	if lr.Namespaces.Selector == nil {
+		// Should never happen, invalid config
+		return []string{"*"}
+	}
+
+	// gateway-api has selectors, but Istio Gateway just has a list of names. We will run the selector
+	// against all namespaces and get a list of matching namespaces that can be converted into a list
+	// Istio can handle.
+	ls, err := metav1.LabelSelectorAsSelector(lr.Namespaces.Selector)
+	if err != nil {
+		return nil
+	}
+	namespaces := []string{}
+	namespaceObjects := krt.Fetch(ctx, namespaceCol)
+	for _, ns := range namespaceObjects {
+		if ls.Matches(toNamespaceSet(ns.Name, ns.Labels)) {
+			namespaces = append(namespaces, ns.Name)
+		}
+	}
+	// Ensure stable order
+	sort.Strings(namespaces)
+	return namespaces
+}
+
+func humanReadableJoin(ss []string) string {
+	switch len(ss) {
+	case 0:
+		return ""
+	case 1:
+		return ss[0]
+	case 2:
+		return ss[0] + " and " + ss[1]
+	default:
+		return strings.Join(ss[:len(ss)-1], ", ") + ", and " + ss[len(ss)-1]
+	}
+}
+
+// NamespaceNameLabel represents that label added automatically to namespaces is newer Kubernetes clusters
+const NamespaceNameLabel = "kubernetes.io/metadata.name"
+
+// toNamespaceSet converts a set of namespace labels to a Set that can be used to select against.
+func toNamespaceSet(name string, labels map[string]string) klabels.Set {
+	// If namespace label is not set, implicitly insert it to support older Kubernetes versions
+	if labels[NamespaceNameLabel] == name {
+		// Already set, avoid copies
+		return labels
+	}
+	// First we need a copy to not modify the underlying object
+	ret := make(map[string]string, len(labels)+1)
+	for k, v := range labels {
+		ret[k] = v
+	}
+	ret[NamespaceNameLabel] = name
+	return ret
+}
+
+func GetCommonRouteInfo(spec any) ([]k8s.ParentReference, []k8s.Hostname, config.GroupVersionKind) {
+	switch t := spec.(type) {
+	case *k8salpha.TCPRoute:
+		return t.Spec.ParentRefs, nil, gvk.TCPRoute
+	case *k8salpha.TLSRoute:
+		return t.Spec.ParentRefs, t.Spec.Hostnames, gvk.TLSRoute
+	case *k8sbeta.HTTPRoute:
+		return t.Spec.ParentRefs, t.Spec.Hostnames, gvk.HTTPRoute
+	case *k8s.GRPCRoute:
+		return t.Spec.ParentRefs, t.Spec.Hostnames, gvk.GRPCRoute
+	default:
+		log.Fatalf("unknown type %T", t)
+		return nil, nil, config.GroupVersionKind{}
+	}
+}
+
+func GetCommonRouteStateParents(spec any) []k8s.RouteParentStatus {
+	switch t := spec.(type) {
+	case *k8salpha.TCPRoute:
+		return t.Status.Parents
+	case *k8salpha.TLSRoute:
+		return t.Status.Parents
+	case *k8sbeta.HTTPRoute:
+		return t.Status.Parents
+	case *k8s.GRPCRoute:
+		return t.Status.Parents
+	default:
+		log.Fatalf("unknown type %T", t)
+		return nil
+	}
+}
+
+// normalizeReference takes a generic Group/Kind (the API uses a few variations) and converts to a known GroupVersionKind.
+// Defaults for the group/kind are also passed.
+func normalizeReference[G ~string, K ~string](group *G, kind *K, def config.GroupVersionKind) config.GroupVersionKind {
+	k := def.Kind
+	if kind != nil {
+		k = string(*kind)
+	}
+	g := def.Group
+	if group != nil {
+		g = string(*group)
+	}
+	gk := config.GroupVersionKind{
+		Group: g,
+		Kind:  k,
+	}
+	s, f := collections.All.FindByGroupKind(gk)
+	if f {
+		return s.GroupVersionKind()
+	}
+	return gk
+}
+
+func defaultString[T ~string](s *T, def string) string {
+	if s == nil {
+		return def
+	}
+	return string(*s)
+}
+
+func toRouteKind(g config.GroupVersionKind) k8s.RouteGroupKind {
+	return k8s.RouteGroupKind{Group: (*k8s.Group)(&g.Group), Kind: k8s.Kind(g.Kind)}
+}
+
+func routeGroupKindEqual(rgk1, rgk2 k8s.RouteGroupKind) bool {
+	return rgk1.Kind == rgk2.Kind && getGroup(rgk1) == getGroup(rgk2)
+}
+
+func getGroup(rgk k8s.RouteGroupKind) k8s.Group {
+	return ptr.OrDefault(rgk.Group, k8s.Group(gvk.KubernetesGateway.Group))
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go b/internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go
new file mode 100644
index 000000000..631a5abf5
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go
@@ -0,0 +1,1560 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"cmp"
+	"encoding/json"
+	"fmt"
+	"os"
+	"reflect"
+	"regexp"
+	"strings"
+	"sync"
+	"testing"
+
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"sigs.k8s.io/gateway-api/pkg/consts"
+	"sigs.k8s.io/yaml"
+
+	istio "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/config/kube/crd"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/networking/core"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
+	"istio.io/istio/pilot/pkg/status"
+	"istio.io/istio/pilot/test/util"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	crdvalidation "istio.io/istio/pkg/config/crd"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/gvr"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/kclient/clienttest"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/maps"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/util/sets"
+)
+
+var ports = []*model.Port{
+	{
+		Name:     "http",
+		Port:     80,
+		Protocol: "HTTP",
+	},
+	{
+		Name:     "tcp",
+		Port:     34000,
+		Protocol: "TCP",
+	},
+	{
+		Name:     "tcp-other",
+		Port:     34001,
+		Protocol: "TCP",
+	},
+}
+
+var services = []*model.Service{
+	{
+		Attributes: model.ServiceAttributes{
+			Name:      "istio-ingressgateway",
+			Namespace: "istio-system",
+			ClusterExternalAddresses: &model.AddressMap{
+				Addresses: map[cluster.ID][]string{
+					constants.DefaultClusterName: {"1.2.3.4"},
+				},
+			},
+		},
+		Ports:    ports,
+		Hostname: "istio-ingressgateway.istio-system.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "istio-system",
+		},
+		Ports:    ports,
+		Hostname: "example.com",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "apple",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-apple.apple.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "banana",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-banana.banana.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-second.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-wildcard.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "foo-svc.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-other.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "example.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "echo.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "cert",
+		},
+		Ports:    ports,
+		Hostname: "httpbin.cert.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "service",
+		},
+		Ports:    ports,
+		Hostname: "my-svc.service.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "google.com",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "allowed-1",
+		},
+		Ports:    ports,
+		Hostname: "a-example.allowed-1.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "allowed-2",
+		},
+		Ports:    ports,
+		Hostname: "a-example.allowed-2.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "allowed-1",
+		},
+		Ports:    ports,
+		Hostname: "b-example.allowed-1.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "allowed-1",
+		},
+		Ports:    ports,
+		Hostname: "svc2.allowed-1.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "allowed-2",
+		},
+		Ports:    ports,
+		Hostname: "svc2.allowed-2.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "allowed-1",
+		},
+		Ports:    ports,
+		Hostname: "svc1.allowed-1.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "allowed-2",
+		},
+		Ports:    ports,
+		Hostname: "svc3.allowed-2.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "svc4.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "group-namespace1",
+		},
+		Ports:    ports,
+		Hostname: "httpbin.group-namespace1.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "group-namespace2",
+		},
+		Ports:    ports,
+		Hostname: "httpbin.group-namespace2.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-zero.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "istio-system",
+		},
+		Ports:    ports,
+		Hostname: "httpbin.istio-system.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-mirror.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-foo.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-alt.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "istio-system",
+		},
+		Ports:    ports,
+		Hostname: "istiod.istio-system.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "istio-system",
+		},
+		Ports:    ports,
+		Hostname: "echo.istio-system.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "httpbin-bad.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Name:      "echo-1",
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "echo-1.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Name:      "echo-2",
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "echo-2.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Name:      "echo-port",
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "echo-port.default.svc.domain.suffix",
+	},
+	{
+		Attributes: model.ServiceAttributes{
+			Name:      "not-found",
+			Namespace: "default",
+		},
+		Ports:    ports,
+		Hostname: "not-found.default.svc.domain.suffix",
+	},
+}
+
+var svcPorts = []corev1.ServicePort{
+	{
+		Name:     "http",
+		Port:     80,
+		Protocol: "HTTP",
+	},
+	{
+		Name:     "tcp",
+		Port:     34000,
+		Protocol: "TCP",
+	},
+	{
+		Name:     "tcp-other",
+		Port:     34001,
+		Protocol: "TCP",
+	},
+}
+
+var (
+	// https://github.com/kubernetes/kubernetes/blob/v1.25.4/staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_tls_test.go#L31
+	rsaCertPEM = `-----BEGIN CERTIFICATE-----
+MIIB0zCCAX2gAwIBAgIJAI/M7BYjwB+uMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV
+BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX
+aWRnaXRzIFB0eSBMdGQwHhcNMTIwOTEyMjE1MjAyWhcNMTUwOTEyMjE1MjAyWjBF
+MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50
+ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANLJ
+hPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wok/4xIA+ui35/MmNa
+rtNuC+BdZ1tMuVCPFZcCAwEAAaNQME4wHQYDVR0OBBYEFJvKs8RfJaXTH08W+SGv
+zQyKn0H8MB8GA1UdIwQYMBaAFJvKs8RfJaXTH08W+SGvzQyKn0H8MAwGA1UdEwQF
+MAMBAf8wDQYJKoZIhvcNAQEFBQADQQBJlffJHybjDGxRMqaRmDhX0+6v02TUKZsW
+r5QuVbpQhH6u+0UgcW0jp9QwpxoPTLTWGXEWBBBurxFwiCBhkQ+V
+-----END CERTIFICATE-----
+`
+	rsaKeyPEM = `-----BEGIN RSA PRIVATE KEY-----
+MIIBOwIBAAJBANLJhPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wo
+k/4xIA+ui35/MmNartNuC+BdZ1tMuVCPFZcCAwEAAQJAEJ2N+zsR0Xn8/Q6twa4G
+6OB1M1WO+k+ztnX/1SvNeWu8D6GImtupLTYgjZcHufykj09jiHmjHx8u8ZZB/o1N
+MQIhAPW+eyZo7ay3lMz1V01WVjNKK9QSn1MJlb06h/LuYv9FAiEA25WPedKgVyCW
+SmUwbPw8fnTcpqDWE3yTO3vKcebqMSsCIBF3UmVue8YU3jybC3NxuXq3wNm34R8T
+xVLHwDXh/6NJAiEAl2oHGGLz64BuAfjKrqwz7qMYr9HCLIe/YsoWq/olzScCIQDi
+D2lWusoe2/nEqfDVVWGWlyJ7yOmqaVm/iNUN9B2N2g==
+-----END RSA PRIVATE KEY-----
+`
+
+	secrets = []runtime.Object{
+		&corev1.Secret{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "my-cert-http",
+				Namespace: "istio-system",
+			},
+			Data: map[string][]byte{
+				"tls.crt": []byte(rsaCertPEM),
+				"tls.key": []byte(rsaKeyPEM),
+			},
+		},
+		&corev1.Secret{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "cert",
+				Namespace: "cert",
+			},
+			Data: map[string][]byte{
+				"tls.crt": []byte(rsaCertPEM),
+				"tls.key": []byte(rsaKeyPEM),
+			},
+		},
+		&corev1.Secret{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      "malformed",
+				Namespace: "istio-system",
+			},
+			Data: map[string][]byte{
+				// nolint: lll
+				// https://github.com/kubernetes-sigs/gateway-api/blob/d7f71d6b7df7e929ae299948973a693980afc183/conformance/tests/gateway-invalid-tls-certificateref.yaml#L87-L90
+				// this certificate is invalid because contains an invalid pem (base64 of "Hello world"),
+				// and the certificate and the key are identical
+				"tls.crt": []byte("SGVsbG8gd29ybGQK"),
+				"tls.key": []byte("SGVsbG8gd29ybGQK"),
+			},
+		},
+	}
+)
+
+func init() {
+	features.EnableAlphaGatewayAPI = true
+	features.EnableAmbientWaypoints = true
+	// Recompute with ambient enabled
+	classInfos = getClassInfos()
+	builtinClasses = getBuiltinClasses()
+}
+
+type TestStatusQueue struct {
+	mu    sync.Mutex
+	state map[status.Resource]any
+}
+
+func (t *TestStatusQueue) EnqueueStatusUpdateResource(context any, target status.Resource) {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	t.state[target] = context
+}
+
+func (t *TestStatusQueue) Statuses() []any {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	return maps.Values(t.state)
+}
+
+func (t *TestStatusQueue) Dump() string {
+	t.mu.Lock()
+	defer t.mu.Unlock()
+	sb := strings.Builder{}
+	objs := []crd.IstioKind{}
+	for k, v := range t.state {
+		statusj, _ := json.Marshal(v)
+		gk, _ := gvk.FromGVR(k.GroupVersionResource)
+		obj := crd.IstioKind{
+			TypeMeta: metav1.TypeMeta{
+				Kind:       gk.Kind,
+				APIVersion: k.GroupVersion().String(),
+			},
+			ObjectMeta: metav1.ObjectMeta{
+				Name:      k.Name,
+				Namespace: k.Namespace,
+			},
+			Spec:   nil,
+			Status: ptr.Of(json.RawMessage(statusj)),
+		}
+		objs = append(objs, obj)
+	}
+	slices.SortFunc(objs, func(a, b crd.IstioKind) int {
+		ord := []string{gvk.GatewayClass.Kind, gvk.Gateway.Kind, gvk.HTTPRoute.Kind, gvk.GRPCRoute.Kind, gvk.TLSRoute.Kind, gvk.TCPRoute.Kind}
+		if r := cmp.Compare(slices.Index(ord, a.Kind), slices.Index(ord, b.Kind)); r != 0 {
+			return r
+		}
+		if r := a.CreationTimestamp.Time.Compare(b.CreationTimestamp.Time); r != 0 {
+			return r
+		}
+		if r := cmp.Compare(a.Namespace, b.Namespace); r != 0 {
+			return r
+		}
+		return cmp.Compare(a.Name, b.Name)
+	})
+	for _, obj := range objs {
+		b, err := yaml.Marshal(obj)
+		if err != nil {
+			panic(err.Error())
+		}
+		// Replace parts that are not stable
+		b = timestampRegex.ReplaceAll(b, []byte("lastTransitionTime: fake"))
+		sb.WriteString(string(b))
+		sb.WriteString("---\n")
+	}
+	return sb.String()
+}
+
+var _ status.Queue = &TestStatusQueue{}
+
+func TestConvertResources(t *testing.T) {
+	validator := crdvalidation.NewIstioValidator(t)
+	cases := []struct {
+		name string
+		// Some configs are intended to be generated with invalid configs, and since they will be validated
+		// by the validator, we need to ignore the validation errors to prevent the test from failing.
+		validationIgnorer *crdvalidation.ValidationIgnorer
+	}{
+		{name: "http"},
+		{name: "tcp"},
+		{name: "tls"},
+		{name: "grpc"},
+		{name: "mismatch"},
+		{name: "weighted"},
+		{name: "zero"},
+		{name: "mesh"},
+		{
+			name: "invalid",
+			validationIgnorer: crdvalidation.NewValidationIgnorer(
+				"default/^invalid-backendRef-kind-",
+				"default/^invalid-backendRef-mixed-",
+			),
+		},
+		{name: "multi-gateway"},
+		{name: "delegated"},
+		{name: "route-binding"},
+		{name: "reference-policy-tls"},
+		{
+			name: "reference-policy-service",
+			validationIgnorer: crdvalidation.NewValidationIgnorer(
+				"istio-system/^backend-not-allowed-",
+			),
+		},
+		{
+			name: "reference-policy-tcp",
+			validationIgnorer: crdvalidation.NewValidationIgnorer(
+				"istio-system/^not-allowed-echo-",
+			),
+		},
+		{name: "serviceentry"},
+		{name: "eastwest"},
+		{name: "eastwest-tlsoption"},
+		{name: "eastwest-labelport"},
+		{name: "eastwest-remote"},
+		{name: "mcs"},
+		{name: "route-precedence"},
+		{name: "waypoint"},
+		{name: "isolation"},
+		{
+			name: "valid-invalid-parent-ref",
+			validationIgnorer: crdvalidation.NewValidationIgnorer(
+				"default/^valid-invalid-parent-ref-",
+			),
+		},
+	}
+	test.SetForTest(t, &features.EnableGatewayAPIGatewayClassController, false)
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			stop := test.NewStop(t)
+			input := readConfig(t, fmt.Sprintf("testdata/%s.yaml", tt.name), validator, nil)
+			kc := kube.NewFakeClient(input...)
+			setupClientCRDs(t, kc)
+			// Setup a few preconfigured services
+			instances := []*model.ServiceInstance{}
+			for _, svc := range services {
+				instances = append(instances, &model.ServiceInstance{
+					Service:     svc,
+					ServicePort: ports[0],
+					Endpoint:    &model.IstioEndpoint{EndpointPort: 8080},
+				}, &model.ServiceInstance{
+					Service:     svc,
+					ServicePort: ports[1],
+					Endpoint:    &model.IstioEndpoint{},
+				}, &model.ServiceInstance{
+					Service:     svc,
+					ServicePort: ports[2],
+					Endpoint:    &model.IstioEndpoint{},
+				})
+			}
+			cg := core.NewConfigGenTest(t, core.TestOptions{
+				Services:  services,
+				Instances: instances,
+			})
+
+			dbg := &krt.DebugHandler{}
+			dumpOnFailure(t, dbg)
+			ctrl := NewController(
+				kc,
+				AlwaysReady,
+				controller.Options{DomainSuffix: "domain.suffix", KrtDebugger: dbg},
+				nil,
+			)
+			sq := &TestStatusQueue{
+				state: map[status.Resource]any{},
+			}
+			go ctrl.Run(stop)
+			kc.RunAndWait(stop)
+			ctrl.Reconcile(cg.PushContext())
+			kube.WaitForCacheSync("test", stop, ctrl.HasSynced)
+			// Normally we don't care to block on status being written, but here we need to since we want to test output
+			statusSynced := ctrl.status.SetQueue(sq)
+			for _, st := range statusSynced {
+				st.WaitUntilSynced(stop)
+			}
+
+			res := ctrl.List(gvk.Gateway, "")
+			sortConfigByCreationTime(res)
+			vs := ctrl.List(gvk.VirtualService, "")
+			res = append(res, sortedConfigByCreationTime(vs)...)
+
+			goldenFile := fmt.Sprintf("testdata/%s.yaml.golden", tt.name)
+			util.CompareContent(t, marshalYaml(t, res), goldenFile)
+
+			outputStatus := sq.Dump()
+			goldenStatusFile := fmt.Sprintf("testdata/%s.status.yaml.golden", tt.name)
+			util.CompareContent(t, []byte(outputStatus), goldenStatusFile)
+		})
+	}
+}
+
+func setupClientCRDs(t *testing.T, kc kube.CLIClient) {
+	for _, crd := range []schema.GroupVersionResource{
+		gvr.KubernetesGateway,
+		gvr.ReferenceGrant,
+		gvr.GatewayClass,
+		gvr.HTTPRoute,
+		gvr.GRPCRoute,
+		gvr.TCPRoute,
+		gvr.TLSRoute,
+		gvr.ServiceEntry,
+	} {
+		clienttest.MakeCRDWithAnnotations(t, kc, crd, map[string]string{
+			consts.BundleVersionAnnotation: "v1.1.0",
+		})
+	}
+}
+
+func dumpOnFailure(t *testing.T, debugger *krt.DebugHandler) {
+	t.Cleanup(func() {
+		if t.Failed() {
+			b, _ := yaml.Marshal(debugger)
+			t.Log(string(b))
+		}
+	})
+}
+
+func TestSortHTTPRoutes(t *testing.T) {
+	cases := []struct {
+		name string
+		in   []*istio.HTTPRoute
+		out  []*istio.HTTPRoute
+	}{
+		{
+			"match is preferred over no match",
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{
+									Exact: "/foo",
+								},
+							},
+						},
+					},
+				},
+			},
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{
+									Exact: "/foo",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{},
+				},
+			},
+		},
+		{
+			"path matching exact > prefix  > regex",
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Regex{
+									Regex: ".*foo",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{
+									Exact: "/foo",
+								},
+							},
+						},
+					},
+				},
+			},
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{
+									Exact: "/foo",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Regex{
+									Regex: ".*foo",
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			"path prefix matching with largest characters",
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/foo",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/foobar",
+								},
+							},
+						},
+					},
+				},
+			},
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/foobar",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/foo",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/",
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			"path match is preferred over method match",
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Method: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{
+									Exact: "GET",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/foobar",
+								},
+							},
+						},
+					},
+				},
+			},
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/foobar",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Method: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{
+									Exact: "GET",
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			"largest number of header matches is preferred",
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Headers: map[string]*istio.StringMatch{
+								"header1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Headers: map[string]*istio.StringMatch{
+								"header1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+								"header2": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value2",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Headers: map[string]*istio.StringMatch{
+								"header1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+								"header2": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value2",
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Headers: map[string]*istio.StringMatch{
+								"header1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			"largest number of query params is preferred",
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							QueryParams: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							QueryParams: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+								"param2": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value2",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							QueryParams: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+								"param2": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value2",
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							QueryParams: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			"path > method > header > query params",
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							QueryParams: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Method: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{Exact: "GET"},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Headers: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			[]*istio.HTTPRoute{
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Uri: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Prefix{
+									Prefix: "/",
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Method: &istio.StringMatch{
+								MatchType: &istio.StringMatch_Exact{Exact: "GET"},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							Headers: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					Match: []*istio.HTTPMatchRequest{
+						{
+							QueryParams: map[string]*istio.StringMatch{
+								"param1": {
+									MatchType: &istio.StringMatch_Exact{
+										Exact: "value1",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			sortHTTPRoutes(tt.in)
+			if !reflect.DeepEqual(tt.in, tt.out) {
+				t.Fatalf("expected %v, got %v", tt.out, tt.in)
+			}
+		})
+	}
+}
+
+func TestReferencePolicy(t *testing.T) {
+	validator := crdvalidation.NewIstioValidator(t)
+	type res struct {
+		name, namespace string
+		allowed         bool
+	}
+	cases := []struct {
+		name         string
+		config       string
+		expectations []res
+	}{
+		{
+			name: "simple",
+			config: `apiVersion: gateway.networking.k8s.io/v1beta1
+kind: ReferenceGrant
+metadata:
+ name: allow-gateways-to-ref-secrets
+ namespace: default
+spec:
+ from:
+ - group: gateway.networking.k8s.io
+   kind: Gateway
+   namespace: istio-system
+ to:
+ - group: ""
+   kind: Secret
+`,
+			expectations: []res{
+				// allow cross namespace
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "istio-system", true},
+				// denied same namespace. We do not implicitly allow (in this code - higher level code does)
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "default", false},
+				// denied namespace
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
+			},
+		},
+		{
+			name: "multiple in one",
+			config: `apiVersion: gateway.networking.k8s.io/v1beta1
+kind: ReferenceGrant
+metadata:
+ name: allow-gateways-to-ref-secrets
+ namespace: default
+spec:
+ from:
+ - group: gateway.networking.k8s.io
+   kind: Gateway
+   namespace: ns-1
+ - group: gateway.networking.k8s.io
+   kind: Gateway
+   namespace: ns-2
+ to:
+ - group: ""
+   kind: Secret
+`,
+			expectations: []res{
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-1", true},
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-2", true},
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
+			},
+		},
+		{
+			name: "multiple",
+			config: `apiVersion: gateway.networking.k8s.io/v1beta1
+kind: ReferenceGrant
+metadata:
+ name: ns1
+ namespace: default
+spec:
+ from:
+ - group: gateway.networking.k8s.io
+   kind: Gateway
+   namespace: ns-1
+ to:
+ - group: ""
+   kind: Secret
+---
+apiVersion: gateway.networking.k8s.io/v1beta1
+kind: ReferenceGrant
+metadata:
+ name: ns2
+ namespace: default
+spec:
+ from:
+ - group: gateway.networking.k8s.io
+   kind: Gateway
+   namespace: ns-2
+ to:
+ - group: ""
+   kind: Secret
+`,
+			expectations: []res{
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-1", true},
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-2", true},
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
+			},
+		},
+		{
+			name: "same namespace",
+			config: `apiVersion: gateway.networking.k8s.io/v1beta1
+kind: ReferenceGrant
+metadata:
+ name: allow-gateways-to-ref-secrets
+ namespace: default
+spec:
+ from:
+ - group: gateway.networking.k8s.io
+   kind: Gateway
+   namespace: default
+ to:
+ - group: ""
+   kind: Secret
+`,
+			expectations: []res{
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "istio-system", false},
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "default", true},
+				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
+			},
+		},
+		{
+			name: "same name",
+			config: `apiVersion: gateway.networking.k8s.io/v1beta1
+kind: ReferenceGrant
+metadata:
+ name: allow-gateways-to-ref-secrets
+ namespace: default
+spec:
+ from:
+ - group: gateway.networking.k8s.io
+   kind: Gateway
+   namespace: default
+ to:
+ - group: ""
+   kind: Secret
+   name: public
+`,
+			expectations: []res{
+				{"kubernetes-gateway://default/public", "istio-system", false},
+				{"kubernetes-gateway://default/public", "default", true},
+				{"kubernetes-gateway://default/private", "default", false},
+			},
+		},
+	}
+	for _, tt := range cases {
+		t.Run(tt.name, func(t *testing.T) {
+			input := readConfigString(t, tt.config, validator, nil)
+			kr := setupController(t, input...)
+			for _, sc := range tt.expectations {
+				t.Run(fmt.Sprintf("%v/%v", sc.name, sc.namespace), func(t *testing.T) {
+					got := kr.SecretAllowed(sc.name, sc.namespace)
+					if got != sc.allowed {
+						t.Fatalf("expected allowed=%v, got allowed=%v", sc.allowed, got)
+					}
+				})
+			}
+		})
+	}
+}
+
+var timestampRegex = regexp.MustCompile(`lastTransitionTime:.*`)
+
+func readConfig(t testing.TB, filename string, validator *crdvalidation.Validator, ignorer *crdvalidation.ValidationIgnorer) []runtime.Object {
+	t.Helper()
+
+	data, err := os.ReadFile(filename)
+	if err != nil {
+		t.Fatalf("failed to read input yaml file: %v", err)
+	}
+	objs := readConfigString(t, string(data), validator, ignorer)
+
+	namespaces := sets.New[string](slices.Map(objs, func(e runtime.Object) string {
+		return e.(controllers.Object).GetNamespace()
+	})...)
+	for _, svc := range services {
+		if !strings.HasSuffix(svc.Hostname.String(), "domain.suffix") {
+			continue
+		}
+		name := svc.Attributes.Name
+		if name == "" {
+			name, _, _ = strings.Cut(svc.Hostname.String(), ".")
+		}
+		svcObj := &corev1.Service{
+			ObjectMeta: metav1.ObjectMeta{
+				Namespace: svc.Attributes.Namespace,
+				Name:      name,
+			},
+			Spec: corev1.ServiceSpec{
+				Ports: svcPorts,
+			},
+		}
+		objs = append(objs, svcObj)
+	}
+	objs = append(objs, secrets...)
+
+	for ns := range namespaces {
+		objs = append(objs, &corev1.Namespace{
+			ObjectMeta: metav1.ObjectMeta{
+				Name: ns,
+				Labels: map[string]string{
+					"istio.io/test-name-part": strings.Split(ns, "-")[0],
+				},
+			},
+		})
+	}
+	return objs
+}
+
+func readConfigString(t testing.TB, data string, validator *crdvalidation.Validator, ignorer *crdvalidation.ValidationIgnorer,
+) []runtime.Object {
+	if err := validator.ValidateCustomResourceYAML(data, ignorer); err != nil {
+		t.Error(err)
+	}
+
+	c, err := kubernetesObjectsFromString(data)
+	if err != nil {
+		t.Fatalf("failed to parse CRD: %v", err)
+	}
+	return c
+}
+
+// Print as YAML
+func marshalYaml(t test.Failer, cl []config.Config) []byte {
+	t.Helper()
+	result := []byte{}
+	separator := []byte("---\n")
+	for _, config := range cl {
+		obj, err := crd.ConvertConfig(config)
+		if err != nil {
+			t.Fatalf("Could not decode %v: %v", config.Name, err)
+		}
+		bytes, err := yaml.Marshal(obj)
+		if err != nil {
+			t.Fatalf("Could not convert %v to YAML: %v", config, err)
+		}
+		result = append(result, bytes...)
+		result = append(result, separator...)
+	}
+	return result
+}
+
+func TestHumanReadableJoin(t *testing.T) {
+	tests := []struct {
+		input []string
+		want  string
+	}{
+		{[]string{"a"}, "a"},
+		{[]string{"a", "b"}, "a and b"},
+		{[]string{"a", "b", "c"}, "a, b, and c"},
+	}
+	for _, tt := range tests {
+		t.Run(strings.Join(tt.input, "_"), func(t *testing.T) {
+			if got := humanReadableJoin(tt.input); !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("got %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
+
+//
+//func BenchmarkBuildHTTPVirtualServices(b *testing.B) {
+//	ports := []*model.Port{
+//		{
+//			Name:     "http",
+//			Port:     80,
+//			Protocol: "HTTP",
+//		},
+//		{
+//			Name:     "tcp",
+//			Port:     34000,
+//			Protocol: "TCP",
+//		},
+//	}
+//	ingressSvc := &model.Service{
+//		Attributes: model.ServiceAttributes{
+//			Name:      "istio-ingressgateway",
+//			Namespace: "istio-system",
+//			ClusterExternalAddresses: &model.AddressMap{
+//				Addresses: map[cluster.ID][]string{
+//					constants.DefaultClusterName: {"1.2.3.4"},
+//				},
+//			},
+//		},
+//		Ports:    ports,
+//		Hostname: "istio-ingressgateway.istio-system.svc.domain.suffix",
+//	}
+//	altIngressSvc := &model.Service{
+//		Attributes: model.ServiceAttributes{
+//			Namespace: "istio-system",
+//		},
+//		Ports:    ports,
+//		Hostname: "example.com",
+//	}
+//	cg := core.NewConfigGenTest(b, core.TestOptions{
+//		Services: []*model.Service{ingressSvc, altIngressSvc},
+//		Instances: []*model.ServiceInstance{
+//			{Service: ingressSvc, ServicePort: ingressSvc.Ports[0], Endpoint: &model.IstioEndpoint{EndpointPort: 8080}},
+//			{Service: ingressSvc, ServicePort: ingressSvc.Ports[1], Endpoint: &model.IstioEndpoint{}},
+//			{Service: altIngressSvc, ServicePort: altIngressSvc.Ports[0], Endpoint: &model.IstioEndpoint{}},
+//			{Service: altIngressSvc, ServicePort: altIngressSvc.Ports[1], Endpoint: &model.IstioEndpoint{}},
+//		},
+//	})
+//
+//	validator := crdvalidation.NewIstioValidator(b)
+//	input := readConfig(b, "testdata/benchmark-httproute.yaml", validator, nil)
+//	kr := splitInput(b, input)
+//	kr.Context = NewGatewayContext(cg.PushContext(), "Kubernetes")
+//	ctx := configContext{
+//		GatewayResources:  kr,
+//		AllowedReferences: convertReferencePolicies(kr),
+//	}
+//	_, gwMap, _ := convertGateways(ctx)
+//	ctx.GatewayReferences = gwMap
+//
+//	b.ResetTimer()
+//	for n := 0; n < b.N; n++ {
+//		// for gateway routes, build one VS per gateway+host
+//		gatewayRoutes := make(map[string]map[string]*config.Config)
+//		// for mesh routes, build one VS per namespace+host
+//		meshRoutes := make(map[string]map[string]*config.Config)
+//		for _, obj := range kr.HTTPRoute {
+//			buildHTTPVirtualServices(ctx, obj, gatewayRoutes, meshRoutes)
+//		}
+//	}
+//}
+
+//func TestExtractGatewayServices(t *testing.T) {
+//	tests := []struct {
+//		name            string
+//		r               GatewayResources
+//		kgw             *k8s.Gateway
+//		obj             config.Config
+//		gatewayServices []string
+//		err             *ConfigError
+//	}{
+//		{
+//			name: "managed gateway",
+//			r:    GatewayResources{Domain: "cluster.local"},
+//			kgw: &k8s.GatewaySpec{
+//				GatewayClassName: "istio",
+//			},
+//			obj: config.Config{
+//				Meta: config.Meta{
+//					Name:      "foo",
+//					Namespace: "default",
+//				},
+//			},
+//			gatewayServices: []string{"foo-istio.default.svc.cluster.local"},
+//		},
+//		{
+//			name: "managed gateway with name overridden",
+//			r:    GatewayResources{Domain: "cluster.local"},
+//			kgw: &k8s.GatewaySpec{
+//				GatewayClassName: "istio",
+//			},
+//			obj: config.Config{
+//				Meta: config.Meta{
+//					Name:      "foo",
+//					Namespace: "default",
+//					Annotations: map[string]string{
+//						annotation.GatewayNameOverride.Name: "bar",
+//					},
+//				},
+//			},
+//			gatewayServices: []string{"bar.default.svc.cluster.local"},
+//		},
+//		{
+//			name: "unmanaged gateway",
+//			r:    GatewayResources{Domain: "domain"},
+//			kgw: &k8s.GatewaySpec{
+//				GatewayClassName: "istio",
+//				Addresses: []k8s.GatewayAddress{
+//					{
+//						Value: "abc",
+//					},
+//					{
+//						Type: func() *k8s.AddressType {
+//							t := k8s.HostnameAddressType
+//							return &t
+//						}(),
+//						Value: "example.com",
+//					},
+//					{
+//						Type: func() *k8s.AddressType {
+//							t := k8s.IPAddressType
+//							return &t
+//						}(),
+//						Value: "1.2.3.4",
+//					},
+//				},
+//			},
+//			obj: config.Config{
+//				Meta: config.Meta{
+//					Name:      "foo",
+//					Namespace: "default",
+//				},
+//			},
+//			gatewayServices: []string{"abc.default.svc.domain", "example.com"},
+//			err: &ConfigError{
+//				Reason:  InvalidAddress,
+//				Message: "only Hostname is supported, ignoring [1.2.3.4]",
+//			},
+//		},
+//	}
+//	for _, tt := range tests {
+//		t.Run(tt.name, func(t *testing.T) {
+//			gatewayServices, err := extractGatewayServices(tt.r, tt.kgw, tt.obj, classInfo{})
+//			assert.Equal(t, gatewayServices, tt.gatewayServices)
+//			assert.Equal(t, err, tt.err)
+//		})
+//	}
+//}
+
+func kubernetesObjectsFromString(s string) ([]runtime.Object, error) {
+	var objects []runtime.Object
+	decode := kube.IstioCodec.UniversalDeserializer().Decode
+	objectStrs := strings.Split(s, "---")
+	for _, s := range objectStrs {
+		if len(strings.TrimSpace(s)) == 0 {
+			continue
+		}
+		o, _, err := decode([]byte(s), nil, nil)
+		if err != nil {
+			return nil, fmt.Errorf("failed deserializing kubernetes object: %v (%v)", err, s)
+		}
+		objects = append(objects, o)
+	}
+	return objects, nil
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go b/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go
new file mode 100644
index 000000000..60a9ab756
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go
@@ -0,0 +1,952 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"reflect"
+	"strconv"
+	"strings"
+
+	appsv1 "k8s.io/api/apps/v1"
+	autoscalingv2 "k8s.io/api/autoscaling/v2"
+	corev1 "k8s.io/api/core/v1"
+	policyv1 "k8s.io/api/policy/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	klabels "k8s.io/apimachinery/pkg/labels"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/mergepatch"
+	"k8s.io/apimachinery/pkg/util/strategicpatch"
+	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+	"sigs.k8s.io/yaml"
+
+	"istio.io/api/annotation"
+	"istio.io/api/label"
+	meshapi "istio.io/api/mesh/v1alpha1"
+	"istio.io/istio/pilot/pkg/config/kube/crd"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/gvr"
+	common_features "istio.io/istio/pkg/features"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/inject"
+	"istio.io/istio/pkg/kube/kclient"
+	istiolog "istio.io/istio/pkg/log"
+	"istio.io/istio/pkg/maps"
+	"istio.io/istio/pkg/revisions"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/test/util/tmpl"
+	"istio.io/istio/pkg/test/util/yml"
+	"istio.io/istio/pkg/util/sets"
+)
+
+// DeploymentController implements a controller that materializes a Gateway into an in cluster gateway proxy
+// to serve requests from. This is implemented with a Deployment and Service today.
+// The implementation makes a few non-obvious choices - namely using Server Side Apply from go templates
+// and not using controller-runtime.
+//
+// controller-runtime has a number of constraints that make it inappropriate for usage here, despite this
+// seeming to be the bread and butter of the library:
+// * It is not readily possible to bring existing Informers, which would require extra watches (#1668)
+// * Goroutine leaks (#1655)
+// * Excessive API-server calls at startup which have no benefit to us (#1603)
+// * Hard to use with SSA (#1669)
+// While these can be worked around, at some point it isn't worth the effort.
+//
+// Server Side Apply with go templates is an odd choice (no one likes YAML templating...) but is one of the few
+// remaining options after all others are ruled out.
+//   - Merge patch/Update cannot be used. If we always enforce that our object is *exactly* the same as
+//     the in-cluster object we will get in endless loops due to other controllers that like to add annotations, etc.
+//     If we chose to allow any unknown fields, then we would never be able to remove fields we added, as
+//     we cannot tell if we created it or someone else did. SSA fixes these issues
+//   - SSA using client-go Apply libraries is almost a good choice, but most third-party clients (Istio, MCS, and gateway-api)
+//     do not provide these libraries.
+//   - SSA using standard API types doesn't work well either: https://github.com/kubernetes-sigs/controller-runtime/issues/1669
+//   - This leaves YAML templates, converted to unstructured types and Applied with the dynamic client.
+type DeploymentController struct {
+	client         kube.Client
+	clusterID      cluster.ID
+	env            *model.Environment
+	queue          controllers.Queue
+	patcher        patcher
+	gateways       kclient.Client[*gateway.Gateway]
+	gatewayClasses kclient.Client[*gateway.GatewayClass]
+
+	clients         map[schema.GroupVersionResource]getter
+	injectConfig    func() inject.WebhookConfig
+	deployments     kclient.Client[*appsv1.Deployment]
+	services        kclient.Client[*corev1.Service]
+	hpas            kclient.Client[*autoscalingv2.HorizontalPodAutoscaler]
+	pdbs            kclient.Client[*policyv1.PodDisruptionBudget]
+	configMaps      kclient.Client[*corev1.ConfigMap]
+	serviceAccounts kclient.Client[*corev1.ServiceAccount]
+	namespaces      kclient.Client[*corev1.Namespace]
+	tagWatcher      revisions.TagWatcher
+	revision        string
+	systemNamespace string
+}
+
+// Patcher is a function that abstracts patching logic. This is largely because client-go fakes do not handle patching
+type patcher func(gvr schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error
+
+// classInfo holds information about a gateway class
+type classInfo struct {
+	// controller name for this class
+	controller string
+	// description for this class
+	description string
+	// The key in the templates to use for this class
+	templates string
+
+	// defaultServiceType sets the default service type if one is not explicit set
+	defaultServiceType corev1.ServiceType
+
+	// disableRouteGeneration, if set, will make it so the controller ignores this class.
+	disableRouteGeneration bool
+
+	// disableNameSuffix, if set, will avoid appending -<class> to names
+	disableNameSuffix bool
+
+	// addressType is the default address type to report
+	addressType gateway.AddressType
+}
+
+var classInfos = getClassInfos()
+
+var builtinClasses = getBuiltinClasses()
+
+func getBuiltinClasses() map[gateway.ObjectName]gateway.GatewayController {
+	res := map[gateway.ObjectName]gateway.GatewayController{
+		gateway.ObjectName(features.GatewayAPIDefaultGatewayClass): gateway.GatewayController(features.ManagedGatewayController),
+	}
+
+	if features.MultiNetworkGatewayAPI {
+		res[constants.RemoteGatewayClassName] = constants.UnmanagedGatewayController
+	}
+
+	if features.EnableAmbientWaypoints {
+		res[constants.WaypointGatewayClassName] = constants.ManagedGatewayMeshController
+	}
+	return res
+}
+
+func getClassInfos() map[gateway.GatewayController]classInfo {
+	m := map[gateway.GatewayController]classInfo{
+		gateway.GatewayController(features.ManagedGatewayController): {
+			controller:         features.ManagedGatewayController,
+			description:        "The default Istio GatewayClass",
+			templates:          "kube-gateway",
+			defaultServiceType: corev1.ServiceTypeLoadBalancer,
+			addressType:        gateway.HostnameAddressType,
+		},
+	}
+
+	if features.MultiNetworkGatewayAPI {
+		m[constants.UnmanagedGatewayController] = classInfo{
+			// This represents a gateway that our control plane cannot discover directly via the API server.
+			// We shouldn't generate Istio resources for it. We aren't programming this gateway.
+			controller:             constants.UnmanagedGatewayController,
+			description:            "Remote to this cluster. Does not deploy or affect configuration.",
+			disableRouteGeneration: true,
+			addressType:            gateway.HostnameAddressType,
+		}
+	}
+	if features.EnableAmbientWaypoints {
+		m[constants.ManagedGatewayMeshController] = classInfo{
+			controller:         constants.ManagedGatewayMeshController,
+			description:        "The default Istio waypoint GatewayClass",
+			templates:          "waypoint",
+			disableNameSuffix:  true,
+			defaultServiceType: corev1.ServiceTypeClusterIP,
+			// Report both. Consumers of the gateways can choose which they want.
+			// In particular, Istio across different versions consumes different address types, so this retains compat
+			addressType: "",
+		}
+	}
+	return m
+}
+
+// NewDeploymentController constructs a DeploymentController and registers required informers.
+// The controller will not start until Run() is called.
+func NewDeploymentController(
+	client kube.Client,
+	clusterID cluster.ID,
+	env *model.Environment,
+	webhookConfig func() inject.WebhookConfig,
+	injectionHandler func(fn func()),
+	tw revisions.TagWatcher,
+	revision string,
+	systemNamespace string,
+) *DeploymentController {
+	filter := kclient.Filter{ObjectFilter: client.ObjectFilter()}
+	gateways := kclient.NewFiltered[*gateway.Gateway](client, filter)
+	gatewayClasses := kclient.New[*gateway.GatewayClass](client)
+	dc := &DeploymentController{
+		client:    client,
+		clusterID: clusterID,
+		clients:   map[schema.GroupVersionResource]getter{},
+		env:       env,
+		patcher: func(gvr schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error {
+			c := client.Dynamic().Resource(gvr).Namespace(namespace)
+			t := true
+			_, err := c.Patch(context.Background(), name, types.ApplyPatchType, data, metav1.PatchOptions{
+				Force:        &t,
+				FieldManager: features.ManagedGatewayController,
+			}, subresources...)
+			return err
+		},
+		gateways:        gateways,
+		gatewayClasses:  gatewayClasses,
+		injectConfig:    webhookConfig,
+		tagWatcher:      tw,
+		revision:        revision,
+		systemNamespace: systemNamespace,
+	}
+	gatewaysByParamsRef := kclient.CreateIndex(gateways, func(o *gateway.Gateway) []types.NamespacedName {
+		p, err := fetchParameters(o)
+		if p == nil || err != nil {
+			return nil
+		}
+		return []types.NamespacedName{*p}
+	})
+	dc.queue = controllers.NewQueue("gateway deployment",
+		controllers.WithReconciler(dc.Reconcile),
+		controllers.WithMaxAttempts(5))
+
+	// Set up a handler that will add the parent Gateway object onto the queue.
+	// The queue will only handle Gateway objects; if child resources (Service, etc) are updated we re-add
+	// the Gateway to the queue and reconcile the state of the world.
+	parentHandler := controllers.ObjectHandler(controllers.EnqueueForParentHandler(dc.queue, gvk.KubernetesGateway))
+
+	dc.services = kclient.NewFiltered[*corev1.Service](client, filter)
+	dc.services.AddEventHandler(parentHandler)
+	dc.clients[gvr.Service] = NewUntypedWrapper(dc.services)
+
+	dc.configMaps = kclient.NewFiltered[*corev1.ConfigMap](client, filter)
+	dc.configMaps.AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
+		// This could be a configmap referenced by a Gateway paramsRef
+		impacted := gatewaysByParamsRef.Lookup(config.NamespacedName(o))
+		for _, gw := range impacted {
+			dc.queue.AddObject(gw)
+		}
+		// Or it could also be a global GatewayClass config
+		classDefaults, classDefaultsF := o.GetLabels()[gatewayClassDefaults]
+		if classDefaultsF && o.GetNamespace() == dc.systemNamespace {
+			for _, gw := range dc.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
+				if string(gw.Spec.GatewayClassName) == classDefaults {
+					dc.queue.AddObject(gw)
+				}
+			}
+		}
+	}))
+
+	dc.deployments = kclient.NewFiltered[*appsv1.Deployment](client, filter)
+	dc.deployments.AddEventHandler(parentHandler)
+	dc.clients[gvr.Deployment] = NewUntypedWrapper(dc.deployments)
+
+	dc.serviceAccounts = kclient.NewFiltered[*corev1.ServiceAccount](client, filter)
+	dc.serviceAccounts.AddEventHandler(parentHandler)
+	dc.clients[gvr.ServiceAccount] = NewUntypedWrapper(dc.serviceAccounts)
+
+	dc.hpas = kclient.NewFiltered[*autoscalingv2.HorizontalPodAutoscaler](client, filter)
+	dc.hpas.AddEventHandler(parentHandler)
+	dc.clients[gvr.HorizontalPodAutoscaler] = NewUntypedWrapper(dc.hpas)
+
+	dc.pdbs = kclient.NewFiltered[*policyv1.PodDisruptionBudget](client, filter)
+	dc.pdbs.AddEventHandler(parentHandler)
+	dc.clients[gvr.PodDisruptionBudget] = NewUntypedWrapper(dc.pdbs)
+
+	dc.namespaces = kclient.NewFiltered[*corev1.Namespace](client, filter)
+	dc.namespaces.AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
+		// TODO: make this more intelligent, checking if something we care about has changed
+		// requeue this namespace
+		for _, gw := range dc.gateways.List(o.GetName(), klabels.Everything()) {
+			dc.queue.AddObject(gw)
+		}
+	}))
+
+	gateways.AddEventHandler(controllers.ObjectHandler(dc.queue.AddObject))
+	gatewayClasses.AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
+		for _, g := range dc.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
+			if string(g.Spec.GatewayClassName) == o.GetName() {
+				dc.queue.AddObject(g)
+			}
+		}
+	}))
+
+	// On injection template change, requeue all gateways
+	injectionHandler(func() {
+		for _, gw := range dc.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
+			dc.queue.AddObject(gw)
+		}
+	})
+
+	dc.tagWatcher.AddHandler(dc.HandleTagChange)
+
+	return dc
+}
+
+func (d *DeploymentController) Run(stop <-chan struct{}) {
+	kube.WaitForCacheSync(
+		"deployment controller",
+		stop,
+		d.namespaces.HasSynced,
+		d.deployments.HasSynced,
+		d.services.HasSynced,
+		d.configMaps.HasSynced,
+		d.serviceAccounts.HasSynced,
+		d.hpas.HasSynced,
+		d.pdbs.HasSynced,
+		d.gateways.HasSynced,
+		d.gatewayClasses.HasSynced,
+		d.tagWatcher.HasSynced,
+	)
+	d.queue.Run(stop)
+	controllers.ShutdownAll(
+		d.namespaces,
+		d.deployments,
+		d.services,
+		d.configMaps,
+		d.serviceAccounts,
+		d.hpas,
+		d.pdbs,
+		d.gateways,
+		d.gatewayClasses,
+	)
+}
+
+// Reconcile takes in the name of a Gateway and ensures the cluster is in the desired state
+func (d *DeploymentController) Reconcile(req types.NamespacedName) error {
+	log := log.WithLabels("gateway", req)
+
+	gw := d.gateways.Get(req.Name, req.Namespace)
+	if gw == nil {
+		log.Debugf("gateway no longer exists")
+		// we'll ignore not-found errors, since they can't be fixed by an immediate
+		// requeue (we'll need to wait for a new notification), and we can get them
+		// on deleted requests.
+		return nil
+	}
+
+	var controller gateway.GatewayController
+	if gc := d.gatewayClasses.Get(string(gw.Spec.GatewayClassName), ""); gc != nil {
+		controller = gc.Spec.ControllerName
+	} else {
+		if builtin, f := builtinClasses[gw.Spec.GatewayClassName]; f {
+			controller = builtin
+		}
+	}
+	ci, f := classInfos[controller]
+	if !f {
+		log.Debugf("skipping unknown controller %q", controller)
+		return nil
+	}
+
+	// find the tag or revision indicated by the object
+	if !d.tagWatcher.IsMine(gw.ObjectMeta) {
+		log.Debugf("gateway is not for this revision, skipping")
+		return nil
+	}
+	// TODO: Here we could check if the tag is set and matches no known tags, and handle that if we are default.
+
+	// Matched class, reconcile it
+	return d.configureIstioGateway(log, *gw, ci)
+}
+
+func (d *DeploymentController) configureIstioGateway(log *istiolog.Scope, gw gateway.Gateway, gi classInfo) error {
+	// If user explicitly sets addresses, we are assuming they are pointing to an existing deployment.
+	// We will not manage it in this case
+	if gi.templates == "" {
+		log.Debug("skip gateway class without template")
+		return nil
+	}
+	if !IsManaged(&gw.Spec) {
+		log.Debug("skip disabled gateway")
+		return nil
+	}
+	existingControllerVersion, overwriteControllerVersion, shouldHandle := ManagedGatewayControllerVersion(gw)
+	if !shouldHandle {
+		log.Debugf("skipping gateway which is managed by controller version %v", existingControllerVersion)
+		return nil
+	}
+	log.Info("reconciling")
+
+	var ns *corev1.Namespace
+	if d.namespaces != nil {
+		ns = d.namespaces.Get(gw.Namespace, "")
+	}
+	proxyUID, proxyGID := inject.GetProxyIDs(ns)
+
+	defaultName := getDefaultName(gw.Name, &gw.Spec, gi.disableNameSuffix)
+
+	serviceType := gi.defaultServiceType
+	if o, f := gw.Annotations[annotation.NetworkingServiceType.Name]; f {
+		serviceType = corev1.ServiceType(o)
+	}
+
+	input := TemplateInput{
+		Gateway:        &gw,
+		DeploymentName: model.GetOrDefault(gw.Annotations[annotation.GatewayNameOverride.Name], defaultName),
+		ServiceAccount: model.GetOrDefault(gw.Annotations[annotation.GatewayServiceAccount.Name], defaultName),
+		Ports:          extractServicePorts(gw),
+		ClusterID:      d.clusterID.String(),
+
+		KubeVersion:               kube.GetVersionAsInt(d.client),
+		Revision:                  d.revision,
+		ServiceType:               serviceType,
+		ProxyUID:                  proxyUID,
+		ProxyGID:                  proxyGID,
+		CompliancePolicy:          common_features.CompliancePolicy,
+		InfrastructureLabels:      gw.GetLabels(),
+		InfrastructureAnnotations: gw.GetAnnotations(),
+		GatewayNameLabel:          label.IoK8sNetworkingGatewayGatewayName.Name,
+	}
+	// Default to the gateway labels/annotations and overwrite if infrastructure labels/annotations are set
+	input.InfrastructureLabels = extractInfrastructureLabels(gw)
+	input.InfrastructureAnnotations = extractInfrastructureAnnotations(gw)
+	d.setLabelOverrides(gw, input)
+
+	if overwriteControllerVersion {
+		log.Debugf("write controller version, existing=%v", existingControllerVersion)
+		if err := d.setGatewayControllerVersion(gw); err != nil {
+			return fmt.Errorf("update gateway annotation: %v", err)
+		}
+	} else {
+		log.Debugf("controller version existing=%v, no action needed", existingControllerVersion)
+	}
+
+	rendered, err := d.render(gi.templates, input)
+	if err != nil {
+		// Just log error, we do not need to retry since rendering errors are not ephemeral errors
+		log.Errorf("error rendering templates: %v", err)
+		return nil
+	}
+	for _, t := range rendered {
+		if err := d.apply(gi.controller, t); err != nil {
+			return fmt.Errorf("apply failed: %v", err)
+		}
+	}
+
+	log.Info("gateway updated")
+	return nil
+}
+
+func (d *DeploymentController) setLabelOverrides(gw gateway.Gateway, input TemplateInput) {
+	// TODO: Codify this API (i.e how to know if a specific gateway is an Istio waypoint gateway)
+	isWaypointGateway := strings.Contains(string(gw.Spec.GatewayClassName), "waypoint")
+
+	var hasAmbientLabel bool
+	if _, ok := gw.Labels[label.IoIstioDataplaneMode.Name]; ok {
+		hasAmbientLabel = true
+	}
+	if _, ok := input.InfrastructureLabels[label.IoIstioDataplaneMode.Name]; ok {
+		hasAmbientLabel = true
+	}
+	// If no ambient redirection label is set explicitly, explicitly disable.
+	// TODO this sprays ambient annotations/labels all over EVER gateway resource (serviceaccts, services, etc)
+	if features.EnableAmbientWaypoints && !isWaypointGateway && !hasAmbientLabel {
+		input.InfrastructureLabels[label.IoIstioDataplaneMode.Name] = constants.DataplaneModeNone
+	}
+
+	// Default the network label for waypoints if not explicitly set in gateway's labels
+	network := d.injectConfig().Values.Struct().GetGlobal().GetNetwork()
+	if _, ok := gw.GetLabels()[label.TopologyNetwork.Name]; !ok && network != "" && isWaypointGateway {
+		input.InfrastructureLabels[label.TopologyNetwork.Name] = d.injectConfig().Values.Struct().GetGlobal().GetNetwork()
+	}
+}
+
+func extractInfrastructureLabels(gw gateway.Gateway) map[string]string {
+	return extractInfrastructureMetadata(gw.Spec.Infrastructure, true, gw)
+}
+
+func extractInfrastructureAnnotations(gw gateway.Gateway) map[string]string {
+	return extractInfrastructureMetadata(gw.Spec.Infrastructure, false, gw)
+}
+
+func translateInfraMeta[K ~string, V ~string](meta map[K]V) map[string]string {
+	infra := make(map[string]string, len(meta))
+	for k, v := range meta {
+		if strings.HasPrefix(string(k), "gateway.networking.k8s.io/") {
+			continue // ignore this prefix to avoid conflicts
+		}
+		infra[string(k)] = string(v)
+	}
+	return infra
+}
+
+func extractInfrastructureMetadata(gwInfra *gatewayv1.GatewayInfrastructure, isLabel bool, gw gateway.Gateway) map[string]string {
+	if gwInfra != nil && isLabel && gwInfra.Labels != nil {
+		return translateInfraMeta(gwInfra.Labels)
+	}
+	if gwInfra != nil && !isLabel && gwInfra.Annotations != nil {
+		return translateInfraMeta(gwInfra.Annotations)
+	}
+	if isLabel {
+		if gw.GetLabels() == nil {
+			return make(map[string]string)
+		}
+		return maps.Clone(gw.GetLabels())
+	}
+	if gw.GetAnnotations() == nil {
+		return make(map[string]string)
+	}
+	return maps.Clone(gw.GetAnnotations())
+}
+
+const (
+	// ControllerVersionAnnotation is an annotation added to the Gateway by the controller specifying
+	// the "controller version". The original intent of this was to work around
+	// https://github.com/istio/istio/issues/44164, where we needed to transition from a global owner
+	// to a per-revision owner. The newer version number allows forcing ownership, even if the other
+	// version was otherwise expected to control the Gateway.
+	// The version number has no meaning other than "larger numbers win".
+	// Numbers are used to future-proof in case we need to do another migration in the future.
+	ControllerVersionAnnotation = "gateway.istio.io/controller-version"
+	// ControllerVersion is the current version of our controller logic. Known versions are:
+	//
+	// * 1.17 and older: version 1 OR no version at all, depending on patch release
+	// * 1.18+: version 5
+	//
+	// 2, 3, and 4 were intentionally skipped to allow for the (unlikely) event we need to insert
+	// another version between these
+	ControllerVersion = 5
+)
+
+// ManagedGatewayControllerVersion determines the version of the controller managing this Gateway,
+// and if we should manage this.
+// See ControllerVersionAnnotation for motivations.
+func ManagedGatewayControllerVersion(gw gateway.Gateway) (existing string, takeOver bool, manage bool) {
+	cur, f := gw.Annotations[ControllerVersionAnnotation]
+	if !f {
+		// No current owner, we should take it over.
+		return "", true, true
+	}
+	curNum, err := strconv.Atoi(cur)
+	if err != nil {
+		// We cannot parse it - must be some new schema we don't know about. We should assume we do not manage it.
+		// In theory, this should never happen, unless we decide a number was a bad idea in the future.
+		return cur, false, false
+	}
+	if curNum > ControllerVersion {
+		// A newer version owns this gateway, let them handle it
+		return cur, false, false
+	}
+	if curNum == ControllerVersion {
+		// We already manage this at this version
+		// We will manage it, but no need to attempt to apply the version annotation, which could race with newer versions
+		return cur, false, true
+	}
+	// We are either newer or the same version of the last owner - we can take over. We need to actually
+	// re-apply the annotation
+	return cur, true, true
+}
+
+type derivedInput struct {
+	TemplateInput
+
+	// Inserted from injection config
+	ProxyImage  string
+	ProxyConfig *meshapi.ProxyConfig
+	MeshConfig  *meshapi.MeshConfig
+	Values      map[string]any
+}
+
+func (d *DeploymentController) render(templateName string, mi TemplateInput) ([]string, error) {
+	cfg := d.injectConfig()
+
+	template := cfg.Templates[templateName]
+	if template == nil {
+		return nil, fmt.Errorf("no %q template defined", templateName)
+	}
+
+	var templateOverlays []map[string]string
+
+	classConfigs := d.configMaps.List(d.systemNamespace, klabels.SelectorFromValidatedSet(map[string]string{
+		gatewayClassDefaults: string(mi.Spec.GatewayClassName),
+	}))
+	if len(classConfigs) > 0 {
+		classConfig := controllers.OldestObject(classConfigs)
+		templateOverlays = append(templateOverlays, classConfig.Data)
+	}
+	params, err := fetchParameters(mi.Gateway)
+	if err != nil {
+		return nil, fmt.Errorf("invalid parameters: %v", err)
+	}
+	if params != nil {
+		cm := d.configMaps.Get(params.Name, params.Namespace)
+		if cm == nil {
+			return nil, fmt.Errorf("parametersRef targeting configmap %q, but configmap does not exist", params)
+		}
+		templateOverlays = append(templateOverlays, cm.Data)
+	}
+
+	labelToMatch := map[string]string{label.IoK8sNetworkingGatewayGatewayName.Name: mi.Name}
+	proxyConfig := d.env.GetProxyConfigOrDefault(mi.Namespace, labelToMatch, nil, cfg.MeshConfig)
+	input := derivedInput{
+		TemplateInput: mi,
+		ProxyImage: inject.ProxyImage(
+			cfg.Values.Struct(),
+			proxyConfig.GetImage(),
+			mi.Annotations,
+		),
+		ProxyConfig: proxyConfig,
+		MeshConfig:  cfg.MeshConfig,
+		Values:      cfg.Values.Map(),
+	}
+	results, err := tmpl.Execute(template, input)
+	if err != nil {
+		return nil, err
+	}
+
+	rawOutput := yml.SplitString(results)
+	transformedOutput := make([]string, 0, len(rawOutput))
+	for _, output := range rawOutput {
+		to, err := applyOverlay(output, templateOverlays)
+		if err != nil {
+			return nil, err
+		}
+		if to != "" {
+			transformedOutput = append(transformedOutput, to)
+		}
+	}
+	return transformedOutput, nil
+}
+
+var supportedOverlays = sets.New(
+	"deployment",
+	"service",
+	"serviceAccount",
+	"horizontalPodAutoscaler",
+	"podDisruptionBudget",
+)
+
+var requiredOverlays = sets.New(
+	"horizontalPodAutoscaler",
+	"podDisruptionBudget",
+)
+
+func applyOverlay(object string, overlaysList []map[string]string) (string, error) {
+	var ik crd.IstioKind
+	if err := yaml.Unmarshal([]byte(object), &ik); err != nil {
+		return "", fmt.Errorf("failed to find kind: %v", err)
+	}
+	gv, err := schema.ParseGroupVersion(ik.TypeMeta.APIVersion)
+	if err != nil {
+		return "", fmt.Errorf("failed to find kind: %v", err)
+	}
+	kind := &schema.GroupVersionKind{Group: gv.Group, Version: gv.Version, Kind: ik.TypeMeta.Kind}
+
+	var data any
+	var key string
+	switch kind.Kind {
+	case gvk.Deployment.Kind:
+		data = &appsv1.Deployment{}
+		key = "deployment"
+	case gvk.Service.Kind:
+		data = &corev1.Service{}
+		key = "service"
+	case gvk.ServiceAccount.Kind:
+		data = &corev1.ServiceAccount{}
+		key = "serviceAccount"
+	case gvk.HorizontalPodAutoscaler.Kind:
+		data = &autoscalingv2.HorizontalPodAutoscaler{}
+		key = "horizontalPodAutoscaler"
+	case gvk.PodDisruptionBudget.Kind:
+		data = &policyv1.PodDisruptionBudget{}
+		key = "podDisruptionBudget"
+	default:
+		return "", fmt.Errorf("unknown overlay kind %q", kind.Kind)
+	}
+	applied := false
+	for _, overlays := range overlaysList {
+		for k := range overlays {
+			if !supportedOverlays.Contains(k) {
+				return "", fmt.Errorf("unsupported overlay %q (supported: %v)", k, sets.SortedList(supportedOverlays))
+			}
+		}
+		overlay, f := overlays[key]
+		if !f {
+			continue
+		}
+		b, err := strategicMergePatchYAML([]byte(object), []byte(overlay), data)
+		if err != nil {
+			return "", fmt.Errorf("strategic merge patch failed: %v", err)
+		}
+		applied = true
+		object = string(b)
+	}
+	if !applied && requiredOverlays.Contains(key) {
+		return "", nil
+	}
+
+	var finalIK crd.IstioKind
+	if err := yaml.Unmarshal([]byte(object), &finalIK); err != nil {
+		return "", fmt.Errorf("failed to find final kind: %v", err)
+	}
+
+	a, b := ik.ObjectMeta, finalIK.ObjectMeta
+	if !(a.Name == b.Name &&
+		a.GenerateName == b.GenerateName &&
+		a.Namespace == b.Namespace &&
+		a.UID == b.UID &&
+		a.ResourceVersion == b.ResourceVersion &&
+		a.Generation == b.Generation &&
+		a.CreationTimestamp == b.CreationTimestamp &&
+		a.DeletionTimestamp == b.DeletionTimestamp &&
+		a.DeletionGracePeriodSeconds == b.DeletionGracePeriodSeconds &&
+		reflect.DeepEqual(a.OwnerReferences, b.OwnerReferences) &&
+		slices.Equal(a.Finalizers, b.Finalizers)) {
+		return "", fmt.Errorf("illegal metadata change")
+	}
+	// We could deep equal here but its a bit more tedious, so just never allow setting it
+	if len(a.ManagedFields) != 0 || len(b.ManagedFields) != 0 {
+		return "", fmt.Errorf("illegal metadata change")
+	}
+
+	return object, nil
+}
+
+// fetchParameters returns the infrastructure parameters for the Gateway. This is currently always a local configmap so we return the name only.
+// An error is returned if the parameter is invalid. This does not check the configmap exists, though.
+// If no parameter is specified, no name or error is returned.
+func fetchParameters(gw *gateway.Gateway) (*types.NamespacedName, error) {
+	if gw.Spec.Infrastructure != nil && gw.Spec.Infrastructure.ParametersRef != nil {
+		pr := gw.Spec.Infrastructure.ParametersRef
+		if string(pr.Kind) == gvk.ConfigMap.Kind && string(pr.Group) == gvk.ConfigMap.Group {
+			return &types.NamespacedName{
+				Namespace: gw.Namespace,
+				Name:      pr.Name,
+			}, nil
+		}
+		return nil, fmt.Errorf("unknown infrastructure parameters type %v/%v", pr.Group, pr.Kind)
+	}
+	return nil, nil
+}
+
+func (d *DeploymentController) setGatewayControllerVersion(gws gateway.Gateway) error {
+	patch := fmt.Sprintf(`{"apiVersion":"gateway.networking.k8s.io/v1beta1","kind":"Gateway","metadata":{"annotations":{"%s":"%d"}}}`,
+		ControllerVersionAnnotation, ControllerVersion)
+
+	log.Debugf("applying %v", patch)
+	// Use status RBAC so we do not require full Gateway write.
+	// `status` write can modify annotations, and we already need to write status anyway so we have the permission.
+	return d.patcher(gvr.KubernetesGateway, gws.GetName(), gws.GetNamespace(), []byte(patch), "status")
+}
+
+// apply server-side applies a template to the cluster.
+func (d *DeploymentController) apply(controller string, yml string) error {
+	data := map[string]any{}
+	err := yaml.Unmarshal([]byte(yml), &data)
+	if err != nil {
+		return err
+	}
+	us := unstructured.Unstructured{Object: data}
+	// set managed-by label
+	clabel := strings.ReplaceAll(controller, "/", "-")
+	err = unstructured.SetNestedField(us.Object, clabel, "metadata", "labels", label.GatewayManaged.Name)
+	if err != nil {
+		return err
+	}
+	gvr, err := controllers.UnstructuredToGVR(us)
+	if err != nil {
+		return err
+	}
+
+	canManage, resourceVersion := d.canManage(gvr, us.GetName(), us.GetNamespace())
+	if !canManage {
+		log.Debugf("skipping %v/%v/%v, already managed", gvr, us.GetName(), us.GetNamespace())
+		return nil
+	}
+	// Ensure our canManage assertion is not stale
+	us.SetResourceVersion(resourceVersion)
+
+	// Because in 1.24 we removed old label "istio.io/gateway-name", in order to not mutate the deployment.spec.Selector during upgrade.
+	// we always use the old `selector` value
+	if gvr.Resource == "deployments" {
+		deployment := d.deployments.Get(us.GetName(), us.GetNamespace())
+		if deployment != nil && deployment.Spec.Selector.MatchLabels["istio.io/gateway-name"] != "" {
+			us.Object["spec"].(map[string]any)["selector"] = deployment.Spec.Selector
+			// nolint lll
+			us.Object["spec"].(map[string]any)["template"].(map[string]any)["metadata"].(map[string]any)["labels"].(map[string]any)["istio.io/gateway-name"] = deployment.Spec.Template.ObjectMeta.Labels["istio.io/gateway-name"]
+		}
+	}
+
+	j, err := json.Marshal(us.Object)
+	if err != nil {
+		return err
+	}
+	log.Debugf("applying %v", string(j))
+	if err := d.patcher(gvr, us.GetName(), us.GetNamespace(), j); err != nil {
+		return fmt.Errorf("patch %v/%v/%v: %v", us.GroupVersionKind(), us.GetNamespace(), us.GetName(), err)
+	}
+	return nil
+}
+
+func (d *DeploymentController) HandleTagChange(newTags sets.String) {
+	for _, gw := range d.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
+		d.queue.AddObject(gw)
+	}
+}
+
+// canManage checks if a resource we are about to write should be managed by us. If the resource already exists
+// but does not have the ManagedGatewayLabel, we won't overwrite it.
+// This ensures we don't accidentally take over some resource we weren't supposed to, which could cause outages.
+// Note K8s doesn't have a perfect way to "conditionally SSA", but its close enough (https://github.com/kubernetes/kubernetes/issues/116156).
+func (d *DeploymentController) canManage(gvr schema.GroupVersionResource, name, namespace string) (bool, string) {
+	store, f := d.clients[gvr]
+	if !f {
+		log.Warnf("unknown GVR %v", gvr)
+		// Even though we don't know what it is, allow users to put the resource. We won't be able to
+		// protect against overwrites though.
+		return true, ""
+	}
+	obj := store.Get(name, namespace)
+	if obj == nil {
+		// no object, we can manage it
+		return true, ""
+	}
+	_, managed := obj.GetLabels()[label.GatewayManaged.Name]
+	// If object already exists, we can only manage it if it has the label
+	return managed, obj.GetResourceVersion()
+}
+
+type TemplateInput struct {
+	*gateway.Gateway
+	DeploymentName            string
+	ServiceAccount            string
+	Ports                     []corev1.ServicePort
+	ServiceType               corev1.ServiceType
+	ClusterID                 string
+	KubeVersion               int
+	Revision                  string
+	ProxyUID                  int64
+	ProxyGID                  int64
+	CompliancePolicy          string
+	InfrastructureLabels      map[string]string
+	InfrastructureAnnotations map[string]string
+	GatewayNameLabel          string
+}
+
+func extractServicePorts(gw gateway.Gateway) []corev1.ServicePort {
+	tcp := strings.ToLower(string(protocol.TCP))
+	svcPorts := make([]corev1.ServicePort, 0, len(gw.Spec.Listeners)+1)
+	svcPorts = append(svcPorts, corev1.ServicePort{
+		Name:        "status-port",
+		Port:        int32(15021),
+		AppProtocol: &tcp,
+	})
+	portNums := sets.New[int32]()
+	for i, l := range gw.Spec.Listeners {
+		if portNums.Contains(int32(l.Port)) {
+			continue
+		}
+		portNums.Insert(int32(l.Port))
+		name := sanitizeListenerNameForPort(string(l.Name))
+		if name == "" {
+			// Should not happen since name is required, but in case an invalid resource gets in...
+			name = fmt.Sprintf("%s-%d", strings.ToLower(string(l.Protocol)), i)
+		}
+		appProtocol := strings.ToLower(string(l.Protocol))
+		svcPorts = append(svcPorts, corev1.ServicePort{
+			Name:        name,
+			Port:        int32(l.Port),
+			AppProtocol: &appProtocol,
+		})
+	}
+	return svcPorts
+}
+
+// ListenerName allows periods and 253 chars.
+// We map this to service port name which does not allow period and only 63 chars.
+func sanitizeListenerNameForPort(s string) string {
+	// In theory, this mapping can result in a duplicate, but probably not likely
+	s = strings.ReplaceAll(s, ".", "-")
+	if len(s) <= 63 {
+		return s
+	}
+	return s[:63]
+}
+
+// UntypedWrapper wraps a typed reader to an untyped one, since Go cannot do it automatically.
+type UntypedWrapper[T controllers.ComparableObject] struct {
+	reader kclient.Reader[T]
+}
+type getter interface {
+	Get(name, namespace string) controllers.Object
+}
+
+func NewUntypedWrapper[T controllers.ComparableObject](c kclient.Client[T]) getter {
+	return UntypedWrapper[T]{c}
+}
+
+func (u UntypedWrapper[T]) Get(name, namespace string) controllers.Object {
+	// DO NOT return u.reader.Get directly, or we run into issues with https://go.dev/tour/methods/12
+	res := u.reader.Get(name, namespace)
+	if controllers.IsNil(res) {
+		return nil
+	}
+	return res
+}
+
+var _ getter = UntypedWrapper[*corev1.Service]{}
+
+// strategicMergePatchYAML is a small fork of strategicpatch.StrategicMergePatch to allow YAML patches
+// This avoids expensive conversion from YAML to JSON
+func strategicMergePatchYAML(originalYAML []byte, patchYAML []byte, dataStruct any) ([]byte, error) {
+	schema, err := strategicpatch.NewPatchMetaFromStruct(dataStruct)
+	if err != nil {
+		return nil, err
+	}
+
+	originalMap, err := patchHandleUnmarshal(originalYAML)
+	if err != nil {
+		return nil, err
+	}
+	patchMap, err := patchHandleUnmarshal(patchYAML)
+	if err != nil {
+		return nil, err
+	}
+
+	result, err := strategicpatch.StrategicMergeMapPatchUsingLookupPatchMeta(originalMap, patchMap, schema)
+	if err != nil {
+		return nil, err
+	}
+
+	return json.Marshal(result)
+}
+
+func patchHandleUnmarshal(j []byte) (map[string]any, error) {
+	if j == nil {
+		j = []byte("{}")
+	}
+
+	m := map[string]any{}
+	err := yaml.Unmarshal(j, &m)
+	if err != nil {
+		return nil, mergepatch.ErrBadJSONDoc
+	}
+	return m, nil
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go b/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go
new file mode 100644
index 000000000..6dfaaf112
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go
@@ -0,0 +1,683 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"bytes"
+	"fmt"
+	"os"
+	"path/filepath"
+	"testing"
+	"time"
+
+	"go.uber.org/atomic"
+	appsv1 "k8s.io/api/apps/v1"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	kubeVersion "k8s.io/apimachinery/pkg/version"
+	fakediscovery "k8s.io/client-go/discovery/fake"
+	k8s "sigs.k8s.io/gateway-api/apis/v1"
+	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
+	"sigs.k8s.io/yaml"
+
+	"istio.io/api/annotation"
+	"istio.io/api/label"
+	istioio_networking_v1beta1 "istio.io/api/networking/v1beta1"
+	istio_type_v1beta1 "istio.io/api/type/v1beta1"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/test/util"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/mesh"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/gvr"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/inject"
+	"istio.io/istio/pkg/kube/kclient"
+	"istio.io/istio/pkg/kube/kclient/clienttest"
+	"istio.io/istio/pkg/kube/kubetypes"
+	istiolog "istio.io/istio/pkg/log"
+	"istio.io/istio/pkg/revisions"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/env"
+	"istio.io/istio/pkg/test/util/assert"
+	"istio.io/istio/pkg/test/util/file"
+	"istio.io/istio/pkg/test/util/retry"
+)
+
+func TestConfigureIstioGateway(t *testing.T) {
+	discoveryNamespacesFilter := buildFilter("default")
+	defaultNamespace := &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: "default"}}
+	customClass := &k8sbeta.GatewayClass{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: "custom",
+		},
+		Spec: k8s.GatewayClassSpec{
+			ControllerName: k8s.GatewayController(features.ManagedGatewayController),
+		},
+	}
+	upgradeDeployment := &appsv1.Deployment{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      "test-upgrade",
+			Namespace: "default",
+			Labels: map[string]string{
+				"gateway.istio.io/managed": "istio.io-mesh-controller",
+				"istio.io/gateway-name":    "test-upgrade",
+			},
+		},
+		Spec: appsv1.DeploymentSpec{
+			Selector: &metav1.LabelSelector{
+				MatchLabels: map[string]string{
+					"gateway.networking.k8s.io/gateway-name": "test-upgrade",
+					"istio.io/gateway-name":                  "test-upgrade",
+				},
+			},
+			Template: corev1.PodTemplateSpec{
+				ObjectMeta: metav1.ObjectMeta{
+					Labels: map[string]string{
+						"gateway.istio.io/managed":               "istio.io-mesh-controller",
+						"gateway.networking.k8s.io/gateway-name": "test-upgrade",
+						"istio.io/gateway-name":                  "test-upgrade",
+						"istio.io/dataplane-mode":                "none",
+						"service.istio.io/canonical-name":        "test-upgrade",
+						"service.istio.io/canonical-revision":    "latest",
+						"sidecar.istio.io/inject":                "false",
+						"topology.istio.io/network":              "network-1",
+					},
+				},
+			},
+		},
+	}
+
+	defaultObjects := []runtime.Object{defaultNamespace}
+	store := model.NewFakeStore()
+	if _, err := store.Create(config.Config{
+		Meta: config.Meta{
+			GroupVersionKind: gvk.ProxyConfig,
+			Name:             "test",
+			Namespace:        "default",
+		},
+		Spec: &istioio_networking_v1beta1.ProxyConfig{
+			Selector: &istio_type_v1beta1.WorkloadSelector{
+				MatchLabels: map[string]string{
+					label.IoK8sNetworkingGatewayGatewayName.Name: "default",
+				},
+			},
+			Image: &istioio_networking_v1beta1.ProxyImage{
+				ImageType: "distroless",
+			},
+		},
+	}); err != nil {
+		t.Fatalf("failed to create ProxyConfigs: %s", err)
+	}
+	proxyConfig := model.GetProxyConfigs(store, mesh.DefaultMeshConfig())
+	tests := []struct {
+		name                     string
+		gw                       k8sbeta.Gateway
+		objects                  []runtime.Object
+		pcs                      *model.ProxyConfigs
+		values                   string
+		discoveryNamespaceFilter kubetypes.DynamicObjectFilter
+		ignore                   bool
+	}{
+		{
+			name: "simple",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:        "default",
+					Namespace:   "default",
+					Labels:      map[string]string{"should": "see"},
+					Annotations: map[string]string{"should": "see"},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+				},
+			},
+			objects:                  defaultObjects,
+			discoveryNamespaceFilter: discoveryNamespacesFilter,
+		},
+		{
+			name: "simple",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "default",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+				},
+			},
+			objects:                  defaultObjects,
+			discoveryNamespaceFilter: buildFilter("not-default"),
+			ignore:                   true,
+		},
+		{
+			name: "manual-sa",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:        "default",
+					Namespace:   "default",
+					Annotations: map[string]string{annotation.GatewayServiceAccount.Name: "custom-sa"},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+				},
+			},
+			objects:                  defaultObjects,
+			discoveryNamespaceFilter: discoveryNamespacesFilter,
+		},
+		{
+			name: "manual-ip",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:        "default",
+					Namespace:   "default",
+					Annotations: map[string]string{annotation.GatewayNameOverride.Name: "default"},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+					Addresses: []k8s.GatewaySpecAddress{{
+						Type:  func() *k8s.AddressType { x := k8s.IPAddressType; return &x }(),
+						Value: "1.2.3.4",
+					}},
+				},
+			},
+			objects:                  defaultObjects,
+			discoveryNamespaceFilter: discoveryNamespacesFilter,
+		},
+		{
+			name: "cluster-ip",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "default",
+					Namespace: "default",
+					Annotations: map[string]string{
+						"networking.istio.io/service-type":  string(corev1.ServiceTypeClusterIP),
+						annotation.GatewayNameOverride.Name: "default",
+					},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+					Listeners: []k8s.Listener{{
+						Name:     "http",
+						Port:     k8s.PortNumber(80),
+						Protocol: k8s.HTTPProtocolType,
+					}},
+				},
+			},
+			objects:                  defaultObjects,
+			discoveryNamespaceFilter: discoveryNamespacesFilter,
+		},
+		{
+			name: "multinetwork",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:        "default",
+					Namespace:   "default",
+					Labels:      map[string]string{label.TopologyNetwork.Name: "network-1"},
+					Annotations: map[string]string{annotation.GatewayNameOverride.Name: "default"},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+					Listeners: []k8s.Listener{{
+						Name:     "http",
+						Port:     k8s.PortNumber(80),
+						Protocol: k8s.HTTPProtocolType,
+					}},
+				},
+			},
+			objects:                  defaultObjects,
+			discoveryNamespaceFilter: discoveryNamespacesFilter,
+		},
+		{
+			name: "waypoint",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "namespace",
+					Namespace: "default",
+					Labels: map[string]string{
+						label.TopologyNetwork.Name: "network-1", // explicitly set network won't be overwritten
+					},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: constants.WaypointGatewayClassName,
+					Listeners: []k8s.Listener{{
+						Name:     "mesh",
+						Port:     k8s.PortNumber(15008),
+						Protocol: "ALL",
+					}},
+				},
+			},
+			objects: defaultObjects,
+			values: `global:
+  hub: test
+  tag: test
+  network: network-2`,
+		},
+		{
+			name: "waypoint-no-network-label",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "namespace",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: constants.WaypointGatewayClassName,
+					Listeners: []k8s.Listener{{
+						Name:     "mesh",
+						Port:     k8s.PortNumber(15008),
+						Protocol: "ALL",
+					}},
+				},
+			},
+			objects: defaultObjects,
+			values: `global:
+  hub: test
+  tag: test
+  network: network-1`,
+		},
+		{
+			name: "proxy-config-crd",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "default",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+				},
+			},
+			objects: defaultObjects,
+			pcs:     proxyConfig,
+		},
+		{
+			name: "custom-class",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "default",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(customClass.Name),
+				},
+			},
+			objects: defaultObjects,
+		},
+		{
+			name: "infrastructure-labels-annotations",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:        "default",
+					Namespace:   "default",
+					Labels:      map[string]string{"should-not": "see"},
+					Annotations: map[string]string{"should-not": "see"},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+					Infrastructure: &k8s.GatewayInfrastructure{
+						Labels:      map[k8s.LabelKey]k8s.LabelValue{"foo": "bar", "gateway.networking.k8s.io/ignore": "true"},
+						Annotations: map[k8s.AnnotationKey]k8s.AnnotationValue{"fizz": "buzz", "gateway.networking.k8s.io/ignore": "true"},
+					},
+				},
+			},
+			objects: defaultObjects,
+		},
+		{
+			name: "kube-gateway-ambient-redirect",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "default",
+					Namespace: "default",
+					// TODO why are we setting this on gateways?
+					Labels: map[string]string{
+						label.IoIstioDataplaneMode.Name: constants.DataplaneModeAmbient,
+					},
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+				},
+			},
+			objects: defaultObjects,
+		},
+		{
+			name: "kube-gateway-ambient-redirect-infra",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "default",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+					Infrastructure: &k8s.GatewayInfrastructure{
+						Labels: map[k8s.LabelKey]k8s.LabelValue{
+							k8s.LabelKey(label.IoIstioDataplaneMode.Name): constants.DataplaneModeAmbient,
+						},
+					},
+				},
+			},
+			objects: defaultObjects,
+		},
+		{
+			name: "istio-upgrade-to-1.24",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-upgrade",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: constants.WaypointGatewayClassName,
+					Listeners: []k8s.Listener{{
+						Name:     "mesh",
+						Port:     k8s.PortNumber(15008),
+						Protocol: "ALL",
+					}},
+				},
+			},
+			objects: defaultObjects,
+			values: `global:
+  hub: test
+  tag: test
+  network: network-1`,
+		},
+		{
+			name: "customizations",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "namespace",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+					Infrastructure: &k8s.GatewayInfrastructure{
+						Labels: map[k8s.LabelKey]k8s.LabelValue{"foo": "bar"},
+						ParametersRef: &k8s.LocalParametersReference{
+							Group: "",
+							Kind:  "ConfigMap",
+							Name:  "gw-options",
+						},
+					},
+				},
+			},
+			objects: append(slices.Clone(defaultObjects), &corev1.ConfigMap{
+				ObjectMeta: metav1.ObjectMeta{Name: "gw-options", Namespace: "default"},
+				Data: map[string]string{
+					"podDisruptionBudget": `
+spec:
+  minAvailable: 1`,
+					"horizontalPodAutoscaler": `
+spec:
+  minReplicas: 2
+  maxReplicas: 2`,
+					"deployment": `
+metadata:
+  annotations:
+    cm-annotation: cm-annotation-value
+spec:
+  replicas: 4
+  template:
+    spec:
+      containers:
+      - name: istio-proxy
+        resources:
+          requests:
+            cpu: 222m`,
+				},
+			}),
+			values: ``,
+		},
+		{
+			name: "illegal_customizations",
+			gw: k8sbeta.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "namespace",
+					Namespace: "default",
+				},
+				Spec: k8s.GatewaySpec{
+					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+					Infrastructure: &k8s.GatewayInfrastructure{
+						Labels: map[k8s.LabelKey]k8s.LabelValue{"foo": "bar"},
+						ParametersRef: &k8s.LocalParametersReference{
+							Group: "",
+							Kind:  "ConfigMap",
+							Name:  "gw-options",
+						},
+					},
+				},
+			},
+			objects: append(slices.Clone(defaultObjects), &corev1.ConfigMap{
+				ObjectMeta: metav1.ObjectMeta{Name: "gw-options", Namespace: "default"},
+				Data: map[string]string{
+					"deployment": `
+metadata:
+  name: not-allowed`,
+				},
+			}),
+			values: ``,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			buf := &bytes.Buffer{}
+			client := kube.NewFakeClient(tt.objects...)
+			kube.SetObjectFilter(client, tt.discoveryNamespaceFilter)
+			client.Kube().Discovery().(*fakediscovery.FakeDiscovery).FakedServerVersion = &kubeVersion.Info{Major: "1", Minor: "28"}
+			kclient.NewWriteClient[*k8sbeta.GatewayClass](client).Create(customClass)
+			kclient.NewWriteClient[*k8sbeta.Gateway](client).Create(tt.gw.DeepCopy())
+			kclient.NewWriteClient[*appsv1.Deployment](client).Create(upgradeDeployment)
+			stop := test.NewStop(t)
+			env := model.NewEnvironment()
+			env.PushContext().ProxyConfigs = tt.pcs
+			tw := revisions.NewTagWatcher(client, "")
+			go tw.Run(stop)
+			d := NewDeploymentController(client, cluster.ID(features.ClusterName), env, testInjectionConfig(t, tt.values), func(fn func()) {
+			}, tw, "", "")
+			d.patcher = func(gvr schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error {
+				b, err := yaml.JSONToYAML(data)
+				if err != nil {
+					return err
+				}
+				buf.Write(b)
+				buf.WriteString("---\n")
+				return nil
+			}
+			client.RunAndWait(stop)
+			go d.Run(stop)
+			kube.WaitForCacheSync("test", stop, d.queue.HasSynced)
+
+			if tt.ignore {
+				assert.Equal(t, buf.String(), "")
+			} else {
+				resp := timestampRegex.ReplaceAll(buf.Bytes(), []byte("lastTransitionTime: fake"))
+				if util.Refresh() {
+					if err := os.WriteFile(filepath.Join("testdata", "deployment", tt.name+".yaml"), resp, 0o644); err != nil {
+						t.Fatal(err)
+					}
+				}
+				util.CompareContent(t, resp, filepath.Join("testdata", "deployment", tt.name+".yaml"))
+			}
+			// ensure we didn't mutate the object
+			if !tt.ignore {
+				assert.Equal(t, d.gateways.Get(tt.gw.Name, tt.gw.Namespace), &tt.gw)
+			}
+		})
+	}
+}
+
+func buildFilter(allowedNamespace string) kubetypes.DynamicObjectFilter {
+	return kubetypes.NewStaticObjectFilter(func(obj any) bool {
+		if ns, ok := obj.(string); ok {
+			return ns == allowedNamespace
+		}
+		object := controllers.ExtractObject(obj)
+		if object == nil {
+			return false
+		}
+		ns := object.GetNamespace()
+		if _, ok := object.(*corev1.Namespace); ok {
+			ns = object.GetName()
+		}
+		return ns == allowedNamespace
+	})
+}
+
+func TestVersionManagement(t *testing.T) {
+	log.SetOutputLevel(istiolog.DebugLevel)
+	writes := make(chan string, 10)
+	c := kube.NewFakeClient(&corev1.Namespace{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: "default",
+		},
+	})
+	tw := revisions.NewTagWatcher(c, "default")
+	env := &model.Environment{}
+	d := NewDeploymentController(c, "", env, testInjectionConfig(t, ""), func(fn func()) {}, tw, "", "")
+	reconciles := atomic.NewInt32(0)
+	wantReconcile := int32(0)
+	expectReconciled := func() {
+		t.Helper()
+		wantReconcile++
+		assert.EventuallyEqual(t, reconciles.Load, wantReconcile, retry.Timeout(time.Second*5), retry.Message("no reconciliation"))
+	}
+
+	d.patcher = func(g schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error {
+		if g == gvr.Service {
+			reconciles.Inc()
+		}
+		if g == gvr.KubernetesGateway {
+			b, err := yaml.JSONToYAML(data)
+			if err != nil {
+				return err
+			}
+			writes <- string(b)
+		}
+		return nil
+	}
+	stop := test.NewStop(t)
+	gws := clienttest.Wrap(t, d.gateways)
+	go tw.Run(stop)
+	go d.Run(stop)
+	c.RunAndWait(stop)
+	kube.WaitForCacheSync("test", stop, d.queue.HasSynced)
+	// Create a gateway, we should mark our ownership
+	defaultGateway := &k8sbeta.Gateway{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      "gw",
+			Namespace: "default",
+		},
+		Spec: k8s.GatewaySpec{
+			GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
+		},
+	}
+	gws.Create(defaultGateway)
+	assert.Equal(t, assert.ChannelHasItem(t, writes), buildPatch(ControllerVersion))
+	expectReconciled()
+	assert.ChannelIsEmpty(t, writes)
+	// Test fake doesn't actual do Apply, so manually do this
+	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(ControllerVersion)}
+	gws.Update(defaultGateway)
+	expectReconciled()
+	// We shouldn't write in response to our write.
+	assert.ChannelIsEmpty(t, writes)
+
+	defaultGateway.Annotations["foo"] = "bar"
+	gws.Update(defaultGateway)
+	expectReconciled()
+	// We should not be updating the version, its already set. Setting it introduces a possible race condition
+	// since we use SSA so there is no conflict checks.
+	assert.ChannelIsEmpty(t, writes)
+
+	// Somehow the annotation is removed - it should be added back
+	defaultGateway.Annotations = map[string]string{}
+	gws.Update(defaultGateway)
+	expectReconciled()
+	assert.Equal(t, assert.ChannelHasItem(t, writes), buildPatch(ControllerVersion))
+	assert.ChannelIsEmpty(t, writes)
+	// Test fake doesn't actual do Apply, so manually do this
+	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(ControllerVersion)}
+	gws.Update(defaultGateway)
+	expectReconciled()
+	// We shouldn't write in response to our write.
+	assert.ChannelIsEmpty(t, writes)
+
+	// Somehow the annotation is set to an older version - it should be added back
+	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(1)}
+	gws.Update(defaultGateway)
+	expectReconciled()
+	assert.Equal(t, assert.ChannelHasItem(t, writes), buildPatch(ControllerVersion))
+	assert.ChannelIsEmpty(t, writes)
+	// Test fake doesn't actual do Apply, so manually do this
+	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(ControllerVersion)}
+	gws.Update(defaultGateway)
+	expectReconciled()
+	// We shouldn't write in response to our write.
+	assert.ChannelIsEmpty(t, writes)
+
+	// Somehow the annotation is set to an new version - we should do nothing
+	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(10)}
+	gws.Update(defaultGateway)
+	assert.ChannelIsEmpty(t, writes)
+	// Do not expect reconcile
+	assert.Equal(t, reconciles.Load(), wantReconcile)
+}
+
+func testInjectionConfig(t test.Failer, values string) func() inject.WebhookConfig {
+	var vc inject.ValuesConfig
+	var err error
+	if values != "" {
+		vc, err = inject.NewValuesConfig(values)
+		if err != nil {
+			t.Fatal(err)
+		}
+	} else {
+		vc, err = inject.NewValuesConfig(`
+global:
+  hub: test
+  tag: test`)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+	}
+	tmpl, err := inject.ParseTemplates(map[string]string{
+		"kube-gateway": file.AsStringOrFail(t, filepath.Join(env.IstioSrc, "manifests/charts/istio-control/istio-discovery/files/kube-gateway.yaml")),
+		"waypoint":     file.AsStringOrFail(t, filepath.Join(env.IstioSrc, "manifests/charts/istio-control/istio-discovery/files/waypoint.yaml")),
+	})
+	if err != nil {
+		t.Fatal(err)
+	}
+	injConfig := func() inject.WebhookConfig {
+		return inject.WebhookConfig{
+			Templates:  tmpl,
+			Values:     vc,
+			MeshConfig: mesh.DefaultMeshConfig(),
+		}
+	}
+	return injConfig
+}
+
+func buildPatch(version int) string {
+	return fmt.Sprintf(`apiVersion: gateway.networking.k8s.io/v1beta1
+kind: Gateway
+metadata:
+  annotations:
+    gateway.istio.io/controller-version: "%d"
+`, version)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
new file mode 100644
index 000000000..1766584e8
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
@@ -0,0 +1,294 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"strings"
+
+	"go.uber.org/atomic"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/types"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	istio "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	kubeconfig "istio.io/istio/pkg/config/gateway/kube"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/revisions"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/workloadapi"
+)
+
+func toResourcep(gw types.NamespacedName, t any) *model.ADPResource {
+	res := toResource(gw, t)
+	return &res
+}
+
+func toResource(gw types.NamespacedName, t any) model.ADPResource {
+	switch tt := t.(type) {
+	case Bind:
+		return model.ADPResource{Resource: &workloadapi.Resource{Kind: &workloadapi.Resource_Bind{tt.Bind}}, Gateway: gw}
+	case ADPListener:
+		return model.ADPResource{Resource: &workloadapi.Resource{Kind: &workloadapi.Resource_Listener{tt.Listener}}, Gateway: gw}
+	case ADPRoute:
+		return model.ADPResource{Resource: &workloadapi.Resource{Kind: &workloadapi.Resource_Route{tt.Route}}, Gateway: gw}
+	}
+	panic("unknown resource kind")
+}
+
+// TODO: we need some way to associate this to a specific instance of the proxy!!
+type Bind struct {
+	*workloadapi.Bind
+}
+
+func (g Bind) ResourceName() string {
+	return g.Key
+}
+
+func (g Bind) Equals(other Bind) bool {
+	return protoconv.Equals(g, other)
+}
+
+type ADPListener struct {
+	*workloadapi.Listener
+}
+
+func (g ADPListener) ResourceName() string {
+	return g.Key
+}
+
+func (g ADPListener) Equals(other ADPListener) bool {
+	return protoconv.Equals(g, other)
+}
+
+type ADPRoute struct {
+	*workloadapi.Route
+}
+
+func (g ADPRoute) ResourceName() string {
+	return g.Key
+}
+
+func (g ADPRoute) Equals(other ADPRoute) bool {
+	return protoconv.Equals(g, other)
+}
+
+type TLSInfo struct {
+	Cert []byte
+	Key  []byte `json:"-"`
+}
+
+type Gateway struct {
+	*config.Config
+	parent     parentKey
+	parentInfo parentInfo
+	TLSInfo    *TLSInfo
+	Valid      bool
+}
+
+func (g Gateway) ResourceName() string {
+	return config.NamespacedName(g.Config).Name
+}
+
+func (g Gateway) Equals(other Gateway) bool {
+	return g.Config.Equals(other.Config) &&
+		g.Valid == other.Valid // TODO: ok to ignore parent/parentInfo?
+}
+
+func GatewayCollection(
+	gateways krt.Collection[*gateway.Gateway],
+	gatewayClasses krt.Collection[GatewayClass],
+	namespaces krt.Collection[*corev1.Namespace],
+	grants ReferenceGrants,
+	secrets krt.Collection[*corev1.Secret],
+	domainSuffix string,
+	gatewayContext krt.RecomputeProtected[*atomic.Pointer[GatewayContext]],
+	tagWatcher krt.RecomputeProtected[revisions.TagWatcher],
+	opts krt.OptionsBuilder,
+) (
+	krt.StatusCollection[*gateway.Gateway, gateway.GatewayStatus],
+	krt.Collection[Gateway],
+) {
+	statusCol, gw := krt.NewStatusManyCollection(gateways, func(ctx krt.HandlerContext, obj *gateway.Gateway) (*gateway.GatewayStatus, []Gateway) {
+		// We currently depend on service discovery information not know to krt; mark we depend on it.
+		context := gatewayContext.Get(ctx).Load()
+		if context == nil {
+			return nil, nil
+		}
+		if !tagWatcher.Get(ctx).IsMine(obj.ObjectMeta) {
+			return nil, nil
+		}
+		result := []Gateway{}
+		kgw := obj.Spec
+		status := obj.Status.DeepCopy()
+		class := fetchClass(ctx, gatewayClasses, kgw.GatewayClassName)
+		if class == nil {
+			return nil, nil
+		}
+		controllerName := class.Controller
+		classInfo, f := classInfos[controllerName]
+		if !f {
+			return nil, nil
+		}
+		if classInfo.disableRouteGeneration {
+			reportUnmanagedGatewayStatus(status, obj)
+			// We found it, but don't want to handle this class
+			return status, nil
+		}
+		servers := []*istio.Server{}
+
+		// Extract the addresses. A gateway will bind to a specific Service
+		gatewayServices, err := extractGatewayServices(domainSuffix, obj, classInfo)
+		if len(gatewayServices) == 0 && err != nil {
+			// Short circuit if its a hard failure
+			reportGatewayStatus(context, obj, status, classInfo, gatewayServices, servers, err)
+			return status, nil
+		}
+
+		for i, l := range kgw.Listeners {
+			server, tlsInfo, programmed := buildListener(ctx, secrets, grants, namespaces, obj, status, l, i, controllerName)
+
+			servers = append(servers, server)
+			if controllerName == constants.ManagedGatewayMeshController {
+				// Waypoint doesn't actually convert the routes to VirtualServices
+				continue
+			}
+			meta := parentMeta(obj, &l.Name)
+			meta[constants.InternalGatewaySemantics] = constants.GatewaySemanticsGateway
+			meta[model.InternalGatewayServiceAnnotation] = strings.Join(gatewayServices, ",")
+
+			// Each listener generates an Istio Gateway with a single Server. This allows binding to a specific listener.
+			gatewayConfig := config.Config{
+				Meta: config.Meta{
+					CreationTimestamp: obj.CreationTimestamp.Time,
+					GroupVersionKind:  gvk.Gateway,
+					Name:              kubeconfig.InternalGatewayName(obj.Name, string(l.Name)),
+					Annotations:       meta,
+					Namespace:         obj.Namespace,
+					Domain:            domainSuffix,
+				},
+				Spec: &istio.Gateway{
+					Servers: []*istio.Server{server},
+				},
+			}
+
+			allowed, _ := generateSupportedKinds(l)
+			ref := parentKey{
+				Kind:      gvk.KubernetesGateway,
+				Name:      obj.Name,
+				Namespace: obj.Namespace,
+			}
+			pri := parentInfo{
+				InternalName:     obj.Namespace + "/" + gatewayConfig.Name,
+				AllowedKinds:     allowed,
+				Hostnames:        server.Hosts,
+				OriginalHostname: string(ptr.OrEmpty(l.Hostname)),
+				SectionName:      l.Name,
+				Port:             l.Port,
+				Protocol:         l.Protocol,
+			}
+
+			res := Gateway{
+				Config:     &gatewayConfig,
+				Valid:      programmed,
+				TLSInfo:    tlsInfo,
+				parent:     ref,
+				parentInfo: pri,
+			}
+			result = append(result, res)
+		}
+
+		reportGatewayStatus(context, obj, status, classInfo, gatewayServices, servers, err)
+		return status, result
+	}, opts.WithName("KubernetesGateway")...)
+
+	return statusCol, gw
+}
+
+var count = atomic.NewInt64(0)
+
+// FinalGatewayStatusCollection finalizes a Gateway status. There is a circular logic between Gateways and Routes to determine
+// the attachedRoute count, so we first build a partial Gateway status, then once routes are computed we finalize it with
+// the attachedRoute count.
+func FinalGatewayStatusCollection(
+	gatewayStatuses krt.StatusCollection[*gateway.Gateway, gateway.GatewayStatus],
+	routeAttachments krt.Collection[*RouteAttachment],
+	routeAttachmentsIndex krt.Index[GatewayAndListener, *RouteAttachment],
+	opts krt.OptionsBuilder,
+) krt.StatusCollection[*gateway.Gateway, gateway.GatewayStatus] {
+	return krt.NewCollection(
+		gatewayStatuses,
+		func(ctx krt.HandlerContext, i krt.ObjectWithStatus[*gateway.Gateway, gateway.GatewayStatus]) *krt.ObjectWithStatus[*gateway.Gateway, gateway.GatewayStatus] {
+			gw := config.NamespacedName(i.Obj)
+			counts := map[string]int32{}
+			for _, l := range i.Obj.Spec.Listeners {
+				routes := krt.FetchCount(ctx, routeAttachments, krt.FilterIndex(routeAttachmentsIndex, GatewayAndListener{To: gw, ListenerName: string(l.Name)}))
+				counts[string(l.Name)] += int32(routes)
+			}
+			status := i.Status.DeepCopy()
+			for i, s := range status.Listeners {
+				s.AttachedRoutes = counts[string(s.Name)]
+				status.Listeners[i] = s
+			}
+			return &krt.ObjectWithStatus[*gateway.Gateway, gateway.GatewayStatus]{
+				Obj:    i.Obj,
+				Status: *status,
+			}
+		}, opts.WithName("GatewayFinalStatus")...)
+}
+
+// RouteParents holds information about things routes can reference as parents.
+type RouteParents struct {
+	gateways     krt.Collection[Gateway]
+	gatewayIndex krt.Index[parentKey, Gateway]
+}
+
+func (p RouteParents) fetch(ctx krt.HandlerContext, pk parentKey) []*parentInfo {
+	if pk == meshParentKey {
+		// Special case
+		return []*parentInfo{
+			{
+				InternalName: "mesh",
+				// Mesh has no configurable AllowedKinds, so allow all supported
+				AllowedKinds: []gateway.RouteGroupKind{
+					{Group: (*gateway.Group)(ptr.Of(gvk.HTTPRoute.Group)), Kind: gateway.Kind(gvk.HTTPRoute.Kind)},
+					{Group: (*gateway.Group)(ptr.Of(gvk.GRPCRoute.Group)), Kind: gateway.Kind(gvk.GRPCRoute.Kind)},
+					{Group: (*gateway.Group)(ptr.Of(gvk.TCPRoute.Group)), Kind: gateway.Kind(gvk.TCPRoute.Kind)},
+					{Group: (*gateway.Group)(ptr.Of(gvk.TLSRoute.Group)), Kind: gateway.Kind(gvk.TLSRoute.Kind)},
+				},
+			},
+		}
+	}
+	return slices.Map(krt.Fetch(ctx, p.gateways, krt.FilterIndex(p.gatewayIndex, pk)), func(gw Gateway) *parentInfo {
+		return &gw.parentInfo
+	})
+}
+
+func BuildRouteParents(
+	gateways krt.Collection[Gateway],
+) RouteParents {
+	idx := krt.NewIndex(gateways, func(o Gateway) []parentKey {
+		return []parentKey{o.parent}
+	})
+	return RouteParents{
+		gateways:     gateways,
+		gatewayIndex: idx,
+	}
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go
new file mode 100644
index 000000000..da5e4c603
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go
@@ -0,0 +1,118 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"github.com/hashicorp/go-multierror"
+	kerrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	k8sv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"istio.io/istio/pilot/pkg/model/kstatus"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/kclient"
+	"istio.io/istio/pkg/util/istiomultierror"
+)
+
+// ClassController is a controller that creates the default Istio GatewayClass(s). This will not
+// continually reconcile the full state of the GatewayClass object, and instead only create the class
+// if it doesn't exist. This allows users to manage it through other means or modify it as they wish.
+// If it is deleted, however, it will be added back.
+// This controller intentionally does not do leader election for simplicity. Because we only create
+// and not update there is no need; the first controller to create the GatewayClass wins.
+type ClassController struct {
+	queue   controllers.Queue
+	classes kclient.Client[*gateway.GatewayClass]
+}
+
+func NewClassController(kc kube.Client) *ClassController {
+	gc := &ClassController{}
+	gc.queue = controllers.NewQueue("gateway class",
+		controllers.WithReconciler(gc.Reconcile),
+		controllers.WithMaxAttempts(25))
+
+	gc.classes = kclient.New[*gateway.GatewayClass](kc)
+	gc.classes.AddEventHandler(controllers.FilteredObjectHandler(gc.queue.AddObject, func(o controllers.Object) bool {
+		_, f := builtinClasses[gateway.ObjectName(o.GetName())]
+		return f
+	}))
+	return gc
+}
+
+func (c *ClassController) Run(stop <-chan struct{}) {
+	// Ensure we initially reconcile the current state
+	c.queue.Add(types.NamespacedName{})
+	c.queue.Run(stop)
+}
+
+func (c *ClassController) Reconcile(types.NamespacedName) error {
+	err := istiomultierror.New()
+	for class := range builtinClasses {
+		err = multierror.Append(err, c.reconcileClass(class))
+	}
+	return err.ErrorOrNil()
+}
+
+func (c *ClassController) reconcileClass(class gateway.ObjectName) error {
+	if c.classes.Get(string(class), "") != nil {
+		log.Debugf("GatewayClass/%v already exists, no action", class)
+		return nil
+	}
+	controller := builtinClasses[class]
+	classInfo, f := classInfos[controller]
+	if !f {
+		// Should only happen when ambient is disabled; otherwise builtinClasses and classInfos should be consistent
+		return nil
+	}
+	gc := &gateway.GatewayClass{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: string(class),
+		},
+		Spec: gateway.GatewayClassSpec{
+			ControllerName: gateway.GatewayController(classInfo.controller),
+			Description:    &classInfo.description,
+		},
+	}
+	_, err := c.classes.Create(gc)
+	if err != nil && !kerrors.IsConflict(err) {
+		return err
+	} else if err != nil && kerrors.IsConflict(err) {
+		// This is not really an error, just a race condition
+		log.Infof("Attempted to create GatewayClass/%v, but it was already created", class)
+	}
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
+func GetClassStatus(existing *k8sv1.GatewayClassStatus, gen int64) k8sv1.GatewayClassStatus {
+	if existing == nil {
+		existing = &k8sv1.GatewayClassStatus{}
+	}
+	existing.Conditions = kstatus.UpdateConditionIfChanged(existing.Conditions, metav1.Condition{
+		Type:               string(k8sv1.GatewayClassConditionStatusAccepted),
+		Status:             kstatus.StatusTrue,
+		ObservedGeneration: gen,
+		LastTransitionTime: metav1.Now(),
+		Reason:             string(k8sv1.GatewayClassConditionStatusAccepted),
+		Message:            "Handled by Istio controller",
+	})
+	return *existing
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
new file mode 100644
index 000000000..cf18f5726
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
@@ -0,0 +1,67 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"istio.io/istio/pkg/kube/krt"
+)
+
+type GatewayClass struct {
+	Name       string
+	Controller gateway.GatewayController
+}
+
+func (g GatewayClass) ResourceName() string {
+	return g.Name
+}
+
+func GatewayClassesCollection(
+	gatewayClasses krt.Collection[*gateway.GatewayClass],
+	opts krt.OptionsBuilder,
+) (
+	krt.StatusCollection[*gateway.GatewayClass, gateway.GatewayClassStatus],
+	krt.Collection[GatewayClass],
+) {
+	return krt.NewStatusCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gateway.GatewayClass) (*gateway.GatewayClassStatus, *GatewayClass) {
+		_, known := classInfos[obj.Spec.ControllerName]
+		if !known {
+			return nil, nil
+		}
+		status := GetClassStatus(&obj.Status, obj.Generation)
+		return &status, &GatewayClass{
+			Name:       obj.Name,
+			Controller: obj.Spec.ControllerName,
+		}
+	}, opts.WithName("GatewayClasses")...)
+}
+
+func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayClass], gc gatewayv1.ObjectName) *GatewayClass {
+	class := krt.FetchOne(ctx, gatewayClasses, krt.FilterKey(string(gc)))
+	if class == nil {
+		if bc, f := builtinClasses[gc]; f {
+			// We allow some classes to exist without being in the cluster
+			return &GatewayClass{
+				Name:       string(gc),
+				Controller: bc,
+			}
+		}
+		// No gateway class found, this may be meant for another controller; should be skipped.
+		return nil
+	}
+	return class
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go
new file mode 100644
index 000000000..90aadb89a
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go
@@ -0,0 +1,93 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"fmt"
+	"testing"
+	"time"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/kclient/clienttest"
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/util/retry"
+)
+
+func TestClassController(t *testing.T) {
+	client := kube.NewFakeClient()
+	cc := NewClassController(client)
+	classes := clienttest.Wrap(t, cc.classes)
+	stop := test.NewStop(t)
+	client.RunAndWait(stop)
+	go cc.Run(stop)
+	createClass := func(name, controller string) {
+		gc := &gateway.GatewayClass{
+			ObjectMeta: metav1.ObjectMeta{
+				Name: name,
+			},
+			Spec: gateway.GatewayClassSpec{
+				ControllerName: gateway.GatewayController(controller),
+			},
+		}
+		classes.CreateOrUpdate(gc)
+	}
+	deleteClass := func(name string) {
+		classes.Delete(name, "")
+	}
+	expectClass := func(name, controller string) {
+		t.Helper()
+		retry.UntilSuccessOrFail(t, func() error {
+			gc := classes.Get(name, "")
+			if controller == "" {
+				if gc == nil { // Expect none, got none
+					return nil
+				}
+				return fmt.Errorf("expected no class, got %v", gc.Spec.ControllerName)
+			}
+			if gc == nil {
+				return fmt.Errorf("expected class %v, got none", controller)
+			}
+			if gateway.GatewayController(controller) != gc.Spec.ControllerName {
+				return fmt.Errorf("expected class %v, got %v", controller, gc.Spec.ControllerName)
+			}
+			return nil
+		}, retry.Timeout(time.Second*3))
+	}
+
+	// Class should be created initially
+	expectClass(features.GatewayAPIDefaultGatewayClass, features.ManagedGatewayController)
+
+	// Once we delete it, it should be added back
+	deleteClass(features.GatewayAPIDefaultGatewayClass)
+	expectClass(features.GatewayAPIDefaultGatewayClass, features.ManagedGatewayController)
+
+	// Overwrite the class, controller should not reconcile it back
+	createClass(features.GatewayAPIDefaultGatewayClass, "different-controller")
+	expectClass(features.GatewayAPIDefaultGatewayClass, "different-controller")
+
+	// Once we delete it, it should be added back
+	deleteClass(features.GatewayAPIDefaultGatewayClass)
+	expectClass(features.GatewayAPIDefaultGatewayClass, features.ManagedGatewayController)
+
+	// Create an unrelated GatewayClass, we should not do anything to it
+	createClass("something-else", "different-controller")
+	expectClass("something-else", "different-controller")
+	deleteClass("something-else")
+	expectClass("something-else", "")
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/leak_test.go b/internal/kgateway/agentgatewaysyncer/gateway/leak_test.go
new file mode 100644
index 000000000..b47fbbea2
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/leak_test.go
@@ -0,0 +1,25 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"testing"
+
+	"istio.io/istio/tests/util/leak"
+)
+
+func TestMain(m *testing.M) {
+	leak.CheckMain(m)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/model.go b/internal/kgateway/agentgatewaysyncer/gateway/model.go
new file mode 100644
index 000000000..c8522d656
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/model.go
@@ -0,0 +1,15 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
new file mode 100644
index 000000000..3924708e8
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
@@ -0,0 +1,164 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"fmt"
+
+	"k8s.io/apimachinery/pkg/types"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	creds "istio.io/istio/pilot/pkg/model/credentials"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/kube/krt"
+)
+
+// Reference stores a reference to a namespaced GVK, as used by ReferencePolicy
+type Reference struct {
+	Kind      config.GroupVersionKind
+	Namespace gateway.Namespace
+}
+
+func (refs Reference) String() string {
+	return refs.Kind.String() + "/" + string(refs.Namespace)
+}
+
+type ReferencePair struct {
+	To, From Reference
+}
+
+func (r ReferencePair) String() string {
+	return fmt.Sprintf("%s->%s", r.To, r.From)
+}
+
+type ReferenceGrants struct {
+	collection krt.Collection[ReferenceGrant]
+	index      krt.Index[ReferencePair, ReferenceGrant]
+}
+
+func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.ReferenceGrant], opts krt.OptionsBuilder) krt.Collection[ReferenceGrant] {
+	return krt.NewManyCollection(referenceGrants, func(ctx krt.HandlerContext, obj *gateway.ReferenceGrant) []ReferenceGrant {
+		rp := obj.Spec
+		results := make([]ReferenceGrant, 0, len(rp.From)*len(rp.To))
+		for _, from := range rp.From {
+			fromKey := Reference{
+				Namespace: from.Namespace,
+			}
+			if string(from.Group) == gvk.KubernetesGateway.Group && string(from.Kind) == gvk.KubernetesGateway.Kind {
+				fromKey.Kind = gvk.KubernetesGateway
+			} else if string(from.Group) == gvk.HTTPRoute.Group && string(from.Kind) == gvk.HTTPRoute.Kind {
+				fromKey.Kind = gvk.HTTPRoute
+			} else if string(from.Group) == gvk.GRPCRoute.Group && string(from.Kind) == gvk.GRPCRoute.Kind {
+				fromKey.Kind = gvk.GRPCRoute
+			} else if string(from.Group) == gvk.TLSRoute.Group && string(from.Kind) == gvk.TLSRoute.Kind {
+				fromKey.Kind = gvk.TLSRoute
+			} else if string(from.Group) == gvk.TCPRoute.Group && string(from.Kind) == gvk.TCPRoute.Kind {
+				fromKey.Kind = gvk.TCPRoute
+			} else {
+				// Not supported type. Not an error; may be for another controller
+				continue
+			}
+			for _, to := range rp.To {
+				toKey := Reference{
+					Namespace: gateway.Namespace(obj.Namespace),
+				}
+				if to.Group == "" && string(to.Kind) == gvk.Secret.Kind {
+					toKey.Kind = gvk.Secret
+				} else if to.Group == "" && string(to.Kind) == gvk.Service.Kind {
+					toKey.Kind = gvk.Service
+				} else {
+					// Not supported type. Not an error; may be for another controller
+					continue
+				}
+				rg := ReferenceGrant{
+					Source:      config.NamespacedName(obj),
+					From:        fromKey,
+					To:          toKey,
+					AllowAll:    false,
+					AllowedName: "",
+				}
+				if to.Name != nil {
+					rg.AllowedName = string(*to.Name)
+				} else {
+					rg.AllowAll = true
+				}
+				results = append(results, rg)
+			}
+		}
+		return results
+	}, opts.WithName("ReferenceGrants")...)
+}
+
+func BuildReferenceGrants(collection krt.Collection[ReferenceGrant]) ReferenceGrants {
+	idx := krt.NewIndex(collection, func(o ReferenceGrant) []ReferencePair {
+		return []ReferencePair{{
+			To:   o.To,
+			From: o.From,
+		}}
+	})
+	return ReferenceGrants{
+		collection: collection,
+		index:      idx,
+	}
+}
+
+type ReferenceGrant struct {
+	Source      types.NamespacedName
+	From        Reference
+	To          Reference
+	AllowAll    bool
+	AllowedName string
+}
+
+func (g ReferenceGrant) ResourceName() string {
+	return g.Source.String() + "/" + g.From.String() + "/" + g.To.String()
+}
+
+func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName string, namespace string) bool {
+	p, err := creds.ParseResourceName(resourceName, "", "", "")
+	if err != nil {
+		log.Warnf("failed to parse resource name %q: %v", resourceName, err)
+		return false
+	}
+	from := Reference{Kind: gvk.KubernetesGateway, Namespace: gateway.Namespace(namespace)}
+	to := Reference{Kind: gvk.Secret, Namespace: gateway.Namespace(p.Namespace)}
+	pair := ReferencePair{From: from, To: to}
+	grants := krt.FetchOrList(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
+	for _, g := range grants {
+		if g.AllowAll || g.AllowedName == p.Name {
+			return true
+		}
+	}
+	return false
+}
+
+func (refs ReferenceGrants) BackendAllowed(ctx krt.HandlerContext,
+	k config.GroupVersionKind,
+	backendName gateway.ObjectName,
+	backendNamespace gateway.Namespace,
+	routeNamespace string,
+) bool {
+	from := Reference{Kind: k, Namespace: gateway.Namespace(routeNamespace)}
+	to := Reference{Kind: gvk.Service, Namespace: backendNamespace}
+	pair := ReferencePair{From: from, To: to}
+	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
+	for _, g := range grants {
+		if g.AllowAll || g.AllowedName == string(backendName) {
+			return true
+		}
+	}
+	return false
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go b/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
new file mode 100644
index 000000000..78baf2560
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
@@ -0,0 +1,686 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"fmt"
+	"iter"
+	"strings"
+
+	"go.uber.org/atomic"
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/types"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	istio "istio.io/api/networking/v1alpha3"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pilot/pkg/model"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/protomarshal"
+)
+
+func HTTPRouteCollection(
+	httpRoutes krt.Collection[*gateway.HTTPRoute],
+	inputs RouteContextInputs,
+	opts krt.OptionsBuilder,
+) RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus] {
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, httpRoutes, gvk.HTTPRoute, opts)
+	status, baseVirtualServices := krt.NewStatusManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) (
+		*gateway.HTTPRouteStatus,
+		[]RouteWithKey,
+	) {
+		ctx := inputs.WithCtx(krtctx)
+		status := obj.Status.DeepCopy()
+		route := obj.Spec
+		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx, obj, func(mesh bool, obj *gateway.HTTPRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
+			return func(yield func(*istio.HTTPRoute, *ConfigError) bool) {
+				for n, r := range route.Rules {
+					// split the rule to make sure each rule has up to one match
+					matches := slices.Reference(r.Matches)
+					if len(matches) == 0 {
+						matches = append(matches, nil)
+					}
+					for _, m := range matches {
+						if m != nil {
+							r.Matches = []gateway.HTTPRouteMatch{*m}
+						}
+						if !yield(convertHTTPRoute(ctx, r, obj, n, !mesh)) {
+							return
+						}
+					}
+				}
+			}
+		})
+		status.Parents = parentStatus
+
+		count := 0
+		virtualServices := []RouteWithKey{}
+		for _, parent := range filteredReferences(parentRefs) {
+			// for gateway routes, build one VS per gateway+host
+			routeKey := parent.InternalName
+			vsHosts := hostnameToStringList(route.Hostnames)
+			routes := gwResult.routes
+			if parent.IsMesh() {
+				routes = meshResult.routes
+				// for mesh routes, build one VS per namespace/port->host
+				routeKey = obj.Namespace
+				if parent.OriginalReference.Port != nil {
+					routes = augmentPortMatch(routes, *parent.OriginalReference.Port)
+					routeKey += fmt.Sprintf("/%d", *parent.OriginalReference.Port)
+				}
+				ref := types.NamespacedName{
+					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
+					Name:      string(parent.OriginalReference.Name),
+				}
+				if parent.InternalKind == gvk.ServiceEntry {
+					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
+					if ses != nil {
+						vsHosts = ses.Spec.Hosts
+					} else {
+						// TODO: report an error
+						vsHosts = []string{}
+					}
+				} else {
+					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s",
+						parent.OriginalReference.Name, ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace)), ctx.DomainSuffix)}
+				}
+			}
+			if len(routes) == 0 {
+				continue
+			}
+			// Create one VS per hostname with a single hostname.
+			// This ensures we can treat each hostname independently, as the spec requires
+			for _, h := range vsHosts {
+				if !parent.hostnameAllowedByIsolation(h) {
+					// TODO: standardize a status message for this upstream and report
+					continue
+				}
+				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, constants.KubernetesGatewayName)
+				sortHTTPRoutes(routes)
+				cfg := &config.Config{
+					Meta: config.Meta{
+						CreationTimestamp: obj.CreationTimestamp.Time,
+						GroupVersionKind:  gvk.VirtualService,
+						Name:              name,
+						Annotations:       routeMeta(obj),
+						Namespace:         obj.Namespace,
+						Domain:            ctx.DomainSuffix,
+					},
+					Spec: &istio.VirtualService{
+						Hosts:    []string{h},
+						Gateways: []string{parent.InternalName},
+						Http:     routes,
+					},
+				}
+				virtualServices = append(virtualServices, RouteWithKey{
+					Config: cfg,
+					Key:    routeKey + "/" + h,
+				})
+				count++
+			}
+		}
+		return status, virtualServices
+	}, opts.WithName("HTTPRoute")...)
+
+	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, opts.WithName("HTTPRouteMerged")...)
+	return RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus]{
+		VirtualServices:  finalVirtualServices,
+		RouteAttachments: routeCount,
+		Status:           status,
+	}
+}
+
+func ADPRouteCollection(
+	httpRoutes krt.Collection[*gateway.HTTPRoute],
+	inputs RouteContextInputs,
+	opts krt.OptionsBuilder,
+) krt.Collection[model.ADPResource] {
+	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []model.ADPResource {
+		ctx := inputs.WithCtx(krtctx)
+		route := obj.Spec
+		_, parentRefs, _, gwResult := computeRoute(ctx, obj, func(mesh bool, obj *gateway.HTTPRoute) iter.Seq2[ADPRoute, *ConfigError] {
+			return func(yield func(ADPRoute, *ConfigError) bool) {
+				for n, r := range route.Rules {
+					// split the rule to make sure each rule has up to one match
+					matches := slices.Reference(r.Matches)
+					if len(matches) == 0 {
+						matches = append(matches, nil)
+					}
+					for idx, m := range matches {
+						if m != nil {
+							r.Matches = []gateway.HTTPRouteMatch{*m}
+						}
+						res, err := convertHTTPRouteToADP(ctx, r, obj, n, idx, !mesh)
+
+						if !yield(ADPRoute{Route: res}, err) {
+							return
+						}
+					}
+				}
+			}
+		})
+
+		res := []model.ADPResource{}
+		for _, parent := range filteredReferences(parentRefs) {
+			// for gateway routes, build one VS per gateway+host
+			routes := gwResult.routes
+			if parent.IsMesh() {
+				continue
+			}
+			if len(routes) == 0 {
+				continue
+			}
+			gw := types.NamespacedName{
+				Namespace: parent.ParentKey.Namespace,
+				Name:      parent.ParentKey.Name,
+			}
+			res = append(res, slices.Map(routes, func(e ADPRoute) model.ADPResource {
+				inner := protomarshal.Clone(e.Route)
+				_, name, _ := strings.Cut(parent.InternalName, "/")
+				inner.ListenerKey = name
+				inner.Key = inner.Key + "." + string(parent.ParentSection)
+				return toResource(gw, ADPRoute{Route: inner})
+			})...)
+		}
+		return res
+	}, opts.WithName("ADPRoutes")...)
+
+	return routes
+}
+
+type conversionResult[O any] struct {
+	error  *ConfigError
+	routes []O
+}
+
+func GRPCRouteCollection(
+	grpcRoutes krt.Collection[*gatewayv1.GRPCRoute],
+	inputs RouteContextInputs,
+	opts krt.OptionsBuilder,
+) RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus] {
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, grpcRoutes, gvk.GRPCRoute, opts)
+	status, baseVirtualServices := krt.NewStatusManyCollection(grpcRoutes, func(krtctx krt.HandlerContext, obj *gatewayv1.GRPCRoute) (
+		*gatewayv1.GRPCRouteStatus,
+		[]RouteWithKey,
+	) {
+		ctx := inputs.WithCtx(krtctx)
+		status := obj.Status.DeepCopy()
+		route := obj.Spec
+		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx, obj, func(mesh bool, obj *gatewayv1.GRPCRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
+			return func(yield func(*istio.HTTPRoute, *ConfigError) bool) {
+				for n, r := range route.Rules {
+					// split the rule to make sure each rule has up to one match
+					matches := slices.Reference(r.Matches)
+					if len(matches) == 0 {
+						matches = append(matches, nil)
+					}
+					for _, m := range matches {
+						if m != nil {
+							r.Matches = []gatewayv1.GRPCRouteMatch{*m}
+						}
+						if !yield(convertGRPCRoute(ctx, r, obj, n, !mesh)) {
+							return
+						}
+					}
+				}
+			}
+		})
+		status.Parents = parentStatus
+
+		count := 0
+		virtualServices := []RouteWithKey{}
+		for _, parent := range filteredReferences(parentRefs) {
+			// for gateway routes, build one VS per gateway+host
+			routeKey := parent.InternalName
+			vsHosts := hostnameToStringList(route.Hostnames)
+			routes := gwResult.routes
+			if parent.IsMesh() {
+				routes = meshResult.routes
+				// for mesh routes, build one VS per namespace/port->host
+				routeKey = obj.Namespace
+				if parent.OriginalReference.Port != nil {
+					routes = augmentPortMatch(routes, *parent.OriginalReference.Port)
+					routeKey += fmt.Sprintf("/%d", *parent.OriginalReference.Port)
+				}
+				ref := types.NamespacedName{
+					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
+					Name:      string(parent.OriginalReference.Name),
+				}
+				if parent.InternalKind == gvk.ServiceEntry {
+					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
+					if ses != nil {
+						vsHosts = ses.Spec.Hosts
+					} else {
+						// TODO: report an error
+						vsHosts = []string{}
+					}
+				} else {
+					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s",
+						parent.OriginalReference.Name, ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace)), ctx.DomainSuffix)}
+				}
+			}
+			if len(routes) == 0 {
+				continue
+			}
+			// Create one VS per hostname with a single hostname.
+			// This ensures we can treat each hostname independently, as the spec requires
+			for _, h := range vsHosts {
+				if !parent.hostnameAllowedByIsolation(h) {
+					// TODO: standardize a status message for this upstream and report
+					continue
+				}
+				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, constants.KubernetesGatewayName)
+				sortHTTPRoutes(routes)
+				cfg := &config.Config{
+					Meta: config.Meta{
+						CreationTimestamp: obj.CreationTimestamp.Time,
+						GroupVersionKind:  gvk.VirtualService,
+						Name:              name,
+						Annotations:       routeMeta(obj),
+						Namespace:         obj.Namespace,
+						Domain:            ctx.DomainSuffix,
+					},
+					Spec: &istio.VirtualService{
+						Hosts:    []string{h},
+						Gateways: []string{parent.InternalName},
+						Http:     routes,
+					},
+				}
+				virtualServices = append(virtualServices, RouteWithKey{
+					Config: cfg,
+					Key:    routeKey + "/" + h,
+				})
+				count++
+			}
+		}
+		return status, virtualServices
+	}, opts.WithName("GRPCRoute")...)
+
+	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, opts.WithName("GRPCRouteMerged")...)
+	return RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus]{
+		VirtualServices:  finalVirtualServices,
+		RouteAttachments: routeCount,
+		Status:           status,
+	}
+}
+
+func TCPRouteCollection(
+	tcpRoutes krt.Collection[*gatewayalpha.TCPRoute],
+	inputs RouteContextInputs,
+	opts krt.OptionsBuilder,
+) RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus] {
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, tcpRoutes, gvk.TCPRoute, opts)
+	status, virtualServices := krt.NewStatusManyCollection(tcpRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TCPRoute) (
+		*gatewayalpha.TCPRouteStatus,
+		[]*config.Config,
+	) {
+		ctx := inputs.WithCtx(krtctx)
+		status := obj.Status.DeepCopy()
+		route := obj.Spec
+		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx, obj,
+			func(mesh bool, obj *gatewayalpha.TCPRoute) iter.Seq2[*istio.TCPRoute, *ConfigError] {
+				return func(yield func(*istio.TCPRoute, *ConfigError) bool) {
+					for _, r := range route.Rules {
+						if !yield(convertTCPRoute(ctx, r, obj, !mesh)) {
+							return
+						}
+					}
+				}
+			})
+		status.Parents = parentStatus
+
+		vs := []*config.Config{}
+		for _, parent := range filteredReferences(parentRefs) {
+			routes := gwResult.routes
+			vsHosts := []string{"*"}
+			if parent.IsMesh() {
+				routes = meshResult.routes
+				if parent.OriginalReference.Port != nil {
+					routes = augmentTCPPortMatch(routes, *parent.OriginalReference.Port)
+				}
+				ref := types.NamespacedName{
+					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
+					Name:      string(parent.OriginalReference.Name),
+				}
+				if parent.InternalKind == gvk.ServiceEntry {
+					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
+					if ses != nil {
+						vsHosts = ses.Spec.Hosts
+					} else {
+						// TODO: report an error
+						vsHosts = []string{}
+					}
+				} else {
+					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s", ref.Name, ref.Namespace, ctx.DomainSuffix)}
+				}
+			}
+			for i, host := range vsHosts {
+				name := fmt.Sprintf("%s-tcp-%d-%s", obj.Name, i, constants.KubernetesGatewayName)
+				// Create one VS per hostname with a single hostname.
+				// This ensures we can treat each hostname independently, as the spec requires
+				vs = append(vs, &config.Config{
+					Meta: config.Meta{
+						CreationTimestamp: obj.CreationTimestamp.Time,
+						GroupVersionKind:  gvk.VirtualService,
+						Name:              name,
+						Annotations:       routeMeta(obj),
+						Namespace:         obj.Namespace,
+						Domain:            ctx.DomainSuffix,
+					},
+					Spec: &istio.VirtualService{
+						// We can use wildcard here since each listener can have at most one route bound to it, so we have
+						// a single VS per Gateway.
+						Hosts:    []string{host},
+						Gateways: []string{parent.InternalName},
+						Tcp:      routes,
+					},
+				})
+			}
+		}
+		return status, vs
+	}, opts.WithName("TCPRoute")...)
+
+	return RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus]{
+		VirtualServices:  virtualServices,
+		RouteAttachments: routeCount,
+		Status:           status,
+	}
+}
+
+func TLSRouteCollection(
+	tlsRoutes krt.Collection[*gatewayalpha.TLSRoute],
+	inputs RouteContextInputs,
+	opts krt.OptionsBuilder,
+) RouteResult[*gatewayalpha.TLSRoute, gatewayalpha.TLSRouteStatus] {
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, tlsRoutes, gvk.TLSRoute, opts)
+	status, virtualServices := krt.NewStatusManyCollection(tlsRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TLSRoute) (
+		*gatewayalpha.TLSRouteStatus,
+		[]*config.Config,
+	) {
+		ctx := inputs.WithCtx(krtctx)
+		status := obj.Status.DeepCopy()
+		route := obj.Spec
+		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx,
+			obj, func(mesh bool, obj *gatewayalpha.TLSRoute) iter.Seq2[*istio.TLSRoute, *ConfigError] {
+				return func(yield func(*istio.TLSRoute, *ConfigError) bool) {
+					for _, r := range route.Rules {
+						if !yield(convertTLSRoute(ctx, r, obj, !mesh)) {
+							return
+						}
+					}
+				}
+			})
+		status.Parents = parentStatus
+
+		vs := []*config.Config{}
+		for _, parent := range filteredReferences(parentRefs) {
+			routes := gwResult.routes
+			vsHosts := hostnameToStringList(route.Hostnames)
+			if parent.IsMesh() {
+				routes = meshResult.routes
+				ref := types.NamespacedName{
+					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
+					Name:      string(parent.OriginalReference.Name),
+				}
+				if parent.InternalKind == gvk.ServiceEntry {
+					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
+					if ses != nil {
+						vsHosts = ses.Spec.Hosts
+					} else {
+						// TODO: report an error
+						vsHosts = []string{}
+					}
+				} else {
+					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s", ref.Name, ref.Namespace, ctx.DomainSuffix)}
+				}
+				routes = augmentTLSPortMatch(routes, parent.OriginalReference.Port, vsHosts)
+			}
+			for i, host := range vsHosts {
+				name := fmt.Sprintf("%s-tls-%d-%s", obj.Name, i, constants.KubernetesGatewayName)
+				filteredRoutes := routes
+				if parent.IsMesh() {
+					filteredRoutes = compatibleRoutesForHost(routes, host)
+				}
+				// Create one VS per hostname with a single hostname.
+				// This ensures we can treat each hostname independently, as the spec requires
+				vs = append(vs, &config.Config{
+					Meta: config.Meta{
+						CreationTimestamp: obj.CreationTimestamp.Time,
+						GroupVersionKind:  gvk.VirtualService,
+						Name:              name,
+						Annotations:       routeMeta(obj),
+						Namespace:         obj.Namespace,
+						Domain:            ctx.DomainSuffix,
+					},
+					Spec: &istio.VirtualService{
+						Hosts:    []string{host},
+						Gateways: []string{parent.InternalName},
+						Tls:      filteredRoutes,
+					},
+				})
+			}
+		}
+		return status, vs
+	}, opts.WithName("TLSRoute")...)
+	return RouteResult[*gatewayalpha.TLSRoute, gatewayalpha.TLSRouteStatus]{
+		VirtualServices:  virtualServices,
+		RouteAttachments: routeCount,
+		Status:           status,
+	}
+}
+
+// computeRoute holds the common route building logic shared amongst all types
+func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, translator func(
+	mesh bool,
+	obj T,
+) iter.Seq2[O, *ConfigError],
+) ([]gateway.RouteParentStatus, []routeParentReference, conversionResult[O], conversionResult[O]) {
+	parentRefs := extractParentReferenceInfo(ctx, ctx.RouteParents, obj)
+
+	convertRules := func(mesh bool) conversionResult[O] {
+		res := conversionResult[O]{}
+		for vs, err := range translator(mesh, obj) {
+			// This was a hard error
+			if controllers.IsNil(vs) {
+				res.error = err
+				return conversionResult[O]{error: err}
+			}
+			// Got an error but also routes
+			if err != nil {
+				res.error = err
+			}
+			res.routes = append(res.routes, vs)
+		}
+		return res
+	}
+	meshResult, gwResult := buildMeshAndGatewayRoutes(parentRefs, convertRules)
+
+	rpResults := slices.Map(parentRefs, func(r routeParentReference) RouteParentResult {
+		res := RouteParentResult{
+			OriginalReference: r.OriginalReference,
+			DeniedReason:      r.DeniedReason,
+			RouteError:        gwResult.error,
+		}
+		if r.IsMesh() {
+			res.RouteError = meshResult.error
+			res.WaypointError = r.WaypointError
+		}
+		return res
+	})
+	parents := createRouteStatus(rpResults, obj.GetGeneration(), GetCommonRouteStateParents(obj))
+	return parents, parentRefs, meshResult, gwResult
+}
+
+// RouteContext defines a common set of inputs to a route collection. This should be built once per route translation and
+// not shared outside of that.
+// The embedded RouteContextInputs is typically based into a collection, then translated to a RouteContext with RouteContextInputs.WithCtx().
+type RouteContext struct {
+	Krt krt.HandlerContext
+	RouteContextInputs
+}
+
+func (r RouteContext) LookupHostname(hostname string, namespace string) *model.Service {
+	if c := r.internalContext.Get(r.Krt).Load(); c != nil {
+		return c.GetService(hostname, namespace)
+	}
+	return nil
+}
+
+type RouteContextInputs struct {
+	Grants          ReferenceGrants
+	RouteParents    RouteParents
+	DomainSuffix    string
+	Services        krt.Collection[*corev1.Service]
+	InferencePools  krt.Collection[*inf.InferencePool]
+	Namespaces      krt.Collection[*corev1.Namespace]
+	ServiceEntries  krt.Collection[*networkingclient.ServiceEntry]
+	internalContext krt.RecomputeProtected[*atomic.Pointer[GatewayContext]]
+}
+
+func (i RouteContextInputs) WithCtx(krtctx krt.HandlerContext) RouteContext {
+	return RouteContext{
+		Krt:                krtctx,
+		RouteContextInputs: i,
+	}
+}
+
+type RouteWithKey struct {
+	*config.Config
+	Key string
+}
+
+func (r RouteWithKey) ResourceName() string {
+	return config.NamespacedName(r.Config).String()
+}
+
+func (r RouteWithKey) Equals(o RouteWithKey) bool {
+	return r.Config.Equals(o.Config)
+}
+
+// buildMeshAndGatewayRoutes contains common logic to build a set of routes with mesh and/or gateway semantics
+func buildMeshAndGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func(mesh bool) T) (T, T) {
+	var meshResult, gwResult T
+	needMesh, needGw := parentTypes(parentRefs)
+	if needMesh {
+		meshResult = convertRules(true)
+	}
+	if needGw {
+		gwResult = convertRules(false)
+	}
+	return meshResult, gwResult
+}
+
+// RouteResult holds the result of a route collection
+type RouteResult[I, IStatus any] struct {
+	// VirtualServices are the primary output that configures the internal routing logic
+	VirtualServices krt.Collection[*config.Config]
+	// RouteAttachments holds information about parent attachment to routes, used for computed the `attachedRoutes` count.
+	RouteAttachments krt.Collection[*RouteAttachment]
+	// Status stores the status reports for the incoming object
+	Status krt.StatusCollection[I, IStatus]
+}
+
+type GatewayAndListener struct {
+	// To is assumed to be a Gateway
+	To           types.NamespacedName
+	ListenerName string
+}
+
+func (g GatewayAndListener) String() string {
+	return g.To.String() + "/" + g.ListenerName
+}
+
+type RouteAttachment struct {
+	From TypedResource
+	// To is assumed to be a Gateway
+	To           types.NamespacedName
+	ListenerName string
+}
+
+func (r *RouteAttachment) ResourceName() string {
+	return r.From.Kind.String() + "/" + r.From.Name.String() + "/" + r.To.String() + "/" + r.ListenerName
+}
+
+func (r *RouteAttachment) Equals(other RouteAttachment) bool {
+	return r.From == other.From && r.To == other.To && r.ListenerName == other.ListenerName
+}
+
+// gatewayRouteAttachmentCountCollection holds the generic logic to determine the parents a route is attached to, used for
+// computing the aggregated `attachedRoutes` status in Gateway.
+func gatewayRouteAttachmentCountCollection[T controllers.Object](
+	inputs RouteContextInputs,
+	col krt.Collection[T],
+	kind config.GroupVersionKind,
+	opts krt.OptionsBuilder,
+) krt.Collection[*RouteAttachment] {
+	return krt.NewManyCollection(col, func(krtctx krt.HandlerContext, obj T) []*RouteAttachment {
+		ctx := inputs.WithCtx(krtctx)
+		from := TypedResource{
+			Kind: kind,
+			Name: config.NamespacedName(obj),
+		}
+
+		parentRefs := extractParentReferenceInfo(ctx, inputs.RouteParents, obj)
+		return slices.MapFilter(filteredReferences(parentRefs), func(e routeParentReference) **RouteAttachment {
+			if e.ParentKey.Kind != gvk.KubernetesGateway {
+				return nil
+			}
+			return ptr.Of(&RouteAttachment{
+				From: from,
+				To: types.NamespacedName{
+					Name:      e.ParentKey.Name,
+					Namespace: e.ParentKey.Namespace,
+				},
+				ListenerName: string(e.ParentSection),
+			})
+		})
+	}, opts.WithName(kind.Kind+"/count")...)
+}
+
+// mergeHTTPRoutes merges HTTProutes by key. Gateway API has semantics for the ordering of `match` rules, that merges across resource.
+// So we merge everything (by key) following that ordering logic, and sort into a linear list (how VirtualService semantics work).
+func mergeHTTPRoutes(baseVirtualServices krt.Collection[RouteWithKey], opts ...krt.CollectionOption) krt.Collection[*config.Config] {
+	idx := krt.NewIndex(baseVirtualServices, func(o RouteWithKey) []string {
+		return []string{o.Key}
+	}).AsCollection(opts...)
+	finalVirtualServices := krt.NewCollection(idx, func(ctx krt.HandlerContext, object krt.IndexObject[string, RouteWithKey]) **config.Config {
+		configs := object.Objects
+		if len(configs) == 1 {
+			return &configs[0].Config
+		}
+		sortRoutesByCreationTime(configs)
+		base := configs[0].DeepCopy()
+		baseVS := base.Spec.(*istio.VirtualService)
+		for _, config := range configs[1:] {
+			thisVS := config.Spec.(*istio.VirtualService)
+			baseVS.Http = append(baseVS.Http, thisVS.Http...)
+			// append parents
+			base.Annotations[constants.InternalParentNames] = fmt.Sprintf("%s,%s",
+				base.Annotations[constants.InternalParentNames], config.Annotations[constants.InternalParentNames])
+		}
+		sortHTTPRoutes(baseVS.Http)
+		return ptr.Of(&base)
+	}, opts...)
+	return finalVirtualServices
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/status.go b/internal/kgateway/agentgatewaysyncer/gateway/status.go
new file mode 100644
index 000000000..be976097b
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/status.go
@@ -0,0 +1,90 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"strconv"
+	"sync"
+
+	"istio.io/istio/pilot/pkg/status"
+	schematypes "istio.io/istio/pkg/config/schema/kubetypes"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/slices"
+)
+
+type StatusRegistration = func(statusWriter status.Queue) krt.HandlerRegistration
+
+// StatusCollections stores a variety of collections that can write status.
+// These can be fed into a queue which can be dynamically changed (to handle leader election)
+type StatusCollections struct {
+	mu           sync.Mutex
+	constructors []func(statusWriter status.Queue) krt.HandlerRegistration
+	active       []krt.HandlerRegistration
+	queue        status.Queue
+}
+
+func (s *StatusCollections) Register(sr StatusRegistration) {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	s.constructors = append(s.constructors, sr)
+}
+
+func (s *StatusCollections) UnsetQueue() {
+	// Now we are disabled
+	s.queue = nil
+	for _, act := range s.active {
+		act.UnregisterHandler()
+	}
+	s.active = nil
+}
+
+func (s *StatusCollections) SetQueue(queue status.Queue) []krt.Syncer {
+	s.mu.Lock()
+	defer s.mu.Unlock()
+	// Now we are enabled!
+	s.queue = queue
+	// Register all constructors
+	s.active = slices.Map(s.constructors, func(reg StatusRegistration) krt.HandlerRegistration {
+		return reg(queue)
+	})
+	return slices.Map(s.active, func(e krt.HandlerRegistration) krt.Syncer {
+		return e
+	})
+}
+
+// registerStatus takes a status collection and registers it to be managed by the status queue.
+func registerStatus[I controllers.Object, IS any](c *Controller, statusCol krt.StatusCollection[I, IS]) {
+	reg := func(statusWriter status.Queue) krt.HandlerRegistration {
+		h := statusCol.Register(func(o krt.Event[krt.ObjectWithStatus[I, IS]]) {
+			l := o.Latest()
+			enqueueStatus(statusWriter, l.Obj, &l.Status)
+		})
+		return h
+	}
+	c.status.Register(reg)
+}
+
+func enqueueStatus[T any](sw status.Queue, obj controllers.Object, ws T) {
+	// TODO: this is a bit awkward since the status controller is reading from crdstore. I suppose it works -- it just means
+	// we cannot remove Gateway API types from there.
+	res := status.Resource{
+		GroupVersionResource: schematypes.GvrFromObject(obj),
+		Namespace:            obj.GetNamespace(),
+		Name:                 obj.GetName(),
+		Generation:           strconv.FormatInt(obj.GetGeneration(), 10),
+	}
+	sw.EnqueueStatusUpdateResource(ws, res)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/status_test.go b/internal/kgateway/agentgatewaysyncer/gateway/status_test.go
new file mode 100644
index 000000000..e68a5e29a
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/status_test.go
@@ -0,0 +1,104 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"testing"
+
+	v1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+
+	"istio.io/istio/pilot/pkg/networking/core"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
+	"istio.io/istio/pilot/pkg/status"
+	"istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/test/util/assert"
+)
+
+func TestStatusCollections(t *testing.T) {
+	stop := test.NewStop(t)
+	fetch := func(q *TestStatusQueue) []string {
+		return slices.Sort(slices.Map(q.Statuses(), func(e any) string {
+			return *(e.(*string))
+		}))
+	}
+
+	type Status = krt.ObjectWithStatus[*v1.ConfigMap, string]
+	c := setupControllerWithoutGatewayClasses(t)
+	obj1 := Status{
+		Obj:    &v1.ConfigMap{},
+		Status: "hello world",
+	}
+	fakeCol := krt.NewStaticCollection[Status](nil, []Status{obj1}, krt.WithStop(stop))
+	registerStatus(c, fakeCol)
+
+	sq1 := &TestStatusQueue{state: map[status.Resource]any{}}
+	setAndWait(t, c, sq1)
+	assert.Equal(t, fetch(sq1), []string{"hello world"})
+
+	c.status.UnsetQueue()
+
+	// We should not get an update on the un-registered queue
+	fakeCol.UpdateObject(Status{
+		Obj:    &v1.ConfigMap{},
+		Status: "hello world2",
+	})
+	assert.Equal(t, fetch(sq1), []string{"hello world"})
+
+	// New queue should send new events, including existing state
+	sq2 := &TestStatusQueue{state: map[status.Resource]any{}}
+	setAndWait(t, c, sq2)
+	assert.Equal(t, fetch(sq2), []string{"hello world2"})
+	// And any new state
+	fakeCol.UpdateObject(Status{
+		Obj:    &v1.ConfigMap{},
+		Status: "hello world3",
+	})
+	// New event, so this is eventually consistent
+	assert.EventuallyEqual(t, func() []string {
+		return fetch(sq2)
+	}, []string{"hello world3"})
+}
+
+func setAndWait(t test.Failer, c *Controller, q status.Queue) {
+	stop := test.NewStop(t)
+	for _, syncer := range c.status.SetQueue(q) {
+		syncer.WaitUntilSynced(stop)
+	}
+}
+
+func setupControllerWithoutGatewayClasses(t *testing.T, objs ...runtime.Object) *Controller {
+	kc := kube.NewFakeClient(objs...)
+	setupClientCRDs(t, kc)
+	stop := test.NewStop(t)
+	controller := NewController(
+		kc,
+		func(class schema.GroupVersionResource, stop <-chan struct{}) bool {
+			return false
+		},
+		controller.Options{KrtDebugger: krt.GlobalDebugHandler},
+		nil)
+	kc.RunAndWait(stop)
+	go controller.Run(stop)
+	cg := core.NewConfigGenTest(t, core.TestOptions{})
+	controller.Reconcile(cg.PushContext())
+	kube.WaitForCacheSync("test", stop, controller.HasSynced)
+
+	return controller
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/supported_features.go b/internal/kgateway/agentgatewaysyncer/gateway/supported_features.go
new file mode 100644
index 000000000..e71988cac
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/supported_features.go
@@ -0,0 +1,21 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package gateway
+
+import (
+	"sigs.k8s.io/gateway-api/pkg/features"
+)
+
+var SupportedFeatures = features.AllFeatures
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 88e848a24..22ba1d5e2 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -4,32 +4,23 @@ import (
 	"context"
 	"fmt"
 	"maps"
-	"regexp"
 	"slices"
-	"strings"
 
-	agentgateway "github.com/agentgateway/agentgateway/go/api"
-	"github.com/agentgateway/agentgateway/go/api/a2a"
-	"github.com/agentgateway/agentgateway/go/api/mcp"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	"google.golang.org/protobuf/proto"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
-	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/client-go/tools/cache"
 	"sigs.k8s.io/controller-runtime/pkg/manager"
-	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/xds"
-	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 )
 
 var logger = logging.New("agentgateway/syncer")
@@ -37,12 +28,11 @@ var logger = logging.New("agentgateway/syncer")
 // AgentGwSyncer synchronizes Kubernetes Gateway API resources with xDS for agentgateway proxies.
 // It watches Gateway resources with the agentgateway class and translates them to agentgateway configuration.
 type AgentGwSyncer struct {
-	commonCols            *common.CommonCollections
-	controllerName        string
-	agentGatewayClassName string
-	xDS                   krt.Collection[agentGwXdsResources]
-	xdsCache              envoycache.SnapshotCache
-	istioClient           kube.Client
+	commonCols     *common.CommonCollections
+	controllerName string
+	xDS            krt.Collection[agentGwXdsResources]
+	xdsCache       envoycache.SnapshotCache
+	istioClient    kube.Client
 
 	waitForSync []cache.InformerSynced
 }
@@ -50,7 +40,6 @@ type AgentGwSyncer struct {
 func NewAgentGwSyncer(
 	ctx context.Context,
 	controllerName string,
-	agentGatewayClassName string,
 	mgr manager.Manager,
 	client kube.Client,
 	commonCols *common.CommonCollections,
@@ -58,10 +47,9 @@ func NewAgentGwSyncer(
 ) *AgentGwSyncer {
 	// TODO: register types (auth, policy, etc.) if necessary
 	return &AgentGwSyncer{
-		commonCols:            commonCols,
-		controllerName:        controllerName,
-		agentGatewayClassName: agentGatewayClassName,
-		xdsCache:              xdsCache,
+		commonCols:     commonCols,
+		controllerName: controllerName,
+		xdsCache:       xdsCache,
 		// mgr:            mgr,
 		istioClient: client,
 	}
@@ -70,21 +58,20 @@ func NewAgentGwSyncer(
 type agentGwXdsResources struct {
 	types.NamespacedName
 
-	reports            reports.ReportMap
-	AgentGwA2AServices envoycache.Resources
-	AgentGwMcpServices envoycache.Resources
-	Listeners          envoycache.Resources
+	reports   reports.ReportMap
+	Resources envoycache.Resources
+	Addresses envoycache.Resources
 }
 
 func (r agentGwXdsResources) ResourceName() string {
-	return xds.OwnerNamespaceNameID(OwnerNodeId, r.Namespace, r.Name)
+	return fmt.Sprintf("%s~%s", r.Namespace, r.Name)
 }
 
 func (r agentGwXdsResources) Equals(in agentGwXdsResources) bool {
 	return r.NamespacedName == in.NamespacedName &&
 		report{r.reports}.Equals(report{in.reports}) &&
-		r.AgentGwA2AServices.Version == in.AgentGwA2AServices.Version &&
-		r.AgentGwMcpServices.Version == in.AgentGwMcpServices.Version
+		r.Resources.Version == in.Resources.Version &&
+		r.Addresses.Version == in.Addresses.Version
 }
 
 type envoyResourceWithName struct {
@@ -155,162 +142,15 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	// TODO: convert auth to rbac json config for agentgateways
 
 	gatewaysCol := krt.NewCollection(s.commonCols.GatewayIndex.Gateways, func(kctx krt.HandlerContext, gw ir.Gateway) *ir.Gateway {
-		if string(gw.Obj.Spec.GatewayClassName) != s.agentGatewayClassName {
+		if gw.Obj.Spec.GatewayClassName != wellknown.AgentGatewayClassName {
 			return nil
 		}
 		return &gw
 	}, krtopts.ToOptions("agentgateway")...)
 
-	// TODO(npolshak): optimize this in the future with an index
-	agentGwServices := krt.NewManyCollection(s.commonCols.Services, func(kctx krt.HandlerContext, s *corev1.Service) []agentGwService {
-		var allowedA2AListeners, allowedMCPListeners []string
-
-		gws := krt.Fetch(kctx, gatewaysCol)
-		for _, gw := range gws {
-			for _, listener := range gw.Listeners {
-				if listener.Protocol != A2AProtocol && listener.Protocol != MCPProtocol {
-					continue
-				}
-				logger.Debug("found agentgateway service", "namespace", s.Namespace, "name", s.Name)
-				if listener.AllowedRoutes == nil {
-					// only allow agent services in same namespace
-					if s.Namespace == gw.Obj.Namespace {
-						if listener.Protocol == A2AProtocol {
-							allowedA2AListeners = append(allowedA2AListeners, string(listener.Name))
-						} else {
-							allowedMCPListeners = append(allowedMCPListeners, string(listener.Name))
-						}
-					}
-				} else if listener.AllowedRoutes.Namespaces.From != nil {
-					switch *listener.AllowedRoutes.Namespaces.From {
-					case gwv1.NamespacesFromAll:
-						if listener.Protocol == A2AProtocol {
-							allowedA2AListeners = append(allowedA2AListeners, string(listener.Name))
-						} else {
-							allowedMCPListeners = append(allowedMCPListeners, string(listener.Name))
-						}
-					case gwv1.NamespacesFromSame:
-						// only allow agent services in same namespace
-						if s.Namespace == gw.Obj.Namespace {
-							if listener.Protocol == A2AProtocol {
-								allowedA2AListeners = append(allowedA2AListeners, string(listener.Name))
-							} else {
-								allowedMCPListeners = append(allowedMCPListeners, string(listener.Name))
-							}
-						}
-					case gwv1.NamespacesFromSelector:
-						// TODO: implement namespace selectors with gateway index
-						logger.Error("namespace selectors not supported for agentgateways")
-						continue
-					}
-				}
-			}
-		}
-		return translateAgentService(s, allowedA2AListeners, allowedMCPListeners)
-	})
-	xdsA2AServices := krt.NewCollection(agentGwServices, func(kctx krt.HandlerContext, s agentGwService) *envoyResourceWithName {
-		if s.protocol != A2AProtocol {
-			return nil
-		}
-		t := &a2a.Target{
-			Name:      getTargetName(s.ResourceName()),
-			Host:      s.ip,
-			Port:      uint32(s.port),
-			Path:      s.path,
-			Listeners: s.allowedListeners,
-		}
-		return &envoyResourceWithName{inner: t, version: utils.HashProto(t)}
-	}, krtopts.ToOptions("a2a-target-xds")...)
-	xdsMcpServices := krt.NewCollection(agentGwServices, func(kctx krt.HandlerContext, s agentGwService) *envoyResourceWithName {
-		if s.protocol != MCPProtocol {
-			return nil
-		}
-		t := &mcp.Target{
-			// Note: No slashes allowed here (must match ^[a-zA-Z0-9-]+$)
-			Name: getTargetName(s.ResourceName()),
-			Target: &mcp.Target_Sse{
-				Sse: &mcp.Target_SseTarget{
-					Host: s.ip,
-					Port: uint32(s.port),
-					Path: s.path,
-				},
-			},
-			Listeners: s.allowedListeners,
-		}
-		return &envoyResourceWithName{inner: t, version: utils.HashProto(t)}
-	}, krtopts.ToOptions("mcp-target-xds")...)
-
-	// translate gateways to xds
-	s.xDS = krt.NewCollection(gatewaysCol, func(kctx krt.HandlerContext, gw ir.Gateway) *agentGwXdsResources {
-		// listeners for the agentgateway
-		agwListeners := make([]envoytypes.Resource, 0, len(gw.Listeners))
-		var listenerVersion uint64
-		var listener *agentgateway.Listener
-		for _, gwListener := range gw.Listeners {
-			var protocol agentgateway.Listener_Protocol
-			switch string(gwListener.Protocol) {
-			case MCPProtocol:
-				protocol = agentgateway.Listener_MCP
-			case A2AProtocol:
-				protocol = agentgateway.Listener_A2A
-			default:
-				// Not a valid protocol for agentgateway
-				continue
-			}
-
-			listener = &agentgateway.Listener{
-				Name:     string(gwListener.Name),
-				Protocol: protocol,
-				// TODO: Add support for stdio listener
-				Listener: &agentgateway.Listener_Sse{
-					Sse: &agentgateway.SseListener{
-						Address: "[::]",
-						Port:    uint32(gwListener.Port),
-					},
-				},
-			}
-
-			// Update listenerVersion to be the result
-			listenerVersion ^= utils.HashProto(listener)
-			agwListeners = append(agwListeners, listener)
-		}
-
-		// a2a services
-		a2aServiceResources := krt.Fetch(kctx, xdsA2AServices)
-		logger.Debug("found A2A resources for gateway", "total_services", len(a2aServiceResources), "resource_ref", gw.ResourceName())
-		a2aResources := make([]envoytypes.Resource, len(a2aServiceResources))
-		var a2aVersion uint64
-		for i, res := range a2aServiceResources {
-			a2aVersion ^= res.version
-			target := res.inner.(*a2a.Target)
-			a2aResources[i] = target
-		}
-		// mcp services
-		mcpServiceResources := krt.Fetch(kctx, xdsMcpServices)
-		logger.Debug("found MCP resources for gateway", "total_services", len(mcpServiceResources), "resource_ref", gw.ResourceName())
-		mcpResources := make([]envoytypes.Resource, len(mcpServiceResources))
-		var mcpVersion uint64
-		for i, res := range mcpServiceResources {
-			mcpVersion ^= res.version
-			target := res.inner.(*mcp.Target)
-			mcpResources[i] = target
-		}
-		result := &agentGwXdsResources{
-			NamespacedName:     types.NamespacedName{Namespace: gw.Namespace, Name: gw.Name},
-			AgentGwA2AServices: envoycache.NewResources(fmt.Sprintf("%d", a2aVersion), a2aResources),
-			AgentGwMcpServices: envoycache.NewResources(fmt.Sprintf("%d", mcpVersion), mcpResources),
-			Listeners:          envoycache.NewResources(fmt.Sprintf("%d", listenerVersion), agwListeners),
-		}
-		logger.Debug("created XDS resources for with ID", "gwname", gw.Name, "resourceid", result.ResourceName())
-		return result
-	}, krtopts.ToOptions("agentgateway-xds")...)
-
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
-		xdsA2AServices.HasSynced,
-		xdsMcpServices.HasSynced,
 		gatewaysCol.HasSynced,
-		agentGwServices.HasSynced,
 		s.xDS.HasSynced,
 	}
 }
@@ -332,9 +172,8 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 				continue
 			}
 			snapshot := &agentGwSnapshot{
-				AgentGwA2AServices: r.AgentGwA2AServices,
-				AgentGwMcpServices: r.AgentGwMcpServices,
-				Listeners:          r.Listeners,
+				Resources: r.Resources,
+				Addresses: r.Addresses,
 			}
 			logger.Debug("setting xds snapshot", "resourcename", r.ResourceName())
 			err := s.xdsCache.SetSnapshot(ctx, r.ResourceName(), snapshot)
@@ -349,10 +188,9 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 }
 
 type agentGwSnapshot struct {
-	AgentGwA2AServices envoycache.Resources
-	AgentGwMcpServices envoycache.Resources
-	Listeners          envoycache.Resources
-	VersionMap         map[string]map[string]string
+	Resources  envoycache.Resources
+	Addresses  envoycache.Resources
+	VersionMap map[string]map[string]string
 }
 
 func (m *agentGwSnapshot) GetResources(typeURL string) map[string]envoytypes.Resource {
@@ -366,12 +204,10 @@ func (m *agentGwSnapshot) GetResources(typeURL string) map[string]envoytypes.Res
 
 func (m *agentGwSnapshot) GetResourcesAndTTL(typeURL string) map[string]envoytypes.ResourceWithTTL {
 	switch typeURL {
-	case TargetTypeA2AUrl:
-		return m.AgentGwA2AServices.Items
-	case TargetTypeMcpUrl:
-		return m.AgentGwMcpServices.Items
-	case TargetTypeListenerUrl:
-		return m.Listeners.Items
+	case TargetTypeResourceUrl:
+		return m.Resources.Items
+	case TargetTypeAddressUrl:
+		return m.Addresses.Items
 	default:
 		return nil
 	}
@@ -379,12 +215,10 @@ func (m *agentGwSnapshot) GetResourcesAndTTL(typeURL string) map[string]envoytyp
 
 func (m *agentGwSnapshot) GetVersion(typeURL string) string {
 	switch typeURL {
-	case TargetTypeA2AUrl:
-		return m.AgentGwA2AServices.Version
-	case TargetTypeMcpUrl:
-		return m.AgentGwMcpServices.Version
-	case TargetTypeListenerUrl:
-		return m.Listeners.Version
+	case TargetTypeResourceUrl:
+		return m.Resources.Version
+	case TargetTypeAddressUrl:
+		return m.Resources.Version
 	default:
 		return ""
 	}
@@ -400,9 +234,8 @@ func (m *agentGwSnapshot) ConstructVersionMap() error {
 
 	m.VersionMap = make(map[string]map[string]string)
 	resources := map[string]map[string]envoytypes.ResourceWithTTL{
-		TargetTypeA2AUrl:      m.AgentGwA2AServices.Items,
-		TargetTypeMcpUrl:      m.AgentGwMcpServices.Items,
-		TargetTypeListenerUrl: m.Listeners.Items,
+		TargetTypeResourceUrl: m.Resources.Items,
+		TargetTypeAddressUrl:  m.Addresses.Items,
 	}
 
 	for typeUrl, items := range resources {
@@ -428,69 +261,3 @@ func (m *agentGwSnapshot) GetVersionMap(typeURL string) map[string]string {
 }
 
 var _ envoycache.ResourceSnapshot = &agentGwSnapshot{}
-
-// getTargetName sanitizes the given resource name to ensure it matches the AgentGateway required pattern:
-// ^[a-zA-Z0-9-]+$ by replacing slashes and removing invalid characters.
-func getTargetName(resourceName string) string {
-	var (
-		invalidCharsRegex      = regexp.MustCompile(`[^a-zA-Z0-9-]+`)
-		consecutiveDashesRegex = regexp.MustCompile(`-+`)
-	)
-
-	// Replace all invalid characters with dashes
-	sanitized := invalidCharsRegex.ReplaceAllString(resourceName, "-")
-
-	// Remove leading/trailing dashes and collapse consecutive dashes
-	sanitized = strings.Trim(sanitized, "-")
-	sanitized = consecutiveDashesRegex.ReplaceAllString(sanitized, "-")
-
-	return sanitized
-}
-
-func translateAgentService(svc *corev1.Service, allowedA2AListeners, allowedMCPListeners []string) []agentGwService {
-	var svcs []agentGwService
-
-	if svc.Spec.ClusterIP == "" && svc.Spec.ExternalName == "" {
-		// Return early if there's no valid IP or external name set on the service
-		return svcs
-	}
-
-	addr := svc.Spec.ClusterIP
-	if addr == "" {
-		addr = svc.Spec.ExternalName
-	}
-
-	for _, port := range svc.Spec.Ports {
-		if port.AppProtocol == nil {
-			continue
-		}
-		appProtocol := *port.AppProtocol
-		var path string
-		var allowedListeners []string
-
-		switch appProtocol {
-		case A2AProtocol:
-			path = svc.Annotations[A2APathAnnotation]
-			allowedListeners = allowedA2AListeners
-		case MCPProtocol:
-			path = svc.Annotations[MCPPathAnnotation]
-			allowedListeners = allowedMCPListeners
-		default:
-			// Skip unsupported protocols
-			continue
-		}
-
-		svcs = append(svcs, agentGwService{
-			Named: krt.Named{
-				Name:      svc.Name,
-				Namespace: svc.Namespace,
-			},
-			ip:               addr,
-			port:             int(port.Port),
-			path:             path,
-			protocol:         appProtocol,
-			allowedListeners: allowedListeners,
-		})
-	}
-	return svcs
-}
diff --git a/internal/kgateway/agentgatewaysyncer/syncer_test.go b/internal/kgateway/agentgatewaysyncer/syncer_test.go
index b385c55ff..aeeeea27c 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer_test.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer_test.go
@@ -2,15 +2,8 @@ package agentgatewaysyncer
 
 import (
 	"context"
-	"testing"
 
-	agentgateway "github.com/agentgateway/agentgateway/go/api"
-	"github.com/agentgateway/agentgateway/go/api/a2a"
-	"github.com/agentgateway/agentgateway/go/api/mcp"
-	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
 )
 
 // dumpXDSCacheState is a helper function that dump the current state of the XDS cache for the agentgateway cache
@@ -27,220 +20,16 @@ func dumpXDSCacheState(ctx context.Context, cache envoycache.SnapshotCache) {
 			continue
 		}
 
-		// Check for A2A targets
-		logger.Info("A2A targets version", "snapshot", snapshot.GetVersion(TargetTypeA2AUrl)) //nolint:sloglint // ignore msg-type
-		resources := snapshot.GetResources(TargetTypeA2AUrl)
+		logger.Info("Resource targets version", "snapshot", snapshot.GetVersion(TargetTypeResourceUrl))
+		resources := snapshot.GetResources(TargetTypeResourceUrl)
 		for name := range resources {
 			logger.Info("snapshot has resources", "name", name)
 		}
 
-		// Check for MCP targets
-		logger.Info("MCP targets version", "snapshot", snapshot.GetVersion(TargetTypeMcpUrl))
-		resources = snapshot.GetResources(TargetTypeMcpUrl)
+		logger.Info("Address targets version", "snapshot", snapshot.GetVersion(TargetTypeAddressUrl))
+		resources = snapshot.GetResources(TargetTypeAddressUrl)
 		for name := range resources {
 			logger.Info("snapshot has resources", "name", name)
 		}
 	}
 }
-
-// TestXDSCacheState checks that the xds cache has targets and listeners properly set
-func TestXDSCacheState(t *testing.T) {
-	ctx := context.Background()
-	cache := envoycache.NewSnapshotCache(false, envoycache.IDHash{}, nil)
-
-	a2aTarget := &a2a.Target{
-		Name:      "test-a2a-service",
-		Host:      "10.0.0.1",
-		Port:      8080,
-		Path:      "/api",
-		Listeners: []string{"a2a-listener"},
-	}
-	mcpTarget := &mcp.Target{
-		Name: "test-mcp-service",
-		Target: &mcp.Target_Sse{
-			Sse: &mcp.Target_SseTarget{
-				Host: "10.0.0.2",
-				Port: 8081,
-				Path: "/events",
-			},
-		},
-		Listeners: []string{"mcp-listener"},
-	}
-	listener := &agentgateway.Listener{
-		Name:     "test-listener",
-		Protocol: agentgateway.Listener_A2A,
-		Listener: &agentgateway.Listener_Sse{
-			Sse: &agentgateway.SseListener{
-				Address: "[::]",
-				Port:    8080,
-			},
-		},
-	}
-
-	snapshot := &agentGwSnapshot{
-		AgentGwA2AServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			a2aTarget,
-		}),
-		AgentGwMcpServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			mcpTarget,
-		}),
-		Listeners: envoycache.NewResources("v1", []envoytypes.Resource{
-			listener,
-		}),
-	}
-
-	// Set the snapshot in the cache
-	err := cache.SetSnapshot(ctx, "test-node", snapshot)
-	require.NoError(t, err)
-
-	// Test dumping the cache state
-	dumpXDSCacheState(ctx, cache)
-
-	// Verify the resources were properly set
-	retrievedSnapshot, err := cache.GetSnapshot("test-node")
-	require.NoError(t, err)
-
-	// Verify A2A resources
-	a2aResources := retrievedSnapshot.GetResources(TargetTypeA2AUrl)
-	assert.NotNil(t, a2aResources)
-	assert.Contains(t, a2aResources, "test-a2a-service")
-	retrievedA2A := a2aResources["test-a2a-service"].(*a2a.Target)
-	assert.Equal(t, "10.0.0.1", retrievedA2A.Host)
-	assert.Equal(t, uint32(8080), retrievedA2A.Port)
-	assert.Equal(t, "/api", retrievedA2A.Path)
-
-	// Verify MCP resources
-	mcpResources := retrievedSnapshot.GetResources(TargetTypeMcpUrl)
-	assert.NotNil(t, mcpResources)
-	assert.Contains(t, mcpResources, "test-mcp-service")
-	retrievedMCP := mcpResources["test-mcp-service"].(*mcp.Target)
-	assert.Equal(t, "10.0.0.2", retrievedMCP.GetSse().Host)
-	assert.Equal(t, uint32(8081), retrievedMCP.GetSse().Port)
-	assert.Equal(t, "/events", retrievedMCP.GetSse().Path)
-
-	// Verify Listener resources
-	listenerResources := retrievedSnapshot.GetResources(TargetTypeListenerUrl)
-	assert.NotNil(t, listenerResources)
-	assert.Contains(t, listenerResources, "test-listener")
-	retrievedListener := listenerResources["test-listener"].(*agentgateway.Listener)
-	assert.Equal(t, agentgateway.Listener_A2A, retrievedListener.Protocol)
-	assert.Equal(t, uint32(8080), retrievedListener.GetSse().Port)
-}
-
-// TestGetTargetName checks that the getTargetName function correctly formats target names
-func TestGetTargetName(t *testing.T) {
-	tests := []struct {
-		name     string
-		input    string
-		expected string
-	}{
-		{
-			name:     "simple name",
-			input:    "test-service",
-			expected: "test-service",
-		},
-		{
-			name:     "name with slashes",
-			input:    "namespace/service",
-			expected: "namespace-service",
-		},
-		{
-			name:     "name with invalid characters",
-			input:    "test@service#123",
-			expected: "test-service-123",
-		},
-		{
-			name:     "name with multiple consecutive dashes",
-			input:    "test--service",
-			expected: "test-service",
-		},
-		{
-			name:     "name with leading/trailing dashes",
-			input:    "-test-service-",
-			expected: "test-service",
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			result := getTargetName(tt.input)
-			assert.Equal(t, tt.expected, result)
-		})
-	}
-}
-
-// TestAgentGwSnapshot checks that the snapshot GetVersion and GetResources methods work as expected
-func TestAgentGwSnapshot(t *testing.T) {
-	a2aTarget := &a2a.Target{
-		Name:      "test-a2a-service",
-		Host:      "10.0.0.1",
-		Port:      8080,
-		Path:      "/api",
-		Listeners: []string{"a2a-listener"},
-	}
-	mcpTarget := &mcp.Target{
-		Name: "test-mcp-service",
-		Target: &mcp.Target_Sse{
-			Sse: &mcp.Target_SseTarget{
-				Host: "10.0.0.2",
-				Port: 8081,
-				Path: "/events",
-			},
-		},
-		Listeners: []string{"mcp-listener"},
-	}
-	listener := &agentgateway.Listener{
-		Name:     "test-listener",
-		Protocol: agentgateway.Listener_A2A,
-		Listener: &agentgateway.Listener_Sse{
-			Sse: &agentgateway.SseListener{
-				Address: "[::]",
-				Port:    8080,
-			},
-		},
-	}
-
-	// manually build the snapshot
-	snapshot := &agentGwSnapshot{
-		AgentGwA2AServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			a2aTarget,
-		}),
-		AgentGwMcpServices: envoycache.NewResources("v1", []envoytypes.Resource{
-			mcpTarget,
-		}),
-		Listeners: envoycache.NewResources("v1", []envoytypes.Resource{
-			listener,
-		}),
-	}
-
-	// Construct the version map based on the snapshot
-	err := snapshot.ConstructVersionMap()
-	assert.NoError(t, err)
-
-	assert.Equal(t, "v1", snapshot.GetVersion(TargetTypeA2AUrl))
-	assert.Equal(t, "v1", snapshot.GetVersion(TargetTypeMcpUrl))
-	assert.Equal(t, "v1", snapshot.GetVersion(TargetTypeListenerUrl))
-	assert.Equal(t, "", snapshot.GetVersion("invalid-type"))
-
-	a2aResources := snapshot.GetResources(TargetTypeA2AUrl)
-	assert.NotNil(t, a2aResources)
-	assert.Len(t, a2aResources, 1)
-	a2aVersionMap := snapshot.GetVersionMap(TargetTypeA2AUrl)
-	assert.NotNil(t, a2aVersionMap)
-
-	mcpResources := snapshot.GetResources(TargetTypeMcpUrl)
-	assert.NotNil(t, mcpResources)
-	assert.Len(t, mcpResources, 1)
-	mcpVersionMap := snapshot.GetVersionMap(TargetTypeMcpUrl)
-	assert.NotNil(t, mcpVersionMap)
-
-	listenerResources := snapshot.GetResources(TargetTypeListenerUrl)
-	assert.NotNil(t, listenerResources)
-	assert.Len(t, listenerResources, 1)
-	listenerVersionMap := snapshot.GetVersionMap(TargetTypeListenerUrl)
-	assert.NotNil(t, listenerVersionMap)
-
-	err = snapshot.ConstructVersionMap()
-	assert.NoError(t, err)
-	assert.NotNil(t, snapshot.VersionMap)
-}
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index db564e641..a5b645de5 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -1,322 +1 @@
 package setup_test
-
-import (
-	"context"
-	"fmt"
-	"os"
-	"strings"
-	"testing"
-	"time"
-
-	istiokube "istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/krt"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
-	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
-)
-
-func TestAgentGatewaySelfManaged(t *testing.T) {
-	st, err := settings.BuildSettings()
-	st.EnableAgentGateway = true
-
-	if err != nil {
-		t.Fatalf("can't get settings %v", err)
-	}
-	setupEnvTestAndRun(t, st, func(t *testing.T, ctx context.Context, kdbg *krt.DebugHandler, client istiokube.CLIClient, xdsPort int) {
-		client.Kube().CoreV1().Namespaces().Create(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: "gwtest"}}, metav1.CreateOptions{})
-
-		err = client.ApplyYAMLContents("gwtest", `
-apiVersion: v1
-kind: Service
-metadata:
-  name: mcp
-  namespace: gwtest
-  labels:
-    app: mcp
-spec:
-  clusterIP: "10.0.0.11"
-  ports:
-    - name: http
-      port: 8080
-      targetPort: 8080
-      appProtocol: kgateway.dev/mcp
-  selector:
-    app: mcp
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: a2a
-  namespace: gwtest
-  labels:
-    app: a2a
-spec:
-  clusterIP: "10.0.0.12"
-  ports:
-    - name: http
-      port: 8081
-      targetPort: 8081
-      appProtocol: kgateway.dev/a2a
-  selector:
-    app: a2a
----
-kind: GatewayClass
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: agentgateway
-spec:
-  controllerName: kgateway.dev/kgateway
-  parametersRef:
-    group: gateway.kgateway.dev
-    kind: GatewayParameters
-    name: kgateway
-    namespace: default
----
-kind: GatewayParameters
-apiVersion: gateway.kgateway.dev/v1alpha1
-metadata:
-  name: kgateway
-spec:
-  selfManaged: {}
----
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: http-gw
-  namespace: gwtest
-spec:
-  gatewayClassName: agentgateway
-  listeners:
-  - protocol: kgateway.dev/mcp
-    port: 8080
-    name: mcp
-    allowedRoutes:
-      namespaces:
-        from: All
-  - protocol: kgateway.dev/a2a
-    port: 8081
-    name: a2a
-    allowedRoutes:
-      namespaces:
-        from: All
-`)
-
-		if err != nil {
-			t.Fatalf("failed to apply yamls: %v", err)
-		}
-
-		time.Sleep(time.Second / 2)
-
-		dumper := newAgentGatewayXdsDumper(t, ctx, xdsPort, "http-gw", "gwtest")
-		t.Cleanup(dumper.Close)
-		t.Cleanup(func() {
-			if t.Failed() {
-				logKrtState(t, fmt.Sprintf("krt state for failed test: %s", t.Name()), kdbg)
-			} else if os.Getenv("KGW_DUMP_KRT_ON_SUCCESS") == "true" {
-				logKrtState(t, fmt.Sprintf("krt state for successful test: %s", t.Name()), kdbg)
-			}
-		})
-
-		dump := dumper.DumpAgentGateway(t, ctx)
-		if len(dump.McpTargets) != 1 {
-			t.Fatalf("expected 1 mcp target config, got %d", len(dump.McpTargets))
-		}
-		if len(dump.A2ATargets) != 1 {
-			t.Fatalf("expected 1 a2a target config, got %d", len(dump.A2ATargets))
-		}
-		if len(dump.Listeners) != 2 {
-			t.Fatalf("expected 2 listener config, got %d", len(dump.Listeners))
-		}
-		t.Logf("%s finished", t.Name())
-	})
-}
-
-func TestAgentGatewayAllowedRoutes(t *testing.T) {
-	st, err := settings.BuildSettings()
-	st.EnableAgentGateway = true
-
-	if err != nil {
-		t.Fatalf("can't get settings %v", err)
-	}
-	setupEnvTestAndRun(t, st, func(t *testing.T, ctx context.Context, kdbg *krt.DebugHandler, client istiokube.CLIClient, xdsPort int) {
-		client.Kube().CoreV1().Namespaces().Create(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: "gwtest"}}, metav1.CreateOptions{})
-
-		err = client.ApplyYAMLContents("", `
-apiVersion: v1
-kind: Namespace
-metadata:
-  name: othernamespace
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: mcp-other
-  namespace: othernamespace
-  labels:
-    app: mcp-other
-spec:
-  clusterIP: "10.0.0.11"
-  ports:
-    - name: http
-      port: 8080
-      targetPort: 8080
-      appProtocol: kgateway.dev/mcp
-  selector:
-    app: mcp-other
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: a2a-other
-  namespace: othernamespace
-  labels:
-    app: a2a-other
-spec:
-  clusterIP: "10.0.0.12"
-  ports:
-    - name: http
-      port: 8081
-      targetPort: 8081
-      appProtocol: kgateway.dev/a2a
-  selector:
-    app: a2a-other
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: mcp-allowed
-  namespace: gwtest
-  labels:
-    app: mcp-allowed
-spec:
-  clusterIP: "10.0.0.13"
-  ports:
-    - name: http
-      port: 8080
-      targetPort: 8080
-      appProtocol: kgateway.dev/mcp
-  selector:
-    app: mcp-allowed
----
-apiVersion: v1
-kind: Service
-metadata:
-  name: a2a-allowed
-  namespace: gwtest
-  labels:
-    app: a2a-allowed
-spec:
-  clusterIP: "10.0.0.14"
-  ports:
-    - name: http
-      port: 8081
-      targetPort: 8081
-      appProtocol: kgateway.dev/a2a
-  selector:
-    app: a2a-allowed
----
-kind: GatewayParameters
-apiVersion: gateway.kgateway.dev/v1alpha1
-metadata:
-  name: kgateway
-  namespace: gwtest
-spec:
-  kube:
-    agentGateway:
-      enabled: true
----
-kind: GatewayClass
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: agentgateway
-  namespace: gwtest
-spec:
-  controllerName: kgateway.dev/kgateway
-  parametersRef:
-    group: gateway.kgateway.dev
-    kind: GatewayParameters
-    name: kgateway
-    namespace: gwtest
----
-kind: Gateway
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: http-gw
-  namespace: gwtest
-spec:
-  gatewayClassName: agentgateway
-  listeners:
-  - protocol: kgateway.dev/mcp
-    port: 8080
-    name: mcp
-    allowedRoutes:
-      namespaces:
-        from: Same
-  - protocol: kgateway.dev/a2a
-    port: 8081
-    name: a2a
-    allowedRoutes:
-      namespaces:
-        from: Same
-`)
-
-		if err != nil {
-			t.Fatalf("failed to apply yamls: %v", err)
-		}
-
-		time.Sleep(time.Second / 2)
-
-		dumper := newAgentGatewayXdsDumper(t, ctx, xdsPort, "http-gw", "gwtest")
-		t.Cleanup(dumper.Close)
-		t.Cleanup(func() {
-			if t.Failed() {
-				logKrtState(t, fmt.Sprintf("krt state for failed test: %s", t.Name()), kdbg)
-			} else if os.Getenv("KGW_DUMP_KRT_ON_SUCCESS") == "true" {
-				logKrtState(t, fmt.Sprintf("krt state for successful test: %s", t.Name()), kdbg)
-			}
-		})
-
-		dump := dumper.DumpAgentGateway(t, ctx)
-		if len(dump.McpTargets) != 2 {
-			t.Fatalf("expected 2 mcp target config, got %d", len(dump.McpTargets))
-		}
-		for _, mcpTarget := range dump.McpTargets {
-			// same namespace should have mcp listener
-			if strings.Contains(mcpTarget.Name, "mcp-allowed") {
-				if len(mcpTarget.Listeners) != 1 {
-					t.Fatalf("expected mcp target to have 1 listener, got %v", mcpTarget.Listeners)
-				}
-				if mcpTarget.Listeners[0] != "mcp" {
-					t.Fatalf("expected mcp target to have listener mcp, got %s", mcpTarget.Listeners[0])
-				}
-			} else {
-				if len(mcpTarget.Listeners) != 0 {
-					t.Fatalf("expected mcp target to not have listeners, got %v", mcpTarget.Listeners)
-				}
-			}
-		}
-		if len(dump.A2ATargets) != 2 {
-			t.Fatalf("expected 2 a2a target config, got %d", len(dump.A2ATargets))
-		}
-		for _, a2aTarget := range dump.A2ATargets {
-			// same namespace should have a2a listener
-			if strings.Contains(a2aTarget.Name, "a2a-allowed") {
-				if len(a2aTarget.Listeners) != 1 {
-					t.Fatalf("expected mcp target to have 1 listener, got %v", a2aTarget.Listeners)
-				}
-				if a2aTarget.Listeners[0] != "a2a" {
-					t.Fatalf("expected a2a target to have listener mcp, got %s", a2aTarget.Listeners[0])
-				}
-			} else {
-				if len(a2aTarget.Listeners) != 0 {
-					t.Fatalf("expected a2a target to not have listeners, got %v", a2aTarget.Listeners)
-				}
-			}
-		}
-		if len(dump.Listeners) != 2 {
-			t.Fatalf("expected 2 listener config, got %d", len(dump.Listeners))
-		}
-		t.Logf("%s finished", t.Name())
-	})
-}
diff --git a/internal/kgateway/setup/setup_test.go b/internal/kgateway/setup/setup_test.go
index 2d216476b..d56746317 100644
--- a/internal/kgateway/setup/setup_test.go
+++ b/internal/kgateway/setup/setup_test.go
@@ -17,9 +17,6 @@ import (
 	"testing"
 	"time"
 
-	agentgateway "github.com/agentgateway/agentgateway/go/api"
-	"github.com/agentgateway/agentgateway/go/api/a2a"
-	"github.com/agentgateway/agentgateway/go/api/mcp"
 	envoycluster "github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3"
 	envoycore "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
 	envoyendpoint "github.com/envoyproxy/go-control-plane/envoy/config/endpoint/v3"
@@ -48,9 +45,8 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/log"
 	"sigs.k8s.io/yaml"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/settings"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/proxy_syncer"
-	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 	"github.com/kgateway-dev/kgateway/v2/test/envtestutil"
 )
 
@@ -173,7 +169,7 @@ func TestWithAutoDns(t *testing.T) {
 	if err != nil {
 		t.Fatalf("can't get settings %v", err)
 	}
-	st.DnsLookupFamily = settings.DnsLookupFamilyAuto
+	st.DnsLookupFamily = "AUTO"
 
 	runScenario(t, "testdata/autodns", st)
 }
@@ -512,188 +508,6 @@ func newXdsDumper(t *testing.T, ctx context.Context, xdsPort int, gwname string)
 	return d
 }
 
-func newAgentGatewayXdsDumper(t *testing.T, ctx context.Context, xdsPort int, gwname, gwnamespace string) xdsDumper {
-	conn, err := grpc.NewClient(fmt.Sprintf("localhost:%d", xdsPort),
-		grpc.WithTransportCredentials(insecure.NewCredentials()),
-		grpc.WithIdleTimeout(time.Second*10),
-	)
-	if err != nil {
-		t.Fatalf("failed to connect to xds server: %v", err)
-	}
-
-	d := xdsDumper{
-		conn: conn,
-		dr: &discovery_v3.DiscoveryRequest{
-			Node: &envoycore.Node{
-				Id: "gateway.gwtest",
-				Metadata: &structpb.Struct{
-					Fields: map[string]*structpb.Value{
-						"role": structpb.NewStringValue(fmt.Sprintf("%s~%s~%s", agentgatewaysyncer.OwnerNodeId, gwnamespace, gwname)),
-					},
-				},
-			},
-		},
-	}
-
-	ads := discovery_v3.NewAggregatedDiscoveryServiceClient(d.conn)
-	ctx, cancel := context.WithTimeout(ctx, time.Second*30) // long timeout - just in case. we should never reach it.
-	adsClient, err := ads.StreamAggregatedResources(ctx)
-	if err != nil {
-		t.Fatalf("failed to get ads client: %v", err)
-	}
-	d.adsClient = adsClient
-	d.cancel = cancel
-
-	return d
-}
-
-type agentGwDump struct {
-	A2ATargets []*a2a.Target
-	McpTargets []*mcp.Target
-	Listeners  []*agentgateway.Listener
-}
-
-func (x xdsDumper) DumpAgentGateway(t *testing.T, ctx context.Context) agentGwDump {
-	// get a2a targets
-	a2aTargets := x.GetA2ATargets(t, ctx)
-	// get mcp targets
-	mcpTargets := x.GetMcpTargets(t, ctx)
-	// get listeners
-	listeners := x.GetListeners(t, ctx)
-
-	return agentGwDump{
-		A2ATargets: a2aTargets,
-		McpTargets: mcpTargets,
-		Listeners:  listeners,
-	}
-}
-
-func (x xdsDumper) GetA2ATargets(t *testing.T, ctx context.Context) []*a2a.Target {
-	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
-	dr.TypeUrl = agentgatewaysyncer.TargetTypeA2AUrl
-	x.adsClient.Send(dr)
-	var a2aTargets []*a2a.Target
-	// run this in parallel with a 5s timeout
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		sent := 1
-		for i := 0; i < sent; i++ {
-			dresp, err := x.adsClient.Recv()
-			if err != nil {
-				t.Errorf("failed to get response from xds server: %v", err)
-			}
-			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
-			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeA2AUrl {
-				for _, anyResource := range dresp.GetResources() {
-					var target a2a.Target
-					if err := anyResource.UnmarshalTo(&target); err != nil {
-						t.Errorf("failed to unmarshal target: %v", err)
-					}
-					a2aTargets = append(a2aTargets, &target)
-				}
-			}
-		}
-	}()
-	select {
-	case <-done:
-	case <-time.After(5 * time.Second):
-		// don't fatal yet as we want to dump the state while still connected
-		t.Error("timed out waiting for targets for a2a xds dump")
-		return nil
-	}
-	if len(a2aTargets) == 0 {
-		t.Error("no a2a targets found")
-		return nil
-	}
-	t.Logf("xds: found %d a2a targets", len(a2aTargets))
-	return a2aTargets
-}
-
-func (x xdsDumper) GetMcpTargets(t *testing.T, ctx context.Context) []*mcp.Target {
-	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
-	dr.TypeUrl = agentgatewaysyncer.TargetTypeMcpUrl
-	x.adsClient.Send(dr)
-	var mcpTargets []*mcp.Target
-	// run this in parallel with a 5s timeout
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		sent := 1
-		for i := 0; i < sent; i++ {
-			dresp, err := x.adsClient.Recv()
-			if err != nil {
-				t.Errorf("failed to get response from xds server: %v", err)
-			}
-			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
-			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeMcpUrl {
-				for _, anyResource := range dresp.GetResources() {
-					var target mcp.Target
-					if err := anyResource.UnmarshalTo(&target); err != nil {
-						t.Errorf("failed to unmarshal target: %v", err)
-					}
-					mcpTargets = append(mcpTargets, &target)
-				}
-			}
-		}
-	}()
-	select {
-	case <-done:
-	case <-time.After(5 * time.Second):
-		// don't fatal yet as we want to dump the state while still connected
-		t.Error("timed out waiting for targets for mcp xds dump")
-		return nil
-	}
-	if len(mcpTargets) == 0 {
-		t.Error("no mcp targets found")
-		return nil
-	}
-	t.Logf("xds: found %d mcp targets", len(mcpTargets))
-	return mcpTargets
-}
-
-func (x xdsDumper) GetListeners(t *testing.T, ctx context.Context) []*agentgateway.Listener {
-	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
-	dr.TypeUrl = agentgatewaysyncer.TargetTypeListenerUrl
-	x.adsClient.Send(dr)
-	var listeners []*agentgateway.Listener
-	// run this in parallel with a 5s timeout
-	done := make(chan struct{})
-	go func() {
-		defer close(done)
-		sent := 1
-		for i := 0; i < sent; i++ {
-			dresp, err := x.adsClient.Recv()
-			if err != nil {
-				t.Errorf("failed to get response from xds server: %v", err)
-			}
-			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
-			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeListenerUrl {
-				for _, anyResource := range dresp.GetResources() {
-					var listener agentgateway.Listener
-					if err := anyResource.UnmarshalTo(&listener); err != nil {
-						t.Errorf("failed to unmarshal target: %v", err)
-					}
-					listeners = append(listeners, &listener)
-				}
-			}
-		}
-	}()
-	select {
-	case <-done:
-	case <-time.After(5 * time.Second):
-		// don't fatal yet as we want to dump the state while still connected
-		t.Error("timed out waiting for listeners for xds dump")
-		return nil
-	}
-	if len(listeners) == 0 {
-		t.Error("no listeners found")
-		return nil
-	}
-	t.Logf("xds: found %d listeners", len(listeners))
-	return listeners
-}
-
 func (x xdsDumper) Dump(t *testing.T, ctx context.Context) (xdsDump, error) {
 	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
 	dr.TypeUrl = "type.googleapis.com/envoy.config.cluster.v3.Cluster"
-- 
2.39.5 (Apple Git-154)


From 4a23b0a1f41e2fcca4f0ecefb3346b50ece990af Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 07:39:33 -0700
Subject: [PATCH 02/17] wip

---
 pkg/client/clientset/versioned/clientset.go                | 3 +--
 pkg/client/clientset/versioned/fake/register.go            | 3 +--
 pkg/client/clientset/versioned/scheme/register.go          | 3 +--
 .../clientset/versioned/typed/api/v1alpha1/api_client.go   | 3 +--
 .../clientset/versioned/typed/api/v1alpha1/backend.go      | 7 +++----
 .../versioned/typed/api/v1alpha1/backendconfigpolicy.go    | 7 +++----
 .../versioned/typed/api/v1alpha1/directresponse.go         | 7 +++----
 .../versioned/typed/api/v1alpha1/fake/fake_api_client.go   | 3 +--
 .../versioned/typed/api/v1alpha1/fake/fake_backend.go      | 3 +--
 .../typed/api/v1alpha1/fake/fake_backendconfigpolicy.go    | 3 +--
 .../typed/api/v1alpha1/fake/fake_directresponse.go         | 3 +--
 .../typed/api/v1alpha1/fake/fake_gatewayextension.go       | 3 +--
 .../typed/api/v1alpha1/fake/fake_gatewayparameters.go      | 3 +--
 .../typed/api/v1alpha1/fake/fake_httplistenerpolicy.go     | 3 +--
 .../typed/api/v1alpha1/fake/fake_trafficpolicy.go          | 3 +--
 .../versioned/typed/api/v1alpha1/gatewayextension.go       | 7 +++----
 .../versioned/typed/api/v1alpha1/gatewayparameters.go      | 7 +++----
 .../versioned/typed/api/v1alpha1/httplistenerpolicy.go     | 7 +++----
 .../versioned/typed/api/v1alpha1/trafficpolicy.go          | 7 +++----
 19 files changed, 33 insertions(+), 52 deletions(-)

diff --git a/pkg/client/clientset/versioned/clientset.go b/pkg/client/clientset/versioned/clientset.go
index 383394268..657495743 100644
--- a/pkg/client/clientset/versioned/clientset.go
+++ b/pkg/client/clientset/versioned/clientset.go
@@ -6,11 +6,10 @@ import (
 	fmt "fmt"
 	http "net/http"
 
+	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 	discovery "k8s.io/client-go/discovery"
 	rest "k8s.io/client-go/rest"
 	flowcontrol "k8s.io/client-go/util/flowcontrol"
-
-	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 )
 
 type Interface interface {
diff --git a/pkg/client/clientset/versioned/fake/register.go b/pkg/client/clientset/versioned/fake/register.go
index cca1527a7..07654aded 100644
--- a/pkg/client/clientset/versioned/fake/register.go
+++ b/pkg/client/clientset/versioned/fake/register.go
@@ -3,13 +3,12 @@
 package fake
 
 import (
+	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	serializer "k8s.io/apimachinery/pkg/runtime/serializer"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
-
-	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 var scheme = runtime.NewScheme()
diff --git a/pkg/client/clientset/versioned/scheme/register.go b/pkg/client/clientset/versioned/scheme/register.go
index 80797f75c..29eef6163 100644
--- a/pkg/client/clientset/versioned/scheme/register.go
+++ b/pkg/client/clientset/versioned/scheme/register.go
@@ -3,13 +3,12 @@
 package scheme
 
 import (
+	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	serializer "k8s.io/apimachinery/pkg/runtime/serializer"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
-
-	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 var Scheme = runtime.NewScheme()
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
index 5145d2df3..93755431d 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
@@ -5,10 +5,9 @@ package v1alpha1
 import (
 	http "net/http"
 
-	rest "k8s.io/client-go/rest"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
+	rest "k8s.io/client-go/rest"
 )
 
 type GatewayV1alpha1Interface interface {
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go
index b89745996..8fa2933db 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go
@@ -5,14 +5,13 @@ package v1alpha1
 import (
 	context "context"
 
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
-
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // BackendsGetter has a method to return a BackendInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go
index 8f2334a71..0b6fb9918 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go
@@ -5,14 +5,13 @@ package v1alpha1
 import (
 	context "context"
 
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
-
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // BackendConfigPoliciesGetter has a method to return a BackendConfigPolicyInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go
index a23e9360f..bf2c2affc 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go
@@ -5,14 +5,13 @@ package v1alpha1
 import (
 	context "context"
 
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
-
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // DirectResponsesGetter has a method to return a DirectResponseInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go
index c9d2aa367..3c78200b4 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go
@@ -3,10 +3,9 @@
 package fake
 
 import (
+	v1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 	rest "k8s.io/client-go/rest"
 	testing "k8s.io/client-go/testing"
-
-	v1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 )
 
 type FakeGatewayV1alpha1 struct {
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go
index 1fa501faa..773f5d9a7 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go
@@ -3,11 +3,10 @@
 package fake
 
 import (
-	gentype "k8s.io/client-go/gentype"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
+	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeBackends implements BackendInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go
index 26cb4a939..cf732d330 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go
@@ -3,11 +3,10 @@
 package fake
 
 import (
-	gentype "k8s.io/client-go/gentype"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
+	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeBackendConfigPolicies implements BackendConfigPolicyInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go
index 83a9c87d5..02825770b 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go
@@ -3,11 +3,10 @@
 package fake
 
 import (
-	gentype "k8s.io/client-go/gentype"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
+	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeDirectResponses implements DirectResponseInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go
index 711f46f35..37312c1e5 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go
@@ -3,11 +3,10 @@
 package fake
 
 import (
-	gentype "k8s.io/client-go/gentype"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
+	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeGatewayExtensions implements GatewayExtensionInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go
index d2ba16ea9..ca41c4fee 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go
@@ -3,11 +3,10 @@
 package fake
 
 import (
-	gentype "k8s.io/client-go/gentype"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
+	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeGatewayParameterses implements GatewayParametersInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go
index 2aa6e09b0..d463a8733 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go
@@ -3,11 +3,10 @@
 package fake
 
 import (
-	gentype "k8s.io/client-go/gentype"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
+	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeHTTPListenerPolicies implements HTTPListenerPolicyInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go
index 0ebaa2a19..f119c271d 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go
@@ -3,11 +3,10 @@
 package fake
 
 import (
-	gentype "k8s.io/client-go/gentype"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
+	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeTrafficPolicies implements TrafficPolicyInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go
index c8c1fd535..637bc7752 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go
@@ -5,14 +5,13 @@ package v1alpha1
 import (
 	context "context"
 
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
-
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // GatewayExtensionsGetter has a method to return a GatewayExtensionInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go
index c4db750a1..066fd0635 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go
@@ -5,14 +5,13 @@ package v1alpha1
 import (
 	context "context"
 
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
-
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // GatewayParametersesGetter has a method to return a GatewayParametersInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go
index 415171c6f..365bbc6e7 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go
@@ -5,14 +5,13 @@ package v1alpha1
 import (
 	context "context"
 
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
-
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // HTTPListenerPoliciesGetter has a method to return a HTTPListenerPolicyInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go
index ad5242ca8..750779b73 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go
@@ -5,14 +5,13 @@ package v1alpha1
 import (
 	context "context"
 
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
-
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // TrafficPoliciesGetter has a method to return a TrafficPolicyInterface.
-- 
2.39.5 (Apple Git-154)


From a45db7c98066cde83e8fe439b68836a70370e3f6 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 07:40:34 -0700
Subject: [PATCH 03/17] wip

---
 .../api/v1alpha1/awsauth.go                   |    3 +-
 .../api/v1alpha1/backend.go                   |    5 +-
 .../api/v1alpha1/backendconfigpolicy.go       |    5 +-
 .../api/v1alpha1/directresponse.go            |    5 +-
 .../api/v1alpha1/extauthpolicy.go             |    3 +-
 .../api/v1alpha1/gatewayextension.go          |    5 +-
 .../api/v1alpha1/gatewayparameters.go         |    5 +-
 .../api/v1alpha1/httplistenerpolicy.go        |    5 +-
 .../api/v1alpha1/loadbalancer.go              |    3 +-
 .../api/v1alpha1/service.go                   |    3 +-
 .../api/v1alpha1/singleauthtoken.go           |    3 +-
 .../api/v1alpha1/trafficpolicy.go             |    5 +-
 api/applyconfiguration/utils.go               |    7 +-
 go.mod                                        |    2 +-
 go.sum                                        |    4 +-
 .../agentgatewaysyncer/gateway/adp.go         |   94 +-
 .../agentgatewaysyncer/gateway/conditions.go  |  189 +-
 .../agentgatewaysyncer/gateway/controller.go  |  429 ++--
 .../agentgatewaysyncer/gateway/conversion.go  |  253 +--
 .../gateway/gateway_collection.go             |  137 +-
 .../gateway/gatewayclass_collection.go        |   17 +-
 .../agentgatewaysyncer/gateway/model.go       | 1775 +++++++++++++++++
 .../gateway/references_collection.go          |    2 +-
 .../gateway/route_collections.go              |  307 +--
 .../kgateway/agentgatewaysyncer/syncer.go     |  141 +-
 internal/kgateway/query/mocks/mock_queries.go |    5 +-
 26 files changed, 2398 insertions(+), 1014 deletions(-)

diff --git a/api/applyconfiguration/api/v1alpha1/awsauth.go b/api/applyconfiguration/api/v1alpha1/awsauth.go
index 6ec76eb77..02689bc08 100644
--- a/api/applyconfiguration/api/v1alpha1/awsauth.go
+++ b/api/applyconfiguration/api/v1alpha1/awsauth.go
@@ -3,9 +3,8 @@
 package v1alpha1
 
 import (
-	v1 "k8s.io/api/core/v1"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	v1 "k8s.io/api/core/v1"
 )
 
 // AwsAuthApplyConfiguration represents a declarative configuration of the AwsAuth type for use
diff --git a/api/applyconfiguration/api/v1alpha1/backend.go b/api/applyconfiguration/api/v1alpha1/backend.go
index 467cd9f59..2f0e01292 100644
--- a/api/applyconfiguration/api/v1alpha1/backend.go
+++ b/api/applyconfiguration/api/v1alpha1/backend.go
@@ -3,13 +3,12 @@
 package v1alpha1
 
 import (
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
-
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // BackendApplyConfiguration represents a declarative configuration of the Backend type for use
diff --git a/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go b/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go
index 7b80b4d32..95912d942 100644
--- a/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go
@@ -3,14 +3,13 @@
 package v1alpha1
 
 import (
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
 	v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
-
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // BackendConfigPolicyApplyConfiguration represents a declarative configuration of the BackendConfigPolicy type for use
diff --git a/api/applyconfiguration/api/v1alpha1/directresponse.go b/api/applyconfiguration/api/v1alpha1/directresponse.go
index 280fea8c1..655c042ba 100644
--- a/api/applyconfiguration/api/v1alpha1/directresponse.go
+++ b/api/applyconfiguration/api/v1alpha1/directresponse.go
@@ -3,13 +3,12 @@
 package v1alpha1
 
 import (
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
-
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // DirectResponseApplyConfiguration represents a declarative configuration of the DirectResponse type for use
diff --git a/api/applyconfiguration/api/v1alpha1/extauthpolicy.go b/api/applyconfiguration/api/v1alpha1/extauthpolicy.go
index 37b993ddf..a8f061ee8 100644
--- a/api/applyconfiguration/api/v1alpha1/extauthpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/extauthpolicy.go
@@ -3,9 +3,8 @@
 package v1alpha1
 
 import (
-	v1 "k8s.io/api/core/v1"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	v1 "k8s.io/api/core/v1"
 )
 
 // ExtAuthPolicyApplyConfiguration represents a declarative configuration of the ExtAuthPolicy type for use
diff --git a/api/applyconfiguration/api/v1alpha1/gatewayextension.go b/api/applyconfiguration/api/v1alpha1/gatewayextension.go
index 2b592e530..461eb2d62 100644
--- a/api/applyconfiguration/api/v1alpha1/gatewayextension.go
+++ b/api/applyconfiguration/api/v1alpha1/gatewayextension.go
@@ -3,13 +3,12 @@
 package v1alpha1
 
 import (
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
-
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // GatewayExtensionApplyConfiguration represents a declarative configuration of the GatewayExtension type for use
diff --git a/api/applyconfiguration/api/v1alpha1/gatewayparameters.go b/api/applyconfiguration/api/v1alpha1/gatewayparameters.go
index 40f16258a..8d5277208 100644
--- a/api/applyconfiguration/api/v1alpha1/gatewayparameters.go
+++ b/api/applyconfiguration/api/v1alpha1/gatewayparameters.go
@@ -3,13 +3,12 @@
 package v1alpha1
 
 import (
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
-
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // GatewayParametersApplyConfiguration represents a declarative configuration of the GatewayParameters type for use
diff --git a/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go b/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go
index e16e41b38..e498eebe7 100644
--- a/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go
@@ -3,14 +3,13 @@
 package v1alpha1
 
 import (
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
 	v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
-
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // HTTPListenerPolicyApplyConfiguration represents a declarative configuration of the HTTPListenerPolicy type for use
diff --git a/api/applyconfiguration/api/v1alpha1/loadbalancer.go b/api/applyconfiguration/api/v1alpha1/loadbalancer.go
index 97e3a905a..ef46aa1f1 100644
--- a/api/applyconfiguration/api/v1alpha1/loadbalancer.go
+++ b/api/applyconfiguration/api/v1alpha1/loadbalancer.go
@@ -3,9 +3,8 @@
 package v1alpha1
 
 import (
-	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 )
 
 // LoadBalancerApplyConfiguration represents a declarative configuration of the LoadBalancer type for use
diff --git a/api/applyconfiguration/api/v1alpha1/service.go b/api/applyconfiguration/api/v1alpha1/service.go
index f4d546ace..257ec8246 100644
--- a/api/applyconfiguration/api/v1alpha1/service.go
+++ b/api/applyconfiguration/api/v1alpha1/service.go
@@ -3,9 +3,8 @@
 package v1alpha1
 
 import (
-	v1 "k8s.io/api/core/v1"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	v1 "k8s.io/api/core/v1"
 )
 
 // ServiceApplyConfiguration represents a declarative configuration of the Service type for use
diff --git a/api/applyconfiguration/api/v1alpha1/singleauthtoken.go b/api/applyconfiguration/api/v1alpha1/singleauthtoken.go
index 6e65af715..2747befc3 100644
--- a/api/applyconfiguration/api/v1alpha1/singleauthtoken.go
+++ b/api/applyconfiguration/api/v1alpha1/singleauthtoken.go
@@ -3,9 +3,8 @@
 package v1alpha1
 
 import (
-	v1 "k8s.io/api/core/v1"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	v1 "k8s.io/api/core/v1"
 )
 
 // SingleAuthTokenApplyConfiguration represents a declarative configuration of the SingleAuthToken type for use
diff --git a/api/applyconfiguration/api/v1alpha1/trafficpolicy.go b/api/applyconfiguration/api/v1alpha1/trafficpolicy.go
index bfc34f877..7fc71076f 100644
--- a/api/applyconfiguration/api/v1alpha1/trafficpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/trafficpolicy.go
@@ -3,14 +3,13 @@
 package v1alpha1
 
 import (
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
 	v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
-
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // TrafficPolicyApplyConfiguration represents a declarative configuration of the TrafficPolicy type for use
diff --git a/api/applyconfiguration/utils.go b/api/applyconfiguration/utils.go
index 407b61e5d..da00e29e8 100644
--- a/api/applyconfiguration/utils.go
+++ b/api/applyconfiguration/utils.go
@@ -3,13 +3,12 @@
 package applyconfiguration
 
 import (
-	runtime "k8s.io/apimachinery/pkg/runtime"
-	schema "k8s.io/apimachinery/pkg/runtime/schema"
-	testing "k8s.io/client-go/testing"
-
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+	schema "k8s.io/apimachinery/pkg/runtime/schema"
+	testing "k8s.io/client-go/testing"
 )
 
 // ForKind returns an apply configuration type for the given GroupVersionKind, or nil if no
diff --git a/go.mod b/go.mod
index 0d9a91942..968ebe42b 100644
--- a/go.mod
+++ b/go.mod
@@ -624,7 +624,7 @@ require (
 )
 
 replace (
-	github.com/agentgateway/agentgateway => github.com/solo-io/agentgateway-enterprise v0.0.0-20250625151206-94c5ea602e02
+	github.com/agentgateway/agentgateway => github.com/solo-io/agentgateway-enterprise v0.0.0-20250626235044-bb6ced925fc3
 	github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
 )
 
diff --git a/go.sum b/go.sum
index 57183d0f2..1250a13da 100644
--- a/go.sum
+++ b/go.sum
@@ -1662,8 +1662,8 @@ github.com/smartystreets/goconvey v1.7.2/go.mod h1:Vw0tHAZW6lzCRk3xgdin6fKYcG+G3
 github.com/smartystreets/goconvey v1.8.1 h1:qGjIddxOk4grTu9JPOU31tVfq3cNdBlNa5sSznIX1xY=
 github.com/smartystreets/goconvey v1.8.1/go.mod h1:+/u4qLyY6x1jReYOp7GOM2FSt8aP9CzCZL03bI28W60=
 github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
-github.com/solo-io/agentgateway-enterprise v0.0.0-20250625151206-94c5ea602e02 h1:fneENV02KnjbI74pZQqHebBWQ7oanPA/5qQx/RuUrQk=
-github.com/solo-io/agentgateway-enterprise v0.0.0-20250625151206-94c5ea602e02/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
+github.com/solo-io/agentgateway-enterprise v0.0.0-20250626235044-bb6ced925fc3 h1:n/r6SAYyKQ8AcH8I6mLwDSNuk9nxmgyR94GVfwSbO14=
+github.com/solo-io/agentgateway-enterprise v0.0.0-20250626235044-bb6ced925fc3/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966 h1:MavIqMAvo9dxhcuN0/m7Ok830e7htfhR+JWRDqs3qj4=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966/go.mod h1:27GcajR+wxZ34COPvLp1+4hxGN66/GSx7SSjVn8LySY=
 github.com/solo-io/go-list-licenses v0.1.4 h1:u4xh1OUORT4iSWuAp3Q4NsfHcDaeUV8QRDH8ACQqbxw=
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/adp.go b/internal/kgateway/agentgatewaysyncer/gateway/adp.go
index a4fb3bcbf..099cd23f1 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/adp.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/adp.go
@@ -10,20 +10,19 @@ import (
 
 	"istio.io/istio/pkg/ptr"
 	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/workloadapi"
 )
 
 func createADPMethodMatch(match k8s.HTTPRouteMatch) (*api.MethodMatch, *ConfigError) {
 	if match.Method == nil {
 		return nil, nil
 	}
-	return &workloadapi.MethodMatch{
+	return &api.MethodMatch{
 		Exact: string(*match.Method),
 	}, nil
 }
 
-func createADPQueryMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.QueryMatch, *ConfigError) {
-	res := []*workloadapi.QueryMatch{}
+func createADPQueryMatch(match k8s.HTTPRouteMatch) ([]*api.QueryMatch, *ConfigError) {
+	res := []*api.QueryMatch{}
 	for _, header := range match.QueryParams {
 		tp := k8s.QueryParamMatchExact
 		if header.Type != nil {
@@ -31,14 +30,14 @@ func createADPQueryMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.QueryMatch, *
 		}
 		switch tp {
 		case k8s.QueryParamMatchExact:
-			res = append(res, &workloadapi.QueryMatch{
+			res = append(res, &api.QueryMatch{
 				Name:  string(header.Name),
-				Value: &workloadapi.QueryMatch_Exact{Exact: header.Value},
+				Value: &api.QueryMatch_Exact{Exact: header.Value},
 			})
 		case k8s.QueryParamMatchRegularExpression:
-			res = append(res, &workloadapi.QueryMatch{
+			res = append(res, &api.QueryMatch{
 				Name:  string(header.Name),
-				Value: &workloadapi.QueryMatch_Regex{Regex: header.Value},
+				Value: &api.QueryMatch_Regex{Regex: header.Value},
 			})
 		default:
 			// Should never happen, unless a new field is added
@@ -51,7 +50,7 @@ func createADPQueryMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.QueryMatch, *
 	return res, nil
 }
 
-func createADPPathMatch(match k8s.HTTPRouteMatch) (*workloadapi.PathMatch, *ConfigError) {
+func createADPPathMatch(match k8s.HTTPRouteMatch) (*api.PathMatch, *ConfigError) {
 	tp := k8s.PathMatchPathPrefix
 	if match.Path.Type != nil {
 		tp = *match.Path.Type
@@ -66,15 +65,15 @@ func createADPPathMatch(match k8s.HTTPRouteMatch) (*workloadapi.PathMatch, *Conf
 		if dest != "/" {
 			dest = strings.TrimSuffix(dest, "/")
 		}
-		return &workloadapi.PathMatch{Kind: &workloadapi.PathMatch_PathPrefix{
+		return &api.PathMatch{Kind: &api.PathMatch_PathPrefix{
 			PathPrefix: dest,
 		}}, nil
 	case k8s.PathMatchExact:
-		return &workloadapi.PathMatch{Kind: &workloadapi.PathMatch_Exact{
+		return &api.PathMatch{Kind: &api.PathMatch_Exact{
 			Exact: dest,
 		}}, nil
 	case k8s.PathMatchRegularExpression:
-		return &workloadapi.PathMatch{Kind: &workloadapi.PathMatch_Regex{
+		return &api.PathMatch{Kind: &api.PathMatch_Regex{
 			Regex: dest,
 		}}, nil
 	default:
@@ -83,8 +82,8 @@ func createADPPathMatch(match k8s.HTTPRouteMatch) (*workloadapi.PathMatch, *Conf
 	}
 }
 
-func createADPHeadersMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.HeaderMatch, *ConfigError) {
-	res := []*workloadapi.HeaderMatch{}
+func createADPHeadersMatch(match k8s.HTTPRouteMatch) ([]*api.HeaderMatch, *ConfigError) {
+	res := []*api.HeaderMatch{}
 	for _, header := range match.Headers {
 		tp := k8s.HeaderMatchExact
 		if header.Type != nil {
@@ -92,14 +91,14 @@ func createADPHeadersMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.HeaderMatch
 		}
 		switch tp {
 		case k8s.HeaderMatchExact:
-			res = append(res, &workloadapi.HeaderMatch{
+			res = append(res, &api.HeaderMatch{
 				Name:  string(header.Name),
-				Value: &workloadapi.HeaderMatch_Exact{Exact: header.Value},
+				Value: &api.HeaderMatch_Exact{Exact: header.Value},
 			})
 		case k8s.HeaderMatchRegularExpression:
-			res = append(res, &workloadapi.HeaderMatch{
+			res = append(res, &api.HeaderMatch{
 				Name:  string(header.Name),
-				Value: &workloadapi.HeaderMatch_Regex{Regex: header.Value},
+				Value: &api.HeaderMatch_Regex{Regex: header.Value},
 			})
 		default:
 			// Should never happen, unless a new field is added
@@ -113,13 +112,13 @@ func createADPHeadersMatch(match k8s.HTTPRouteMatch) ([]*workloadapi.HeaderMatch
 	return res, nil
 }
 
-func createADPHeadersFilter(filter *k8s.HTTPHeaderFilter) *workloadapi.RouteFilter {
+func createADPHeadersFilter(filter *k8s.HTTPHeaderFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
-	return &workloadapi.RouteFilter{
-		Kind: &workloadapi.RouteFilter_RequestHeaderModifier{
-			RequestHeaderModifier: &workloadapi.HeaderModifier{
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_RequestHeaderModifier{
+			RequestHeaderModifier: &api.HeaderModifier{
 				Add:    headerListToADP(filter.Add),
 				Set:    headerListToADP(filter.Set),
 				Remove: filter.Remove,
@@ -128,13 +127,13 @@ func createADPHeadersFilter(filter *k8s.HTTPHeaderFilter) *workloadapi.RouteFilt
 	}
 }
 
-func createADPResponseHeadersFilter(filter *k8s.HTTPHeaderFilter) *workloadapi.RouteFilter {
+func createADPResponseHeadersFilter(filter *k8s.HTTPHeaderFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
-	return &workloadapi.RouteFilter{
-		Kind: &workloadapi.RouteFilter_ResponseHeaderModifier{
-			ResponseHeaderModifier: &workloadapi.HeaderModifier{
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_ResponseHeaderModifier{
+			ResponseHeaderModifier: &api.HeaderModifier{
 				Add:    headerListToADP(filter.Add),
 				Set:    headerListToADP(filter.Set),
 				Remove: filter.Remove,
@@ -143,23 +142,23 @@ func createADPResponseHeadersFilter(filter *k8s.HTTPHeaderFilter) *workloadapi.R
 	}
 }
 
-func createADPRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *workloadapi.RouteFilter {
+func createADPRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
-	ff := &workloadapi.UrlRewrite{
+	ff := &api.UrlRewrite{
 		Host: string(ptr.OrEmpty(filter.Hostname)),
 	}
 	if filter.Path != nil {
 		switch filter.Path.Type {
 		case k8s.PrefixMatchHTTPPathModifier:
-			ff.Path = &workloadapi.UrlRewrite_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
+			ff.Path = &api.UrlRewrite_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
 		case k8s.FullPathHTTPPathModifier:
-			ff.Path = &workloadapi.UrlRewrite_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
+			ff.Path = &api.UrlRewrite_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
 		}
 	}
-	return &workloadapi.RouteFilter{
-		Kind: &workloadapi.RouteFilter_UrlRewrite{
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_UrlRewrite{
 			UrlRewrite: ff,
 		},
 	}
@@ -169,9 +168,8 @@ func createADPMirrorFilter(
 	ctx RouteContext,
 	filter *k8s.HTTPRequestMirrorFilter,
 	ns string,
-	enforceRefGrant bool,
 	k config.GroupVersionKind,
-) (*workloadapi.RouteFilter, *ConfigError) {
+) (*api.RouteFilter, *ConfigError) {
 	if filter == nil {
 		return nil, nil
 	}
@@ -181,7 +179,7 @@ func createADPMirrorFilter(
 			BackendObjectReference: filter.BackendRef,
 			Weight:                 &weightOne,
 		},
-	}, ns, enforceRefGrant, k)
+	}, ns, k)
 	if err != nil {
 		return nil, err
 	}
@@ -196,25 +194,25 @@ func createADPMirrorFilter(
 	if percent == 0 {
 		return nil, nil
 	}
-	rm := &workloadapi.RequestMirror{
+	rm := &api.RequestMirror{
 		Kind:       nil,
 		Percentage: percent,
 		Port:       dst.Port,
 	}
 	switch dk := dst.Kind.(type) {
-	case *workloadapi.RouteBackend_Service:
-		rm.Kind = &workloadapi.RequestMirror_Service{
+	case *api.RouteBackend_Service:
+		rm.Kind = &api.RequestMirror_Service{
 			Service: dk.Service,
 		}
 	}
-	return &workloadapi.RouteFilter{Kind: &workloadapi.RouteFilter_RequestMirror{RequestMirror: rm}}, nil
+	return &api.RouteFilter{Kind: &api.RouteFilter_RequestMirror{RequestMirror: rm}}, nil
 }
 
-func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *workloadapi.RouteFilter {
+func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
-	ff := &workloadapi.RequestRedirect{
+	ff := &api.RequestRedirect{
 		Scheme: ptr.OrEmpty(filter.Scheme),
 		Host:   string(ptr.OrEmpty(filter.Hostname)),
 		Port:   uint32(ptr.OrEmpty(filter.Port)),
@@ -223,21 +221,21 @@ func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *workloadapi
 	if filter.Path != nil {
 		switch filter.Path.Type {
 		case k8s.PrefixMatchHTTPPathModifier:
-			ff.Path = &workloadapi.RequestRedirect_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
+			ff.Path = &api.RequestRedirect_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
 		case k8s.FullPathHTTPPathModifier:
-			ff.Path = &workloadapi.RequestRedirect_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
+			ff.Path = &api.RequestRedirect_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
 		}
 	}
-	return &workloadapi.RouteFilter{
-		Kind: &workloadapi.RouteFilter_RequestRedirect{
+	return &api.RouteFilter{
+		Kind: &api.RouteFilter_RequestRedirect{
 			RequestRedirect: ff,
 		},
 	}
 }
 
-func headerListToADP(hl []k8s.HTTPHeader) []*workloadapi.Header {
-	return slices.Map(hl, func(hl k8s.HTTPHeader) *workloadapi.Header {
-		return &workloadapi.Header{
+func headerListToADP(hl []k8s.HTTPHeader) []*api.Header {
+	return slices.Map(hl, func(hl k8s.HTTPHeader) *api.Header {
+		return &api.Header{
 			Name:  string(hl.Name),
 			Value: hl.Value,
 		}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conditions.go b/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
index 16570fcdb..3765df1e5 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
@@ -1,33 +1,14 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 package gateway
 
 import (
-	"fmt"
-	"sort"
-
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	k8s "sigs.k8s.io/gateway-api/apis/v1"
 	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
 
-	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model/kstatus"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/maps"
 	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/util/sets"
 )
 
 // RouteParentResult holds the result of a route for a specific parent
@@ -38,158 +19,6 @@ type RouteParentResult struct {
 	DeniedReason *ParentError
 	// RouteError, if present, indicates why the reference was not valid
 	RouteError *ConfigError
-	// WaypointError, if present, indicates why the reference was does not have a waypoint
-	WaypointError *WaypointError
-}
-
-func createRouteStatus(parentResults []RouteParentResult, generation int64, currentParents []k8s.RouteParentStatus) []k8s.RouteParentStatus {
-	parents := make([]k8s.RouteParentStatus, 0, len(parentResults))
-	// Fill in all the gateways that are already present but not owned by us. This is non-trivial as there may be multiple
-	// gateway controllers that are exposing their status on the same route. We need to attempt to manage ours properly (including
-	// removing gateway references when they are removed), without mangling other Controller's status.
-	for _, r := range currentParents {
-		if r.ControllerName != k8s.GatewayController(features.ManagedGatewayController) {
-			// We don't own this status, so keep it around
-			parents = append(parents, r)
-		}
-	}
-	// Collect all of our unique parent references. There may be multiple when we have a route without section name,
-	// but reference a parent with multiple sections.
-	// While we process these internally for-each sectionName, in the status we are just supposed to report one merged entry
-	seen := map[k8s.ParentReference][]RouteParentResult{}
-	seenReasons := sets.New[ParentErrorReason]()
-	successCount := map[k8s.ParentReference]int{}
-	for _, incoming := range parentResults {
-		// We will append it if it is our first occurrence, or the existing one has an error. This means
-		// if *any* section has no errors, we will declare Admitted
-		if incoming.DeniedReason == nil {
-			successCount[incoming.OriginalReference]++
-		}
-		seen[incoming.OriginalReference] = append(seen[incoming.OriginalReference], incoming)
-		if incoming.DeniedReason != nil {
-			seenReasons.Insert(incoming.DeniedReason.Reason)
-		} else {
-			seenReasons.Insert(ParentNoError)
-		}
-	}
-
-	const (
-		rankParentNoErrors = iota
-		rankParentErrorNotAllowed
-		rankParentErrorNoHostname
-		rankParentErrorParentRefConflict
-		rankParentErrorNotAccepted
-	)
-
-	rankParentError := func(result RouteParentResult) int {
-		if result.DeniedReason == nil {
-			return rankParentNoErrors
-		}
-		switch result.DeniedReason.Reason {
-		case ParentErrorNotAllowed:
-			return rankParentErrorNotAllowed
-		case ParentErrorNoHostname:
-			return rankParentErrorNoHostname
-		case ParentErrorParentRefConflict:
-			return rankParentErrorParentRefConflict
-		case ParentErrorNotAccepted:
-			return rankParentErrorNotAccepted
-		}
-		return rankParentNoErrors
-	}
-
-	// Next we want to collapse these. We need to report 1 type of error, or none.
-	report := map[k8s.ParentReference]RouteParentResult{}
-	for ref, results := range seen {
-		if len(results) == 0 {
-			continue
-		}
-
-		toReport := results[0]
-		mostSevereRankSeen := rankParentError(toReport)
-
-		for _, result := range results[1:] {
-			resultRank := rankParentError(result)
-			// lower number means more severe
-			if resultRank < mostSevereRankSeen {
-				mostSevereRankSeen = resultRank
-				toReport = result
-			} else if resultRank == mostSevereRankSeen {
-				// join the error messages
-				if toReport.DeniedReason == nil {
-					toReport.DeniedReason = result.DeniedReason
-				} else {
-					toReport.DeniedReason.Message += "; " + result.DeniedReason.Message
-				}
-			}
-		}
-
-		report[ref] = toReport
-	}
-
-	// Now we fill in all the parents we do own
-	for k, gw := range report {
-		msg := "Route was valid"
-		if successCount[k] > 1 {
-			msg = fmt.Sprintf("Route was valid, bound to %d parents", successCount[k])
-		}
-		conds := map[string]*condition{
-			string(k8s.RouteConditionAccepted): {
-				reason:  string(k8s.RouteReasonAccepted),
-				message: msg,
-			},
-			string(k8s.RouteConditionResolvedRefs): {
-				reason:  string(k8s.RouteReasonResolvedRefs),
-				message: "All references resolved",
-			},
-		}
-		if gw.RouteError != nil {
-			// Currently, the spec is not clear on where errors should be reported. The provided resources are:
-			// * Accepted - used to describe errors binding to parents
-			// * ResolvedRefs - used to describe errors about binding to objects
-			// But no general errors
-			// For now, we will treat all general route errors as "Ref" errors.
-			conds[string(k8s.RouteConditionResolvedRefs)].error = gw.RouteError
-		}
-		if gw.DeniedReason != nil {
-			conds[string(k8s.RouteConditionAccepted)].error = &ConfigError{
-				Reason:  ConfigErrorReason(gw.DeniedReason.Reason),
-				Message: gw.DeniedReason.Message,
-			}
-		}
-
-		// when ambient is enabled, report the waypoints resolved condition
-		if features.EnableAmbient {
-			cond := &condition{
-				reason:  string(RouteReasonResolvedWaypoints),
-				message: "All waypoints resolved",
-			}
-			if gw.WaypointError != nil {
-				cond.message = gw.WaypointError.Message
-			}
-			conds[string(RouteConditionResolvedWaypoints)] = cond
-		}
-
-		var currentConditions []metav1.Condition
-		currentStatus := slices.FindFunc(currentParents, func(s k8s.RouteParentStatus) bool {
-			return parentRefString(s.ParentRef) == parentRefString(gw.OriginalReference) &&
-				s.ControllerName == k8s.GatewayController(features.ManagedGatewayController)
-		})
-		if currentStatus != nil {
-			currentConditions = currentStatus.Conditions
-		}
-		parents = append(parents, k8s.RouteParentStatus{
-			ParentRef:      gw.OriginalReference,
-			ControllerName: k8s.GatewayController(features.ManagedGatewayController),
-			Conditions:     setConditions(generation, currentConditions, conds),
-		})
-	}
-	// Ensure output is deterministic.
-	// TODO: will we fight over other controllers doing similar (but not identical) ordering?
-	sort.SliceStable(parents, func(i, j int) bool {
-		return parentRefString(parents[i].ParentRef) > parentRefString(parents[j].ParentRef)
-	})
-	return parents
 }
 
 type ParentErrorReason string
@@ -233,15 +62,6 @@ const (
 	RouteReasonResolvedWaypoints    k8s.RouteConditionReason = "ResolvedWaypoints"
 )
 
-type WaypointErrorReason string
-
-const (
-	WaypointErrorReasonMissingLabel     = WaypointErrorReason("MissingUseWaypointLabel")
-	WaypointErrorMsgMissingLabel        = "istio.io/use-waypoint label missing from parent and parent namespace; in ambient mode, route will not be respected"
-	WaypointErrorReasonNoMatchingParent = WaypointErrorReason("NoMatchingParent")
-	WaypointErrorMsgNoMatchingParent    = "parent not found"
-)
-
 // ParentError represents that a parent could not be referenced
 type ParentError struct {
 	Reason  ParentErrorReason
@@ -254,11 +74,6 @@ type ConfigError struct {
 	Message string
 }
 
-type WaypointError struct {
-	Reason  WaypointErrorReason
-	Message string
-}
-
 type condition struct {
 	// reason defines the reason to report on success. Ignored if error is set
 	reason string
@@ -343,7 +158,7 @@ func reportListenerCondition(index int, l k8s.Listener, obj *k8sbeta.Gateway,
 }
 
 func generateSupportedKinds(l k8s.Listener) ([]k8s.RouteGroupKind, bool) {
-	supported := []k8s.RouteGroupKind{}
+	var supported []k8s.RouteGroupKind
 	switch l.Protocol {
 	case k8s.HTTPProtocolType, k8s.HTTPSProtocolType:
 		// Only terminate allowed, so its always HTTP
@@ -363,7 +178,7 @@ func generateSupportedKinds(l k8s.Listener) ([]k8s.RouteGroupKind, bool) {
 	}
 	if l.AllowedRoutes != nil && len(l.AllowedRoutes.Kinds) > 0 {
 		// We need to filter down to only ones we actually support
-		intersection := []k8s.RouteGroupKind{}
+		var intersection []k8s.RouteGroupKind
 		for _, s := range supported {
 			for _, kind := range l.AllowedRoutes.Kinds {
 				if routeGroupKindEqual(s, kind) {
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/controller.go b/internal/kgateway/agentgatewaysyncer/gateway/controller.go
index 9b10c5faf..76495cf34 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/controller.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/controller.go
@@ -18,19 +18,22 @@ import (
 	"fmt"
 	"strconv"
 
+	"github.com/agentgateway/agentgateway/go/api"
+	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"go.uber.org/atomic"
 	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/client-go/tools/cache"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
-	kubesecrets "istio.io/istio/pilot/pkg/credentials/kube"
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
 	"istio.io/istio/pilot/pkg/status"
 	"istio.io/istio/pkg/cluster"
@@ -39,17 +42,14 @@ import (
 	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/schema/gvr"
-	"istio.io/istio/pkg/config/schema/kind"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/kclient"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/kube/kubetypes"
 	istiolog "istio.io/istio/pkg/log"
-	"istio.io/istio/pkg/revisions"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/sets"
-	"istio.io/istio/pkg/workloadapi"
 )
 
 var log = istiolog.RegisterScope("gateway", "gateway-api controller")
@@ -80,31 +80,28 @@ type Controller struct {
 	// is only the case when we are the leader.
 	status *StatusCollections
 
-	waitForCRD func(class schema.GroupVersionResource, stop <-chan struct{}) bool
-
-	// gatewayContext exposes us to the internal Istio service registry. This is outside krt knowledge (currently), so,
-	// so we wrap it in a RecomputeProtected.
-	// Most usages in the API are directly referenced typed objects (Service, ServiceEntry, etc) so this is not needed typically.
-	gatewayContext krt.RecomputeProtected[*atomic.Pointer[GatewayContext]]
-	// tagWatcher allows us to check which tags are ours. Unlike most Istio codepaths, we read istio.io/rev=<tag> and not just
-	// revisions for Gateways. This is because a Gateway is sort of a mix of a Deployment and Config.
-	// Since the TagWatcher is not yet krt-aware, we wrap this in RecomputeProtected.
-	tagWatcher krt.RecomputeProtected[revisions.TagWatcher]
-
-	stop chan struct{}
-
-	xdsUpdater model.XDSUpdater
-
-	// Handlers tracks all registered handlers, so that syncing can be detected
-	handlers []krt.HandlerRegistration
-
 	// outputs contains all the output collections for this controller.
 	// Currently, the only usage of this controller is from non-krt things (PushContext) so this is not exposed directly.
 	// If desired in the future, it could be.
 	outputs Outputs
+
+	commonCols     *common.CommonCollections
+	controllerName string
+	xDS            krt.Collection[AgentGwXdsResources]
+	xdsCache       envoycache.SnapshotCache
+
+	waitForSync []cache.InformerSynced
 }
 
-func (c *Controller) Collection() krt.Collection[model.ADPResource] {
+type AgentGwXdsResources struct {
+	types.NamespacedName
+
+	reports   reports.ReportMap
+	Resources envoycache.Resources
+	Addresses envoycache.Resources
+}
+
+func (c *Controller) Collection() krt.Collection[ADPResource] {
 	return c.outputs.ADPResources
 }
 
@@ -114,7 +111,7 @@ type ParentInfo struct {
 }
 
 func (pi ParentInfo) ResourceName() string {
-	return pi.Key.Name // TODO!!!! more infoi and section name
+	return pi.Key.Name // TODO!!!! more info and section name
 }
 
 type TypedResource struct {
@@ -127,7 +124,7 @@ type Outputs struct {
 	VirtualServices krt.Collection[*config.Config]
 	ReferenceGrants ReferenceGrants
 
-	ADPResources krt.Collection[model.ADPResource]
+	ADPResources krt.Collection[ADPResource]
 }
 
 type Inputs struct {
@@ -147,39 +144,27 @@ type Inputs struct {
 	InferencePools  krt.Collection[*inf.InferencePool]
 }
 
-var _ model.GatewayController = &Controller{}
+var _ GatewayController = &Controller{}
 
 func NewController(
 	kc kube.Client,
-	waitForCRD func(class schema.GroupVersionResource, stop <-chan struct{}) bool,
 	options controller.Options,
-	xdsUpdater model.XDSUpdater,
 ) *Controller {
 	stop := make(chan struct{})
-	opts := krt.NewOptionsBuilder(stop, "gateway", options.KrtDebugger)
+	opts := krt.NewOptionsBuilder(stop, options.KrtDebugger)
 
-	tw := revisions.NewTagWatcher(kc, options.Revision)
 	c := &Controller{
-		client:         kc,
-		cluster:        options.ClusterID,
-		revision:       options.Revision,
-		status:         &StatusCollections{},
-		tagWatcher:     krt.NewRecomputeProtected(tw, false, opts.WithName("tagWatcher")...),
-		waitForCRD:     waitForCRD,
-		gatewayContext: krt.NewRecomputeProtected(atomic.NewPointer[GatewayContext](nil), false, opts.WithName("gatewayContext")...),
-		stop:           stop,
-		xdsUpdater:     xdsUpdater,
+		client:   kc,
+		cluster:  options.ClusterID,
+		revision: options.Revision,
 	}
-	tw.AddHandler(func(s sets.String) {
-		c.tagWatcher.TriggerRecomputation()
-	})
 
 	inputs := Inputs{
 		Namespaces: krt.NewInformer[*corev1.Namespace](kc, opts.WithName("informer/Namespaces")...),
 		Secrets: krt.WrapClient[*corev1.Secret](
 			kclient.NewFiltered[*corev1.Secret](kc, kubetypes.Filter{
-				FieldSelector: kubesecrets.SecretsFieldSelector,
-				ObjectFilter:  kc.ObjectFilter(),
+				//FieldSelector: kubesecrets.SecretsFieldSelector,
+				ObjectFilter: kc.ObjectFilter(),
 			}),
 			opts.WithName("informer/Secrets")...,
 		),
@@ -194,41 +179,41 @@ func NewController(
 
 		ReferenceGrants: buildClient[*gateway.ReferenceGrant](c, kc, gvr.ReferenceGrant, opts, "informer/ReferenceGrants"),
 		ServiceEntries:  buildClient[*networkingclient.ServiceEntry](c, kc, gvr.ServiceEntry, opts, "informer/ServiceEntries"),
-		InferencePools:  buildClient[*inf.InferencePool](c, kc, gvr.InferencePool, opts, "informer/InferencePools"),
+		//InferencePools:  buildClient[*inf.InferencePool](c, kc, gvr.InferencePool, opts, "informer/InferencePools"),
 	}
 	if features.EnableAlphaGatewayAPI {
 		inputs.TCPRoutes = buildClient[*gatewayalpha.TCPRoute](c, kc, gvr.TCPRoute, opts, "informer/TCPRoutes")
 		inputs.TLSRoutes = buildClient[*gatewayalpha.TLSRoute](c, kc, gvr.TLSRoute, opts, "informer/TLSRoutes")
 	} else {
 		// If disabled, still build a collection but make it always empty
-		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, nil, opts.WithName("disable/TCPRoutes")...)
-		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, nil, opts.WithName("disable/TLSRoutes")...)
+		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, opts.WithName("disable/TCPRoutes")...)
+		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, opts.WithName("disable/TLSRoutes")...)
 	}
 
-	handlers := []krt.HandlerRegistration{}
+	GatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, opts)
 
-	GatewayClassStatus, GatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, opts)
-	registerStatus(c, GatewayClassStatus)
+	RefGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, opts))
 
-	ReferenceGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, opts))
-
-	// GatewaysStatus cannot is not fully complete until its join with route attachments to report attachedRoutes.
+	// Note: not fully complete until its join with route attachments to report attachedRoutes.
 	// Do not register yet.
-	GatewaysStatus, Gateways := GatewayCollection(
+	Gateways := GatewayCollection(
 		inputs.Gateways,
 		GatewayClasses,
 		inputs.Namespaces,
-		ReferenceGrants,
+		RefGrants,
 		inputs.Secrets,
 		options.DomainSuffix,
-		c.gatewayContext,
-		c.tagWatcher,
 		opts,
 	)
-	ports := krt.NewIndex(Gateways, func(o Gateway) []string {
-		return []string{fmt.Sprint(o.parentInfo.Port)}
-	}).AsCollection(opts.WithName("PortBindings")...)
-	Binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object krt.IndexObject[string, Gateway]) []model.ADPResource {
+	ports := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
+		port := fmt.Sprint(obj.parentInfo.Port)
+		return &IndexObject[string, Gateway]{
+			Key:     port,
+			Objects: []Gateway{obj},
+		}
+	}, opts.WithName("ports")...)
+
+	Binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object IndexObject[string, Gateway]) []ADPResource {
 		port, _ := strconv.Atoi(object.Key)
 		uniq := sets.New[types.NamespacedName]()
 		for _, gw := range object.Objects {
@@ -237,9 +222,9 @@ func NewController(
 				Name:      gw.parent.Name,
 			})
 		}
-		return slices.Map(uniq.UnsortedList(), func(e types.NamespacedName) model.ADPResource {
+		return slices.Map(uniq.UnsortedList(), func(e types.NamespacedName) ADPResource {
 			bind := Bind{
-				Bind: &workloadapi.Bind{
+				Bind: &api.Bind{
 					Key:  object.Key + "/" + e.String(),
 					Port: uint32(port),
 				},
@@ -247,22 +232,9 @@ func NewController(
 			return toResource(e, bind)
 		})
 	}, opts.WithName("Binds")...)
-	WaypointBinds := krt.NewCollection(inputs.Gateways, func(ctx krt.HandlerContext, gw *gateway.Gateway) *model.ADPResource {
-		if gw.Spec.GatewayClassName != "istio-waypoint" {
-			return nil
-		}
-		port := 15008
-		e := config.NamespacedName(gw)
-		bind := Bind{
-			Bind: &workloadapi.Bind{
-				Key:  "waypoint/" + e.String(),
-				Port: uint32(port),
-			},
-		}
-		return toResourcep(e, bind)
-	}, opts.WithName("WaypointBinds")...)
-	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *model.ADPResource {
-		l := &workloadapi.Listener{
+
+	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *ADPResource {
+		l := &api.Listener{
 			Key:         obj.ResourceName(),
 			Name:        string(obj.parentInfo.SectionName),
 			BindKey:     fmt.Sprint(obj.parentInfo.Port) + "/" + obj.parent.Namespace + "/" + obj.parent.Name,
@@ -272,27 +244,27 @@ func NewController(
 
 		switch obj.parentInfo.Protocol {
 		case gatewayv1.HTTPProtocolType:
-			l.Protocol = workloadapi.Protocol_HTTP
+			l.Protocol = api.Protocol_HTTP
 		case gatewayv1.HTTPSProtocolType:
-			l.Protocol = workloadapi.Protocol_HTTPS
+			l.Protocol = api.Protocol_HTTPS
 			if obj.TLSInfo == nil {
 				return nil
 			}
-			l.Tls = &workloadapi.TLSConfig{
+			l.Tls = &api.TLSConfig{
 				Cert:       obj.TLSInfo.Cert,
 				PrivateKey: obj.TLSInfo.Key,
 			}
 		case gatewayv1.TLSProtocolType:
-			l.Protocol = workloadapi.Protocol_TLS
+			l.Protocol = api.Protocol_TLS
 			if obj.TLSInfo == nil {
 				return nil
 			}
-			l.Tls = &workloadapi.TLSConfig{
+			l.Tls = &api.TLSConfig{
 				Cert:       obj.TLSInfo.Cert,
 				PrivateKey: obj.TLSInfo.Key,
 			}
 		case gatewayv1.TCPProtocolType:
-			l.Protocol = workloadapi.Protocol_TCP
+			l.Protocol = api.Protocol_TCP
 		default:
 			return nil
 		}
@@ -301,37 +273,17 @@ func NewController(
 			Name:      obj.parent.Name,
 		}, ADPListener{l})
 	}, opts.WithName("Listeners")...)
-	WaypointListeners := krt.NewCollection(inputs.Gateways, func(ctx krt.HandlerContext, gw *gateway.Gateway) *model.ADPResource {
-		if gw.Spec.GatewayClassName != "istio-waypoint" {
-			return nil
-		}
 
-		e := config.NamespacedName(gw)
-		bind := ADPListener{
-			Listener: &workloadapi.Listener{
-				Key:         "waypoint/" + e.String(),
-				Name:        "waypoint/" + e.String(),
-				BindKey:     "waypoint/" + e.String(),
-				GatewayName: e.String(),
-				Hostname:    "",
-				Protocol:    workloadapi.Protocol_HBONE,
-				Tls:         nil,
-			},
-		}
-		return toResourcep(e, bind)
-	}, opts.WithName("WaypointListeners")...)
-
-	RouteParents := BuildRouteParents(Gateways)
+	routeParents := BuildRouteParents(Gateways)
 
 	routeInputs := RouteContextInputs{
-		Grants:          ReferenceGrants,
-		RouteParents:    RouteParents,
-		DomainSuffix:    options.DomainSuffix,
-		Services:        inputs.Services,
-		Namespaces:      inputs.Namespaces,
-		ServiceEntries:  inputs.ServiceEntries,
-		InferencePools:  inputs.InferencePools,
-		internalContext: c.gatewayContext,
+		Grants:         RefGrants,
+		RouteParents:   routeParents,
+		DomainSuffix:   options.DomainSuffix,
+		Services:       inputs.Services,
+		Namespaces:     inputs.Namespaces,
+		ServiceEntries: inputs.ServiceEntries,
+		InferencePools: inputs.InferencePools,
 	}
 	ADPRoutes := ADPRouteCollection(
 		inputs.HTTPRoutes,
@@ -355,82 +307,81 @@ func NewController(
 		routeInputs,
 		opts,
 	)
-	registerStatus(c, httpRoutes.Status)
-	status, _ := krt.NewStatusCollection(inputs.InferencePools, func(krtctx krt.HandlerContext, obj *inf.InferencePool) (
-		*inf.InferencePoolStatus,
-		*any,
-	) {
-		status := obj.Status.DeepCopy()
-		myGws := sets.New[types.NamespacedName]()
-		allGws := sets.New[types.NamespacedName]() // this is dumb but https://github.com/kubernetes-sigs/gateway-api-inference-extension/issues/942...
-		allGwsRaw := krt.Fetch(krtctx, inputs.Gateways)
-		for _, g := range allGwsRaw {
-			allGws.Insert(config.NamespacedName(g))
-			if string(g.Spec.GatewayClassName) == features.GatewayAPIDefaultGatewayClass {
-				myGws.Insert(config.NamespacedName(g))
-			}
-		}
-		seen := sets.New[types.NamespacedName]()
-		np := []inf.PoolStatus{}
-		for _, s := range status.Parents {
-			k := types.NamespacedName{
-				Name:      s.GatewayRef.Name,
-				Namespace: s.GatewayRef.Namespace,
-			}
-			if !allGws.Contains(k) {
-				// Even if it's not ours, delete stale ref. Shrug.
-				continue
-			}
-			if s.GatewayRef.Kind != gvk.KubernetesGateway.Kind {
-				np = append(np, s)
-				continue
-			}
-			if seen.Contains(k) {
-				continue
-			}
-			if !myGws.Contains(k) {
-				np = append(np, s)
-				continue
-			}
-			myGws.Delete(k)
-			seen.Insert(k)
-			conds := map[string]*condition{
-				string(inf.InferencePoolConditionAccepted): {
-					reason:  string(inf.InferencePoolReasonAccepted),
-					message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
-				},
-			}
-			np = append(np, inf.PoolStatus{
-				GatewayRef: corev1.ObjectReference{
-					APIVersion: gatewayv1.GroupVersion.String(),
-					Kind:       gvk.KubernetesGateway.Kind,
-					Namespace:  k.Namespace,
-					Name:       k.Name,
-				},
-				Conditions: setConditions(obj.Generation, s.Conditions, conds),
-			})
-		}
-		for _, k := range myGws.UnsortedList() {
-			conds := map[string]*condition{
-				string(inf.InferencePoolConditionAccepted): {
-					reason:  string(inf.InferencePoolReasonAccepted),
-					message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
-				},
-			}
-			np = append(np, inf.PoolStatus{
-				GatewayRef: corev1.ObjectReference{
-					APIVersion: gatewayv1.GroupVersion.String(),
-					Kind:       gvk.KubernetesGateway.Kind,
-					Namespace:  k.Namespace,
-					Name:       k.Name,
-				},
-				Conditions: setConditions(obj.Generation, nil, conds),
-			})
-		}
-		status.Parents = np
-		return status, nil
-	}, opts.WithName("InferencePools")...)
-	registerStatus(c, status)
+	//status, _ := krt.NewStatusCollection(inputs.InferencePools, func(krtctx krt.HandlerContext, obj *inf.InferencePool) (
+	//	*inf.InferencePoolStatus,
+	//	*any,
+	//) {
+	//	status := obj.Status.DeepCopy()
+	//	myGws := sets.New[types.NamespacedName]()
+	//	allGws := sets.New[types.NamespacedName]() // this is dumb but https://github.com/kubernetes-sigs/gateway-api-inference-extension/issues/942...
+	//	allGwsRaw := krt.Fetch(krtctx, inputs.Gateways)
+	//	for _, g := range allGwsRaw {
+	//		allGws.Insert(config.NamespacedName(g))
+	//		if string(g.Spec.GatewayClassName) == features.GatewayAPIDefaultGatewayClass {
+	//			myGws.Insert(config.NamespacedName(g))
+	//		}
+	//	}
+	//	seen := sets.New[types.NamespacedName]()
+	//	np := []inf.PoolStatus{}
+	//	for _, s := range status.Parents {
+	//		k := types.NamespacedName{
+	//			Name:      s.GatewayRef.Name,
+	//			Namespace: s.GatewayRef.Namespace,
+	//		}
+	//		if !allGws.Contains(k) {
+	//			// Even if it's not ours, delete stale ref. Shrug.
+	//			continue
+	//		}
+	//		if s.GatewayRef.Kind != gvk.KubernetesGateway.Kind {
+	//			np = append(np, s)
+	//			continue
+	//		}
+	//		if seen.Contains(k) {
+	//			continue
+	//		}
+	//		if !myGws.Contains(k) {
+	//			np = append(np, s)
+	//			continue
+	//		}
+	//		myGws.Delete(k)
+	//		seen.Insert(k)
+	//		conds := map[string]*condition{
+	//			string(inf.InferencePoolConditionAccepted): {
+	//				reason:  string(inf.InferencePoolReasonAccepted),
+	//				message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
+	//			},
+	//		}
+	//		np = append(np, inf.PoolStatus{
+	//			GatewayRef: corev1.ObjectReference{
+	//				APIVersion: gatewayv1.GroupVersion.String(),
+	//				Kind:       gvk.KubernetesGateway.Kind,
+	//				Namespace:  k.Namespace,
+	//				Name:       k.Name,
+	//			},
+	//			Conditions: setConditions(obj.Generation, s.Conditions, conds),
+	//		})
+	//	}
+	//	for _, k := range myGws.UnsortedList() {
+	//		conds := map[string]*condition{
+	//			string(inf.InferencePoolConditionAccepted): {
+	//				reason:  string(inf.InferencePoolReasonAccepted),
+	//				message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
+	//			},
+	//		}
+	//		np = append(np, inf.PoolStatus{
+	//			GatewayRef: corev1.ObjectReference{
+	//				APIVersion: gatewayv1.GroupVersion.String(),
+	//				Kind:       gvk.KubernetesGateway.Kind,
+	//				Namespace:  k.Namespace,
+	//				Name:       k.Name,
+	//			},
+	//			Conditions: setConditions(obj.Generation, nil, conds),
+	//		})
+	//	}
+	//	status.Parents = np
+	//	return status, nil
+	//}, opts.WithName("InferencePools")...)
+	//registerStatus(c, status)
 	//grpcRoutes := GRPCRouteCollection(
 	//	inputs.GRPCRoutes,
 	//	routeInputs,
@@ -438,21 +389,20 @@ func NewController(
 	//)
 	//registerStatus(c, grpcRoutes.Status)
 
-	RouteAttachments := krt.JoinCollection([]krt.Collection[*RouteAttachment]{
-		// tcpRoutes.RouteAttachments,
-		// tlsRoutes.RouteAttachments,
-		httpRoutes.RouteAttachments,
-		// grpcRoutes.RouteAttachments,
-	}, opts.WithName("RouteAttachments")...)
-	RouteAttachmentsIndex := krt.NewIndex(RouteAttachments, func(o *RouteAttachment) []GatewayAndListener {
-		return []GatewayAndListener{{
-			ListenerName: o.ListenerName,
-			To:           o.To,
-		}}
-	})
-
-	GatewayFinalStatus := FinalGatewayStatusCollection(GatewaysStatus, RouteAttachments, RouteAttachmentsIndex, opts)
-	registerStatus(c, GatewayFinalStatus)
+	//RouteAttachments := krt.JoinCollection([]krt.Collection[*RouteAttachment]{
+	//	// tcpRoutes.RouteAttachments,
+	//	// tlsRoutes.RouteAttachments,
+	//	httpRoutes.RouteAttachments,
+	//	// grpcRoutes.RouteAttachments,
+	//}, opts.WithName("RouteAttachments")...)
+	//RouteAttachmentsIndex := krt.NewIndex(RouteAttachments, func(o *RouteAttachment) []GatewayAndListener {
+	//	return []GatewayAndListener{{
+	//		ListenerName: o.ListenerName,
+	//		To:           o.To,
+	//	}}
+	//})
+	//
+	//GatewayFinal := FinalGatewayStatusCollection(RouteAttachments, RouteAttachmentsIndex, opts)
 
 	VirtualServices := krt.JoinCollection([]krt.Collection[*config.Config]{
 		// tcpRoutes.VirtualServices,
@@ -461,10 +411,10 @@ func NewController(
 		// grpcRoutes.VirtualServices,
 	}, opts.WithName("DerivedVirtualServices")...)
 
-	ADPResources := krt.JoinCollection([]krt.Collection[model.ADPResource]{Binds, WaypointBinds, Listeners, WaypointListeners, ADPRoutes}, opts.WithName("ADPResources")...)
+	ADPResources := krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, WaypointListeners, ADPRoutes}, opts.WithName("ADPResources")...)
 
 	outputs := Outputs{
-		ReferenceGrants: ReferenceGrants,
+		ReferenceGrants: RefGrants,
 		Gateways:        Gateways,
 		VirtualServices: VirtualServices,
 
@@ -472,40 +422,6 @@ func NewController(
 	}
 	c.outputs = outputs
 
-	handlers = append(handlers,
-		outputs.VirtualServices.RegisterBatch(pushXds(xdsUpdater,
-			func(t *config.Config) model.ConfigKey {
-				return model.ConfigKey{
-					Kind:      kind.VirtualService,
-					Name:      t.Name,
-					Namespace: t.Namespace,
-				}
-			}), false),
-		outputs.ADPResources.RegisterBatch(pushXds(xdsUpdater,
-			func(t model.ADPResource) model.ConfigKey {
-				return model.ConfigKey{
-					Kind: kind.ADP,
-					Name: t.ResourceName(),
-				}
-			}), false),
-		outputs.Gateways.RegisterBatch(pushXds(xdsUpdater,
-			func(t Gateway) model.ConfigKey {
-				return model.ConfigKey{
-					Kind:      kind.Gateway,
-					Name:      t.Name,
-					Namespace: t.Namespace,
-				}
-			}), false),
-		outputs.ReferenceGrants.collection.RegisterBatch(pushXds(xdsUpdater,
-			func(t ReferenceGrant) model.ConfigKey {
-				return model.ConfigKey{
-					Kind:      kind.KubernetesGateway,
-					Name:      t.Source.Name,
-					Namespace: t.Source.Namespace,
-				}
-			}), false))
-	c.handlers = handlers
-
 	return c
 }
 
@@ -572,7 +488,7 @@ func (c *Controller) SetStatusWrite(enabled bool, statusManager *status.Manager)
 }
 
 // Reconcile is called each time the `gatewayContext` may change. We use this to mark it as updated.
-func (c *Controller) Reconcile(ps *model.PushContext) {
+func (c *Controller) Reconcile(ps *PushContext) {
 	ctx := NewGatewayContext(ps, c.cluster)
 	c.gatewayContext.Modify(func(i **atomic.Pointer[GatewayContext]) {
 		(*i).Store(&ctx)
@@ -600,7 +516,7 @@ func (c *Controller) Delete(typ config.GroupVersionKind, name, namespace string,
 	return errUnsupportedOp
 }
 
-func (c *Controller) RegisterEventHandler(typ config.GroupVersionKind, handler model.EventHandler) {
+func (c *Controller) RegisterEventHandler(typ config.GroupVersionKind, handler EventHandler) {
 }
 
 func (c *Controller) Run(stop <-chan struct{}) {
@@ -643,16 +559,16 @@ func (c *Controller) SecretAllowed(resourceName string, namespace string) bool {
 	return c.outputs.ReferenceGrants.SecretAllowed(nil, resourceName, namespace)
 }
 
-func pushXds[T any](xds model.XDSUpdater, f func(T) model.ConfigKey) func(events []krt.Event[T]) {
+func pushXds[T any](xds XDSUpdater, f func(T) ConfigKey) func(events []krt.Event[T]) {
 	return func(events []krt.Event[T]) {
 		if xds == nil {
 			return
 		}
-		cu := sets.New[model.ConfigKey]()
+		cu := sets.New[ConfigKey]()
 		for _, e := range events {
 			for _, i := range e.Items() {
 				c := f(i)
-				if c != (model.ConfigKey{}) {
+				if c != (ConfigKey{}) {
 					cu.Insert(c)
 				}
 			}
@@ -660,10 +576,10 @@ func pushXds[T any](xds model.XDSUpdater, f func(T) model.ConfigKey) func(events
 		if len(cu) == 0 {
 			return
 		}
-		xds.ConfigUpdate(&model.PushRequest{
+		xds.ConfigUpdate(&PushRequest{
 			Full:           true,
 			ConfigsUpdated: cu,
-			Reason:         model.NewReasonStats(model.ConfigUpdate),
+			Reason:         NewReasonStats(ConfigUpdate),
 		})
 	}
 }
@@ -675,3 +591,20 @@ func (c *Controller) inRevision(obj any) bool {
 	}
 	return config.LabelsInRevision(object.GetLabels(), c.revision)
 }
+
+type IndexObject[K comparable, O any] struct {
+	Key     K
+	Objects []O
+}
+
+func (i IndexObject[K, O]) ResourceName() string {
+	return toString(i.Key)
+}
+
+func toString(rk any) string {
+	tk, ok := rk.(string)
+	if !ok {
+		return rk.(fmt.Stringer).String()
+	}
+	return tk
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conversion.go b/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
index f0f23a3a2..994cb8525 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
@@ -34,6 +34,7 @@ import (
 	k8salpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/agentgateway/agentgateway/go/api"
 	"istio.io/api/annotation"
 	"istio.io/api/label"
 	istio "istio.io/api/networking/v1alpha3"
@@ -56,7 +57,6 @@ import (
 	"istio.io/istio/pkg/ptr"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/sets"
-	"istio.io/istio/pkg/workloadapi"
 )
 
 const (
@@ -65,18 +65,6 @@ const (
 	gatewayClassDefaults       = "gateway.istio.io/defaults-for-class"
 )
 
-func sortConfigByCreationTime(configs []config.Config) {
-	sort.Slice(configs, func(i, j int) bool {
-		if r := configs[i].CreationTimestamp.Compare(configs[j].CreationTimestamp); r != 0 {
-			return r == -1 // -1 means i is less than j, so return true
-		}
-		if r := cmp.Compare(configs[i].Namespace, configs[j].Namespace); r != 0 {
-			return r == -1
-		}
-		return cmp.Compare(configs[i].Name, configs[j].Name) == -1
-	})
-}
-
 func sortRoutesByCreationTime(configs []RouteWithKey) {
 	sort.Slice(configs, func(i, j int) bool {
 		if r := configs[i].CreationTimestamp.Compare(configs[j].CreationTimestamp); r != 0 {
@@ -89,15 +77,14 @@ func sortRoutesByCreationTime(configs []RouteWithKey) {
 	})
 }
 
-func sortedConfigByCreationTime(configs []config.Config) []config.Config {
-	sortConfigByCreationTime(configs)
-	return configs
+func sortedConfigByCreationTime(configs []Config) []Config {
+	return sortConfigByCreationTime(configs)
 }
 
 func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
-	obj *k8sbeta.HTTPRoute, pos int, matchPos int, enforceRefGrant bool,
-) (*workloadapi.Route, *ConfigError) {
-	res := &workloadapi.Route{
+	obj *k8sbeta.HTTPRoute, pos int, matchPos int,
+) (*api.Route, *ConfigError) {
+	res := &api.Route{
 		Key:         obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) + "." + strconv.Itoa(matchPos),
 		RouteName:   obj.Namespace + "/" + obj.Name,
 		ListenerKey: "",
@@ -121,21 +108,21 @@ func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 		if err != nil {
 			return nil, err
 		}
-		res.Matches = append(res.Matches, &workloadapi.RouteMatch{
+		res.Matches = append(res.Matches, &api.RouteMatch{
 			Path:        path,
 			Headers:     headers,
 			Method:      method,
 			QueryParams: query,
 		})
 	}
-	filters, err := buildADPFilters(ctx, obj.Namespace, enforceRefGrant, r.Filters)
+	filters, err := buildADPFilters(ctx, obj.Namespace, r.Filters)
 	if err != nil {
 		return nil, err
 	}
 	res.Filters = filters
 
 	if r.Timeouts != nil {
-		res.TrafficPolicy = &workloadapi.TrafficPolicy{}
+		res.TrafficPolicy = &api.TrafficPolicy{}
 		if r.Timeouts.Request != nil {
 			request, _ := time.ParseDuration(string(*r.Timeouts.Request))
 			if request > 0 {
@@ -151,7 +138,7 @@ func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 	}
 
 	// Retry: todo
-	route, backendErr, err := buildADPHTTPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant)
+	route, backendErr, err := buildADPHTTPDestination(ctx, r.BackendRefs, obj.Namespace)
 	if err != nil {
 		return nil, err
 	}
@@ -165,10 +152,9 @@ func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 func buildADPFilters(
 	ctx RouteContext,
 	ns string,
-	enforceRefGrant bool,
 	inputFilters []k8s.HTTPRouteFilter,
-) ([]*workloadapi.RouteFilter, *ConfigError) {
-	filters := []*workloadapi.RouteFilter{}
+) ([]*api.RouteFilter, *ConfigError) {
+	var filters []*api.RouteFilter
 	var mirrorBackendErr *ConfigError
 	for _, filter := range inputFilters {
 		switch filter.Type {
@@ -191,7 +177,7 @@ func buildADPFilters(
 			}
 			filters = append(filters, h)
 		case k8s.HTTPRouteFilterRequestMirror:
-			h, err := createADPMirrorFilter(ctx, filter.RequestMirror, ns, enforceRefGrant, gvk.HTTPRoute)
+			h, err := createADPMirrorFilter(ctx, filter.RequestMirror, ns, gvk.HTTPRoute)
 			if err != nil {
 				mirrorBackendErr = err
 			} else {
@@ -222,16 +208,15 @@ func buildADPHTTPDestination(
 	ctx RouteContext,
 	forwardTo []k8s.HTTPBackendRef,
 	ns string,
-	enforceRefGrant bool,
-) ([]*workloadapi.RouteBackend, *ConfigError, *ConfigError) {
+) ([]*api.RouteBackend, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
 		return nil, nil, nil
 	}
 
 	var invalidBackendErr *ConfigError
-	res := []*workloadapi.RouteBackend{}
+	var res []*api.RouteBackend
 	for _, fwd := range forwardTo {
-		dst, err := buildADPDestination(ctx, fwd, ns, enforceRefGrant, gvk.HTTPRoute)
+		dst, err := buildADPDestination(ctx, fwd, ns, gvk.HTTPRoute)
 		if err != nil {
 			log.Errorf("howardjohn: adp error: %v", err)
 			if isInvalidBackend(err) {
@@ -242,7 +227,7 @@ func buildADPHTTPDestination(
 			}
 		}
 		if dst != nil {
-			filters, err := buildADPFilters(ctx, ns, enforceRefGrant, fwd.Filters)
+			filters, err := buildADPFilters(ctx, ns, fwd.Filters)
 			if err != nil {
 				return nil, nil, err
 			}
@@ -257,17 +242,14 @@ func buildADPDestination(
 	ctx RouteContext,
 	to k8s.HTTPBackendRef,
 	ns string,
-	enforceRefGrant bool,
 	k config.GroupVersionKind,
-) (*workloadapi.RouteBackend, *ConfigError) {
+) (*api.RouteBackend, *ConfigError) {
 	// check if the reference is allowed
-	if enforceRefGrant {
-		if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
-			if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
-				return nil, &ConfigError{
-					Reason:  InvalidDestinationPermit,
-					Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
-				}
+	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
+		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
+			return nil, &ConfigError{
+				Reason:  InvalidDestinationPermit,
+				Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
 			}
 		}
 	}
@@ -276,25 +258,25 @@ func buildADPDestination(
 	var invalidBackendErr *ConfigError
 	var hostname string
 	ref := normalizeReference(to.Group, to.Kind, gvk.Service)
-	rb := &workloadapi.RouteBackend{
+	rb := &api.RouteBackend{
 		Weight: ptr.OrDefault(to.Weight, 1),
 	}
 	var port *k8s.PortNumber
 	switch ref {
-	case gvk.InferencePool:
-		if strings.Contains(string(to.Name), ".") {
-			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
-		}
-		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
-		key := namespace + "/" + string(to.Name)
-		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
-		log.Errorf("howardjohn: got pool %v for %v", svc, key)
-		if svc == nil {
-			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
-		} else {
-			port = ptr.Of(k8s.PortNumber(svc.Spec.TargetPortNumber))
-		}
-		rb.Kind = &workloadapi.RouteBackend_Service{Service: namespace + "/" + hostname}
+	//case gvk.InferencePool:
+	//	if strings.Contains(string(to.Name), ".") {
+	//		return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+	//	}
+	//	hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+	//	key := namespace + "/" + string(to.Name)
+	//	svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+	//	log.Errorf("howardjohn: got pool %v for %v", svc, key)
+	//	if svc == nil {
+	//		invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+	//	} else {
+	//		port = ptr.Of(k8s.PortNumber(svc.Spec.TargetPortNumber))
+	//	}
+	//	rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
 	case gvk.Service:
 		port = to.Port
 		if strings.Contains(string(to.Name), ".") {
@@ -306,7 +288,7 @@ func buildADPDestination(
 		if svc == nil {
 			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
 		}
-		rb.Kind = &workloadapi.RouteBackend_Service{Service: namespace + "/" + hostname}
+		rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
 	default:
 		port = to.Port
 		return nil, &ConfigError{
@@ -325,7 +307,7 @@ func buildADPDestination(
 }
 
 func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
-	obj *k8sbeta.HTTPRoute, pos int, enforceRefGrant bool,
+	obj *k8sbeta.HTTPRoute, pos int,
 ) (*istio.HTTPRoute, *ConfigError) {
 	vs := &istio.HTTPRoute{}
 	if r.Name != nil {
@@ -384,7 +366,7 @@ func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
 		case k8s.HTTPRouteFilterRequestRedirect:
 			vs.Redirect = createRedirectFilter(filter.RequestRedirect)
 		case k8s.HTTPRouteFilterRequestMirror:
-			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, enforceRefGrant, gvk.HTTPRoute)
+			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, gvk.HTTPRoute)
 			if err != nil {
 				mirrorBackendErr = err
 			} else {
@@ -421,10 +403,10 @@ func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
 			// Invalid to set this when there are no attempts
 			vs.Retries.RetryOn = ""
 		}
-		if r.Retry.Backoff != nil {
-			retrybackOff, _ := time.ParseDuration(string(*r.Retry.Backoff))
-			vs.Retries.Backoff = durationpb.New(retrybackOff)
-		}
+		//if r.Retry.Backoff != nil {
+		//	retrybackOff, _ := time.ParseDuration(string(*r.Retry.Backoff))
+		//	vs.Retries.Backoff = durationpb.New(retrybackOff)
+		//}
 	}
 
 	if r.Timeouts != nil {
@@ -452,7 +434,7 @@ func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
 			Status: 500,
 		}
 	} else {
-		route, backendErr, err := buildHTTPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant)
+		route, backendErr, err := buildHTTPDestination(ctx, r.BackendRefs, obj.Namespace)
 		if err != nil {
 			return nil, err
 		}
@@ -475,7 +457,7 @@ func joinErrors(a *ConfigError, b *ConfigError) *ConfigError {
 }
 
 func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
-	obj *k8s.GRPCRoute, pos int, enforceRefGrant bool,
+	obj *k8s.GRPCRoute, pos int,
 ) (*istio.HTTPRoute, *ConfigError) {
 	vs := &istio.HTTPRoute{}
 	if r.Name != nil {
@@ -521,7 +503,7 @@ func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
 			}
 			vs.Headers.Response = h
 		case k8s.GRPCRouteFilterRequestMirror:
-			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, enforceRefGrant, gvk.GRPCRoute)
+			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, gvk.GRPCRoute)
 			if err != nil {
 				return nil, err
 			}
@@ -540,7 +522,7 @@ func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
 			Status: 500,
 		}
 	} else {
-		route, backendErr, err := buildGRPCDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant)
+		route, backendErr, err := buildGRPCDestination(ctx, r.BackendRefs, obj.Namespace)
 		if err != nil {
 			return nil, err
 		}
@@ -551,17 +533,6 @@ func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
 	return vs, nil
 }
 
-func parentTypes(rpi []routeParentReference) (mesh, gateway bool) {
-	for _, r := range rpi {
-		if r.IsMesh() {
-			mesh = true
-		} else {
-			gateway = true
-		}
-	}
-	return
-}
-
 func augmentPortMatch(routes []*istio.HTTPRoute, port k8s.PortNumber) []*istio.HTTPRoute {
 	res := make([]*istio.HTTPRoute, 0, len(routes))
 	for _, r := range routes {
@@ -757,7 +728,7 @@ func referenceAllowed(
 	parentRef parentReference,
 	hostnames []k8s.Hostname,
 	localNamespace string,
-) (*ParentError, *WaypointError) {
+) *ParentError {
 	if parentRef.Kind == gvk.Service {
 
 		key := parentRef.Namespace + "/" + parentRef.Name
@@ -766,25 +737,8 @@ func referenceAllowed(
 		// check that the referenced svc exists
 		if svc == nil {
 			return &ParentError{
-					Reason:  ParentErrorNotAccepted,
-					Message: fmt.Sprintf("parent service: %q not found", parentRef.Name),
-				}, &WaypointError{
-					Reason:  WaypointErrorReasonNoMatchingParent,
-					Message: WaypointErrorMsgNoMatchingParent,
-				}
-		}
-
-		// check that the reference has the use-waypoint label
-		if !waypointConfigured(svc.Labels) {
-			// if reference does not have use-waypoint label, check the namespace of the reference
-			ns := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Namespaces, krt.FilterKey(svc.Namespace)))
-			if ns != nil {
-				if !waypointConfigured(ns.Labels) {
-					return nil, &WaypointError{
-						Reason:  WaypointErrorReasonMissingLabel,
-						Message: WaypointErrorMsgMissingLabel,
-					}
-				}
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("parent service: %q not found", parentRef.Name),
 			}
 		}
 	} else if parentRef.Kind == gvk.ServiceEntry {
@@ -793,25 +747,8 @@ func referenceAllowed(
 		svcEntry := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(key)))
 		if svcEntry == nil {
 			return &ParentError{
-					Reason:  ParentErrorNotAccepted,
-					Message: fmt.Sprintf("parent service entry: %q not found", parentRef.Name),
-				}, &WaypointError{
-					Reason:  WaypointErrorReasonNoMatchingParent,
-					Message: WaypointErrorMsgNoMatchingParent,
-				}
-		}
-
-		// check that the reference has the use-waypoint label
-		if !waypointConfigured(svcEntry.Labels) {
-			// if reference does not have use-waypoint label, check the namespace of the reference
-			ns := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Namespaces, krt.FilterKey(parentRef.Namespace)))
-			if ns != nil {
-				if !waypointConfigured(ns.Labels) {
-					return nil, &WaypointError{
-						Reason:  WaypointErrorReasonMissingLabel,
-						Message: WaypointErrorMsgMissingLabel,
-					}
-				}
+				Reason:  ParentErrorNotAccepted,
+				Message: fmt.Sprintf("parent service entry: %q not found", parentRef.Name),
 			}
 		}
 	} else {
@@ -820,13 +757,13 @@ func referenceAllowed(
 			return &ParentError{
 				Reason:  ParentErrorNotAccepted,
 				Message: fmt.Sprintf("port %v not found", parentRef.Port),
-			}, nil
+			}
 		}
 		if len(parentRef.SectionName) > 0 && parentRef.SectionName != parent.SectionName {
 			return &ParentError{
 				Reason:  ParentErrorNotAccepted,
 				Message: fmt.Sprintf("sectionName %q not found", parentRef.SectionName),
-			}, nil
+			}
 		}
 
 		// Next check the hostnames are a match. This is a bi-directional wildcard match. Only one route
@@ -863,7 +800,7 @@ func referenceAllowed(
 							"hostnames matched parent hostname %q, but namespace %q is not allowed by the parent",
 							parent.OriginalHostname, localNamespace,
 						),
-					}, nil
+					}
 				}
 				return &ParentError{
 					Reason: ParentErrorNoHostname,
@@ -871,7 +808,7 @@ func referenceAllowed(
 						"no hostnames matched parent hostname %q",
 						parent.OriginalHostname,
 					),
-				}, nil
+				}
 			}
 		}
 	}
@@ -887,15 +824,15 @@ func referenceAllowed(
 		return &ParentError{
 			Reason:  ParentErrorNotAllowed,
 			Message: fmt.Sprintf("kind %v is not allowed", routeKind),
-		}, nil
+		}
 	}
-	return nil, nil
+	return nil
 }
 
 func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj controllers.Object) []routeParentReference {
 	routeRefs, hostnames, kind := GetCommonRouteInfo(obj)
 	localNamespace := obj.GetNamespace()
-	parentRefs := []routeParentReference{}
+	var parentRefs []routeParentReference
 	for _, ref := range routeRefs {
 		ir, err := toInternalParentReference(ref, localNamespace)
 		if err != nil {
@@ -928,7 +865,7 @@ func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj cont
 				}
 				bannedHostnames.Insert(gw.OriginalHostname)
 			}
-			deniedReason, waypointError := referenceAllowed(ctx, pr, kind, pk, hostnames, localNamespace)
+			deniedReason := referenceAllowed(ctx, pr, kind, pk, hostnames, localNamespace)
 			rpi := routeParentReference{
 				InternalName:      pr.InternalName,
 				InternalKind:      ir.Kind,
@@ -938,7 +875,6 @@ func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj cont
 				BannedHostnames:   bannedHostnames.Copy().Delete(pr.OriginalHostname),
 				ParentKey:         ir,
 				ParentSection:     pr.SectionName,
-				WaypointError:     waypointError,
 			}
 			parentRefs = append(parentRefs, rpi)
 		}
@@ -954,7 +890,7 @@ func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj cont
 	return parentRefs
 }
 
-func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TCPRoute, enforceRefGrant bool) (*istio.TCPRoute, *ConfigError) {
+func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TCPRoute) (*istio.TCPRoute, *ConfigError) {
 	if tcpWeightSum(r.BackendRefs) == 0 {
 		// The spec requires us to reject connections when there are no >0 weight backends
 		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
@@ -969,7 +905,7 @@ func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TC
 			}},
 		}, nil
 	}
-	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant, gvk.TCPRoute)
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, gvk.TCPRoute)
 	if err != nil {
 		return nil, err
 	}
@@ -978,7 +914,7 @@ func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TC
 	}, backendErr
 }
 
-func convertTLSRoute(ctx RouteContext, r k8salpha.TLSRouteRule, obj *k8salpha.TLSRoute, enforceRefGrant bool) (*istio.TLSRoute, *ConfigError) {
+func convertTLSRoute(ctx RouteContext, r k8salpha.TLSRouteRule, obj *k8salpha.TLSRoute) (*istio.TLSRoute, *ConfigError) {
 	if tcpWeightSum(r.BackendRefs) == 0 {
 		// The spec requires us to reject connections when there are no >0 weight backends
 		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
@@ -993,7 +929,7 @@ func convertTLSRoute(ctx RouteContext, r k8salpha.TLSRouteRule, obj *k8salpha.TL
 			}},
 		}, nil
 	}
-	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, enforceRefGrant, gvk.TLSRoute)
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, gvk.TLSRoute)
 	if err != nil {
 		return nil, err
 	}
@@ -1007,7 +943,6 @@ func buildTCPDestination(
 	ctx RouteContext,
 	forwardTo []k8s.BackendRef,
 	ns string,
-	enforceRefGrant bool,
 	k config.GroupVersionKind,
 ) ([]*istio.RouteDestination, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
@@ -1029,9 +964,9 @@ func buildTCPDestination(
 	}
 
 	var invalidBackendErr *ConfigError
-	res := []*istio.RouteDestination{}
+	var res []*istio.RouteDestination
 	for i, fwd := range action {
-		dst, err := buildDestination(ctx, fwd, ns, enforceRefGrant, k)
+		dst, err := buildDestination(ctx, fwd, ns, k)
 		if err != nil {
 			if isInvalidBackend(err) {
 				invalidBackendErr = err
@@ -1094,7 +1029,6 @@ func buildHTTPDestination(
 	ctx RouteContext,
 	forwardTo []k8s.HTTPBackendRef,
 	ns string,
-	enforceRefGrant bool,
 ) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
 		return nil, nil, nil
@@ -1116,7 +1050,7 @@ func buildHTTPDestination(
 	var invalidBackendErr *ConfigError
 	res := []*istio.HTTPRouteDestination{}
 	for i, fwd := range action {
-		dst, err := buildDestination(ctx, fwd.BackendRef, ns, enforceRefGrant, gvk.HTTPRoute)
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, gvk.HTTPRoute)
 		if err != nil {
 			if isInvalidBackend(err) {
 				invalidBackendErr = err
@@ -1162,7 +1096,6 @@ func buildGRPCDestination(
 	ctx RouteContext,
 	forwardTo []k8s.GRPCBackendRef,
 	ns string,
-	enforceRefGrant bool,
 ) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
 		return nil, nil, nil
@@ -1184,7 +1117,7 @@ func buildGRPCDestination(
 	var invalidBackendErr *ConfigError
 	res := []*istio.HTTPRouteDestination{}
 	for i, fwd := range action {
-		dst, err := buildDestination(ctx, fwd.BackendRef, ns, enforceRefGrant, gvk.GRPCRoute)
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, gvk.GRPCRoute)
 		if err != nil {
 			if isInvalidBackend(err) {
 				invalidBackendErr = err
@@ -1226,15 +1159,13 @@ func buildGRPCDestination(
 	return res, invalidBackendErr, nil
 }
 
-func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, enforceRefGrant bool, k config.GroupVersionKind) (*istio.Destination, *ConfigError) {
+func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, k config.GroupVersionKind) (*istio.Destination, *ConfigError) {
 	// check if the reference is allowed
-	if enforceRefGrant {
-		if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
-			if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
-				return &istio.Destination{}, &ConfigError{
-					Reason:  InvalidDestinationPermit,
-					Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
-				}
+	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
+		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
+			return &istio.Destination{}, &ConfigError{
+				Reason:  InvalidDestinationPermit,
+				Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
 			}
 		}
 	}
@@ -1244,16 +1175,16 @@ func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, enforceRef
 	var hostname string
 	ref := normalizeReference(to.Group, to.Kind, gvk.Service)
 	switch ref {
-	case gvk.InferencePool: // TODO: add validation
-		if strings.Contains(string(to.Name), ".") {
-			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
-		}
-		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
-		key := namespace + "/" + string(to.Name)
-		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
-		if svc == nil {
-			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
-		}
+	//case gvk.InferencePool: // TODO: add validation
+	//	if strings.Contains(string(to.Name), ".") {
+	//		return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+	//	}
+	//	hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+	//	key := namespace + "/" + string(to.Name)
+	//	svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+	//	if svc == nil {
+	//		invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+	//	}
 	case gvk.Service:
 		if strings.Contains(string(to.Name), ".") {
 			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
@@ -1327,7 +1258,7 @@ func headerListToMap(hl []k8s.HTTPHeader) map[string]string {
 }
 
 func createMirrorFilter(ctx RouteContext, filter *k8s.HTTPRequestMirrorFilter, ns string,
-	enforceRefGrant bool, k config.GroupVersionKind,
+	k config.GroupVersionKind,
 ) (*istio.HTTPMirrorPolicy, *ConfigError) {
 	if filter == nil {
 		return nil, nil
@@ -1336,7 +1267,7 @@ func createMirrorFilter(ctx RouteContext, filter *k8s.HTTPRequestMirrorFilter, n
 	dst, err := buildDestination(ctx, k8s.BackendRef{
 		BackendObjectReference: filter.BackendRef,
 		Weight:                 &weightOne,
-	}, ns, enforceRefGrant, k)
+	}, ns, k)
 	if err != nil {
 		return nil, err
 	}
@@ -1708,8 +1639,6 @@ type routeParentReference struct {
 	BannedHostnames sets.Set[string]
 	ParentKey       parentKey
 	ParentSection   k8s.SectionName
-	// WaypointError, if present, indicates why the reference does not have valid configuration for generating a Waypoint
-	WaypointError *WaypointError
 }
 
 func (r routeParentReference) IsMesh() bool {
@@ -1951,9 +1880,9 @@ func reportUnmanagedGatewayStatus(
 //
 // If manual deployments are disabled, IsManaged() always returns true.
 func IsManaged(gw *k8s.GatewaySpec) bool {
-	if !features.EnableGatewayAPIManualDeployment {
-		return true
-	}
+	//if !features.EnableGatewayAPIManualDeployment {
+	//	return true
+	//}
 	if len(gw.Addresses) == 0 {
 		return true
 	}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
index 1766584e8..615f58c14 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
@@ -15,47 +15,43 @@
 package gateway
 
 import (
-	"strings"
+	"fmt"
 
-	"go.uber.org/atomic"
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+	"istio.io/istio/pkg/config/constants"
 	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/types"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	istio "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/util/protoconv"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/constants"
-	kubeconfig "istio.io/istio/pkg/config/gateway/kube"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/ptr"
-	"istio.io/istio/pkg/revisions"
 	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/workloadapi"
 )
 
-func toResourcep(gw types.NamespacedName, t any) *model.ADPResource {
+func toResourcep(gw types.NamespacedName, t any) *ADPResource {
 	res := toResource(gw, t)
 	return &res
 }
 
-func toResource(gw types.NamespacedName, t any) model.ADPResource {
+func toResource(gw types.NamespacedName, t any) ADPResource {
 	switch tt := t.(type) {
 	case Bind:
-		return model.ADPResource{Resource: &workloadapi.Resource{Kind: &workloadapi.Resource_Bind{tt.Bind}}, Gateway: gw}
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Bind{tt.Bind}}, Gateway: gw}
 	case ADPListener:
-		return model.ADPResource{Resource: &workloadapi.Resource{Kind: &workloadapi.Resource_Listener{tt.Listener}}, Gateway: gw}
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Listener{tt.Listener}}, Gateway: gw}
 	case ADPRoute:
-		return model.ADPResource{Resource: &workloadapi.Resource{Kind: &workloadapi.Resource_Route{tt.Route}}, Gateway: gw}
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Route{tt.Route}}, Gateway: gw}
 	}
 	panic("unknown resource kind")
 }
 
 // TODO: we need some way to associate this to a specific instance of the proxy!!
 type Bind struct {
-	*workloadapi.Bind
+	*api.Bind
 }
 
 func (g Bind) ResourceName() string {
@@ -67,7 +63,7 @@ func (g Bind) Equals(other Bind) bool {
 }
 
 type ADPListener struct {
-	*workloadapi.Listener
+	*api.Listener
 }
 
 func (g ADPListener) ResourceName() string {
@@ -79,7 +75,7 @@ func (g ADPListener) Equals(other ADPListener) bool {
 }
 
 type ADPRoute struct {
-	*workloadapi.Route
+	*api.Route
 }
 
 func (g ADPRoute) ResourceName() string {
@@ -95,8 +91,22 @@ type TLSInfo struct {
 	Key  []byte `json:"-"`
 }
 
+type PortBindings struct {
+	Gateway
+	Port string
+}
+
+func (g PortBindings) ResourceName() string {
+	return g.Gateway.Name
+}
+
+func (g PortBindings) Equals(other PortBindings) bool {
+	return g.Gateway.Equals(other.Gateway) &&
+		g.port == other.port
+}
+
 type Gateway struct {
-	*config.Config
+	*Config
 	parent     parentKey
 	parentInfo parentInfo
 	TLSInfo    *TLSInfo
@@ -104,7 +114,7 @@ type Gateway struct {
 }
 
 func (g Gateway) ResourceName() string {
-	return config.NamespacedName(g.Config).Name
+	return g.Config.Name
 }
 
 func (g Gateway) Equals(other Gateway) bool {
@@ -119,67 +129,47 @@ func GatewayCollection(
 	grants ReferenceGrants,
 	secrets krt.Collection[*corev1.Secret],
 	domainSuffix string,
-	gatewayContext krt.RecomputeProtected[*atomic.Pointer[GatewayContext]],
-	tagWatcher krt.RecomputeProtected[revisions.TagWatcher],
 	opts krt.OptionsBuilder,
-) (
-	krt.StatusCollection[*gateway.Gateway, gateway.GatewayStatus],
-	krt.Collection[Gateway],
-) {
-	statusCol, gw := krt.NewStatusManyCollection(gateways, func(ctx krt.HandlerContext, obj *gateway.Gateway) (*gateway.GatewayStatus, []Gateway) {
-		// We currently depend on service discovery information not know to krt; mark we depend on it.
-		context := gatewayContext.Get(ctx).Load()
-		if context == nil {
-			return nil, nil
-		}
-		if !tagWatcher.Get(ctx).IsMine(obj.ObjectMeta) {
-			return nil, nil
-		}
-		result := []Gateway{}
+) krt.Collection[Gateway] {
+	gw := krt.NewManyCollection(gateways, func(ctx krt.HandlerContext, obj *gateway.Gateway) []Gateway {
+		var result []Gateway
 		kgw := obj.Spec
 		status := obj.Status.DeepCopy()
 		class := fetchClass(ctx, gatewayClasses, kgw.GatewayClassName)
 		if class == nil {
-			return nil, nil
+			return nil
 		}
 		controllerName := class.Controller
 		classInfo, f := classInfos[controllerName]
 		if !f {
-			return nil, nil
+			return nil
 		}
 		if classInfo.disableRouteGeneration {
-			reportUnmanagedGatewayStatus(status, obj)
 			// We found it, but don't want to handle this class
-			return status, nil
+			// TODO: log
+			return nil
 		}
-		servers := []*istio.Server{}
+		var servers []*istio.Server
 
 		// Extract the addresses. A gateway will bind to a specific Service
 		gatewayServices, err := extractGatewayServices(domainSuffix, obj, classInfo)
 		if len(gatewayServices) == 0 && err != nil {
 			// Short circuit if its a hard failure
-			reportGatewayStatus(context, obj, status, classInfo, gatewayServices, servers, err)
-			return status, nil
+			// TODO: log
+			return nil
 		}
 
 		for i, l := range kgw.Listeners {
 			server, tlsInfo, programmed := buildListener(ctx, secrets, grants, namespaces, obj, status, l, i, controllerName)
 
 			servers = append(servers, server)
-			if controllerName == constants.ManagedGatewayMeshController {
-				// Waypoint doesn't actually convert the routes to VirtualServices
-				continue
-			}
 			meta := parentMeta(obj, &l.Name)
-			meta[constants.InternalGatewaySemantics] = constants.GatewaySemanticsGateway
-			meta[model.InternalGatewayServiceAnnotation] = strings.Join(gatewayServices, ",")
-
 			// Each listener generates an Istio Gateway with a single Server. This allows binding to a specific listener.
-			gatewayConfig := config.Config{
-				Meta: config.Meta{
+			gatewayConfig := Config{
+				Meta: Meta{
 					CreationTimestamp: obj.CreationTimestamp.Time,
-					GroupVersionKind:  gvk.Gateway,
-					Name:              kubeconfig.InternalGatewayName(obj.Name, string(l.Name)),
+					GroupVersionKind:  GroupVersionKind{Group: wellknown.GatewayGroup, Kind: wellknown.GatewayKind},
+					Name:              InternalGatewayName(obj.Name, string(l.Name)),
 					Annotations:       meta,
 					Namespace:         obj.Namespace,
 					Domain:            domainSuffix,
@@ -215,43 +205,10 @@ func GatewayCollection(
 			result = append(result, res)
 		}
 
-		reportGatewayStatus(context, obj, status, classInfo, gatewayServices, servers, err)
-		return status, result
+		return result
 	}, opts.WithName("KubernetesGateway")...)
 
-	return statusCol, gw
-}
-
-var count = atomic.NewInt64(0)
-
-// FinalGatewayStatusCollection finalizes a Gateway status. There is a circular logic between Gateways and Routes to determine
-// the attachedRoute count, so we first build a partial Gateway status, then once routes are computed we finalize it with
-// the attachedRoute count.
-func FinalGatewayStatusCollection(
-	gatewayStatuses krt.StatusCollection[*gateway.Gateway, gateway.GatewayStatus],
-	routeAttachments krt.Collection[*RouteAttachment],
-	routeAttachmentsIndex krt.Index[GatewayAndListener, *RouteAttachment],
-	opts krt.OptionsBuilder,
-) krt.StatusCollection[*gateway.Gateway, gateway.GatewayStatus] {
-	return krt.NewCollection(
-		gatewayStatuses,
-		func(ctx krt.HandlerContext, i krt.ObjectWithStatus[*gateway.Gateway, gateway.GatewayStatus]) *krt.ObjectWithStatus[*gateway.Gateway, gateway.GatewayStatus] {
-			gw := config.NamespacedName(i.Obj)
-			counts := map[string]int32{}
-			for _, l := range i.Obj.Spec.Listeners {
-				routes := krt.FetchCount(ctx, routeAttachments, krt.FilterIndex(routeAttachmentsIndex, GatewayAndListener{To: gw, ListenerName: string(l.Name)}))
-				counts[string(l.Name)] += int32(routes)
-			}
-			status := i.Status.DeepCopy()
-			for i, s := range status.Listeners {
-				s.AttachedRoutes = counts[string(s.Name)]
-				status.Listeners[i] = s
-			}
-			return &krt.ObjectWithStatus[*gateway.Gateway, gateway.GatewayStatus]{
-				Obj:    i.Obj,
-				Status: *status,
-			}
-		}, opts.WithName("GatewayFinalStatus")...)
+	return gw
 }
 
 // RouteParents holds information about things routes can reference as parents.
@@ -292,3 +249,9 @@ func BuildRouteParents(
 		gatewayIndex: idx,
 	}
 }
+
+// InternalGatewayName returns the name of the internal Istio Gateway corresponding to the
+// specified gateway-api gateway and listener.
+func InternalGatewayName(gwName, lName string) string {
+	return fmt.Sprintf("%s-%s-%s", gwName, constants.KubernetesGatewayName, lName)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
index cf18f5726..d8cb8f7ae 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
@@ -15,6 +15,7 @@
 package gateway
 
 import (
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
@@ -32,22 +33,18 @@ func (g GatewayClass) ResourceName() string {
 
 func GatewayClassesCollection(
 	gatewayClasses krt.Collection[*gateway.GatewayClass],
-	opts krt.OptionsBuilder,
-) (
-	krt.StatusCollection[*gateway.GatewayClass, gateway.GatewayClassStatus],
-	krt.Collection[GatewayClass],
-) {
-	return krt.NewStatusCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gateway.GatewayClass) (*gateway.GatewayClassStatus, *GatewayClass) {
+	krtopts krtutil.KrtOptions,
+) krt.Collection[GatewayClass] {
+	return krt.NewCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gateway.GatewayClass) *GatewayClass {
 		_, known := classInfos[obj.Spec.ControllerName]
 		if !known {
-			return nil, nil
+			return nil
 		}
-		status := GetClassStatus(&obj.Status, obj.Generation)
-		return &status, &GatewayClass{
+		return &GatewayClass{
 			Name:       obj.Name,
 			Controller: obj.Spec.ControllerName,
 		}
-	}, opts.WithName("GatewayClasses")...)
+	}, krtopts.ToOptions("GatewayClasses")...)
 }
 
 func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayClass], gc gatewayv1.ObjectName) *GatewayClass {
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/model.go b/internal/kgateway/agentgatewaysyncer/gateway/model.go
index c8522d656..84952b395 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/model.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/model.go
@@ -13,3 +13,1778 @@
 // limitations under the License.
 
 package gateway
+
+import (
+	"bytes"
+	"cmp"
+	"fmt"
+	"maps"
+	"reflect"
+	"slices"
+	"sort"
+	"strings"
+	"sync"
+	"time"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	udpa "github.com/cncf/xds/go/udpa/type/v1"
+	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/reflect/protoreflect"
+	"google.golang.org/protobuf/types/known/structpb"
+	"istio.io/api/label"
+	"istio.io/istio/pilot/pkg/credentials"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/trustbundle"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	v3 "istio.io/istio/pilot/pkg/xds/v3"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/mesh"
+	"istio.io/istio/pkg/config/mesh/meshwatcher"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/kube/kubetypes"
+	"istio.io/istio/pkg/network"
+	"istio.io/istio/pkg/spiffe"
+	"istio.io/istio/pkg/util/gogoprotomarshal"
+	"istio.io/istio/pkg/util/identifier"
+	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/xds"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/utils/ptr"
+
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/schema/collection"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/util/hash"
+	netutil "istio.io/istio/pkg/util/net"
+	"istio.io/istio/pkg/util/sets"
+)
+
+// Statically link protobuf descriptors from UDPA
+var _ = udpa.TypedStruct{}
+
+type ConfigHash uint64
+
+// ConfigKey describe a specific config item.
+// In most cases, the name is the config's name. However, for ServiceEntry it is service's FQDN.
+type ConfigKey struct {
+	Kind      kind.Kind
+	Name      string
+	Namespace string
+}
+
+func (key ConfigKey) HashCode() ConfigHash {
+	h := hash.New()
+	h.Write([]byte{byte(key.Kind)})
+	// Add separator / to avoid collision.
+	h.WriteString("/")
+	h.WriteString(key.Namespace)
+	h.WriteString("/")
+	h.WriteString(key.Name)
+	return ConfigHash(h.Sum64())
+}
+
+func (key ConfigKey) String() string {
+	return key.Kind.String() + "/" + key.Namespace + "/" + key.Name
+}
+
+// ConfigsOfKind extracts configs of the specified kind.
+func ConfigsOfKind(configs sets.Set[ConfigKey], kind kind.Kind) sets.Set[ConfigKey] {
+	ret := make(sets.Set[ConfigKey])
+
+	for conf := range configs {
+		if conf.Kind == kind {
+			ret.Insert(conf)
+		}
+	}
+
+	return ret
+}
+
+// HasConfigsOfKind returns true if configs has changes of type kind
+func HasConfigsOfKind(configs sets.Set[ConfigKey], kind kind.Kind) bool {
+	for c := range configs {
+		if c.Kind == kind {
+			return true
+		}
+	}
+	return false
+}
+
+// ConfigNamesOfKind extracts config names of the specified kind.
+func ConfigNamesOfKind(configs sets.Set[ConfigKey], kind kind.Kind) sets.String {
+	ret := sets.New[string]()
+
+	for conf := range configs {
+		if conf.Kind == kind {
+			ret.Insert(conf.Name)
+		}
+	}
+
+	return ret
+}
+
+// ConfigStore describes a set of platform agnostic APIs that must be supported
+// by the underlying platform to store and retrieve Istio configuration.
+//
+// Configuration key is defined to be a combination of the type, name, and
+// namespace of the configuration object. The configuration key is guaranteed
+// to be unique in the store.
+//
+// The storage interface presented here assumes that the underlying storage
+// layer supports _Get_ (list), _Update_ (update), _Create_ (create) and
+// _Delete_ semantics but does not guarantee any transactional semantics.
+//
+// _Update_, _Create_, and _Delete_ are mutator operations. These operations
+// are asynchronous, and you might not see the effect immediately (e.g. _Get_
+// might not return the object by key immediately after you mutate the store.)
+// Intermittent errors might occur even though the operation succeeds, so you
+// should always check if the object store has been modified even if the
+// mutating operation returns an error.  Objects should be created with
+// _Create_ operation and updated with _Update_ operation.
+//
+// Resource versions record the last mutation operation on each object. If a
+// mutation is applied to a different revision of an object than what the
+// underlying storage expects as defined by pure equality, the operation is
+// blocked.  The client of this interface should not make assumptions about the
+// structure or ordering of the revision identifier.
+//
+// Object references supplied and returned from this interface should be
+// treated as read-only. Modifying them violates thread-safety.
+type ConfigStore interface {
+	// Schemas exposes the configuration type schema known by the config store.
+	// The type schema defines the bidirectional mapping between configuration
+	// types and the protobuf encoding schema.
+	Schemas() collection.Schemas
+
+	// Get retrieves a configuration element by a type and a key
+	Get(typ GroupVersionKind, name, namespace string) *Config
+
+	// List returns objects by type and namespace.
+	// Use "" for the namespace to list across namespaces.
+	List(typ GroupVersionKind, namespace string) []Config
+
+	// Create adds a new configuration object to the store. If an object with the
+	// same name and namespace for the type already exists, the operation fails
+	// with no side effects.
+	Create(config Config) (revision string, err error)
+
+	// Update modifies an existing configuration object in the store.  Update
+	// requires that the object has been created.  Resource version prevents
+	// overriding a value that has been changed between prior _Get_ and _Put_
+	// operation to achieve optimistic concurrency. This method returns a new
+	// revision if the operation succeeds.
+	Update(config Config) (newRevision string, err error)
+	UpdateStatus(config Config) (newRevision string, err error)
+
+	// Patch applies only the modifications made in the PatchFunc rather than doing a full replace. Useful to avoid
+	// read-modify-write conflicts when there are many concurrent-writers to the same resource.
+	Patch(orig Config, patchFn PatchFunc) (string, error)
+
+	// Delete removes an object from the store by key
+	// For k8s, resourceVersion must be fulfilled before a deletion is carried out.
+	// If not possible, a 409 Conflict status will be returned.
+	Delete(typ GroupVersionKind, name, namespace string, resourceVersion *string) error
+}
+
+// ResolveShortnameToFQDN uses metadata information to resolve a reference
+// to shortname of the service to FQDN
+func ResolveShortnameToFQDN(hostname string, meta Meta) host.Name {
+	if len(hostname) == 0 {
+		// only happens when the gateway-api BackendRef is invalid
+		return ""
+	}
+	out := hostname
+	// Treat the wildcard hostname as fully qualified. Any other variant of a wildcard hostname will contain a `.` too,
+	// and skip the next if, so we only need to check for the literal wildcard itself.
+	if hostname == "*" {
+		return host.Name(out)
+	}
+
+	// if the hostname is a valid ipv4 or ipv6 address, do not append domain or namespace
+	if netutil.IsValidIPAddress(hostname) {
+		return host.Name(out)
+	}
+
+	// if FQDN is specified, do not append domain or namespace to hostname
+	if !strings.Contains(hostname, ".") {
+		if meta.Namespace != "" {
+			out = out + "." + meta.Namespace
+		}
+
+		// FIXME this is a gross hack to hardcode a service's domain name in kubernetes
+		// BUG this will break non kubernetes environments if they use shortnames in the
+		// rules.
+		if meta.Domain != "" {
+			out = out + ".svc." + meta.Domain
+		}
+	}
+
+	return host.Name(out)
+}
+
+// resolveGatewayName uses metadata information to resolve a reference
+// to shortname of the gateway to FQDN
+func resolveGatewayName(gwname string, meta Meta) string {
+	out := gwname
+
+	// New way of binding to a gateway in remote namespace
+	// is ns/name. Old way is either FQDN or short name
+	if !strings.Contains(gwname, "/") {
+		if !strings.Contains(gwname, ".") {
+			// we have a short name. Resolve to a gateway in same namespace
+			out = meta.Namespace + "/" + gwname
+		} else {
+			// parse namespace from FQDN. This is very hacky, but meant for backward compatibility only
+			// This is a legacy FQDN format. Transform name.ns.svc.cluster.local -> ns/name
+			i := strings.Index(gwname, ".")
+			fqdn := strings.Index(gwname[i+1:], ".")
+			if fqdn == -1 {
+				out = gwname[i+1:] + "/" + gwname[:i]
+			} else {
+				out = gwname[i+1:i+1+fqdn] + "/" + gwname[:i]
+			}
+		}
+	} else {
+		// remove the . from ./gateway and substitute it with the namespace name
+		i := strings.Index(gwname, "/")
+		if gwname[:i] == "." {
+			out = meta.Namespace + "/" + gwname[i+1:]
+		}
+	}
+	return out
+}
+
+// MostSpecificHostMatch compares the maps of specific and wildcard hosts to the needle, and returns the longest element
+// matching the needle and it's value, or false if no element in the maps matches the needle.
+func MostSpecificHostMatch[V any](needle host.Name, specific map[host.Name]V, wildcard map[host.Name]V) (host.Name, V, bool) {
+	if needle.IsWildCarded() {
+		// exact match first
+		if v, ok := wildcard[needle]; ok {
+			return needle, v, true
+		}
+
+		return mostSpecificHostWildcardMatch(string(needle[1:]), wildcard)
+	}
+
+	// exact match first
+	if v, ok := specific[needle]; ok {
+		return needle, v, true
+	}
+
+	// check wildcard
+	return mostSpecificHostWildcardMatch(string(needle), wildcard)
+}
+
+func mostSpecificHostWildcardMatch[V any](needle string, wildcard map[host.Name]V) (host.Name, V, bool) {
+	found := false
+	var matchHost host.Name
+	var matchValue V
+
+	for h, v := range wildcard {
+		if strings.HasSuffix(needle, string(h[1:])) {
+			if !found {
+				matchHost = h
+				matchValue = wildcard[h]
+				found = true
+			} else if host.MoreSpecific(h, matchHost) {
+				matchHost = h
+				matchValue = v
+			}
+		}
+	}
+
+	return matchHost, matchValue, found
+}
+
+// sortConfigByCreationTime sorts the list of config objects in ascending order by their creation time (if available)
+func sortConfigByCreationTime(configs []Config) []Config {
+	sort.Slice(configs, func(i, j int) bool {
+		if r := configs[i].CreationTimestamp.Compare(configs[j].CreationTimestamp); r != 0 {
+			return r == -1 // -1 means i is less than j, so return true
+		}
+		// If creation time is the same, then behavior is nondeterministic. In this case, we can
+		// pick an arbitrary but consistent ordering based on name and namespace, which is unique.
+		// CreationTimestamp is stored in seconds, so this is not uncommon.
+		if r := cmp.Compare(configs[i].Name, configs[j].Name); r != 0 {
+			return r == -1
+		}
+		return cmp.Compare(configs[i].Namespace, configs[j].Namespace) == -1
+	})
+	return configs
+}
+
+type (
+	Node                    = pm.Node
+	NodeMetadata            = pm.NodeMetadata
+	NodeMetaProxyConfig     = pm.NodeMetaProxyConfig
+	NodeType                = pm.NodeType
+	BootstrapNodeMetadata   = pm.BootstrapNodeMetadata
+	TrafficInterceptionMode = pm.TrafficInterceptionMode
+	PodPort                 = pm.PodPort
+	StringBool              = pm.StringBool
+	IPMode                  = pm.IPMode
+)
+
+const (
+	SidecarProxy = pm.SidecarProxy
+	Router       = pm.Router
+	Waypoint     = pm.Waypoint
+	Ztunnel      = pm.Ztunnel
+
+	IPv4 = pm.IPv4
+	IPv6 = pm.IPv6
+	Dual = pm.Dual
+)
+
+var _ mesh.Holder = &Environment{}
+
+func NewEnvironment() *Environment {
+	var cache XdsCache
+	if features.EnableXDSCaching {
+		cache = NewXdsCache()
+	} else {
+		cache = DisabledCache{}
+	}
+	return &Environment{
+		pushContext:   NewPushContext(),
+		Cache:         cache,
+		EndpointIndex: NewEndpointIndex(cache),
+	}
+}
+
+// Watcher is a type alias to keep the embedded type name stable.
+type Watcher = meshwatcher.WatcherCollection
+
+// Environment provides an aggregate environmental API for Pilot
+type Environment struct {
+	// Discovery interface for listing services and instances.
+	ServiceDiscovery
+
+	// Config interface for listing routing rules
+	ConfigStore
+
+	// Watcher is the watcher for the mesh config (to be merged into the config store)
+	Watcher
+
+	// NetworksWatcher (loaded from a config map) provides information about the
+	// set of networks inside a mesh and how to route to endpoints in each
+	// network. Each network provides information about the endpoints in a
+	// routable L3 network. A single routable L3 network can have one or more
+	// service registries.
+	NetworksWatcher mesh.NetworksWatcher
+
+	NetworkManager *NetworkManager
+
+	// mutex used for protecting Environment.pushContext
+	mutex sync.RWMutex
+	// pushContext holds information during push generation. It is reset on config change, at the beginning
+	// of the pushAll. It will hold all errors and stats and possibly caches needed during the entire cache computation.
+	// DO NOT USE EXCEPT FOR TESTS AND HANDLING OF NEW CONNECTIONS.
+	// ALL USE DURING A PUSH SHOULD USE THE ONE CREATED AT THE
+	// START OF THE PUSH, THE GLOBAL ONE MAY CHANGE AND REFLECT A DIFFERENT
+	// CONFIG AND PUSH
+	pushContext *PushContext
+
+	// DomainSuffix provides a default domain for the Istio server.
+	DomainSuffix string
+
+	// TrustBundle: List of Mesh TrustAnchors
+	TrustBundle *trustbundle.TrustBundle
+
+	clusterLocalServices ClusterLocalProvider
+
+	CredentialsController credentials.MulticlusterController
+
+	GatewayAPIController GatewayController
+
+	// EndpointShards for a service. This is a global (per-server) list, built from
+	// incremental updates. This is keyed by service and namespace
+	EndpointIndex *EndpointIndex
+
+	// Cache for XDS resources.
+	Cache XdsCache
+}
+
+func (e *Environment) Mesh() *meshMeshConfig {
+	if e != nil && e.Watcher != nil {
+		return e.Watcher.Mesh()
+	}
+	return nil
+}
+
+func (e *Environment) MeshNetworks() *meshMeshNetworks {
+	if e != nil && e.NetworksWatcher != nil {
+		return e.NetworksWatcher.Networks()
+	}
+	return nil
+}
+
+// SetPushContext sets the push context with lock protected
+func (e *Environment) SetPushContext(pc *PushContext) {
+	e.mutex.Lock()
+	defer e.mutex.Unlock()
+	e.pushContext = pc
+}
+
+// PushContext returns the push context with lock protected
+func (e *Environment) PushContext() *PushContext {
+	e.mutex.RLock()
+	defer e.mutex.RUnlock()
+	return e.pushContext
+}
+
+// GetDiscoveryAddress parses the DiscoveryAddress specified via Mesh
+func (e *Environment) GetDiscoveryAddress() (host.Name, string, error) {
+	proxyConfig := mesh.DefaultProxyConfig()
+	if e.Mesh().DefaultConfig != nil {
+		proxyConfig = e.Mesh().DefaultConfig
+	}
+	hostname, port, err := net.SplitHostPort(proxyDiscoveryAddress)
+	if err != nil {
+		return "", "", fmt.Errorf("invalid Istiod Address: %s, %v", proxyDiscoveryAddress, err)
+	}
+	if _, err := strconv.Atoi(port); err != nil {
+		return "", "", fmt.Errorf("invalid Istiod Port: %s, %s, %v", port, proxyDiscoveryAddress, err)
+	}
+	return host.Name(hostname), port, nil
+}
+
+func (e *Environment) AddMeshHandler(h func()) {
+	if e != nil && e.Watcher != nil {
+		e.Watcher.AddMeshHandler(h)
+	}
+}
+
+func (e *Environment) AddNetworksHandler(h func()) {
+	if e != nil && e.NetworksWatcher != nil {
+		e.NetworksWatcher.AddNetworksHandler(h)
+	}
+}
+
+func (e *Environment) AddMetric(metric monitoring.Metric, key string, proxyID, msg string) {
+	if e != nil {
+		e.PushContext().AddMetric(metric, key, proxyID, msg)
+	}
+}
+
+// Init initializes the Environment for use.
+func (e *Environment) Init() {
+	// Use a default DomainSuffix, if none was provided.
+	if len(e.DomainSuffix) == 0 {
+		e.DomainSuffix = constants.DefaultClusterLocalDomain
+	}
+
+	// Create the cluster-local service registry.
+	e.clusterLocalServices = NewClusterLocalProvider(e)
+}
+
+func (e *Environment) InitNetworksManager(updater XDSUpdater) (err error) {
+	e.NetworkManager, err = NewNetworkManager(e, updater)
+	return
+}
+
+func (e *Environment) ClusterLocal() ClusterLocalProvider {
+	return e.clusterLocalServices
+}
+
+func (e *Environment) GetProxyConfigOrDefault(ns string, labels, annotations map[string]string, meshConfig *meshMeshConfig) *meshProxyConfig {
+	push := e.PushContext()
+	if push != nil && push.ProxyConfigs != nil {
+		if generatedProxyConfig := push.ProxyConfigs.EffectiveProxyConfig(
+			&NodeMetadata{
+				Namespace:   ns,
+				Labels:      labels,
+				Annotations: annotations,
+			}, meshConfig); generatedProxyConfig != nil {
+			return generatedProxyConfig
+		}
+	}
+	return mesh.DefaultProxyConfig()
+}
+
+// Resources is an alias for array of marshaled resources.
+type Resources = []*discovery.Resource
+
+// DeletedResources is an alias for array of strings that represent removed resources in delta.
+type DeletedResources = []string
+
+func AnyToUnnamedResources(r []*anypb.Any) Resources {
+	a := make(Resources, 0, len(r))
+	for _, rr := range r {
+		a = append(a, &discovery.Resource{Resource: rr})
+	}
+	return a
+}
+
+// XdsUpdates include information about the subset of updated resources.
+// See for example EDS incremental updates.
+type XdsUpdates = sets.Set[ConfigKey]
+
+// XdsLogDetails contains additional metadata that is captured by Generators and used by xds processors
+// like Ads and Delta to uniformly log.
+type XdsLogDetails struct {
+	Incremental    bool
+	AdditionalInfo string
+}
+
+var DefaultXdsLogDetails = XdsLogDetails{}
+
+// XdsResourceGenerator creates the response for a typeURL DiscoveryRequest or DeltaDiscoveryRequest. If no generator
+// is associated with a Proxy, the default (a networking.core.ConfigGenerator instance) will be used.
+// The server may associate a different generator based on client metadata. Different
+// WatchedResources may use same or different Generator.
+// Note: any errors returned will completely close the XDS stream. Use with caution; typically and empty
+// or no response is preferred.
+type XdsResourceGenerator interface {
+	// Generate generates the Sotw resources for Xds.
+	Generate(proxy *Proxy, w *WatchedResource, req *PushRequest) (Resources, XdsLogDetails, error)
+}
+
+// XdsDeltaResourceGenerator generates Sotw and delta resources.
+type XdsDeltaResourceGenerator interface {
+	XdsResourceGenerator
+	// GenerateDeltas returns the changed and removed resources, along with whether or not delta was actually used.
+	GenerateDeltas(proxy *Proxy, req *PushRequest, w *WatchedResource) (Resources, DeletedResources, XdsLogDetails, bool, error)
+}
+
+// Proxy contains information about an specific instance of a proxy (envoy sidecar, gateway,
+// etc). The Proxy is initialized when a sidecar connects to Pilot, and populated from
+// 'node' info in the protocol as well as data extracted from registries.
+//
+// In current Istio implementation nodes use a 4-parts '~' delimited ID.
+// Type~IPAddress~ID~Domain
+type Proxy struct {
+	sync.RWMutex
+
+	// Type specifies the node type. First part of the ID.
+	Type NodeType
+
+	// IPAddresses is the IP addresses of the proxy used to identify it and its
+	// co-located service instances. Example: "10.60.1.6". In some cases, the host
+	// where the proxy and service instances reside may have more than one IP address
+	IPAddresses []string
+
+	// ID is the unique platform-specific sidecar proxy ID. For k8s it is the pod ID and
+	// namespace <podName.namespace>.
+	ID string
+
+	// Locality is the location of where Envoy proxy runs. This is extracted from
+	// the registry where possible. If the registry doesn't provide a locality for the
+	// proxy it will use the one sent via ADS that can be configured in the Envoy bootstrap
+	Locality *core.Locality
+
+	// DNSDomain defines the DNS domain suffix for short hostnames (e.g.
+	// "default.svc.cluster.local")
+	DNSDomain string
+
+	// ConfigNamespace defines the namespace where this proxy resides
+	// for the purposes of network scoping.
+	// NOTE: DO NOT USE THIS FIELD TO CONSTRUCT DNS NAMES
+	ConfigNamespace string
+
+	// Labels specifies the set of workload instance (ex: k8s pod) labels associated with this node.
+	// Labels can be different from that in Metadata because of pod labels update after startup,
+	// while NodeMetadata.Labels are set during bootstrap.
+	Labels map[string]string
+
+	// Metadata key-value pairs extending the Node identifier
+	Metadata *NodeMetadata
+
+	// the sidecarScope associated with the proxy
+	SidecarScope *SidecarScope
+
+	// the sidecarScope associated with the proxy previously
+	PrevSidecarScope *SidecarScope
+
+	// The merged gateways associated with the proxy if this is a Router
+	MergedGateway *MergedGateway
+
+	// PrevMergedGateway contains information about merged gateway associated with the proxy previously
+	PrevMergedGateway *PrevMergedGateway
+
+	// ServiceTargets contains a list of all Services associated with the proxy, contextualized for this particular proxy.
+	// These are unique to this proxy, as the port information is specific to it - while a ServicePort is shared with the
+	// service, the target port may be distinct per-endpoint. So this maintains a view specific to this proxy.
+	// ServiceTargets will maintain a list entry for each Service-port, so if we have 2 services each with 3 ports, we
+	// would have 6 entries.
+	ServiceTargets []ServiceTarget
+
+	// Istio version associated with the Proxy
+	IstioVersion *IstioVersion
+
+	// VerifiedIdentity determines whether a proxy had its identity verified. This
+	// generally occurs by JWT or mTLS authentication. This can be false when
+	// connecting over plaintext. If this is set to true, we can verify the proxy has
+	// access to ConfigNamespace namespace. However, other options such as node type
+	// are not part of an Istio identity and thus are not verified.
+	VerifiedIdentity *spiffe.Identity
+
+	// IPMode of proxy.
+	ipMode IPMode
+
+	// GlobalUnicastIP stores the global unicast IP if available, otherwise nil
+	GlobalUnicastIP string
+
+	// XdsResourceGenerator is used to generate resources for the node, based on the PushContext.
+	// If nil, the default networking/core v2 generator is used. This field can be set
+	// at connect time, based on node metadata, to trigger generation of a different style
+	// of configuration.
+	XdsResourceGenerator XdsResourceGenerator
+
+	// WatchedResources contains the list of watched resources for the proxy, keyed by the DiscoveryRequest TypeUrl.
+	WatchedResources map[string]*WatchedResource
+
+	// XdsNode is the xDS node identifier
+	XdsNode *core.Node
+
+	workloadEntryName        string
+	workloadEntryAutoCreated bool
+
+	// LastPushContext stores the most recent push context for this proxy. This will be monotonically
+	// increasing in version. Requests should send config based on this context; not the global latest.
+	// Historically, the latest was used which can cause problems when computing whether a push is
+	// required, as the computed sidecar scope version would not monotonically increase.
+	LastPushContext *PushContext
+	// LastPushTime records the time of the last push. This is used in conjunction with
+	// LastPushContext; the XDS cache depends on knowing the time of the PushContext to determine if a
+	// key is stale or not.
+	LastPushTime time.Time
+}
+
+type WatchedResource = xds.WatchedResource
+
+// GetView returns a restricted view of the mesh for this proxy. The view can be
+// restricted by network (via ISTIO_META_REQUESTED_NETWORK_VIEW).
+// If not set, we assume that the proxy wants to see endpoints in any network.
+func (node *Proxy) GetView() ProxyView {
+	return newProxyView(node)
+}
+
+// InNetwork returns true if the proxy is on the given network, or if either
+// the proxy's network or the given network is unspecified ("").
+func (node *Proxy) InNetwork(network network.ID) bool {
+	return node == nil || identifier.IsSameOrEmpty(network.String(), node.Metadata.Network.String())
+}
+
+// InCluster returns true if the proxy is in the given cluster, or if either
+// the proxy's cluster id or the given cluster id is unspecified ("").
+func (node *Proxy) InCluster(cluster cluster.ID) bool {
+	return node == nil || identifier.IsSameOrEmpty(cluster.String(), node.Metadata.ClusterID.String())
+}
+
+// IsWaypointProxy returns true if the proxy is acting as a waypoint proxy in an ambient mesh.
+func (node *Proxy) IsWaypointProxy() bool {
+	return node.Type == Waypoint
+}
+
+// IsZTunnel returns true if the proxy is acting as a ztunnel in an ambient mesh.
+func (node *Proxy) IsZTunnel() bool {
+	return node.Type == Ztunnel
+}
+
+// IsAmbient returns true if the proxy is acting as either a ztunnel or a waypoint proxy in an ambient mesh.
+func (node *Proxy) IsAmbient() bool {
+	return node.IsWaypointProxy() || node.IsZTunnel()
+}
+
+var NodeTypes = [...]NodeType{SidecarProxy, Router, Waypoint, Ztunnel}
+
+// SetGatewaysForProxy merges the Gateway objects associated with this
+// proxy and caches the merged object in the proxy Node. This is a convenience hack so that
+// callers can simply call push.MergedGateways(node) instead of having to
+// fetch all the gateways and invoke the merge call in multiple places (lds/rds).
+// Must be called after ServiceTargets are set
+func (node *Proxy) SetGatewaysForProxy(ps *PushContext) {
+	if node.Type != Router {
+		return
+	}
+	var prevMergedGateway MergedGateway
+	if node.MergedGateway != nil {
+		prevMergedGateway = *node.MergedGateway
+	}
+	node.MergedGateway = ps.mergeGateways(node)
+	node.PrevMergedGateway = &PrevMergedGateway{
+		ContainsAutoPassthroughGateways: prevMergedGateway.ContainsAutoPassthroughGateways,
+		AutoPassthroughSNIHosts:         prevMergedGateway.GetAutoPassthroughGatewaySNIHosts(),
+	}
+}
+
+func (node *Proxy) ShouldUpdateServiceTargets(updates sets.Set[ConfigKey]) bool {
+	// we only care for services which can actually select this proxy
+	for config := range updates {
+		if Kind == kind.ServiceEntry || Namespace == node.Metadata.Namespace {
+			return true
+		}
+	}
+
+	return false
+}
+
+func (node *Proxy) SetServiceTargets(serviceDiscovery ServiceDiscovery) {
+	instances := serviceDiscovery.GetProxyServiceTargets(node)
+
+	// Keep service instances in order of creation/hostname.
+	sort.SliceStable(instances, func(i, j int) bool {
+		if instances[i].Service != nil && instances[j].Service != nil {
+			if !instances[i].Service.CreationTime.Equal(instances[j].Service.CreationTime) {
+				return instances[i].Service.CreationTime.Before(instances[j].Service.CreationTime)
+			}
+			// Additionally, sort by hostname just in case services created automatically at the same second.
+			return instances[i].Service.Hostname < instances[j].Service.Hostname
+		}
+		return true
+	})
+
+	node.ServiceTargets = instances
+}
+
+// SetWorkloadLabels will set the node.Labels.
+// It merges both node meta labels and workload labels and give preference to workload labels.
+func (node *Proxy) SetWorkloadLabels(env *Environment) {
+	// If this is VM proxy, do not override labels at all, because in istio test we use pod to simulate VM.
+	if node.IsVM() {
+		node.Labels = node.Metadata.Labels
+		return
+	}
+	labels := env.GetProxyWorkloadLabels(node)
+	if labels != nil {
+		node.Labels = make(map[string]string, len(labels)+len(node.Metadata.StaticLabels))
+		// we can't just equate proxy workload labels to node meta labels as it may be customized by user
+		// with `ISTIO_METAJSON_LABELS` env (pkg/bootstrap/go extractAttributesMetadata).
+		// so, we fill the `ISTIO_METAJSON_LABELS` as well.
+		for k, v := range node.Metadata.StaticLabels {
+			node.Labels[k] = v
+		}
+		for k, v := range labels {
+			node.Labels[k] = v
+		}
+	} else {
+		// If could not find pod labels, fallback to use the node metadata labels.
+		node.Labels = node.Metadata.Labels
+	}
+}
+
+// DiscoverIPMode discovers the IP Versions supported by Proxy based on its IP addresses.
+func (node *Proxy) DiscoverIPMode() {
+	node.ipMode = pm.DiscoverIPMode(node.IPAddresses)
+	node.GlobalUnicastIP = networkutil.GlobalUnicastIP(node.IPAddresses)
+}
+
+// SupportsIPv4 returns true if proxy supports IPv4 addresses.
+func (node *Proxy) SupportsIPv4() bool {
+	return node.ipMode == IPv4 || node.ipMode == Dual
+}
+
+// SupportsIPv6 returns true if proxy supports IPv6 addresses.
+func (node *Proxy) SupportsIPv6() bool {
+	return node.ipMode == IPv6 || node.ipMode == Dual
+}
+
+// IsIPv6 returns true if proxy only supports IPv6 addresses.
+func (node *Proxy) IsIPv6() bool {
+	return node.ipMode == IPv6
+}
+
+func (node *Proxy) IsDualStack() bool {
+	return node.ipMode == Dual
+}
+
+// GetIPMode returns proxy's ipMode
+func (node *Proxy) GetIPMode() IPMode {
+	return node.ipMode
+}
+
+// SetIPMode set node's ip mode
+// Note: Donot use this function directly in most cases, use DiscoverIPMode instead.
+func (node *Proxy) SetIPMode(mode IPMode) {
+	node.ipMode = mode
+}
+
+// ParseMetadata parses the opaque Metadata from an Envoy Node into string key-value pairs.
+// Any non-string values are ignored.
+func ParseMetadata(metadata *structpb.Struct) (*NodeMetadata, error) {
+	if metadata == nil {
+		return &NodeMetadata{}, nil
+	}
+
+	bootstrapNodeMeta, err := ParseBootstrapNodeMetadata(metadata)
+	if err != nil {
+		return nil, err
+	}
+	return &bootstrapNodeMeta.NodeMetadata, nil
+}
+
+// ParseBootstrapNodeMetadata parses the opaque Metadata from an Envoy Node into string key-value pairs.
+func ParseBootstrapNodeMetadata(metadata *structpb.Struct) (*BootstrapNodeMetadata, error) {
+	if metadata == nil {
+		return &BootstrapNodeMetadata{}, nil
+	}
+
+	b, err := protomarshal.MarshalProtoNames(metadata)
+	if err != nil {
+		return nil, fmt.Errorf("failed to read node metadata %v: %v", metadata, err)
+	}
+	meta := &BootstrapNodeMetadata{}
+	if err := json.Unmarshal(b, meta); err != nil {
+		return nil, fmt.Errorf("failed to unmarshal node metadata (%v): %v", string(b), err)
+	}
+	return meta, nil
+}
+
+// ParseServiceNodeWithMetadata parse the Envoy Node from the string generated by ServiceNode
+// function and the metadata.
+func ParseServiceNodeWithMetadata(nodeID string, metadata *NodeMetadata) (*Proxy, error) {
+	parts := strings.Split(nodeID, serviceNodeSeparator)
+	out := &Proxy{
+		Metadata: metadata,
+	}
+
+	if len(parts) != 4 {
+		return out, fmt.Errorf("missing parts in the service node %q", nodeID)
+	}
+
+	if !pm.IsApplicationNodeType(NodeType(parts[0])) {
+		return out, fmt.Errorf("invalid node type (valid types: %v) in the service node %q", NodeTypes, nodeID)
+	}
+	out.Type = NodeType(parts[0])
+
+	// Get all IP Addresses from Metadata
+	if hasValidIPAddresses(metadata.InstanceIPs) {
+		out.IPAddresses = metadata.InstanceIPs
+	} else if netutil.IsValidIPAddress(parts[1]) {
+		// Fall back, use IP from node id, it's only for backward-compatibility, IP should come from metadata
+		out.IPAddresses = append(out.IPAddresses, parts[1])
+	}
+
+	// Does query from ingress or router have to carry valid IP address?
+	if len(out.IPAddresses) == 0 {
+		return out, fmt.Errorf("no valid IP address in the service node id or metadata")
+	}
+
+	out.ID = parts[2]
+	out.DNSDomain = parts[3]
+	if len(metadata.IstioVersion) == 0 {
+		log.Warnf("Istio Version is not found in metadata for %v, which may have undesirable side effects", out.ID)
+	}
+	out.IstioVersion = ParseIstioVersion(metadata.IstioVersion)
+	return out, nil
+}
+
+// GetOrDefault returns either the value, or the default if the value is empty. Useful when retrieving node metadata fields.
+func GetOrDefault(s string, def string) string {
+	return pm.GetOrDefault(s, def)
+}
+
+// GetProxyConfigNamespace extracts the namespace associated with the proxy
+// from the proxy metadata or the proxy ID
+func GetProxyConfigNamespace(proxy *Proxy) string {
+	if proxy == nil {
+		return ""
+	}
+
+	// First look for ISTIO_META_CONFIG_NAMESPACE
+	// All newer proxies (from Istio 1.1 onwards) are supposed to supply this
+	if len(proxy.Metadata.Namespace) > 0 {
+		return proxy.Metadata.Namespace
+	}
+
+	// if not found, for backward compatibility, extract the namespace from
+	// the proxy domain. this is a k8s specific hack and should be enabled
+	parts := strings.Split(proxy.DNSDomain, ".")
+	if len(parts) > 1 { // k8s will have namespace.<domain>
+		return parts[0]
+	}
+
+	return ""
+}
+
+const (
+	serviceNodeSeparator = "~"
+)
+
+// hasValidIPAddresses returns true if the input ips are all valid, otherwise returns false.
+func hasValidIPAddresses(ipAddresses []string) bool {
+	if len(ipAddresses) == 0 {
+		return false
+	}
+	for _, ipAddress := range ipAddresses {
+		if !netutil.IsValidIPAddress(ipAddress) {
+			return false
+		}
+	}
+	return true
+}
+
+const (
+	// InterceptionNone indicates that the workload is not using IPtables for traffic interception
+	InterceptionNone TrafficInterceptionMode = "NONE"
+
+	// InterceptionTproxy implies traffic intercepted by IPtables with TPROXY mode
+	InterceptionTproxy TrafficInterceptionMode = "TPROXY"
+
+	// InterceptionRedirect implies traffic intercepted by IPtables with REDIRECT mode
+	// This is our default mode
+	InterceptionRedirect TrafficInterceptionMode = "REDIRECT"
+)
+
+// GetInterceptionMode extracts the interception mode associated with the proxy
+// from the proxy metadata
+func (node *Proxy) GetInterceptionMode() TrafficInterceptionMode {
+	if node == nil {
+		return InterceptionRedirect
+	}
+
+	switch node.Metadata.InterceptionMode {
+	case "TPROXY":
+		return InterceptionTproxy
+	case "REDIRECT":
+		return InterceptionRedirect
+	case "NONE":
+		return InterceptionNone
+	}
+
+	return InterceptionRedirect
+}
+
+// IsUnprivileged returns true if the proxy has explicitly indicated that it is
+// unprivileged, i.e. it cannot bind to the privileged ports 1-1023.
+func (node *Proxy) IsUnprivileged() bool {
+	if node == nil || node.Metadata == nil {
+		return false
+	}
+	// expect explicit "true" value
+	unprivileged, _ := strconv.ParseBool(node.Metadata.UnprivilegedPod)
+	return unprivileged
+}
+
+// CanBindToPort returns true if the proxy can bind to a given port.
+// canbind indicates whether the proxy can bind to the port.
+// knownlistener indicates whether the check failed if the proxy is trying to bind to a port that is reserved for a static listener or virtual listener.
+func (node *Proxy) CanBindToPort(bindTo bool, proxy *Proxy, push *PushContext,
+	bind string, port int, protocol protocol.Instance, wildcard string,
+) (canbind bool, knownlistener bool) {
+	if bindTo {
+		if isPrivilegedPort(port) && node.IsUnprivileged() {
+			return false, false
+		}
+	}
+	if conflictWithReservedListener(proxy, push, bind, port, protocol, wildcard) {
+		return false, true
+	}
+	return true, false
+}
+
+// conflictWithReservedListener checks whether the listener address bind:port conflicts with
+// - static listener port：default is 15021 and 15090
+// - virtual listener port: default is 15001 and 15006 (only need to check for outbound listener)
+func conflictWithReservedListener(proxy *Proxy, push *PushContext, bind string, port int, protocol protocol.Instance, wildcard string) bool {
+	if bind != "" {
+		if bind != wildcard {
+			return false
+		}
+	} else if !protocol.IsHTTP() {
+		// if the protocol is HTTP and bind == "", the listener address will be 0.0.0.0:port
+		return false
+	}
+
+	var conflictWithStaticListener, conflictWithVirtualListener bool
+
+	// bind == wildcard
+	// or bind unspecified, but protocol is HTTP
+	if proxy.Metadata != nil {
+		conflictWithStaticListener = proxy.Metadata.EnvoyStatusPort == port || proxy.Metadata.EnvoyPrometheusPort == port
+	}
+	if push != nil {
+		conflictWithVirtualListener = int(push.Mesh.ProxyListenPort) == port || int(push.Mesh.ProxyInboundListenPort) == port
+	}
+	return conflictWithStaticListener || conflictWithVirtualListener
+}
+
+// isPrivilegedPort returns true if a given port is in the range 1-1023.
+func isPrivilegedPort(port int) bool {
+	// check for 0 is important because:
+	// 1) technically, 0 is not a privileged port; any process can ask to bind to 0
+	// 2) this function will be receiving 0 on input in the case of UDS listeners
+	return 0 < port && port < 1024
+}
+
+func (node *Proxy) IsVM() bool {
+	// TODO use node metadata to indicate that this is a VM instead of the TestVMLabel
+	return node.Metadata.Labels[constants.TestVMLabel] != ""
+}
+
+func (node *Proxy) IsProxylessGrpc() bool {
+	return node.Metadata != nil && node.Metadata.Generator == "grpc"
+}
+
+func (node *Proxy) GetNodeName() string {
+	if node.Metadata != nil && len(node.Metadata.NodeName) > 0 {
+		return node.Metadata.NodeName
+	}
+	return ""
+}
+
+func (node *Proxy) GetClusterID() cluster.ID {
+	if node == nil || node.Metadata == nil {
+		return ""
+	}
+	return node.Metadata.ClusterID
+}
+
+func (node *Proxy) GetNamespace() string {
+	if node == nil || node.Metadata == nil {
+		return ""
+	}
+	return node.Metadata.Namespace
+}
+
+func (node *Proxy) GetID() string {
+	if node == nil {
+		return ""
+	}
+	return node.ID
+}
+
+func (node *Proxy) FuzzValidate() bool {
+	if node.Metadata == nil {
+		return false
+	}
+	found := false
+	for _, t := range NodeTypes {
+		if node.Type == t {
+			found = true
+			break
+		}
+	}
+	if !found {
+		return false
+	}
+	return len(node.IPAddresses) != 0
+}
+
+func (node *Proxy) EnableHBONEListen() bool {
+	return node.IsAmbient() || (features.EnableSidecarHBONEListening && bool(node.Metadata.EnableHBONE))
+}
+
+func (node *Proxy) SetWorkloadEntry(name string, create bool) {
+	node.Lock()
+	defer node.Unlock()
+	node.workloadEntryName = name
+	node.workloadEntryAutoCreated = create
+}
+
+func (node *Proxy) WorkloadEntry() (string, bool) {
+	node.RLock()
+	defer node.RUnlock()
+	return node.workloadEntryName, node.workloadEntryAutoCreated
+}
+
+// ShallowCloneWatchedResources clones the watched resources, both the keys and values are shallow copy.
+func (node *Proxy) ShallowCloneWatchedResources() map[string]*WatchedResource {
+	node.RLock()
+	defer node.RUnlock()
+	return maps.Clone(node.WatchedResources)
+}
+
+// DeepCloneWatchedResources clones the watched resources
+func (node *Proxy) DeepCloneWatchedResources() map[string]WatchedResource {
+	node.RLock()
+	defer node.RUnlock()
+	m := make(map[string]WatchedResource, len(node.WatchedResources))
+	for k, v := range node.WatchedResources {
+		m[k] = *v
+	}
+	return m
+}
+
+func (node *Proxy) GetWatchedResourceTypes() sets.String {
+	node.RLock()
+	defer node.RUnlock()
+
+	ret := sets.NewWithLength[string](len(node.WatchedResources))
+	for typeURL := range node.WatchedResources {
+		ret.Insert(typeURL)
+	}
+	return ret
+}
+
+func (node *Proxy) GetWatchedResource(typeURL string) *WatchedResource {
+	node.RLock()
+	defer node.RUnlock()
+
+	return node.WatchedResources[typeURL]
+}
+
+func (node *Proxy) NonceSent(typeURL string) string {
+	node.RLock()
+	defer node.RUnlock()
+
+	wr := node.WatchedResources[typeURL]
+	if wr != nil {
+		return wr.NonceSent
+	}
+	return ""
+}
+
+func (node *Proxy) NonceAcked(typeURL string) string {
+	node.RLock()
+	defer node.RUnlock()
+
+	wr := node.WatchedResources[typeURL]
+	if wr != nil {
+		return wr.NonceAcked
+	}
+	return ""
+}
+
+func (node *Proxy) Clusters() []string {
+	node.RLock()
+	defer node.RUnlock()
+	wr := node.WatchedResources[v3.EndpointType]
+	if wr != nil {
+		return wr.ResourceNames.UnsortedList()
+	}
+	return nil
+}
+
+func (node *Proxy) NewWatchedResource(typeURL string, names []string) {
+	node.Lock()
+	defer node.Unlock()
+
+	node.WatchedResources[typeURL] = &WatchedResource{TypeUrl: typeURL, ResourceNames: sets.New(names...)}
+	// For all EDS requests that we have already responded with in the same stream let us
+	// force the response. It is important to respond to those requests for Envoy to finish
+	// warming of those resources(Clusters).
+	// This can happen with the following sequence
+	// 1. Envoy disconnects and reconnects to Istiod.
+	// 2. Envoy sends EDS request and we respond with it.
+	// 3. Envoy sends CDS request and we respond with clusters.
+	// 4. Envoy detects a change in cluster state and tries to warm those clusters and send EDS request for them.
+	// 5. We should respond to the EDS request with Endpoints to let Envoy finish cluster warming.
+	// Refer to https://github.com/envoyproxy/envoy/issues/13009 for more details.
+	for _, dependent := range WarmingDependencies(typeURL) {
+		if dwr, exists := node.WatchedResources[dependent]; exists {
+			dwr.AlwaysRespond = true
+		}
+	}
+}
+
+// WarmingDependencies returns the dependent typeURLs that need to be responded with
+// for warming of this typeURL.
+func WarmingDependencies(typeURL string) []string {
+	switch typeURL {
+	case v3.ClusterType:
+		return []string{v3.EndpointType}
+	default:
+		return nil
+	}
+}
+
+func (node *Proxy) AddOrUpdateWatchedResource(r *WatchedResource) {
+	if r == nil {
+		return
+	}
+	node.Lock()
+	defer node.Unlock()
+	node.WatchedResources[r.TypeUrl] = r
+}
+
+func (node *Proxy) UpdateWatchedResource(typeURL string, updateFn func(*WatchedResource) *WatchedResource) {
+	node.Lock()
+	defer node.Unlock()
+	r := node.WatchedResources[typeURL]
+	r = updateFn(r)
+	if r != nil {
+		node.WatchedResources[typeURL] = r
+	} else {
+		delete(node.WatchedResources, typeURL)
+	}
+}
+
+func (node *Proxy) DeleteWatchedResource(typeURL string) {
+	node.Lock()
+	defer node.Unlock()
+
+	delete(node.WatchedResources, typeURL)
+}
+
+type GatewayController interface {
+	ConfigStoreController
+	// Reconcile updates the internal state of the gateway controller for a given input. This should be
+	// called before any List/Get calls if the state has changed
+	Reconcile(ctx *PushContext)
+	// SecretAllowed determines if a SDS credential is accessible to a given namespace.
+	// For example, for resourceName of `kubernetes-gateway://ns-name/secret-name` and namespace of `ingress-ns`,
+	// this would return true only if there was a policy allowing `ingress-ns` to access Secrets in the `ns-name` namespace.
+	SecretAllowed(resourceName string, namespace string) bool
+	Collection() krt.Collection[ADPResource]
+}
+
+// OutboundListenerClass is a helper to turn a NodeType for outbound to a ListenerClass.
+func OutboundListenerClass(t NodeType) istionetworking.ListenerClass {
+	if t == Router {
+		return istionetworking.ListenerClassGateway
+	}
+	return istionetworking.ListenerClassSidecarOutbound
+}
+
+type ADPResource struct {
+	Resource *api.Resource        `json:"resource"`
+	Gateway  types.NamespacedName `json:"gateway"`
+}
+
+func (g ADPResource) ResourceName() string {
+	switch t := g.Resource.Kind.(type) {
+	case *api.Resource_Bind:
+		return "bind/" + t.Bind.Key
+	case *api.Resource_Listener:
+		return "listener/" + t.Listener.Key
+	case *api.Resource_Route:
+		return "route/" + t.Route.Key
+	}
+	panic("unknown resource kind")
+}
+
+func (g ADPResource) Equals(other ADPResource) bool {
+	return proto.Equal(g.Resource, other.Resource) && g.Gateway == other.Gateway
+}
+
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package config
+
+import (
+"bytes"
+"encoding/json"
+"fmt"
+"reflect"
+"time"
+
+gogojsonpb "github.com/gogo/protobuf/jsonpb" // nolint: depguard
+gogoproto "github.com/gogo/protobuf/proto"   // nolint: depguard
+gogotypes "github.com/gogo/protobuf/types"   // nolint: depguard
+"google.golang.org/protobuf/proto"
+"google.golang.org/protobuf/reflect/protoreflect"
+"google.golang.org/protobuf/types/known/anypb"
+"google.golang.org/protobuf/types/known/structpb"
+metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+"k8s.io/apimachinery/pkg/runtime/schema"
+kubetypes "k8s.io/apimachinery/pkg/types"
+"sigs.k8s.io/yaml"
+
+"istio.io/api/label"
+"istio.io/istio/pilot/pkg/util/protoconv"
+"istio.io/istio/pkg/maps"
+"istio.io/istio/pkg/ptr"
+"istio.io/istio/pkg/slices"
+"istio.io/istio/pkg/util/gogoprotomarshal"
+"istio.io/istio/pkg/util/protomarshal"
+"istio.io/istio/pkg/util/sets"
+)
+
+// Meta is metadata attached to each configuration unit.
+// The revision is optional, and if provided, identifies the
+// last update operation on the object.
+type Meta struct {
+	// GroupVersionKind is a short configuration name that matches the content message type
+	// (e.g. "route-rule")
+	GroupVersionKind GroupVersionKind `json:"type,omitempty"`
+
+	// UID
+	UID string `json:"uid,omitempty"`
+
+	// Name is a unique immutable identifier in a namespace
+	Name string `json:"name,omitempty"`
+
+	// Namespace defines the space for names (optional for some types),
+	// applications may choose to use namespaces for a variety of purposes
+	// (security domains, fault domains, organizational domains)
+	Namespace string `json:"namespace,omitempty"`
+
+	// Domain defines the suffix of the fully qualified name past the namespace.
+	// Domain is not a part of the unique key unlike name and namespace.
+	Domain string `json:"domain,omitempty"`
+
+	// Map of string keys and values that can be used to organize and categorize
+	// (scope and select) objects.
+	Labels map[string]string `json:"labels,omitempty"`
+
+	// Annotations is an unstructured key value map stored with a resource that may be
+	// set by external tools to store and retrieve arbitrary metadata. They are not
+	// queryable and should be preserved when modifying objects.
+	Annotations map[string]string `json:"annotations,omitempty"`
+
+	// ResourceVersion is an opaque identifier for tracking updates to the config registry.
+	// The implementation may use a change index or a commit log for the revision.
+	// The config client should not make any assumptions about revisions and rely only on
+	// exact equality to implement optimistic concurrency of read-write operations.
+	//
+	// The lifetime of an object of a particular revision depends on the underlying data store.
+	// The data store may compactify old revisions in the interest of storage optimization.
+	//
+	// An empty revision carries a special meaning that the associated object has
+	// not been stored and assigned a revision.
+	ResourceVersion string `json:"resourceVersion,omitempty"`
+
+	// CreationTimestamp records the creation time
+	CreationTimestamp time.Time `json:"creationTimestamp,omitempty"`
+
+	// OwnerReferences allows specifying in-namespace owning objects.
+	OwnerReferences []metav1.OwnerReference `json:"ownerReferences,omitempty"`
+
+	// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
+	Generation int64 `json:"generation,omitempty"`
+}
+
+// Config is a configuration unit consisting of the type of configuration, the
+// key identifier that is unique per type, and the content represented as a
+// protobuf message.
+type Config struct {
+	Meta
+
+	// Spec holds the configuration object as a gogo protobuf message
+	Spec Spec
+
+	// Status holds long-running status.
+	Status Status
+}
+
+func LabelsInRevision(lbls map[string]string, rev string) bool {
+	configEnv, f := lbls[label.IoIstioRev.Name]
+	if !f {
+		// This is a global object, and always included
+		return true
+	}
+	// If the revision is empty, this means we don't specify a revision, and
+	// we should always include it
+	if rev == "" {
+		return true
+	}
+	// Otherwise, only return true if revisions equal
+	return configEnv == rev
+}
+
+func LabelsInRevisionOrTags(lbls map[string]string, rev string, tags sets.Set[string]) bool {
+	if LabelsInRevision(lbls, rev) {
+		return true
+	}
+	configEnv := lbls[label.IoIstioRev.Name]
+	// Otherwise, only return true if revisions equal
+	return tags.Contains(configEnv)
+}
+
+func ObjectInRevision(o *Config, rev string) bool {
+	return LabelsInRevision(o.Labels, rev)
+}
+
+// Spec defines the spec for the  In order to use below helper methods,
+// this must be one of:
+// * golang/protobuf Message
+// * gogo/protobuf Message
+// * Able to marshal/unmarshal using json
+type Spec any
+
+func ToProto(s Spec) (*anypb.Any, error) {
+	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
+	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
+	// but also not used by Istio at all.
+	if pb, ok := s.(protoreflect.ProtoMessage); ok {
+		return protoconv.MessageToAnyWithError(pb)
+	}
+
+	// gogo protobuf
+	if pb, ok := s.(gogoproto.Message); ok {
+		gogoany, err := gogotypes.MarshalAny(pb)
+		if err != nil {
+			return nil, err
+		}
+		return &anypb.Any{
+			TypeUrl: gogoany.TypeUrl,
+			Value:   gogoany.Value,
+		}, nil
+	}
+
+	js, err := json.Marshal(s)
+	if err != nil {
+		return nil, err
+	}
+	pbs := &structpb.Struct{}
+	if err := protomarshal.Unmarshal(js, pbs); err != nil {
+		return nil, err
+	}
+	return protoconv.MessageToAnyWithError(pbs)
+}
+
+func ToMap(s Spec) (map[string]any, error) {
+	js, err := ToJSON(s)
+	if err != nil {
+		return nil, err
+	}
+
+	// Unmarshal from json bytes to go map
+	var data map[string]any
+	err = json.Unmarshal(js, &data)
+	if err != nil {
+		return nil, err
+	}
+
+	return data, nil
+}
+
+func ToRaw(s Spec) (json.RawMessage, error) {
+	js, err := ToJSON(s)
+	if err != nil {
+		return nil, err
+	}
+
+	// Unmarshal from json bytes to go map
+	return js, nil
+}
+
+func ToJSON(s Spec) ([]byte, error) {
+	return toJSON(s, false)
+}
+
+func ToPrettyJSON(s Spec) ([]byte, error) {
+	return toJSON(s, true)
+}
+
+func toJSON(s Spec, pretty bool) ([]byte, error) {
+	indent := ""
+	if pretty {
+		indent = "    "
+	}
+
+	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
+	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
+	// but also not used by Istio at all.
+	if _, ok := s.(protoreflect.ProtoMessage); ok {
+		if pb, ok := s.(proto.Message); ok {
+			b, err := protomarshal.MarshalIndent(pb, indent)
+			return b, err
+		}
+	}
+
+	b := &bytes.Buffer{}
+	// gogo protobuf
+	if pb, ok := s.(gogoproto.Message); ok {
+		err := (&gogojsonpb.Marshaler{Indent: indent}).Marshal(b, pb)
+		return b.Bytes(), err
+	}
+	if pretty {
+		return json.MarshalIndent(s, "", indent)
+	}
+	return json.Marshal(s)
+}
+
+type deepCopier interface {
+	DeepCopyInterface() any
+}
+
+func ApplyYAML(s Spec, yml string) error {
+	js, err := yaml.YAMLToJSON([]byte(yml))
+	if err != nil {
+		return err
+	}
+	return ApplyJSON(s, string(js))
+}
+
+func ApplyJSONStrict(s Spec, js string) error {
+	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
+	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
+	// but also not used by Istio at all.
+	if _, ok := s.(protoreflect.ProtoMessage); ok {
+		if pb, ok := s.(proto.Message); ok {
+			err := protomarshal.ApplyJSONStrict(js, pb)
+			return err
+		}
+	}
+
+	// gogo protobuf
+	if pb, ok := s.(gogoproto.Message); ok {
+		err := gogoprotomarshal.ApplyJSONStrict(js, pb)
+		return err
+	}
+
+	d := json.NewDecoder(bytes.NewReader([]byte(js)))
+	d.DisallowUnknownFields()
+	return d.Decode(&s)
+}
+
+func ApplyJSON(s Spec, js string) error {
+	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
+	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
+	// but also not used by Istio at all.
+	if _, ok := s.(protoreflect.ProtoMessage); ok {
+		if pb, ok := s.(proto.Message); ok {
+			err := protomarshal.ApplyJSON(js, pb)
+			return err
+		}
+	}
+
+	// gogo protobuf
+	if pb, ok := s.(gogoproto.Message); ok {
+		err := gogoprotomarshal.ApplyJSON(js, pb)
+		return err
+	}
+
+	return json.Unmarshal([]byte(js), &s)
+}
+
+func DeepCopy(s any) any {
+	if s == nil {
+		return nil
+	}
+	// If deep copy is defined, use that
+	if dc, ok := s.(deepCopier); ok {
+		return dc.DeepCopyInterface()
+	}
+
+	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
+	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
+	// but also not used by Istio at all.
+	if _, ok := s.(protoreflect.ProtoMessage); ok {
+		if pb, ok := s.(proto.Message); ok {
+			return protomarshal.Clone(pb)
+		}
+	}
+
+	// gogo protobuf
+	if pb, ok := s.(gogoproto.Message); ok {
+		return gogoproto.Clone(pb)
+	}
+
+	// If we don't have a deep copy method, we will have to do some reflection magic. Its not ideal,
+	// but all Istio types have an efficient deep copy.
+	js, err := json.Marshal(s)
+	if err != nil {
+		return nil
+	}
+
+	data := reflect.New(reflect.TypeOf(s)).Interface()
+	if err := json.Unmarshal(js, data); err != nil {
+		return nil
+	}
+	data = reflect.ValueOf(data).Elem().Interface()
+	return data
+}
+
+func (c *Config) Equals(other *Config) bool {
+	am, bm := c.Meta, other.Meta
+	if am.GroupVersionKind != bm.GroupVersionKind {
+		return false
+	}
+	if am.UID != bm.UID {
+		return false
+	}
+	if am.Name != bm.Name {
+		return false
+	}
+	if am.Namespace != bm.Namespace {
+		return false
+	}
+	if am.Domain != bm.Domain {
+		return false
+	}
+	if !maps.Equal(am.Labels, bm.Labels) {
+		return false
+	}
+	if !maps.Equal(am.Annotations, bm.Annotations) {
+		return false
+	}
+	if am.ResourceVersion != bm.ResourceVersion {
+		return false
+	}
+	if am.CreationTimestamp != bm.CreationTimestamp {
+		return false
+	}
+	if !slices.EqualFunc(am.OwnerReferences, bm.OwnerReferences, func(a metav1.OwnerReference, b metav1.OwnerReference) bool {
+		if a.APIVersion != b.APIVersion {
+			return false
+		}
+		if a.Kind != b.Kind {
+			return false
+		}
+		if a.Name != b.Name {
+			return false
+		}
+		if a.UID != b.UID {
+			return false
+		}
+		if !ptr.Equal(a.Controller, b.Controller) {
+			return false
+		}
+		if !ptr.Equal(a.BlockOwnerDeletion, b.BlockOwnerDeletion) {
+			return false
+		}
+		return true
+	}) {
+		return false
+	}
+	if am.Generation != bm.Generation {
+		return false
+	}
+
+	if !equals(c.Spec, other.Spec) {
+		return false
+	}
+	if !equals(c.Status, other.Status) {
+		return false
+	}
+	return true
+}
+
+func equals(a any, b any) bool {
+	if _, ok := a.(protoreflect.ProtoMessage); ok {
+		if pb, ok := a.(proto.Message); ok {
+			return proto.Equal(pb, b.(proto.Message))
+		}
+	}
+	// We do NOT do gogo here. The reason is Kubernetes has hacked up almost-gogo types that do not allow Equals() calls
+
+	return reflect.DeepEqual(a, b)
+}
+
+type Status any
+
+// Key function for the configuration objects
+func Key(grp, ver, typ, name, namespace string) string {
+	return grp + "/" + ver + "/" + typ + "/" + namespace + "/" + name // Format: %s/%s/%s/%s/%s
+}
+
+// Key is the unique identifier for a configuration object
+func (meta *Meta) Key() string {
+	return Key(
+		meta.GroupVersionKind.Group, meta.GroupVersionKind.Version, meta.GroupVersionKind.Kind,
+		meta.Name, meta.Namespace)
+}
+
+func (meta *Meta) ToObjectMeta() metav1.ObjectMeta {
+	return metav1.ObjectMeta{
+		Name:              meta.Name,
+		Namespace:         meta.Namespace,
+		UID:               kubetypes.UID(meta.UID),
+		ResourceVersion:   meta.ResourceVersion,
+		Generation:        meta.Generation,
+		CreationTimestamp: metav1.NewTime(meta.CreationTimestamp),
+		Labels:            meta.Labels,
+		Annotations:       meta.Annotations,
+		OwnerReferences:   meta.OwnerReferences,
+	}
+}
+
+func (c Config) DeepCopy() Config {
+	var clone Config
+	clone.Meta = c.Meta
+	clone.Labels = maps.Clone(c.Labels)
+	clone.Annotations = maps.Clone(clone.Annotations)
+	clone.Spec = DeepCopy(c.Spec)
+	if c.Status != nil {
+		clone.Status = DeepCopy(c.Status)
+	}
+	return clone
+}
+
+func (c Config) GetName() string {
+	return c.Name
+}
+
+func (c Config) GetNamespace() string {
+	return c.Namespace
+}
+
+func (c Config) GetCreationTimestamp() time.Time {
+	return c.CreationTimestamp
+}
+
+func (c Config) NamespacedName() kubetypes.NamespacedName {
+	return kubetypes.NamespacedName{
+		Namespace: c.Namespace,
+		Name:      c.Name,
+	}
+}
+
+var _ fmt.Stringer = GroupVersionKind{}
+
+type GroupVersionKind struct {
+	Group   string `json:"group"`
+	Version string `json:"version"`
+	Kind    string `json:"kind"`
+}
+
+func (g GroupVersionKind) String() string {
+	return g.CanonicalGroup() + "/" + g.Version + "/" + g.Kind
+}
+
+// GroupVersion returns the group/version similar to what would be found in the apiVersion field of a Kubernetes resource.
+func (g GroupVersionKind) GroupVersion() string {
+	if g.Group == "" {
+		return g.Version
+	}
+	return g.Group + "/" + g.Version
+}
+
+func FromKubernetesGVK(gvk schema.GroupVersionKind) GroupVersionKind {
+	return GroupVersionKind{
+		Group:   gvk.Group,
+		Version: gvk.Version,
+		Kind:    gvk.Kind,
+	}
+}
+
+// Kubernetes returns the same GVK, using the Kubernetes object type
+func (g GroupVersionKind) Kubernetes() schema.GroupVersionKind {
+	return schema.GroupVersionKind{
+		Group:   g.Group,
+		Version: g.Version,
+		Kind:    g.Kind,
+	}
+}
+
+func CanonicalGroup(group string) string {
+	if group != "" {
+		return group
+	}
+	return "core"
+}
+
+// CanonicalGroup returns the group with defaulting applied. This means an empty group will
+// be treated as "core", following Kubernetes API standards
+func (g GroupVersionKind) CanonicalGroup() string {
+	return CanonicalGroup(g.Group)
+}
+
+// PatchFunc provides the cached config as a base for modification. Only diff the between the cfg
+// parameter and the returned Config will be applied.
+type PatchFunc func(cfg Config) (Config, kubetypes.PatchType)
+
+type Namer interface {
+	GetName() string
+	GetNamespace() string
+}
+
+func NamespacedName[T Namer](o T) kubetypes.NamespacedName {
+	return kubetypes.NamespacedName{
+		Namespace: o.GetNamespace(),
+		Name:      o.GetName(),
+	}
+}
+
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
index 3924708e8..14cb43abe 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
@@ -136,7 +136,7 @@ func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName s
 	from := Reference{Kind: gvk.KubernetesGateway, Namespace: gateway.Namespace(namespace)}
 	to := Reference{Kind: gvk.Secret, Namespace: gateway.Namespace(p.Namespace)}
 	pair := ReferencePair{From: from, To: to}
-	grants := krt.FetchOrList(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
+	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
 	for _, g := range grants {
 		if g.AllowAll || g.AllowedName == p.Name {
 			return true
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go b/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
index 78baf2560..89fa45a38 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
@@ -19,7 +19,6 @@ import (
 	"iter"
 	"strings"
 
-	"go.uber.org/atomic"
 	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/types"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
@@ -46,14 +45,10 @@ func HTTPRouteCollection(
 	opts krt.OptionsBuilder,
 ) RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus] {
 	routeCount := gatewayRouteAttachmentCountCollection(inputs, httpRoutes, gvk.HTTPRoute, opts)
-	status, baseVirtualServices := krt.NewStatusManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) (
-		*gateway.HTTPRouteStatus,
-		[]RouteWithKey,
-	) {
+	baseVirtualServices := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []RouteWithKey {
 		ctx := inputs.WithCtx(krtctx)
-		status := obj.Status.DeepCopy()
 		route := obj.Spec
-		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx, obj, func(mesh bool, obj *gateway.HTTPRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
+		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gateway.HTTPRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
 			return func(yield func(*istio.HTTPRoute, *ConfigError) bool) {
 				for n, r := range route.Rules {
 					// split the rule to make sure each rule has up to one match
@@ -65,14 +60,13 @@ func HTTPRouteCollection(
 						if m != nil {
 							r.Matches = []gateway.HTTPRouteMatch{*m}
 						}
-						if !yield(convertHTTPRoute(ctx, r, obj, n, !mesh)) {
+						if !yield(convertHTTPRoute(ctx, r, obj, n)) {
 							return
 						}
 					}
 				}
 			}
 		})
-		status.Parents = parentStatus
 
 		count := 0
 		virtualServices := []RouteWithKey{}
@@ -81,31 +75,6 @@ func HTTPRouteCollection(
 			routeKey := parent.InternalName
 			vsHosts := hostnameToStringList(route.Hostnames)
 			routes := gwResult.routes
-			if parent.IsMesh() {
-				routes = meshResult.routes
-				// for mesh routes, build one VS per namespace/port->host
-				routeKey = obj.Namespace
-				if parent.OriginalReference.Port != nil {
-					routes = augmentPortMatch(routes, *parent.OriginalReference.Port)
-					routeKey += fmt.Sprintf("/%d", *parent.OriginalReference.Port)
-				}
-				ref := types.NamespacedName{
-					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
-					Name:      string(parent.OriginalReference.Name),
-				}
-				if parent.InternalKind == gvk.ServiceEntry {
-					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
-					if ses != nil {
-						vsHosts = ses.Spec.Hosts
-					} else {
-						// TODO: report an error
-						vsHosts = []string{}
-					}
-				} else {
-					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s",
-						parent.OriginalReference.Name, ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace)), ctx.DomainSuffix)}
-				}
-			}
 			if len(routes) == 0 {
 				continue
 			}
@@ -118,14 +87,14 @@ func HTTPRouteCollection(
 				}
 				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, constants.KubernetesGatewayName)
 				sortHTTPRoutes(routes)
-				cfg := &config.Config{
-					Meta: config.Meta{
+				cfg := &Config{
+					Meta: Meta{
 						CreationTimestamp: obj.CreationTimestamp.Time,
-						GroupVersionKind:  gvk.VirtualService,
-						Name:              name,
-						Annotations:       routeMeta(obj),
-						Namespace:         obj.Namespace,
-						Domain:            ctx.DomainSuffix,
+						//GroupVersionKind:  gvk.VirtualService,
+						Name:        name,
+						Annotations: routeMeta(obj),
+						Namespace:   obj.Namespace,
+						Domain:      ctx.DomainSuffix,
 					},
 					Spec: &istio.VirtualService{
 						Hosts:    []string{h},
@@ -140,14 +109,13 @@ func HTTPRouteCollection(
 				count++
 			}
 		}
-		return status, virtualServices
+		return virtualServices
 	}, opts.WithName("HTTPRoute")...)
 
 	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, opts.WithName("HTTPRouteMerged")...)
 	return RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus]{
 		VirtualServices:  finalVirtualServices,
 		RouteAttachments: routeCount,
-		Status:           status,
 	}
 }
 
@@ -155,11 +123,11 @@ func ADPRouteCollection(
 	httpRoutes krt.Collection[*gateway.HTTPRoute],
 	inputs RouteContextInputs,
 	opts krt.OptionsBuilder,
-) krt.Collection[model.ADPResource] {
-	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []model.ADPResource {
+) krt.Collection[ADPResource] {
+	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []ADPResource {
 		ctx := inputs.WithCtx(krtctx)
 		route := obj.Spec
-		_, parentRefs, _, gwResult := computeRoute(ctx, obj, func(mesh bool, obj *gateway.HTTPRoute) iter.Seq2[ADPRoute, *ConfigError] {
+		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gateway.HTTPRoute) iter.Seq2[ADPRoute, *ConfigError] {
 			return func(yield func(ADPRoute, *ConfigError) bool) {
 				for n, r := range route.Rules {
 					// split the rule to make sure each rule has up to one match
@@ -171,7 +139,7 @@ func ADPRouteCollection(
 						if m != nil {
 							r.Matches = []gateway.HTTPRouteMatch{*m}
 						}
-						res, err := convertHTTPRouteToADP(ctx, r, obj, n, idx, !mesh)
+						res, err := convertHTTPRouteToADP(ctx, r, obj, n, idx)
 
 						if !yield(ADPRoute{Route: res}, err) {
 							return
@@ -181,13 +149,10 @@ func ADPRouteCollection(
 			}
 		})
 
-		res := []model.ADPResource{}
+		var res []ADPResource
 		for _, parent := range filteredReferences(parentRefs) {
 			// for gateway routes, build one VS per gateway+host
 			routes := gwResult.routes
-			if parent.IsMesh() {
-				continue
-			}
 			if len(routes) == 0 {
 				continue
 			}
@@ -195,7 +160,7 @@ func ADPRouteCollection(
 				Namespace: parent.ParentKey.Namespace,
 				Name:      parent.ParentKey.Name,
 			}
-			res = append(res, slices.Map(routes, func(e ADPRoute) model.ADPResource {
+			res = append(res, slices.Map(routes, func(e ADPRoute) ADPResource {
 				inner := protomarshal.Clone(e.Route)
 				_, name, _ := strings.Cut(parent.InternalName, "/")
 				inner.ListenerKey = name
@@ -220,14 +185,10 @@ func GRPCRouteCollection(
 	opts krt.OptionsBuilder,
 ) RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus] {
 	routeCount := gatewayRouteAttachmentCountCollection(inputs, grpcRoutes, gvk.GRPCRoute, opts)
-	status, baseVirtualServices := krt.NewStatusManyCollection(grpcRoutes, func(krtctx krt.HandlerContext, obj *gatewayv1.GRPCRoute) (
-		*gatewayv1.GRPCRouteStatus,
-		[]RouteWithKey,
-	) {
+	baseVirtualServices := krt.NewManyCollection(grpcRoutes, func(krtctx krt.HandlerContext, obj *gatewayv1.GRPCRoute) []RouteWithKey {
 		ctx := inputs.WithCtx(krtctx)
-		status := obj.Status.DeepCopy()
 		route := obj.Spec
-		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx, obj, func(mesh bool, obj *gatewayv1.GRPCRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
+		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gatewayv1.GRPCRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
 			return func(yield func(*istio.HTTPRoute, *ConfigError) bool) {
 				for n, r := range route.Rules {
 					// split the rule to make sure each rule has up to one match
@@ -239,47 +200,21 @@ func GRPCRouteCollection(
 						if m != nil {
 							r.Matches = []gatewayv1.GRPCRouteMatch{*m}
 						}
-						if !yield(convertGRPCRoute(ctx, r, obj, n, !mesh)) {
+						if !yield(convertGRPCRoute(ctx, r, obj, n)) {
 							return
 						}
 					}
 				}
 			}
 		})
-		status.Parents = parentStatus
 
 		count := 0
-		virtualServices := []RouteWithKey{}
+		var virtualServices []RouteWithKey
 		for _, parent := range filteredReferences(parentRefs) {
 			// for gateway routes, build one VS per gateway+host
 			routeKey := parent.InternalName
 			vsHosts := hostnameToStringList(route.Hostnames)
 			routes := gwResult.routes
-			if parent.IsMesh() {
-				routes = meshResult.routes
-				// for mesh routes, build one VS per namespace/port->host
-				routeKey = obj.Namespace
-				if parent.OriginalReference.Port != nil {
-					routes = augmentPortMatch(routes, *parent.OriginalReference.Port)
-					routeKey += fmt.Sprintf("/%d", *parent.OriginalReference.Port)
-				}
-				ref := types.NamespacedName{
-					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
-					Name:      string(parent.OriginalReference.Name),
-				}
-				if parent.InternalKind == gvk.ServiceEntry {
-					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
-					if ses != nil {
-						vsHosts = ses.Spec.Hosts
-					} else {
-						// TODO: report an error
-						vsHosts = []string{}
-					}
-				} else {
-					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s",
-						parent.OriginalReference.Name, ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace)), ctx.DomainSuffix)}
-				}
-			}
 			if len(routes) == 0 {
 				continue
 			}
@@ -292,14 +227,14 @@ func GRPCRouteCollection(
 				}
 				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, constants.KubernetesGatewayName)
 				sortHTTPRoutes(routes)
-				cfg := &config.Config{
-					Meta: config.Meta{
+				cfg := &Config{
+					Meta: Meta{
 						CreationTimestamp: obj.CreationTimestamp.Time,
-						GroupVersionKind:  gvk.VirtualService,
-						Name:              name,
-						Annotations:       routeMeta(obj),
-						Namespace:         obj.Namespace,
-						Domain:            ctx.DomainSuffix,
+						//GroupVersionKind:  gvk.VirtualService,
+						Name:        name,
+						Annotations: routeMeta(obj),
+						Namespace:   obj.Namespace,
+						Domain:      ctx.DomainSuffix,
 					},
 					Spec: &istio.VirtualService{
 						Hosts:    []string{h},
@@ -314,14 +249,13 @@ func GRPCRouteCollection(
 				count++
 			}
 		}
-		return status, virtualServices
+		return virtualServices
 	}, opts.WithName("GRPCRoute")...)
 
 	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, opts.WithName("GRPCRouteMerged")...)
 	return RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus]{
 		VirtualServices:  finalVirtualServices,
 		RouteAttachments: routeCount,
-		Status:           status,
 	}
 }
 
@@ -331,62 +265,36 @@ func TCPRouteCollection(
 	opts krt.OptionsBuilder,
 ) RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus] {
 	routeCount := gatewayRouteAttachmentCountCollection(inputs, tcpRoutes, gvk.TCPRoute, opts)
-	status, virtualServices := krt.NewStatusManyCollection(tcpRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TCPRoute) (
-		*gatewayalpha.TCPRouteStatus,
-		[]*config.Config,
-	) {
+	virtualServices := krt.NewManyCollection(tcpRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TCPRoute) []*Config {
 		ctx := inputs.WithCtx(krtctx)
-		status := obj.Status.DeepCopy()
 		route := obj.Spec
-		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx, obj,
-			func(mesh bool, obj *gatewayalpha.TCPRoute) iter.Seq2[*istio.TCPRoute, *ConfigError] {
+		parentRefs, gwResult := computeRoute(ctx, obj,
+			func(obj *gatewayalpha.TCPRoute) iter.Seq2[*istio.TCPRoute, *ConfigError] {
 				return func(yield func(*istio.TCPRoute, *ConfigError) bool) {
 					for _, r := range route.Rules {
-						if !yield(convertTCPRoute(ctx, r, obj, !mesh)) {
+						if !yield(convertTCPRoute(ctx, r, obj)) {
 							return
 						}
 					}
 				}
 			})
-		status.Parents = parentStatus
 
-		vs := []*config.Config{}
+		var vs []*Config
 		for _, parent := range filteredReferences(parentRefs) {
 			routes := gwResult.routes
 			vsHosts := []string{"*"}
-			if parent.IsMesh() {
-				routes = meshResult.routes
-				if parent.OriginalReference.Port != nil {
-					routes = augmentTCPPortMatch(routes, *parent.OriginalReference.Port)
-				}
-				ref := types.NamespacedName{
-					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
-					Name:      string(parent.OriginalReference.Name),
-				}
-				if parent.InternalKind == gvk.ServiceEntry {
-					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
-					if ses != nil {
-						vsHosts = ses.Spec.Hosts
-					} else {
-						// TODO: report an error
-						vsHosts = []string{}
-					}
-				} else {
-					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s", ref.Name, ref.Namespace, ctx.DomainSuffix)}
-				}
-			}
 			for i, host := range vsHosts {
 				name := fmt.Sprintf("%s-tcp-%d-%s", obj.Name, i, constants.KubernetesGatewayName)
 				// Create one VS per hostname with a single hostname.
 				// This ensures we can treat each hostname independently, as the spec requires
-				vs = append(vs, &config.Config{
-					Meta: config.Meta{
+				vs = append(vs, &Config{
+					Meta: Meta{
 						CreationTimestamp: obj.CreationTimestamp.Time,
-						GroupVersionKind:  gvk.VirtualService,
-						Name:              name,
-						Annotations:       routeMeta(obj),
-						Namespace:         obj.Namespace,
-						Domain:            ctx.DomainSuffix,
+						//GroupVersionKind:  gvk.VirtualService,
+						Name:        name,
+						Annotations: routeMeta(obj),
+						Namespace:   obj.Namespace,
+						Domain:      ctx.DomainSuffix,
 					},
 					Spec: &istio.VirtualService{
 						// We can use wildcard here since each listener can have at most one route bound to it, so we have
@@ -398,13 +306,12 @@ func TCPRouteCollection(
 				})
 			}
 		}
-		return status, vs
+		return vs
 	}, opts.WithName("TCPRoute")...)
 
 	return RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus]{
 		VirtualServices:  virtualServices,
 		RouteAttachments: routeCount,
-		Status:           status,
 	}
 }
 
@@ -414,64 +321,37 @@ func TLSRouteCollection(
 	opts krt.OptionsBuilder,
 ) RouteResult[*gatewayalpha.TLSRoute, gatewayalpha.TLSRouteStatus] {
 	routeCount := gatewayRouteAttachmentCountCollection(inputs, tlsRoutes, gvk.TLSRoute, opts)
-	status, virtualServices := krt.NewStatusManyCollection(tlsRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TLSRoute) (
-		*gatewayalpha.TLSRouteStatus,
-		[]*config.Config,
-	) {
+	virtualServices := krt.NewManyCollection(tlsRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TLSRoute) []*Config {
 		ctx := inputs.WithCtx(krtctx)
-		status := obj.Status.DeepCopy()
 		route := obj.Spec
-		parentStatus, parentRefs, meshResult, gwResult := computeRoute(ctx,
-			obj, func(mesh bool, obj *gatewayalpha.TLSRoute) iter.Seq2[*istio.TLSRoute, *ConfigError] {
+		parentRefs, gwResult := computeRoute(ctx,
+			obj, func(obj *gatewayalpha.TLSRoute) iter.Seq2[*istio.TLSRoute, *ConfigError] {
 				return func(yield func(*istio.TLSRoute, *ConfigError) bool) {
 					for _, r := range route.Rules {
-						if !yield(convertTLSRoute(ctx, r, obj, !mesh)) {
+						if !yield(convertTLSRoute(ctx, r, obj)) {
 							return
 						}
 					}
 				}
 			})
-		status.Parents = parentStatus
 
-		vs := []*config.Config{}
+		var vs []*Config
 		for _, parent := range filteredReferences(parentRefs) {
 			routes := gwResult.routes
 			vsHosts := hostnameToStringList(route.Hostnames)
-			if parent.IsMesh() {
-				routes = meshResult.routes
-				ref := types.NamespacedName{
-					Namespace: string(ptr.OrDefault(parent.OriginalReference.Namespace, gateway.Namespace(obj.Namespace))),
-					Name:      string(parent.OriginalReference.Name),
-				}
-				if parent.InternalKind == gvk.ServiceEntry {
-					ses := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(ref.String())))
-					if ses != nil {
-						vsHosts = ses.Spec.Hosts
-					} else {
-						// TODO: report an error
-						vsHosts = []string{}
-					}
-				} else {
-					vsHosts = []string{fmt.Sprintf("%s.%s.svc.%s", ref.Name, ref.Namespace, ctx.DomainSuffix)}
-				}
-				routes = augmentTLSPortMatch(routes, parent.OriginalReference.Port, vsHosts)
-			}
 			for i, host := range vsHosts {
 				name := fmt.Sprintf("%s-tls-%d-%s", obj.Name, i, constants.KubernetesGatewayName)
 				filteredRoutes := routes
-				if parent.IsMesh() {
-					filteredRoutes = compatibleRoutesForHost(routes, host)
-				}
 				// Create one VS per hostname with a single hostname.
 				// This ensures we can treat each hostname independently, as the spec requires
-				vs = append(vs, &config.Config{
-					Meta: config.Meta{
+				vs = append(vs, &Config{
+					Meta: Meta{
 						CreationTimestamp: obj.CreationTimestamp.Time,
-						GroupVersionKind:  gvk.VirtualService,
-						Name:              name,
-						Annotations:       routeMeta(obj),
-						Namespace:         obj.Namespace,
-						Domain:            ctx.DomainSuffix,
+						//GroupVersionKind:  gvk.VirtualService,
+						Name:        name,
+						Annotations: routeMeta(obj),
+						Namespace:   obj.Namespace,
+						Domain:      ctx.DomainSuffix,
 					},
 					Spec: &istio.VirtualService{
 						Hosts:    []string{host},
@@ -481,28 +361,26 @@ func TLSRouteCollection(
 				})
 			}
 		}
-		return status, vs
-	}, opts.WithName("TLSRoute")...)
+		return vs
+	})
 	return RouteResult[*gatewayalpha.TLSRoute, gatewayalpha.TLSRouteStatus]{
 		VirtualServices:  virtualServices,
 		RouteAttachments: routeCount,
-		Status:           status,
 	}
 }
 
 // computeRoute holds the common route building logic shared amongst all types
 func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, translator func(
-	mesh bool,
 	obj T,
 ) iter.Seq2[O, *ConfigError],
-) ([]gateway.RouteParentStatus, []routeParentReference, conversionResult[O], conversionResult[O]) {
+) ([]routeParentReference, conversionResult[O]) {
 	parentRefs := extractParentReferenceInfo(ctx, ctx.RouteParents, obj)
 
-	convertRules := func(mesh bool) conversionResult[O] {
+	convertRules := func() conversionResult[O] {
 		res := conversionResult[O]{}
-		for vs, err := range translator(mesh, obj) {
+		for vs, err := range translator(obj) {
 			// This was a hard error
-			if controllers.IsNil(vs) {
+			if vs == nil {
 				res.error = err
 				return conversionResult[O]{error: err}
 			}
@@ -514,22 +392,9 @@ func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, t
 		}
 		return res
 	}
-	meshResult, gwResult := buildMeshAndGatewayRoutes(parentRefs, convertRules)
+	gwResult := buildMeshAndGatewayRoutes(parentRefs, convertRules)
 
-	rpResults := slices.Map(parentRefs, func(r routeParentReference) RouteParentResult {
-		res := RouteParentResult{
-			OriginalReference: r.OriginalReference,
-			DeniedReason:      r.DeniedReason,
-			RouteError:        gwResult.error,
-		}
-		if r.IsMesh() {
-			res.RouteError = meshResult.error
-			res.WaypointError = r.WaypointError
-		}
-		return res
-	})
-	parents := createRouteStatus(rpResults, obj.GetGeneration(), GetCommonRouteStateParents(obj))
-	return parents, parentRefs, meshResult, gwResult
+	return parentRefs, gwResult
 }
 
 // RouteContext defines a common set of inputs to a route collection. This should be built once per route translation and
@@ -548,14 +413,13 @@ func (r RouteContext) LookupHostname(hostname string, namespace string) *model.S
 }
 
 type RouteContextInputs struct {
-	Grants          ReferenceGrants
-	RouteParents    RouteParents
-	DomainSuffix    string
-	Services        krt.Collection[*corev1.Service]
-	InferencePools  krt.Collection[*inf.InferencePool]
-	Namespaces      krt.Collection[*corev1.Namespace]
-	ServiceEntries  krt.Collection[*networkingclient.ServiceEntry]
-	internalContext krt.RecomputeProtected[*atomic.Pointer[GatewayContext]]
+	Grants         ReferenceGrants
+	RouteParents   RouteParents
+	DomainSuffix   string
+	Services       krt.Collection[*corev1.Service]
+	InferencePools krt.Collection[*inf.InferencePool]
+	Namespaces     krt.Collection[*corev1.Namespace]
+	ServiceEntries krt.Collection[*networkingclient.ServiceEntry]
 }
 
 func (i RouteContextInputs) WithCtx(krtctx krt.HandlerContext) RouteContext {
@@ -566,7 +430,7 @@ func (i RouteContextInputs) WithCtx(krtctx krt.HandlerContext) RouteContext {
 }
 
 type RouteWithKey struct {
-	*config.Config
+	*Config
 	Key string
 }
 
@@ -578,27 +442,17 @@ func (r RouteWithKey) Equals(o RouteWithKey) bool {
 	return r.Config.Equals(o.Config)
 }
 
-// buildMeshAndGatewayRoutes contains common logic to build a set of routes with mesh and/or gateway semantics
-func buildMeshAndGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func(mesh bool) T) (T, T) {
-	var meshResult, gwResult T
-	needMesh, needGw := parentTypes(parentRefs)
-	if needMesh {
-		meshResult = convertRules(true)
-	}
-	if needGw {
-		gwResult = convertRules(false)
-	}
-	return meshResult, gwResult
+// buildMeshAndGatewayRoutes contains common logic to build a set of routes with gateway semantics
+func buildMeshAndGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func() T) T {
+	return convertRules()
 }
 
 // RouteResult holds the result of a route collection
 type RouteResult[I, IStatus any] struct {
 	// VirtualServices are the primary output that configures the internal routing logic
-	VirtualServices krt.Collection[*config.Config]
+	VirtualServices krt.Collection[*Config]
 	// RouteAttachments holds information about parent attachment to routes, used for computed the `attachedRoutes` count.
 	RouteAttachments krt.Collection[*RouteAttachment]
-	// Status stores the status reports for the incoming object
-	Status krt.StatusCollection[I, IStatus]
 }
 
 type GatewayAndListener struct {
@@ -660,11 +514,14 @@ func gatewayRouteAttachmentCountCollection[T controllers.Object](
 
 // mergeHTTPRoutes merges HTTProutes by key. Gateway API has semantics for the ordering of `match` rules, that merges across resource.
 // So we merge everything (by key) following that ordering logic, and sort into a linear list (how VirtualService semantics work).
-func mergeHTTPRoutes(baseVirtualServices krt.Collection[RouteWithKey], opts ...krt.CollectionOption) krt.Collection[*config.Config] {
-	idx := krt.NewIndex(baseVirtualServices, func(o RouteWithKey) []string {
-		return []string{o.Key}
-	}).AsCollection(opts...)
-	finalVirtualServices := krt.NewCollection(idx, func(ctx krt.HandlerContext, object krt.IndexObject[string, RouteWithKey]) **config.Config {
+func mergeHTTPRoutes(baseVirtualServices krt.Collection[RouteWithKey], opts ...krt.CollectionOption) krt.Collection[*Config] {
+	groupedRoutes := krt.NewCollection(baseVirtualServices, func(ctx krt.HandlerContext, obj RouteWithKey) *IndexObject[string, RouteWithKey] {
+		return &IndexObject[string, RouteWithKey]{
+			Key:     obj.Key,
+			Objects: []RouteWithKey{obj},
+		}
+	}, opts...)
+	finalVirtualServices := krt.NewCollection(groupedRoutes, func(ctx krt.HandlerContext, object IndexObject[string, RouteWithKey]) **Config {
 		configs := object.Objects
 		if len(configs) == 1 {
 			return &configs[0].Config
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 22ba1d5e2..a23c21012 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -6,8 +6,10 @@ import (
 	"maps"
 	"slices"
 
+	"github.com/agentgateway/agentgateway/go/api"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer/gateway"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
@@ -15,12 +17,20 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	"google.golang.org/protobuf/proto"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/config/schema/gvr"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/kclient"
 	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/kube/kubetypes"
+	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/client-go/tools/cache"
 	"sigs.k8s.io/controller-runtime/pkg/manager"
+	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 )
 
 var logger = logging.New("agentgateway/syncer")
@@ -139,14 +149,135 @@ func (r report) Equals(in report) bool {
 func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	logger.Debug("init agentgateway Syncer", "controllername", s.controllerName)
 
-	// TODO: convert auth to rbac json config for agentgateways
+	inputs := gateway.Inputs{
+		Namespaces: krt.NewInformer[*corev1.Namespace](s.istioClient),
+		Secrets: krt.WrapClient[*corev1.Secret](
+			kclient.NewFiltered[*corev1.Secret](s.istioClient, kubetypes.Filter{
+				//FieldSelector: kubesecrets.SecretsFieldSelector,
+				ObjectFilter: s.istioClient.ObjectFilter(),
+			}),
+		),
+		Services: krt.WrapClient[*corev1.Service](
+			kclient.NewFiltered[*corev1.Service](s.istioClient, kubetypes.Filter{ObjectFilter: s.istioClient.ObjectFilter()}),
+		),
+		GatewayClasses: buildClient[*gateway.GatewayClass](c, kc, gvr.GatewayClass, opts, "informer/GatewayClasses"),
+		Gateways:       buildClient[*gateway.Gateway](c, kc, gvr.KubernetesGateway, opts, "informer/Gateways"),
+		HTTPRoutes:     buildClient[*gateway.HTTPRoute](c, kc, gvr.HTTPRoute, opts, "informer/HTTPRoutes"),
+		GRPCRoutes:     buildClient[*gatewayv1.GRPCRoute](c, kc, gvr.GRPCRoute, opts, "informer/GRPCRoutes"),
+
+		ReferenceGrants: buildClient[*gateway.ReferenceGrant](c, kc, gvr.ReferenceGrant, opts, "informer/ReferenceGrants"),
+		ServiceEntries:  buildClient[*networkingclient.ServiceEntry](c, kc, gvr.ServiceEntry, opts, "informer/ServiceEntries"),
+		//InferencePools:  buildClient[*inf.InferencePool](c, kc, gvr.InferencePool, opts, "informer/InferencePools"),
+	}
+	if features.EnableAlphaGatewayAPI {
+		inputs.TCPRoutes = buildClient[*gatewayalpha.TCPRoute](c, kc, gvr.TCPRoute, opts, "informer/TCPRoutes")
+		inputs.TLSRoutes = buildClient[*gatewayalpha.TLSRoute](c, kc, gvr.TLSRoute, opts, "informer/TLSRoutes")
+	} else {
+		// If disabled, still build a collection but make it always empty
+		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, opts.WithName("disable/TCPRoutes")...)
+		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, opts.WithName("disable/TLSRoutes")...)
+	}
+
+	GatewayClasses := gateway.GatewayClassesCollection(inputs.GatewayClasses, opts)
+
+	RefGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, opts))
+
+	// Note: not fully complete until its join with route attachments to report attachedRoutes.
+	// Do not register yet.
+	Gateways := GatewayCollection(
+		inputs.Gateways,
+		GatewayClasses,
+		inputs.Namespaces,
+		RefGrants,
+		inputs.Secrets,
+		options.DomainSuffix,
+		opts,
+	)
+	ports := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
+		port := fmt.Sprint(obj.parentInfo.Port)
+		return &IndexObject[string, Gateway]{
+			Key:     port,
+			Objects: []Gateway{obj},
+		}
+	}, opts.WithName("ports")...)
+
+	Binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object IndexObject[string, Gateway]) []ADPResource {
+		port, _ := strconv.Atoi(object.Key)
+		uniq := sets.New[types.NamespacedName]()
+		for _, gw := range object.Objects {
+			uniq.Insert(types.NamespacedName{
+				Namespace: gw.parent.Namespace,
+				Name:      gw.parent.Name,
+			})
+		}
+		return slices.Map(uniq.UnsortedList(), func(e types.NamespacedName) ADPResource {
+			bind := Bind{
+				Bind: &api.Bind{
+					Key:  object.Key + "/" + e.String(),
+					Port: uint32(port),
+				},
+			}
+			return toResource(e, bind)
+		})
+	}, opts.WithName("Binds")...)
+
+	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj gateway.Gateway) *gateway.ADPResource {
+		l := &api.Listener{
+			Key:         obj.ResourceName(),
+			Name:        string(obj.parentInfo.SectionName),
+			BindKey:     fmt.Sprint(obj.parentInfo.Port) + "/" + obj.parent.Namespace + "/" + obj.parent.Name,
+			GatewayName: obj.parent.Namespace + "/" + obj.parent.Name,
+			Hostname:    obj.parentInfo.OriginalHostname,
+		}
 
-	gatewaysCol := krt.NewCollection(s.commonCols.GatewayIndex.Gateways, func(kctx krt.HandlerContext, gw ir.Gateway) *ir.Gateway {
-		if gw.Obj.Spec.GatewayClassName != wellknown.AgentGatewayClassName {
+		switch obj.parentInfo.Protocol {
+		case gatewayv1.HTTPProtocolType:
+			l.Protocol = api.Protocol_HTTP
+		case gatewayv1.HTTPSProtocolType:
+			l.Protocol = api.Protocol_HTTPS
+			if obj.TLSInfo == nil {
+				return nil
+			}
+			l.Tls = &api.TLSConfig{
+				Cert:       obj.TLSInfo.Cert,
+				PrivateKey: obj.TLSInfo.Key,
+			}
+		case gatewayv1.TLSProtocolType:
+			l.Protocol = api.Protocol_TLS
+			if obj.TLSInfo == nil {
+				return nil
+			}
+			l.Tls = &api.TLSConfig{
+				Cert:       obj.TLSInfo.Cert,
+				PrivateKey: obj.TLSInfo.Key,
+			}
+		case gatewayv1.TCPProtocolType:
+			l.Protocol = api.Protocol_TCP
+		default:
 			return nil
 		}
-		return &gw
-	}, krtopts.ToOptions("agentgateway")...)
+		return toResourcep(types.NamespacedName{
+			Namespace: obj.parent.Namespace,
+			Name:      obj.parent.Name,
+		}, gateway.ADPListener{l})
+	}, krtopts.WithName("Listeners")...)
+
+	routeParents := gateway.BuildRouteParents(Gateways)
+
+	routeInputs := gateway.RouteContextInputs{
+		Grants:         RefGrants,
+		RouteParents:   routeParents,
+		DomainSuffix:   options.DomainSuffix,
+		Services:       inputs.Services,
+		Namespaces:     inputs.Namespaces,
+		ServiceEntries: inputs.ServiceEntries,
+		InferencePools: inputs.InferencePools,
+	}
+	ADPRoutes := gateway.ADPRouteCollection(
+		inputs.HTTPRoutes,
+		routeInputs,
+		opts,
+	)
 
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
diff --git a/internal/kgateway/query/mocks/mock_queries.go b/internal/kgateway/query/mocks/mock_queries.go
index fc492f632..59811ed02 100644
--- a/internal/kgateway/query/mocks/mock_queries.go
+++ b/internal/kgateway/query/mocks/mock_queries.go
@@ -9,12 +9,11 @@ import (
 	reflect "reflect"
 
 	gomock "github.com/golang/mock/gomock"
+	query "github.com/kgateway-dev/kgateway/v2/internal/kgateway/query"
+	ir "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/ir"
 	krt "istio.io/istio/pkg/kube/krt"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	v1 "sigs.k8s.io/gateway-api/apis/v1"
-
-	query "github.com/kgateway-dev/kgateway/v2/internal/kgateway/query"
-	ir "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/ir"
 )
 
 // MockGatewayQueries is a mock of GatewayQueries interface.
-- 
2.39.5 (Apple Git-154)


From 47824b4feb183619c58c6377fba74ee9b4e999ce Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 09:31:09 -0700
Subject: [PATCH 04/17] wip

---
 .../{ => gateway}/README.md                   |    0
 .../agentgatewaysyncer/gateway/adp.go         |   43 +-
 .../agentgatewaysyncer/gateway/conditions.go  |   10 -
 .../gateway/conditions_test.go                |  124 --
 .../agentgatewaysyncer/{ => gateway}/const.go |    2 +-
 .../agentgatewaysyncer/gateway/context.go     |    2 +-
 .../agentgatewaysyncer/gateway/controller.go  |  610 -------
 .../gateway/controller_test.go                |  137 --
 .../agentgatewaysyncer/gateway/conversion.go  |   72 +-
 .../gateway/conversion_test.go                | 1560 -----------------
 .../gateway/deploymentcontroller.go           |  952 ----------
 .../gateway/deploymentcontroller_test.go      |  683 --------
 .../gateway/gateway_collection.go             |   18 +-
 .../gateway/gatewayclass.go                   |  118 --
 .../gateway/gatewayclass_collection.go        |   38 +-
 .../gateway/gatewayclass_test.go              |   93 -
 .../agentgatewaysyncer/gateway/leak_test.go   |   25 -
 .../agentgatewaysyncer/gateway/model.go       | 1330 +-------------
 .../gateway/references_collection.go          |    7 +-
 .../gateway/route_collections.go              |   37 +-
 .../agentgatewaysyncer/gateway/service.go     | 1452 +++++++++++++++
 .../agentgatewaysyncer/gateway/status.go      |   90 -
 .../agentgatewaysyncer/gateway/status_test.go |  104 --
 .../gateway/supported_features.go             |   21 -
 .../{ => gateway}/syncer.go                   |  123 +-
 .../{ => gateway}/syncer_test.go              |    2 +-
 internal/kgateway/controller/start.go         |    4 +-
 27 files changed, 1704 insertions(+), 5953 deletions(-)
 rename internal/kgateway/agentgatewaysyncer/{ => gateway}/README.md (100%)
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go
 rename internal/kgateway/agentgatewaysyncer/{ => gateway}/const.go (84%)
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/controller.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/controller_test.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/leak_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/gateway/service.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/status.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/status_test.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/supported_features.go
 rename internal/kgateway/agentgatewaysyncer/{ => gateway}/syncer.go (73%)
 rename internal/kgateway/agentgatewaysyncer/{ => gateway}/syncer_test.go (97%)

diff --git a/internal/kgateway/agentgatewaysyncer/README.md b/internal/kgateway/agentgatewaysyncer/gateway/README.md
similarity index 100%
rename from internal/kgateway/agentgatewaysyncer/README.md
rename to internal/kgateway/agentgatewaysyncer/gateway/README.md
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/adp.go b/internal/kgateway/agentgatewaysyncer/gateway/adp.go
index 099cd23f1..138ae6475 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/adp.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/adp.go
@@ -5,11 +5,8 @@ import (
 	"strings"
 
 	"github.com/agentgateway/agentgateway/go/api"
-	"istio.io/istio/pkg/config"
-	k8s "sigs.k8s.io/gateway-api/apis/v1"
-
-	"istio.io/istio/pkg/ptr"
 	"istio.io/istio/pkg/slices"
+	k8s "sigs.k8s.io/gateway-api/apis/v1"
 )
 
 func createADPMethodMatch(match k8s.HTTPRouteMatch) (*api.MethodMatch, *ConfigError) {
@@ -146,8 +143,13 @@ func createADPRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
+
+	var hostname string
+	if filter.Hostname != nil {
+		hostname = string(*filter.Hostname)
+	}
 	ff := &api.UrlRewrite{
-		Host: string(ptr.OrEmpty(filter.Hostname)),
+		Host: hostname,
 	}
 	if filter.Path != nil {
 		switch filter.Path.Type {
@@ -168,7 +170,7 @@ func createADPMirrorFilter(
 	ctx RouteContext,
 	filter *k8s.HTTPRequestMirrorFilter,
 	ns string,
-	k config.GroupVersionKind,
+	k GroupVersionKind,
 ) (*api.RouteFilter, *ConfigError) {
 	if filter == nil {
 		return nil, nil
@@ -185,7 +187,11 @@ func createADPMirrorFilter(
 	}
 	var percent float64
 	if f := filter.Fraction; f != nil {
-		percent = (100 * float64(f.Numerator)) / float64(ptr.OrDefault(f.Denominator, int32(100)))
+		denominator := float64(100)
+		if f.Denominator != nil {
+			denominator = float64(*f.Denominator)
+		}
+		percent = (100 * float64(f.Numerator)) / denominator
 	} else if p := filter.Percent; p != nil {
 		percent = float64(*p)
 	} else {
@@ -212,11 +218,26 @@ func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *api.RouteFi
 	if filter == nil {
 		return nil
 	}
+	var scheme, host string
+	var port, statusCode uint32
+	if filter.Scheme != nil {
+		scheme = *filter.Scheme
+	}
+	if filter.Hostname != nil {
+		host = string(*filter.Hostname)
+	}
+	if filter.Port != nil {
+		port = uint32(*filter.Port)
+	}
+	if filter.StatusCode != nil {
+		statusCode = uint32(*filter.StatusCode)
+	}
+
 	ff := &api.RequestRedirect{
-		Scheme: ptr.OrEmpty(filter.Scheme),
-		Host:   string(ptr.OrEmpty(filter.Hostname)),
-		Port:   uint32(ptr.OrEmpty(filter.Port)),
-		Status: uint32(ptr.OrEmpty(filter.StatusCode)),
+		Scheme: scheme,
+		Host:   host,
+		Port:   port,
+		Status: statusCode,
 	}
 	if filter.Path != nil {
 		switch filter.Path.Type {
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conditions.go b/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
index 3765df1e5..b39696417 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
@@ -11,16 +11,6 @@ import (
 	"istio.io/istio/pkg/slices"
 )
 
-// RouteParentResult holds the result of a route for a specific parent
-type RouteParentResult struct {
-	// OriginalReference contains the original reference
-	OriginalReference k8s.ParentReference
-	// DeniedReason, if present, indicates why the reference was not valid
-	DeniedReason *ParentError
-	// RouteError, if present, indicates why the reference was not valid
-	RouteError *ConfigError
-}
-
 type ParentErrorReason string
 
 const (
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go b/internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go
deleted file mode 100644
index 5d91e1b65..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/conditions_test.go
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"reflect"
-	"testing"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	k8s "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/schema/gvk"
-)
-
-func TestCreateRouteStatus(t *testing.T) {
-	lastTransitionTime := metav1.Now()
-	parentRef := httpRouteSpec.ParentRefs[0]
-	parentStatus := []k8s.RouteParentStatus{
-		{
-			ParentRef:      parentRef,
-			ControllerName: k8s.GatewayController("another-gateway-controller"),
-			Conditions: []metav1.Condition{
-				{Type: "foo", Status: "bar"},
-			},
-		},
-		{
-			ParentRef:      parentRef,
-			ControllerName: k8s.GatewayController(features.ManagedGatewayController),
-			Conditions: []metav1.Condition{
-				{
-					Type:               string(k8s.RouteReasonAccepted),
-					Status:             metav1.ConditionTrue,
-					ObservedGeneration: 1,
-					LastTransitionTime: lastTransitionTime,
-					Message:            "Route was valid",
-				},
-				{
-					Type:               string(k8s.RouteConditionResolvedRefs),
-					Status:             metav1.ConditionTrue,
-					ObservedGeneration: 1,
-					LastTransitionTime: lastTransitionTime,
-					Message:            "All references resolved",
-				},
-				{
-					Type:               string(RouteConditionResolvedWaypoints),
-					Status:             metav1.ConditionTrue,
-					ObservedGeneration: 1,
-					LastTransitionTime: lastTransitionTime,
-					Message:            "All waypoints resolved",
-				},
-			},
-		},
-	}
-
-	httpRoute := config.Config{
-		Meta: config.Meta{
-			GroupVersionKind: gvk.HTTPRoute,
-			Namespace:        "foo",
-			Name:             "bar",
-			Generation:       1,
-		},
-		Spec: &httpRouteSpec,
-		Status: &k8s.HTTPRouteStatus{
-			RouteStatus: k8s.RouteStatus{
-				Parents: parentStatus,
-			},
-		},
-	}
-
-	type args struct {
-		gateways []RouteParentResult
-		obj      config.Config
-		current  []k8s.RouteParentStatus
-	}
-	tests := []struct {
-		name      string
-		args      args
-		wantEqual bool
-	}{
-		{
-			name: "no error",
-			args: args{
-				gateways: []RouteParentResult{{OriginalReference: parentRef}},
-				obj:      httpRoute,
-				current:  parentStatus,
-			},
-			wantEqual: true,
-		},
-		{
-			name: "route status error",
-			args: args{
-				gateways: []RouteParentResult{{OriginalReference: parentRef, RouteError: &ConfigError{
-					Reason: ConfigErrorReason(k8s.RouteReasonRefNotPermitted),
-				}}},
-				obj:     httpRoute,
-				current: parentStatus,
-			},
-			wantEqual: false,
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got := createRouteStatus(tt.args.gateways, tt.args.obj.Generation, tt.args.current)
-			equal := reflect.DeepEqual(got, tt.args.current)
-			if equal != tt.wantEqual {
-				t.Errorf("route status: old: %+v, new: %+v", tt.args.current, got)
-			}
-		})
-	}
-}
diff --git a/internal/kgateway/agentgatewaysyncer/const.go b/internal/kgateway/agentgatewaysyncer/gateway/const.go
similarity index 84%
rename from internal/kgateway/agentgatewaysyncer/const.go
rename to internal/kgateway/agentgatewaysyncer/gateway/const.go
index d52aef6d2..2442b6413 100644
--- a/internal/kgateway/agentgatewaysyncer/const.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/const.go
@@ -1,4 +1,4 @@
-package agentgatewaysyncer
+package gateway
 
 const (
 	TargetTypeResourceUrl = "type.googleapis.com/istio.adp.Resource"
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/context.go b/internal/kgateway/agentgatewaysyncer/gateway/context.go
index 50190ea21..5519c3620 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/context.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/context.go
@@ -65,7 +65,7 @@ func (gc GatewayContext) ResolveGatewayInstances(
 	foundPending := sets.New[string]()
 	warnings := []string{}
 	foundUnusable := false
-	log.Debugf("Resolving gateway instances for %v in namespace %s", gwsvcs, namespace)
+	logger.Debug("Resolving gateway instances for gateway service", "svc", gwsvcs, "ns", namespace)
 	for _, g := range gwsvcs {
 		svc, f := gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(g)][namespace]
 		if !f {
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/controller.go b/internal/kgateway/agentgatewaysyncer/gateway/controller.go
deleted file mode 100644
index 76495cf34..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/controller.go
+++ /dev/null
@@ -1,610 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"fmt"
-	"strconv"
-
-	"github.com/agentgateway/agentgateway/go/api"
-	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
-	"go.uber.org/atomic"
-	corev1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/apimachinery/pkg/types"
-	"k8s.io/client-go/tools/cache"
-	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
-	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
-	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
-	"istio.io/istio/pilot/pkg/status"
-	"istio.io/istio/pkg/cluster"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/schema/collection"
-	"istio.io/istio/pkg/config/schema/collections"
-	"istio.io/istio/pkg/config/schema/gvk"
-	"istio.io/istio/pkg/config/schema/gvr"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/controllers"
-	"istio.io/istio/pkg/kube/kclient"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/kube/kubetypes"
-	istiolog "istio.io/istio/pkg/log"
-	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/util/sets"
-)
-
-var log = istiolog.RegisterScope("gateway", "gateway-api controller")
-
-var errUnsupportedOp = fmt.Errorf("unsupported operation: the gateway config store is a read-only view")
-
-// Controller defines the controller for the gateway-api. The controller reads a variety of resources (Gateway types, as well
-// as adjacent types like Namespace and Service), and through `krt`, translates them into Istio types (Gateway/VirtualService).
-//
-// Most resources are fully "self-contained" with krt, but there are a few usages breaking out of `krt`; these are managed by `krt.RecomputeProtected`.
-// These are recomputed on each new PushContext initialization, which will call Controller.Reconcile().
-//
-// The generated Istio types are not stored in the cluster at all and are purely internal. Calls to List() (from PushContext)
-// will expose these. They can be introspected at /debug/configz.
-//
-// The status on all gateway-api types is also tracked. Each collection emits downstream objects, but also status about the
-// input type. If the status changes, it is queued to asynchronously update the status of the object in Kubernetes.
-type Controller struct {
-	// client for accessing Kubernetes
-	client kube.Client
-
-	// the cluster where the gateway-api controller runs
-	cluster cluster.ID
-	// revision the controller is running under
-	revision string
-
-	// status controls the status writing queue. Status will only be written if statusEnabled is true, which
-	// is only the case when we are the leader.
-	status *StatusCollections
-
-	// outputs contains all the output collections for this controller.
-	// Currently, the only usage of this controller is from non-krt things (PushContext) so this is not exposed directly.
-	// If desired in the future, it could be.
-	outputs Outputs
-
-	commonCols     *common.CommonCollections
-	controllerName string
-	xDS            krt.Collection[AgentGwXdsResources]
-	xdsCache       envoycache.SnapshotCache
-
-	waitForSync []cache.InformerSynced
-}
-
-type AgentGwXdsResources struct {
-	types.NamespacedName
-
-	reports   reports.ReportMap
-	Resources envoycache.Resources
-	Addresses envoycache.Resources
-}
-
-func (c *Controller) Collection() krt.Collection[ADPResource] {
-	return c.outputs.ADPResources
-}
-
-type ParentInfo struct {
-	Key  parentKey
-	Info parentInfo
-}
-
-func (pi ParentInfo) ResourceName() string {
-	return pi.Key.Name // TODO!!!! more info and section name
-}
-
-type TypedResource struct {
-	Kind config.GroupVersionKind
-	Name types.NamespacedName
-}
-
-type Outputs struct {
-	Gateways        krt.Collection[Gateway]
-	VirtualServices krt.Collection[*config.Config]
-	ReferenceGrants ReferenceGrants
-
-	ADPResources krt.Collection[ADPResource]
-}
-
-type Inputs struct {
-	Namespaces krt.Collection[*corev1.Namespace]
-
-	Services krt.Collection[*corev1.Service]
-	Secrets  krt.Collection[*corev1.Secret]
-
-	GatewayClasses  krt.Collection[*gateway.GatewayClass]
-	Gateways        krt.Collection[*gateway.Gateway]
-	HTTPRoutes      krt.Collection[*gateway.HTTPRoute]
-	GRPCRoutes      krt.Collection[*gatewayv1.GRPCRoute]
-	TCPRoutes       krt.Collection[*gatewayalpha.TCPRoute]
-	TLSRoutes       krt.Collection[*gatewayalpha.TLSRoute]
-	ReferenceGrants krt.Collection[*gateway.ReferenceGrant]
-	ServiceEntries  krt.Collection[*networkingclient.ServiceEntry]
-	InferencePools  krt.Collection[*inf.InferencePool]
-}
-
-var _ GatewayController = &Controller{}
-
-func NewController(
-	kc kube.Client,
-	options controller.Options,
-) *Controller {
-	stop := make(chan struct{})
-	opts := krt.NewOptionsBuilder(stop, options.KrtDebugger)
-
-	c := &Controller{
-		client:   kc,
-		cluster:  options.ClusterID,
-		revision: options.Revision,
-	}
-
-	inputs := Inputs{
-		Namespaces: krt.NewInformer[*corev1.Namespace](kc, opts.WithName("informer/Namespaces")...),
-		Secrets: krt.WrapClient[*corev1.Secret](
-			kclient.NewFiltered[*corev1.Secret](kc, kubetypes.Filter{
-				//FieldSelector: kubesecrets.SecretsFieldSelector,
-				ObjectFilter: kc.ObjectFilter(),
-			}),
-			opts.WithName("informer/Secrets")...,
-		),
-		Services: krt.WrapClient[*corev1.Service](
-			kclient.NewFiltered[*corev1.Service](kc, kubetypes.Filter{ObjectFilter: kc.ObjectFilter()}),
-			opts.WithName("informer/Services")...,
-		),
-		GatewayClasses: buildClient[*gateway.GatewayClass](c, kc, gvr.GatewayClass, opts, "informer/GatewayClasses"),
-		Gateways:       buildClient[*gateway.Gateway](c, kc, gvr.KubernetesGateway, opts, "informer/Gateways"),
-		HTTPRoutes:     buildClient[*gateway.HTTPRoute](c, kc, gvr.HTTPRoute, opts, "informer/HTTPRoutes"),
-		GRPCRoutes:     buildClient[*gatewayv1.GRPCRoute](c, kc, gvr.GRPCRoute, opts, "informer/GRPCRoutes"),
-
-		ReferenceGrants: buildClient[*gateway.ReferenceGrant](c, kc, gvr.ReferenceGrant, opts, "informer/ReferenceGrants"),
-		ServiceEntries:  buildClient[*networkingclient.ServiceEntry](c, kc, gvr.ServiceEntry, opts, "informer/ServiceEntries"),
-		//InferencePools:  buildClient[*inf.InferencePool](c, kc, gvr.InferencePool, opts, "informer/InferencePools"),
-	}
-	if features.EnableAlphaGatewayAPI {
-		inputs.TCPRoutes = buildClient[*gatewayalpha.TCPRoute](c, kc, gvr.TCPRoute, opts, "informer/TCPRoutes")
-		inputs.TLSRoutes = buildClient[*gatewayalpha.TLSRoute](c, kc, gvr.TLSRoute, opts, "informer/TLSRoutes")
-	} else {
-		// If disabled, still build a collection but make it always empty
-		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, opts.WithName("disable/TCPRoutes")...)
-		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, opts.WithName("disable/TLSRoutes")...)
-	}
-
-	GatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, opts)
-
-	RefGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, opts))
-
-	// Note: not fully complete until its join with route attachments to report attachedRoutes.
-	// Do not register yet.
-	Gateways := GatewayCollection(
-		inputs.Gateways,
-		GatewayClasses,
-		inputs.Namespaces,
-		RefGrants,
-		inputs.Secrets,
-		options.DomainSuffix,
-		opts,
-	)
-	ports := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
-		port := fmt.Sprint(obj.parentInfo.Port)
-		return &IndexObject[string, Gateway]{
-			Key:     port,
-			Objects: []Gateway{obj},
-		}
-	}, opts.WithName("ports")...)
-
-	Binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object IndexObject[string, Gateway]) []ADPResource {
-		port, _ := strconv.Atoi(object.Key)
-		uniq := sets.New[types.NamespacedName]()
-		for _, gw := range object.Objects {
-			uniq.Insert(types.NamespacedName{
-				Namespace: gw.parent.Namespace,
-				Name:      gw.parent.Name,
-			})
-		}
-		return slices.Map(uniq.UnsortedList(), func(e types.NamespacedName) ADPResource {
-			bind := Bind{
-				Bind: &api.Bind{
-					Key:  object.Key + "/" + e.String(),
-					Port: uint32(port),
-				},
-			}
-			return toResource(e, bind)
-		})
-	}, opts.WithName("Binds")...)
-
-	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *ADPResource {
-		l := &api.Listener{
-			Key:         obj.ResourceName(),
-			Name:        string(obj.parentInfo.SectionName),
-			BindKey:     fmt.Sprint(obj.parentInfo.Port) + "/" + obj.parent.Namespace + "/" + obj.parent.Name,
-			GatewayName: obj.parent.Namespace + "/" + obj.parent.Name,
-			Hostname:    obj.parentInfo.OriginalHostname,
-		}
-
-		switch obj.parentInfo.Protocol {
-		case gatewayv1.HTTPProtocolType:
-			l.Protocol = api.Protocol_HTTP
-		case gatewayv1.HTTPSProtocolType:
-			l.Protocol = api.Protocol_HTTPS
-			if obj.TLSInfo == nil {
-				return nil
-			}
-			l.Tls = &api.TLSConfig{
-				Cert:       obj.TLSInfo.Cert,
-				PrivateKey: obj.TLSInfo.Key,
-			}
-		case gatewayv1.TLSProtocolType:
-			l.Protocol = api.Protocol_TLS
-			if obj.TLSInfo == nil {
-				return nil
-			}
-			l.Tls = &api.TLSConfig{
-				Cert:       obj.TLSInfo.Cert,
-				PrivateKey: obj.TLSInfo.Key,
-			}
-		case gatewayv1.TCPProtocolType:
-			l.Protocol = api.Protocol_TCP
-		default:
-			return nil
-		}
-		return toResourcep(types.NamespacedName{
-			Namespace: obj.parent.Namespace,
-			Name:      obj.parent.Name,
-		}, ADPListener{l})
-	}, opts.WithName("Listeners")...)
-
-	routeParents := BuildRouteParents(Gateways)
-
-	routeInputs := RouteContextInputs{
-		Grants:         RefGrants,
-		RouteParents:   routeParents,
-		DomainSuffix:   options.DomainSuffix,
-		Services:       inputs.Services,
-		Namespaces:     inputs.Namespaces,
-		ServiceEntries: inputs.ServiceEntries,
-		InferencePools: inputs.InferencePools,
-	}
-	ADPRoutes := ADPRouteCollection(
-		inputs.HTTPRoutes,
-		routeInputs,
-		opts,
-	)
-	//tcpRoutes := TCPRouteCollection(
-	//	inputs.TCPRoutes,
-	//	routeInputs,
-	//	opts,
-	//)
-	//registerStatus(c, tcpRoutes.Status)
-	//tlsRoutes := TLSRouteCollection(
-	//	inputs.TLSRoutes,
-	//	routeInputs,
-	//	opts,
-	//)
-	//registerStatus(c, tlsRoutes.Status)
-	httpRoutes := HTTPRouteCollection(
-		inputs.HTTPRoutes,
-		routeInputs,
-		opts,
-	)
-	//status, _ := krt.NewStatusCollection(inputs.InferencePools, func(krtctx krt.HandlerContext, obj *inf.InferencePool) (
-	//	*inf.InferencePoolStatus,
-	//	*any,
-	//) {
-	//	status := obj.Status.DeepCopy()
-	//	myGws := sets.New[types.NamespacedName]()
-	//	allGws := sets.New[types.NamespacedName]() // this is dumb but https://github.com/kubernetes-sigs/gateway-api-inference-extension/issues/942...
-	//	allGwsRaw := krt.Fetch(krtctx, inputs.Gateways)
-	//	for _, g := range allGwsRaw {
-	//		allGws.Insert(config.NamespacedName(g))
-	//		if string(g.Spec.GatewayClassName) == features.GatewayAPIDefaultGatewayClass {
-	//			myGws.Insert(config.NamespacedName(g))
-	//		}
-	//	}
-	//	seen := sets.New[types.NamespacedName]()
-	//	np := []inf.PoolStatus{}
-	//	for _, s := range status.Parents {
-	//		k := types.NamespacedName{
-	//			Name:      s.GatewayRef.Name,
-	//			Namespace: s.GatewayRef.Namespace,
-	//		}
-	//		if !allGws.Contains(k) {
-	//			// Even if it's not ours, delete stale ref. Shrug.
-	//			continue
-	//		}
-	//		if s.GatewayRef.Kind != gvk.KubernetesGateway.Kind {
-	//			np = append(np, s)
-	//			continue
-	//		}
-	//		if seen.Contains(k) {
-	//			continue
-	//		}
-	//		if !myGws.Contains(k) {
-	//			np = append(np, s)
-	//			continue
-	//		}
-	//		myGws.Delete(k)
-	//		seen.Insert(k)
-	//		conds := map[string]*condition{
-	//			string(inf.InferencePoolConditionAccepted): {
-	//				reason:  string(inf.InferencePoolReasonAccepted),
-	//				message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
-	//			},
-	//		}
-	//		np = append(np, inf.PoolStatus{
-	//			GatewayRef: corev1.ObjectReference{
-	//				APIVersion: gatewayv1.GroupVersion.String(),
-	//				Kind:       gvk.KubernetesGateway.Kind,
-	//				Namespace:  k.Namespace,
-	//				Name:       k.Name,
-	//			},
-	//			Conditions: setConditions(obj.Generation, s.Conditions, conds),
-	//		})
-	//	}
-	//	for _, k := range myGws.UnsortedList() {
-	//		conds := map[string]*condition{
-	//			string(inf.InferencePoolConditionAccepted): {
-	//				reason:  string(inf.InferencePoolReasonAccepted),
-	//				message: "Referenced by an HTTPRoute accepted by the parentRef Gateway",
-	//			},
-	//		}
-	//		np = append(np, inf.PoolStatus{
-	//			GatewayRef: corev1.ObjectReference{
-	//				APIVersion: gatewayv1.GroupVersion.String(),
-	//				Kind:       gvk.KubernetesGateway.Kind,
-	//				Namespace:  k.Namespace,
-	//				Name:       k.Name,
-	//			},
-	//			Conditions: setConditions(obj.Generation, nil, conds),
-	//		})
-	//	}
-	//	status.Parents = np
-	//	return status, nil
-	//}, opts.WithName("InferencePools")...)
-	//registerStatus(c, status)
-	//grpcRoutes := GRPCRouteCollection(
-	//	inputs.GRPCRoutes,
-	//	routeInputs,
-	//	opts,
-	//)
-	//registerStatus(c, grpcRoutes.Status)
-
-	//RouteAttachments := krt.JoinCollection([]krt.Collection[*RouteAttachment]{
-	//	// tcpRoutes.RouteAttachments,
-	//	// tlsRoutes.RouteAttachments,
-	//	httpRoutes.RouteAttachments,
-	//	// grpcRoutes.RouteAttachments,
-	//}, opts.WithName("RouteAttachments")...)
-	//RouteAttachmentsIndex := krt.NewIndex(RouteAttachments, func(o *RouteAttachment) []GatewayAndListener {
-	//	return []GatewayAndListener{{
-	//		ListenerName: o.ListenerName,
-	//		To:           o.To,
-	//	}}
-	//})
-	//
-	//GatewayFinal := FinalGatewayStatusCollection(RouteAttachments, RouteAttachmentsIndex, opts)
-
-	VirtualServices := krt.JoinCollection([]krt.Collection[*config.Config]{
-		// tcpRoutes.VirtualServices,
-		// tlsRoutes.VirtualServices,
-		httpRoutes.VirtualServices,
-		// grpcRoutes.VirtualServices,
-	}, opts.WithName("DerivedVirtualServices")...)
-
-	ADPResources := krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, WaypointListeners, ADPRoutes}, opts.WithName("ADPResources")...)
-
-	outputs := Outputs{
-		ReferenceGrants: RefGrants,
-		Gateways:        Gateways,
-		VirtualServices: VirtualServices,
-
-		ADPResources: ADPResources,
-	}
-	c.outputs = outputs
-
-	return c
-}
-
-// buildClient is a small wrapper to build a krt collection based on a delayed informer.
-func buildClient[I controllers.ComparableObject](
-	c *Controller,
-	kc kube.Client,
-	res schema.GroupVersionResource,
-	opts krt.OptionsBuilder,
-	name string,
-) krt.Collection[I] {
-	filter := kclient.Filter{
-		ObjectFilter: kubetypes.ComposeFilters(kc.ObjectFilter(), c.inRevision),
-	}
-
-	// all other types are filtered by revision, but for gateways we need to select tags as well
-	if res == gvr.KubernetesGateway {
-		filter.ObjectFilter = kc.ObjectFilter()
-	}
-
-	cc := kclient.NewDelayedInformer[I](kc, res, kubetypes.StandardInformer, filter)
-	return krt.WrapClient[I](cc, opts.WithName(name)...)
-}
-
-func (c *Controller) Schemas() collection.Schemas {
-	return collection.SchemasFor(
-		collections.VirtualService,
-		collections.Gateway,
-	)
-}
-
-func (c *Controller) Get(typ config.GroupVersionKind, name, namespace string) *config.Config {
-	return nil
-}
-
-func (c *Controller) List(typ config.GroupVersionKind, namespace string) []config.Config {
-	switch typ {
-	case gvk.Gateway:
-		res := slices.MapFilter(c.outputs.Gateways.List(), func(g Gateway) *config.Config {
-			if g.Valid {
-				return g.Config
-			}
-			return nil
-		})
-		return res
-	case gvk.VirtualService:
-		return slices.Map(c.outputs.VirtualServices.List(), func(e *config.Config) config.Config {
-			return *e
-		})
-	default:
-		return nil
-	}
-}
-
-func (c *Controller) SetStatusWrite(enabled bool, statusManager *status.Manager) {
-	if enabled && features.EnableGatewayAPIStatus && statusManager != nil {
-		var q status.Queue = statusManager.CreateGenericController(func(status status.Manipulator, context any) {
-			status.SetInner(context)
-		})
-		c.status.SetQueue(q)
-	} else {
-		c.status.UnsetQueue()
-	}
-}
-
-// Reconcile is called each time the `gatewayContext` may change. We use this to mark it as updated.
-func (c *Controller) Reconcile(ps *PushContext) {
-	ctx := NewGatewayContext(ps, c.cluster)
-	c.gatewayContext.Modify(func(i **atomic.Pointer[GatewayContext]) {
-		(*i).Store(&ctx)
-	})
-	c.gatewayContext.MarkSynced()
-}
-
-func (c *Controller) Create(config config.Config) (revision string, err error) {
-	return "", errUnsupportedOp
-}
-
-func (c *Controller) Update(config config.Config) (newRevision string, err error) {
-	return "", errUnsupportedOp
-}
-
-func (c *Controller) UpdateStatus(config config.Config) (newRevision string, err error) {
-	return "", errUnsupportedOp
-}
-
-func (c *Controller) Patch(orig config.Config, patchFn config.PatchFunc) (string, error) {
-	return "", errUnsupportedOp
-}
-
-func (c *Controller) Delete(typ config.GroupVersionKind, name, namespace string, _ *string) error {
-	return errUnsupportedOp
-}
-
-func (c *Controller) RegisterEventHandler(typ config.GroupVersionKind, handler EventHandler) {
-}
-
-func (c *Controller) Run(stop <-chan struct{}) {
-	if features.EnableGatewayAPIGatewayClassController {
-		go func() {
-			if c.waitForCRD(gvr.GatewayClass, stop) {
-				gcc := NewClassController(c.client)
-				c.client.RunAndWait(stop)
-				gcc.Run(stop)
-			}
-		}()
-	}
-
-	tw := c.tagWatcher.AccessUnprotected()
-	go tw.Run(stop)
-	go func() {
-		kube.WaitForCacheSync("gateway tag watcher", stop, tw.HasSynced)
-		c.tagWatcher.MarkSynced()
-	}()
-
-	<-stop
-	close(c.stop)
-}
-
-func (c *Controller) HasSynced() bool {
-	if !(c.outputs.VirtualServices.HasSynced() &&
-		c.outputs.Gateways.HasSynced() &&
-		c.outputs.ReferenceGrants.collection.HasSynced()) {
-		return false
-	}
-	for _, h := range c.handlers {
-		if !h.HasSynced() {
-			return false
-		}
-	}
-	return true
-}
-
-func (c *Controller) SecretAllowed(resourceName string, namespace string) bool {
-	return c.outputs.ReferenceGrants.SecretAllowed(nil, resourceName, namespace)
-}
-
-func pushXds[T any](xds XDSUpdater, f func(T) ConfigKey) func(events []krt.Event[T]) {
-	return func(events []krt.Event[T]) {
-		if xds == nil {
-			return
-		}
-		cu := sets.New[ConfigKey]()
-		for _, e := range events {
-			for _, i := range e.Items() {
-				c := f(i)
-				if c != (ConfigKey{}) {
-					cu.Insert(c)
-				}
-			}
-		}
-		if len(cu) == 0 {
-			return
-		}
-		xds.ConfigUpdate(&PushRequest{
-			Full:           true,
-			ConfigsUpdated: cu,
-			Reason:         NewReasonStats(ConfigUpdate),
-		})
-	}
-}
-
-func (c *Controller) inRevision(obj any) bool {
-	object := controllers.ExtractObject(obj)
-	if object == nil {
-		return false
-	}
-	return config.LabelsInRevision(object.GetLabels(), c.revision)
-}
-
-type IndexObject[K comparable, O any] struct {
-	Key     K
-	Objects []O
-}
-
-func (i IndexObject[K, O]) ResourceName() string {
-	return toString(i.Key)
-}
-
-func toString(rk any) string {
-	tk, ok := rk.(string)
-	if !ok {
-		return rk.(fmt.Stringer).String()
-	}
-	return tk
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/controller_test.go b/internal/kgateway/agentgatewaysyncer/gateway/controller_test.go
deleted file mode 100644
index c5cb489e8..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/controller_test.go
+++ /dev/null
@@ -1,137 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"testing"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	k8s "sigs.k8s.io/gateway-api/apis/v1"
-	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	networking "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/networking/core"
-	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/schema/gvk"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/util/assert"
-)
-
-var (
-	gatewayClassSpec = &k8s.GatewayClassSpec{
-		ControllerName: k8s.GatewayController(features.ManagedGatewayController),
-	}
-	gatewaySpec = &k8s.GatewaySpec{
-		GatewayClassName: "gwclass",
-		Listeners: []k8s.Listener{
-			{
-				Name:          "default",
-				Port:          9009,
-				Protocol:      "HTTP",
-				AllowedRoutes: &k8s.AllowedRoutes{Namespaces: &k8s.RouteNamespaces{From: func() *k8s.FromNamespaces { x := k8s.NamespacesFromAll; return &x }()}},
-			},
-		},
-	}
-	httpRouteSpec = &k8s.HTTPRouteSpec{
-		CommonRouteSpec: k8s.CommonRouteSpec{ParentRefs: []k8s.ParentReference{{
-			Name: "gwspec",
-		}}},
-		Hostnames: []k8s.Hostname{"test.cluster.local"},
-	}
-
-	expectedgw = &networking.Gateway{
-		Servers: []*networking.Server{
-			{
-				Port: &networking.Port{
-					Number:   9009,
-					Name:     "default",
-					Protocol: "HTTP",
-				},
-				Hosts: []string{"*/*"},
-			},
-		},
-	}
-)
-
-var AlwaysReady = func(class schema.GroupVersionResource, stop <-chan struct{}) bool {
-	return true
-}
-
-func setupController(t *testing.T, objs ...runtime.Object) *Controller {
-	kc := kube.NewFakeClient(objs...)
-	setupClientCRDs(t, kc)
-	stop := test.NewStop(t)
-	controller := NewController(
-		kc,
-		AlwaysReady,
-		controller.Options{KrtDebugger: krt.GlobalDebugHandler},
-		nil)
-	kc.RunAndWait(stop)
-	go controller.Run(stop)
-	cg := core.NewConfigGenTest(t, core.TestOptions{})
-	controller.Reconcile(cg.PushContext())
-	kube.WaitForCacheSync("test", stop, controller.HasSynced)
-
-	return controller
-}
-
-func TestListInvalidGroupVersionKind(t *testing.T) {
-	controller := setupController(t)
-
-	typ := config.GroupVersionKind{Kind: "wrong-kind"}
-	c := controller.List(typ, "ns1")
-	assert.Equal(t, len(c), 0)
-}
-
-func TestListGatewayResourceType(t *testing.T) {
-	controller := setupController(t,
-		&k8sbeta.GatewayClass{
-			ObjectMeta: metav1.ObjectMeta{
-				Name: "gwclass",
-			},
-			Spec: *gatewayClassSpec,
-		},
-		&k8sbeta.Gateway{
-			ObjectMeta: metav1.ObjectMeta{
-				Name:      "gwspec",
-				Namespace: "ns1",
-			},
-			Spec: *gatewaySpec,
-		},
-		&k8sbeta.HTTPRoute{
-			ObjectMeta: metav1.ObjectMeta{
-				Name:      "http-route",
-				Namespace: "ns1",
-			},
-			Spec: *httpRouteSpec,
-		})
-
-	dumpOnFailure(t, krt.GlobalDebugHandler)
-	cfg := controller.List(gvk.Gateway, "ns1")
-	assert.Equal(t, len(cfg), 1)
-	for _, c := range cfg {
-		assert.Equal(t, c.GroupVersionKind, gvk.Gateway)
-		assert.Equal(t, c.Name, "gwspec"+"-"+constants.KubernetesGatewayName+"-default")
-		assert.Equal(t, c.Namespace, "ns1")
-		assert.Equal(t, c.Spec, any(expectedgw))
-	}
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conversion.go b/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
index 994cb8525..9e221004f 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
@@ -1,17 +1,3 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 package gateway
 
 import (
@@ -25,11 +11,13 @@ import (
 	"strings"
 	"time"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"google.golang.org/protobuf/types/known/durationpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	klabels "k8s.io/apimachinery/pkg/labels"
+	"k8s.io/apimachinery/pkg/runtime/schema"
 	k8s "sigs.k8s.io/gateway-api/apis/v1"
 	k8salpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
@@ -48,7 +36,6 @@ import (
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/config/schema/collections"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/schema/kind"
 	schematypes "istio.io/istio/pkg/config/schema/kubetypes"
@@ -216,9 +203,9 @@ func buildADPHTTPDestination(
 	var invalidBackendErr *ConfigError
 	var res []*api.RouteBackend
 	for _, fwd := range forwardTo {
-		dst, err := buildADPDestination(ctx, fwd, ns, gvk.HTTPRoute)
+		dst, err := buildADPDestination(ctx, fwd, ns, wellknown.HTTPRouteGVK)
 		if err != nil {
-			log.Errorf("howardjohn: adp error: %v", err)
+			logger.Error("erroring building agent gateway destination", "error", err)
 			if isInvalidBackend(err) {
 				invalidBackendErr = err
 				// keep going, we will gracefully drop invalid backends
@@ -242,7 +229,7 @@ func buildADPDestination(
 	ctx RouteContext,
 	to k8s.HTTPBackendRef,
 	ns string,
-	k config.GroupVersionKind,
+	ref schema.GroupVersionKind,
 ) (*api.RouteBackend, *ConfigError) {
 	// check if the reference is allowed
 	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
@@ -254,12 +241,18 @@ func buildADPDestination(
 		}
 	}
 
-	namespace := ptr.OrDefault((*string)(to.Namespace), ns)
+	namespace := ns // use default
+	if to.Namespace != nil {
+		namespace = string(*to.Namespace)
+	}
 	var invalidBackendErr *ConfigError
 	var hostname string
-	ref := normalizeReference(to.Group, to.Kind, gvk.Service)
+	weight := int32(1) // default
+	if to.Weight != nil {
+		weight = *to.Weight
+	}
 	rb := &api.RouteBackend{
-		Weight: ptr.OrDefault(to.Weight, 1),
+		Weight: weight,
 	}
 	var port *k8s.PortNumber
 	switch ref {
@@ -277,7 +270,7 @@ func buildADPDestination(
 	//		port = ptr.Of(k8s.PortNumber(svc.Spec.TargetPortNumber))
 	//	}
 	//	rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
-	case gvk.Service:
+	case wellknown.ServiceGVK:
 		port = to.Port
 		if strings.Contains(string(to.Name), ".") {
 			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
@@ -1573,7 +1566,7 @@ func createGRPCURIMatch(match k8s.GRPCRouteMatch) (*istio.StringMatch, *ConfigEr
 // parentKey holds info about a parentRef (eg route binding to a Gateway). This is a mirror of
 // k8s.ParentReference in a form that can be stored in a map
 type parentKey struct {
-	Kind config.GroupVersionKind
+	Kind schema.GroupVersionKind
 	// Name is the original name of the resource (eg Kubernetes Gateway name)
 	Name string
 	// Namespace is the namespace of the resource
@@ -1691,10 +1684,7 @@ func filteredReferences(parents []routeParentReference) []routeParentReference {
 	return ret
 }
 
-func getDefaultName(name string, kgw *k8s.GatewaySpec, disableNameSuffix bool) string {
-	if disableNameSuffix {
-		return name
-	}
+func getDefaultName(name string, kgw *k8s.GatewaySpec) string {
 	return fmt.Sprintf("%v-%v", name, kgw.GatewayClassName)
 }
 
@@ -1895,9 +1885,9 @@ func IsManaged(gw *k8s.GatewaySpec) bool {
 	return false
 }
 
-func extractGatewayServices(domainSuffix string, kgw *k8sbeta.Gateway, info classInfo) ([]string, *ConfigError) {
+func extractGatewayServices(domainSuffix string, kgw *k8sbeta.Gateway) ([]string, *ConfigError) {
 	if IsManaged(&kgw.Spec) {
-		name := model.GetOrDefault(kgw.Annotations[annotation.GatewayNameOverride.Name], getDefaultName(kgw.Name, &kgw.Spec, info.disableNameSuffix))
+		name := model.GetOrDefault(kgw.Annotations[annotation.GatewayNameOverride.Name], getDefaultName(kgw.Name, &kgw.Spec))
 		return []string{fmt.Sprintf("%s.%s.svc.%v", name, kgw.Namespace, domainSuffix)}, nil
 	}
 	gatewayServices := []string{}
@@ -2291,28 +2281,6 @@ func GetCommonRouteStateParents(spec any) []k8s.RouteParentStatus {
 	}
 }
 
-// normalizeReference takes a generic Group/Kind (the API uses a few variations) and converts to a known GroupVersionKind.
-// Defaults for the group/kind are also passed.
-func normalizeReference[G ~string, K ~string](group *G, kind *K, def config.GroupVersionKind) config.GroupVersionKind {
-	k := def.Kind
-	if kind != nil {
-		k = string(*kind)
-	}
-	g := def.Group
-	if group != nil {
-		g = string(*group)
-	}
-	gk := config.GroupVersionKind{
-		Group: g,
-		Kind:  k,
-	}
-	s, f := collections.All.FindByGroupKind(gk)
-	if f {
-		return s.GroupVersionKind()
-	}
-	return gk
-}
-
 func defaultString[T ~string](s *T, def string) string {
 	if s == nil {
 		return def
@@ -2329,5 +2297,5 @@ func routeGroupKindEqual(rgk1, rgk2 k8s.RouteGroupKind) bool {
 }
 
 func getGroup(rgk k8s.RouteGroupKind) k8s.Group {
-	return ptr.OrDefault(rgk.Group, k8s.Group(gvk.KubernetesGateway.Group))
+	return ptr.OrDefault(rgk.Group, k8s.Group(wellknown.GatewayGroup))
 }
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go b/internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go
deleted file mode 100644
index 631a5abf5..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/conversion_test.go
+++ /dev/null
@@ -1,1560 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"cmp"
-	"encoding/json"
-	"fmt"
-	"os"
-	"reflect"
-	"regexp"
-	"strings"
-	"sync"
-	"testing"
-
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"sigs.k8s.io/gateway-api/pkg/consts"
-	"sigs.k8s.io/yaml"
-
-	istio "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/config/kube/crd"
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/pkg/networking/core"
-	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
-	"istio.io/istio/pilot/pkg/status"
-	"istio.io/istio/pilot/test/util"
-	"istio.io/istio/pkg/cluster"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/constants"
-	crdvalidation "istio.io/istio/pkg/config/crd"
-	"istio.io/istio/pkg/config/schema/gvk"
-	"istio.io/istio/pkg/config/schema/gvr"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/controllers"
-	"istio.io/istio/pkg/kube/kclient/clienttest"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/maps"
-	"istio.io/istio/pkg/ptr"
-	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/util/sets"
-)
-
-var ports = []*model.Port{
-	{
-		Name:     "http",
-		Port:     80,
-		Protocol: "HTTP",
-	},
-	{
-		Name:     "tcp",
-		Port:     34000,
-		Protocol: "TCP",
-	},
-	{
-		Name:     "tcp-other",
-		Port:     34001,
-		Protocol: "TCP",
-	},
-}
-
-var services = []*model.Service{
-	{
-		Attributes: model.ServiceAttributes{
-			Name:      "istio-ingressgateway",
-			Namespace: "istio-system",
-			ClusterExternalAddresses: &model.AddressMap{
-				Addresses: map[cluster.ID][]string{
-					constants.DefaultClusterName: {"1.2.3.4"},
-				},
-			},
-		},
-		Ports:    ports,
-		Hostname: "istio-ingressgateway.istio-system.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "istio-system",
-		},
-		Ports:    ports,
-		Hostname: "example.com",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "apple",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-apple.apple.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "banana",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-banana.banana.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-second.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-wildcard.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "foo-svc.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-other.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "example.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "echo.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "cert",
-		},
-		Ports:    ports,
-		Hostname: "httpbin.cert.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "service",
-		},
-		Ports:    ports,
-		Hostname: "my-svc.service.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "google.com",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "allowed-1",
-		},
-		Ports:    ports,
-		Hostname: "a-example.allowed-1.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "allowed-2",
-		},
-		Ports:    ports,
-		Hostname: "a-example.allowed-2.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "allowed-1",
-		},
-		Ports:    ports,
-		Hostname: "b-example.allowed-1.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "allowed-1",
-		},
-		Ports:    ports,
-		Hostname: "svc2.allowed-1.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "allowed-2",
-		},
-		Ports:    ports,
-		Hostname: "svc2.allowed-2.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "allowed-1",
-		},
-		Ports:    ports,
-		Hostname: "svc1.allowed-1.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "allowed-2",
-		},
-		Ports:    ports,
-		Hostname: "svc3.allowed-2.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "svc4.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "group-namespace1",
-		},
-		Ports:    ports,
-		Hostname: "httpbin.group-namespace1.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "group-namespace2",
-		},
-		Ports:    ports,
-		Hostname: "httpbin.group-namespace2.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-zero.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "istio-system",
-		},
-		Ports:    ports,
-		Hostname: "httpbin.istio-system.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-mirror.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-foo.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-alt.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "istio-system",
-		},
-		Ports:    ports,
-		Hostname: "istiod.istio-system.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "istio-system",
-		},
-		Ports:    ports,
-		Hostname: "echo.istio-system.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "httpbin-bad.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Name:      "echo-1",
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "echo-1.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Name:      "echo-2",
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "echo-2.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Name:      "echo-port",
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "echo-port.default.svc.domain.suffix",
-	},
-	{
-		Attributes: model.ServiceAttributes{
-			Name:      "not-found",
-			Namespace: "default",
-		},
-		Ports:    ports,
-		Hostname: "not-found.default.svc.domain.suffix",
-	},
-}
-
-var svcPorts = []corev1.ServicePort{
-	{
-		Name:     "http",
-		Port:     80,
-		Protocol: "HTTP",
-	},
-	{
-		Name:     "tcp",
-		Port:     34000,
-		Protocol: "TCP",
-	},
-	{
-		Name:     "tcp-other",
-		Port:     34001,
-		Protocol: "TCP",
-	},
-}
-
-var (
-	// https://github.com/kubernetes/kubernetes/blob/v1.25.4/staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_tls_test.go#L31
-	rsaCertPEM = `-----BEGIN CERTIFICATE-----
-MIIB0zCCAX2gAwIBAgIJAI/M7BYjwB+uMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV
-BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX
-aWRnaXRzIFB0eSBMdGQwHhcNMTIwOTEyMjE1MjAyWhcNMTUwOTEyMjE1MjAyWjBF
-MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50
-ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANLJ
-hPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wok/4xIA+ui35/MmNa
-rtNuC+BdZ1tMuVCPFZcCAwEAAaNQME4wHQYDVR0OBBYEFJvKs8RfJaXTH08W+SGv
-zQyKn0H8MB8GA1UdIwQYMBaAFJvKs8RfJaXTH08W+SGvzQyKn0H8MAwGA1UdEwQF
-MAMBAf8wDQYJKoZIhvcNAQEFBQADQQBJlffJHybjDGxRMqaRmDhX0+6v02TUKZsW
-r5QuVbpQhH6u+0UgcW0jp9QwpxoPTLTWGXEWBBBurxFwiCBhkQ+V
------END CERTIFICATE-----
-`
-	rsaKeyPEM = `-----BEGIN RSA PRIVATE KEY-----
-MIIBOwIBAAJBANLJhPHhITqQbPklG3ibCVxwGMRfp/v4XqhfdQHdcVfHap6NQ5Wo
-k/4xIA+ui35/MmNartNuC+BdZ1tMuVCPFZcCAwEAAQJAEJ2N+zsR0Xn8/Q6twa4G
-6OB1M1WO+k+ztnX/1SvNeWu8D6GImtupLTYgjZcHufykj09jiHmjHx8u8ZZB/o1N
-MQIhAPW+eyZo7ay3lMz1V01WVjNKK9QSn1MJlb06h/LuYv9FAiEA25WPedKgVyCW
-SmUwbPw8fnTcpqDWE3yTO3vKcebqMSsCIBF3UmVue8YU3jybC3NxuXq3wNm34R8T
-xVLHwDXh/6NJAiEAl2oHGGLz64BuAfjKrqwz7qMYr9HCLIe/YsoWq/olzScCIQDi
-D2lWusoe2/nEqfDVVWGWlyJ7yOmqaVm/iNUN9B2N2g==
------END RSA PRIVATE KEY-----
-`
-
-	secrets = []runtime.Object{
-		&corev1.Secret{
-			ObjectMeta: metav1.ObjectMeta{
-				Name:      "my-cert-http",
-				Namespace: "istio-system",
-			},
-			Data: map[string][]byte{
-				"tls.crt": []byte(rsaCertPEM),
-				"tls.key": []byte(rsaKeyPEM),
-			},
-		},
-		&corev1.Secret{
-			ObjectMeta: metav1.ObjectMeta{
-				Name:      "cert",
-				Namespace: "cert",
-			},
-			Data: map[string][]byte{
-				"tls.crt": []byte(rsaCertPEM),
-				"tls.key": []byte(rsaKeyPEM),
-			},
-		},
-		&corev1.Secret{
-			ObjectMeta: metav1.ObjectMeta{
-				Name:      "malformed",
-				Namespace: "istio-system",
-			},
-			Data: map[string][]byte{
-				// nolint: lll
-				// https://github.com/kubernetes-sigs/gateway-api/blob/d7f71d6b7df7e929ae299948973a693980afc183/conformance/tests/gateway-invalid-tls-certificateref.yaml#L87-L90
-				// this certificate is invalid because contains an invalid pem (base64 of "Hello world"),
-				// and the certificate and the key are identical
-				"tls.crt": []byte("SGVsbG8gd29ybGQK"),
-				"tls.key": []byte("SGVsbG8gd29ybGQK"),
-			},
-		},
-	}
-)
-
-func init() {
-	features.EnableAlphaGatewayAPI = true
-	features.EnableAmbientWaypoints = true
-	// Recompute with ambient enabled
-	classInfos = getClassInfos()
-	builtinClasses = getBuiltinClasses()
-}
-
-type TestStatusQueue struct {
-	mu    sync.Mutex
-	state map[status.Resource]any
-}
-
-func (t *TestStatusQueue) EnqueueStatusUpdateResource(context any, target status.Resource) {
-	t.mu.Lock()
-	defer t.mu.Unlock()
-	t.state[target] = context
-}
-
-func (t *TestStatusQueue) Statuses() []any {
-	t.mu.Lock()
-	defer t.mu.Unlock()
-	return maps.Values(t.state)
-}
-
-func (t *TestStatusQueue) Dump() string {
-	t.mu.Lock()
-	defer t.mu.Unlock()
-	sb := strings.Builder{}
-	objs := []crd.IstioKind{}
-	for k, v := range t.state {
-		statusj, _ := json.Marshal(v)
-		gk, _ := gvk.FromGVR(k.GroupVersionResource)
-		obj := crd.IstioKind{
-			TypeMeta: metav1.TypeMeta{
-				Kind:       gk.Kind,
-				APIVersion: k.GroupVersion().String(),
-			},
-			ObjectMeta: metav1.ObjectMeta{
-				Name:      k.Name,
-				Namespace: k.Namespace,
-			},
-			Spec:   nil,
-			Status: ptr.Of(json.RawMessage(statusj)),
-		}
-		objs = append(objs, obj)
-	}
-	slices.SortFunc(objs, func(a, b crd.IstioKind) int {
-		ord := []string{gvk.GatewayClass.Kind, gvk.Gateway.Kind, gvk.HTTPRoute.Kind, gvk.GRPCRoute.Kind, gvk.TLSRoute.Kind, gvk.TCPRoute.Kind}
-		if r := cmp.Compare(slices.Index(ord, a.Kind), slices.Index(ord, b.Kind)); r != 0 {
-			return r
-		}
-		if r := a.CreationTimestamp.Time.Compare(b.CreationTimestamp.Time); r != 0 {
-			return r
-		}
-		if r := cmp.Compare(a.Namespace, b.Namespace); r != 0 {
-			return r
-		}
-		return cmp.Compare(a.Name, b.Name)
-	})
-	for _, obj := range objs {
-		b, err := yaml.Marshal(obj)
-		if err != nil {
-			panic(err.Error())
-		}
-		// Replace parts that are not stable
-		b = timestampRegex.ReplaceAll(b, []byte("lastTransitionTime: fake"))
-		sb.WriteString(string(b))
-		sb.WriteString("---\n")
-	}
-	return sb.String()
-}
-
-var _ status.Queue = &TestStatusQueue{}
-
-func TestConvertResources(t *testing.T) {
-	validator := crdvalidation.NewIstioValidator(t)
-	cases := []struct {
-		name string
-		// Some configs are intended to be generated with invalid configs, and since they will be validated
-		// by the validator, we need to ignore the validation errors to prevent the test from failing.
-		validationIgnorer *crdvalidation.ValidationIgnorer
-	}{
-		{name: "http"},
-		{name: "tcp"},
-		{name: "tls"},
-		{name: "grpc"},
-		{name: "mismatch"},
-		{name: "weighted"},
-		{name: "zero"},
-		{name: "mesh"},
-		{
-			name: "invalid",
-			validationIgnorer: crdvalidation.NewValidationIgnorer(
-				"default/^invalid-backendRef-kind-",
-				"default/^invalid-backendRef-mixed-",
-			),
-		},
-		{name: "multi-gateway"},
-		{name: "delegated"},
-		{name: "route-binding"},
-		{name: "reference-policy-tls"},
-		{
-			name: "reference-policy-service",
-			validationIgnorer: crdvalidation.NewValidationIgnorer(
-				"istio-system/^backend-not-allowed-",
-			),
-		},
-		{
-			name: "reference-policy-tcp",
-			validationIgnorer: crdvalidation.NewValidationIgnorer(
-				"istio-system/^not-allowed-echo-",
-			),
-		},
-		{name: "serviceentry"},
-		{name: "eastwest"},
-		{name: "eastwest-tlsoption"},
-		{name: "eastwest-labelport"},
-		{name: "eastwest-remote"},
-		{name: "mcs"},
-		{name: "route-precedence"},
-		{name: "waypoint"},
-		{name: "isolation"},
-		{
-			name: "valid-invalid-parent-ref",
-			validationIgnorer: crdvalidation.NewValidationIgnorer(
-				"default/^valid-invalid-parent-ref-",
-			),
-		},
-	}
-	test.SetForTest(t, &features.EnableGatewayAPIGatewayClassController, false)
-	for _, tt := range cases {
-		t.Run(tt.name, func(t *testing.T) {
-			stop := test.NewStop(t)
-			input := readConfig(t, fmt.Sprintf("testdata/%s.yaml", tt.name), validator, nil)
-			kc := kube.NewFakeClient(input...)
-			setupClientCRDs(t, kc)
-			// Setup a few preconfigured services
-			instances := []*model.ServiceInstance{}
-			for _, svc := range services {
-				instances = append(instances, &model.ServiceInstance{
-					Service:     svc,
-					ServicePort: ports[0],
-					Endpoint:    &model.IstioEndpoint{EndpointPort: 8080},
-				}, &model.ServiceInstance{
-					Service:     svc,
-					ServicePort: ports[1],
-					Endpoint:    &model.IstioEndpoint{},
-				}, &model.ServiceInstance{
-					Service:     svc,
-					ServicePort: ports[2],
-					Endpoint:    &model.IstioEndpoint{},
-				})
-			}
-			cg := core.NewConfigGenTest(t, core.TestOptions{
-				Services:  services,
-				Instances: instances,
-			})
-
-			dbg := &krt.DebugHandler{}
-			dumpOnFailure(t, dbg)
-			ctrl := NewController(
-				kc,
-				AlwaysReady,
-				controller.Options{DomainSuffix: "domain.suffix", KrtDebugger: dbg},
-				nil,
-			)
-			sq := &TestStatusQueue{
-				state: map[status.Resource]any{},
-			}
-			go ctrl.Run(stop)
-			kc.RunAndWait(stop)
-			ctrl.Reconcile(cg.PushContext())
-			kube.WaitForCacheSync("test", stop, ctrl.HasSynced)
-			// Normally we don't care to block on status being written, but here we need to since we want to test output
-			statusSynced := ctrl.status.SetQueue(sq)
-			for _, st := range statusSynced {
-				st.WaitUntilSynced(stop)
-			}
-
-			res := ctrl.List(gvk.Gateway, "")
-			sortConfigByCreationTime(res)
-			vs := ctrl.List(gvk.VirtualService, "")
-			res = append(res, sortedConfigByCreationTime(vs)...)
-
-			goldenFile := fmt.Sprintf("testdata/%s.yaml.golden", tt.name)
-			util.CompareContent(t, marshalYaml(t, res), goldenFile)
-
-			outputStatus := sq.Dump()
-			goldenStatusFile := fmt.Sprintf("testdata/%s.status.yaml.golden", tt.name)
-			util.CompareContent(t, []byte(outputStatus), goldenStatusFile)
-		})
-	}
-}
-
-func setupClientCRDs(t *testing.T, kc kube.CLIClient) {
-	for _, crd := range []schema.GroupVersionResource{
-		gvr.KubernetesGateway,
-		gvr.ReferenceGrant,
-		gvr.GatewayClass,
-		gvr.HTTPRoute,
-		gvr.GRPCRoute,
-		gvr.TCPRoute,
-		gvr.TLSRoute,
-		gvr.ServiceEntry,
-	} {
-		clienttest.MakeCRDWithAnnotations(t, kc, crd, map[string]string{
-			consts.BundleVersionAnnotation: "v1.1.0",
-		})
-	}
-}
-
-func dumpOnFailure(t *testing.T, debugger *krt.DebugHandler) {
-	t.Cleanup(func() {
-		if t.Failed() {
-			b, _ := yaml.Marshal(debugger)
-			t.Log(string(b))
-		}
-	})
-}
-
-func TestSortHTTPRoutes(t *testing.T) {
-	cases := []struct {
-		name string
-		in   []*istio.HTTPRoute
-		out  []*istio.HTTPRoute
-	}{
-		{
-			"match is preferred over no match",
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{
-									Exact: "/foo",
-								},
-							},
-						},
-					},
-				},
-			},
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{
-									Exact: "/foo",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{},
-				},
-			},
-		},
-		{
-			"path matching exact > prefix  > regex",
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Regex{
-									Regex: ".*foo",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{
-									Exact: "/foo",
-								},
-							},
-						},
-					},
-				},
-			},
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{
-									Exact: "/foo",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Regex{
-									Regex: ".*foo",
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-		{
-			"path prefix matching with largest characters",
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/foo",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/foobar",
-								},
-							},
-						},
-					},
-				},
-			},
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/foobar",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/foo",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/",
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-		{
-			"path match is preferred over method match",
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Method: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{
-									Exact: "GET",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/foobar",
-								},
-							},
-						},
-					},
-				},
-			},
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/foobar",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Method: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{
-									Exact: "GET",
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-		{
-			"largest number of header matches is preferred",
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Headers: map[string]*istio.StringMatch{
-								"header1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Headers: map[string]*istio.StringMatch{
-								"header1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-								"header2": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value2",
-									},
-								},
-							},
-						},
-					},
-				},
-			},
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Headers: map[string]*istio.StringMatch{
-								"header1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-								"header2": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value2",
-									},
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Headers: map[string]*istio.StringMatch{
-								"header1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-		{
-			"largest number of query params is preferred",
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							QueryParams: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							QueryParams: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-								"param2": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value2",
-									},
-								},
-							},
-						},
-					},
-				},
-			},
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							QueryParams: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-								"param2": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value2",
-									},
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							QueryParams: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-		{
-			"path > method > header > query params",
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							QueryParams: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Method: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{Exact: "GET"},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Headers: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-			},
-			[]*istio.HTTPRoute{
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Uri: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Prefix{
-									Prefix: "/",
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Method: &istio.StringMatch{
-								MatchType: &istio.StringMatch_Exact{Exact: "GET"},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							Headers: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-				{
-					Match: []*istio.HTTPMatchRequest{
-						{
-							QueryParams: map[string]*istio.StringMatch{
-								"param1": {
-									MatchType: &istio.StringMatch_Exact{
-										Exact: "value1",
-									},
-								},
-							},
-						},
-					},
-				},
-			},
-		},
-	}
-
-	for _, tt := range cases {
-		t.Run(tt.name, func(t *testing.T) {
-			sortHTTPRoutes(tt.in)
-			if !reflect.DeepEqual(tt.in, tt.out) {
-				t.Fatalf("expected %v, got %v", tt.out, tt.in)
-			}
-		})
-	}
-}
-
-func TestReferencePolicy(t *testing.T) {
-	validator := crdvalidation.NewIstioValidator(t)
-	type res struct {
-		name, namespace string
-		allowed         bool
-	}
-	cases := []struct {
-		name         string
-		config       string
-		expectations []res
-	}{
-		{
-			name: "simple",
-			config: `apiVersion: gateway.networking.k8s.io/v1beta1
-kind: ReferenceGrant
-metadata:
- name: allow-gateways-to-ref-secrets
- namespace: default
-spec:
- from:
- - group: gateway.networking.k8s.io
-   kind: Gateway
-   namespace: istio-system
- to:
- - group: ""
-   kind: Secret
-`,
-			expectations: []res{
-				// allow cross namespace
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "istio-system", true},
-				// denied same namespace. We do not implicitly allow (in this code - higher level code does)
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "default", false},
-				// denied namespace
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
-			},
-		},
-		{
-			name: "multiple in one",
-			config: `apiVersion: gateway.networking.k8s.io/v1beta1
-kind: ReferenceGrant
-metadata:
- name: allow-gateways-to-ref-secrets
- namespace: default
-spec:
- from:
- - group: gateway.networking.k8s.io
-   kind: Gateway
-   namespace: ns-1
- - group: gateway.networking.k8s.io
-   kind: Gateway
-   namespace: ns-2
- to:
- - group: ""
-   kind: Secret
-`,
-			expectations: []res{
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-1", true},
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-2", true},
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
-			},
-		},
-		{
-			name: "multiple",
-			config: `apiVersion: gateway.networking.k8s.io/v1beta1
-kind: ReferenceGrant
-metadata:
- name: ns1
- namespace: default
-spec:
- from:
- - group: gateway.networking.k8s.io
-   kind: Gateway
-   namespace: ns-1
- to:
- - group: ""
-   kind: Secret
----
-apiVersion: gateway.networking.k8s.io/v1beta1
-kind: ReferenceGrant
-metadata:
- name: ns2
- namespace: default
-spec:
- from:
- - group: gateway.networking.k8s.io
-   kind: Gateway
-   namespace: ns-2
- to:
- - group: ""
-   kind: Secret
-`,
-			expectations: []res{
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-1", true},
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "ns-2", true},
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
-			},
-		},
-		{
-			name: "same namespace",
-			config: `apiVersion: gateway.networking.k8s.io/v1beta1
-kind: ReferenceGrant
-metadata:
- name: allow-gateways-to-ref-secrets
- namespace: default
-spec:
- from:
- - group: gateway.networking.k8s.io
-   kind: Gateway
-   namespace: default
- to:
- - group: ""
-   kind: Secret
-`,
-			expectations: []res{
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "istio-system", false},
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "default", true},
-				{"kubernetes-gateway://default/wildcard-example-com-cert", "bad", false},
-			},
-		},
-		{
-			name: "same name",
-			config: `apiVersion: gateway.networking.k8s.io/v1beta1
-kind: ReferenceGrant
-metadata:
- name: allow-gateways-to-ref-secrets
- namespace: default
-spec:
- from:
- - group: gateway.networking.k8s.io
-   kind: Gateway
-   namespace: default
- to:
- - group: ""
-   kind: Secret
-   name: public
-`,
-			expectations: []res{
-				{"kubernetes-gateway://default/public", "istio-system", false},
-				{"kubernetes-gateway://default/public", "default", true},
-				{"kubernetes-gateway://default/private", "default", false},
-			},
-		},
-	}
-	for _, tt := range cases {
-		t.Run(tt.name, func(t *testing.T) {
-			input := readConfigString(t, tt.config, validator, nil)
-			kr := setupController(t, input...)
-			for _, sc := range tt.expectations {
-				t.Run(fmt.Sprintf("%v/%v", sc.name, sc.namespace), func(t *testing.T) {
-					got := kr.SecretAllowed(sc.name, sc.namespace)
-					if got != sc.allowed {
-						t.Fatalf("expected allowed=%v, got allowed=%v", sc.allowed, got)
-					}
-				})
-			}
-		})
-	}
-}
-
-var timestampRegex = regexp.MustCompile(`lastTransitionTime:.*`)
-
-func readConfig(t testing.TB, filename string, validator *crdvalidation.Validator, ignorer *crdvalidation.ValidationIgnorer) []runtime.Object {
-	t.Helper()
-
-	data, err := os.ReadFile(filename)
-	if err != nil {
-		t.Fatalf("failed to read input yaml file: %v", err)
-	}
-	objs := readConfigString(t, string(data), validator, ignorer)
-
-	namespaces := sets.New[string](slices.Map(objs, func(e runtime.Object) string {
-		return e.(controllers.Object).GetNamespace()
-	})...)
-	for _, svc := range services {
-		if !strings.HasSuffix(svc.Hostname.String(), "domain.suffix") {
-			continue
-		}
-		name := svc.Attributes.Name
-		if name == "" {
-			name, _, _ = strings.Cut(svc.Hostname.String(), ".")
-		}
-		svcObj := &corev1.Service{
-			ObjectMeta: metav1.ObjectMeta{
-				Namespace: svc.Attributes.Namespace,
-				Name:      name,
-			},
-			Spec: corev1.ServiceSpec{
-				Ports: svcPorts,
-			},
-		}
-		objs = append(objs, svcObj)
-	}
-	objs = append(objs, secrets...)
-
-	for ns := range namespaces {
-		objs = append(objs, &corev1.Namespace{
-			ObjectMeta: metav1.ObjectMeta{
-				Name: ns,
-				Labels: map[string]string{
-					"istio.io/test-name-part": strings.Split(ns, "-")[0],
-				},
-			},
-		})
-	}
-	return objs
-}
-
-func readConfigString(t testing.TB, data string, validator *crdvalidation.Validator, ignorer *crdvalidation.ValidationIgnorer,
-) []runtime.Object {
-	if err := validator.ValidateCustomResourceYAML(data, ignorer); err != nil {
-		t.Error(err)
-	}
-
-	c, err := kubernetesObjectsFromString(data)
-	if err != nil {
-		t.Fatalf("failed to parse CRD: %v", err)
-	}
-	return c
-}
-
-// Print as YAML
-func marshalYaml(t test.Failer, cl []config.Config) []byte {
-	t.Helper()
-	result := []byte{}
-	separator := []byte("---\n")
-	for _, config := range cl {
-		obj, err := crd.ConvertConfig(config)
-		if err != nil {
-			t.Fatalf("Could not decode %v: %v", config.Name, err)
-		}
-		bytes, err := yaml.Marshal(obj)
-		if err != nil {
-			t.Fatalf("Could not convert %v to YAML: %v", config, err)
-		}
-		result = append(result, bytes...)
-		result = append(result, separator...)
-	}
-	return result
-}
-
-func TestHumanReadableJoin(t *testing.T) {
-	tests := []struct {
-		input []string
-		want  string
-	}{
-		{[]string{"a"}, "a"},
-		{[]string{"a", "b"}, "a and b"},
-		{[]string{"a", "b", "c"}, "a, b, and c"},
-	}
-	for _, tt := range tests {
-		t.Run(strings.Join(tt.input, "_"), func(t *testing.T) {
-			if got := humanReadableJoin(tt.input); !reflect.DeepEqual(got, tt.want) {
-				t.Errorf("got %v, want %v", got, tt.want)
-			}
-		})
-	}
-}
-
-//
-//func BenchmarkBuildHTTPVirtualServices(b *testing.B) {
-//	ports := []*model.Port{
-//		{
-//			Name:     "http",
-//			Port:     80,
-//			Protocol: "HTTP",
-//		},
-//		{
-//			Name:     "tcp",
-//			Port:     34000,
-//			Protocol: "TCP",
-//		},
-//	}
-//	ingressSvc := &model.Service{
-//		Attributes: model.ServiceAttributes{
-//			Name:      "istio-ingressgateway",
-//			Namespace: "istio-system",
-//			ClusterExternalAddresses: &model.AddressMap{
-//				Addresses: map[cluster.ID][]string{
-//					constants.DefaultClusterName: {"1.2.3.4"},
-//				},
-//			},
-//		},
-//		Ports:    ports,
-//		Hostname: "istio-ingressgateway.istio-system.svc.domain.suffix",
-//	}
-//	altIngressSvc := &model.Service{
-//		Attributes: model.ServiceAttributes{
-//			Namespace: "istio-system",
-//		},
-//		Ports:    ports,
-//		Hostname: "example.com",
-//	}
-//	cg := core.NewConfigGenTest(b, core.TestOptions{
-//		Services: []*model.Service{ingressSvc, altIngressSvc},
-//		Instances: []*model.ServiceInstance{
-//			{Service: ingressSvc, ServicePort: ingressSvc.Ports[0], Endpoint: &model.IstioEndpoint{EndpointPort: 8080}},
-//			{Service: ingressSvc, ServicePort: ingressSvc.Ports[1], Endpoint: &model.IstioEndpoint{}},
-//			{Service: altIngressSvc, ServicePort: altIngressSvc.Ports[0], Endpoint: &model.IstioEndpoint{}},
-//			{Service: altIngressSvc, ServicePort: altIngressSvc.Ports[1], Endpoint: &model.IstioEndpoint{}},
-//		},
-//	})
-//
-//	validator := crdvalidation.NewIstioValidator(b)
-//	input := readConfig(b, "testdata/benchmark-httproute.yaml", validator, nil)
-//	kr := splitInput(b, input)
-//	kr.Context = NewGatewayContext(cg.PushContext(), "Kubernetes")
-//	ctx := configContext{
-//		GatewayResources:  kr,
-//		AllowedReferences: convertReferencePolicies(kr),
-//	}
-//	_, gwMap, _ := convertGateways(ctx)
-//	ctx.GatewayReferences = gwMap
-//
-//	b.ResetTimer()
-//	for n := 0; n < b.N; n++ {
-//		// for gateway routes, build one VS per gateway+host
-//		gatewayRoutes := make(map[string]map[string]*config.Config)
-//		// for mesh routes, build one VS per namespace+host
-//		meshRoutes := make(map[string]map[string]*config.Config)
-//		for _, obj := range kr.HTTPRoute {
-//			buildHTTPVirtualServices(ctx, obj, gatewayRoutes, meshRoutes)
-//		}
-//	}
-//}
-
-//func TestExtractGatewayServices(t *testing.T) {
-//	tests := []struct {
-//		name            string
-//		r               GatewayResources
-//		kgw             *k8s.Gateway
-//		obj             config.Config
-//		gatewayServices []string
-//		err             *ConfigError
-//	}{
-//		{
-//			name: "managed gateway",
-//			r:    GatewayResources{Domain: "cluster.local"},
-//			kgw: &k8s.GatewaySpec{
-//				GatewayClassName: "istio",
-//			},
-//			obj: config.Config{
-//				Meta: config.Meta{
-//					Name:      "foo",
-//					Namespace: "default",
-//				},
-//			},
-//			gatewayServices: []string{"foo-istio.default.svc.cluster.local"},
-//		},
-//		{
-//			name: "managed gateway with name overridden",
-//			r:    GatewayResources{Domain: "cluster.local"},
-//			kgw: &k8s.GatewaySpec{
-//				GatewayClassName: "istio",
-//			},
-//			obj: config.Config{
-//				Meta: config.Meta{
-//					Name:      "foo",
-//					Namespace: "default",
-//					Annotations: map[string]string{
-//						annotation.GatewayNameOverride.Name: "bar",
-//					},
-//				},
-//			},
-//			gatewayServices: []string{"bar.default.svc.cluster.local"},
-//		},
-//		{
-//			name: "unmanaged gateway",
-//			r:    GatewayResources{Domain: "domain"},
-//			kgw: &k8s.GatewaySpec{
-//				GatewayClassName: "istio",
-//				Addresses: []k8s.GatewayAddress{
-//					{
-//						Value: "abc",
-//					},
-//					{
-//						Type: func() *k8s.AddressType {
-//							t := k8s.HostnameAddressType
-//							return &t
-//						}(),
-//						Value: "example.com",
-//					},
-//					{
-//						Type: func() *k8s.AddressType {
-//							t := k8s.IPAddressType
-//							return &t
-//						}(),
-//						Value: "1.2.3.4",
-//					},
-//				},
-//			},
-//			obj: config.Config{
-//				Meta: config.Meta{
-//					Name:      "foo",
-//					Namespace: "default",
-//				},
-//			},
-//			gatewayServices: []string{"abc.default.svc.domain", "example.com"},
-//			err: &ConfigError{
-//				Reason:  InvalidAddress,
-//				Message: "only Hostname is supported, ignoring [1.2.3.4]",
-//			},
-//		},
-//	}
-//	for _, tt := range tests {
-//		t.Run(tt.name, func(t *testing.T) {
-//			gatewayServices, err := extractGatewayServices(tt.r, tt.kgw, tt.obj, classInfo{})
-//			assert.Equal(t, gatewayServices, tt.gatewayServices)
-//			assert.Equal(t, err, tt.err)
-//		})
-//	}
-//}
-
-func kubernetesObjectsFromString(s string) ([]runtime.Object, error) {
-	var objects []runtime.Object
-	decode := kube.IstioCodec.UniversalDeserializer().Decode
-	objectStrs := strings.Split(s, "---")
-	for _, s := range objectStrs {
-		if len(strings.TrimSpace(s)) == 0 {
-			continue
-		}
-		o, _, err := decode([]byte(s), nil, nil)
-		if err != nil {
-			return nil, fmt.Errorf("failed deserializing kubernetes object: %v (%v)", err, s)
-		}
-		objects = append(objects, o)
-	}
-	return objects, nil
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go b/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go
deleted file mode 100644
index 60a9ab756..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller.go
+++ /dev/null
@@ -1,952 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"context"
-	"encoding/json"
-	"fmt"
-	"reflect"
-	"strconv"
-	"strings"
-
-	appsv1 "k8s.io/api/apps/v1"
-	autoscalingv2 "k8s.io/api/autoscaling/v2"
-	corev1 "k8s.io/api/core/v1"
-	policyv1 "k8s.io/api/policy/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
-	klabels "k8s.io/apimachinery/pkg/labels"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"k8s.io/apimachinery/pkg/types"
-	"k8s.io/apimachinery/pkg/util/mergepatch"
-	"k8s.io/apimachinery/pkg/util/strategicpatch"
-	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
-	"sigs.k8s.io/yaml"
-
-	"istio.io/api/annotation"
-	"istio.io/api/label"
-	meshapi "istio.io/api/mesh/v1alpha1"
-	"istio.io/istio/pilot/pkg/config/kube/crd"
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pkg/cluster"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/config/schema/gvk"
-	"istio.io/istio/pkg/config/schema/gvr"
-	common_features "istio.io/istio/pkg/features"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/controllers"
-	"istio.io/istio/pkg/kube/inject"
-	"istio.io/istio/pkg/kube/kclient"
-	istiolog "istio.io/istio/pkg/log"
-	"istio.io/istio/pkg/maps"
-	"istio.io/istio/pkg/revisions"
-	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/test/util/tmpl"
-	"istio.io/istio/pkg/test/util/yml"
-	"istio.io/istio/pkg/util/sets"
-)
-
-// DeploymentController implements a controller that materializes a Gateway into an in cluster gateway proxy
-// to serve requests from. This is implemented with a Deployment and Service today.
-// The implementation makes a few non-obvious choices - namely using Server Side Apply from go templates
-// and not using controller-runtime.
-//
-// controller-runtime has a number of constraints that make it inappropriate for usage here, despite this
-// seeming to be the bread and butter of the library:
-// * It is not readily possible to bring existing Informers, which would require extra watches (#1668)
-// * Goroutine leaks (#1655)
-// * Excessive API-server calls at startup which have no benefit to us (#1603)
-// * Hard to use with SSA (#1669)
-// While these can be worked around, at some point it isn't worth the effort.
-//
-// Server Side Apply with go templates is an odd choice (no one likes YAML templating...) but is one of the few
-// remaining options after all others are ruled out.
-//   - Merge patch/Update cannot be used. If we always enforce that our object is *exactly* the same as
-//     the in-cluster object we will get in endless loops due to other controllers that like to add annotations, etc.
-//     If we chose to allow any unknown fields, then we would never be able to remove fields we added, as
-//     we cannot tell if we created it or someone else did. SSA fixes these issues
-//   - SSA using client-go Apply libraries is almost a good choice, but most third-party clients (Istio, MCS, and gateway-api)
-//     do not provide these libraries.
-//   - SSA using standard API types doesn't work well either: https://github.com/kubernetes-sigs/controller-runtime/issues/1669
-//   - This leaves YAML templates, converted to unstructured types and Applied with the dynamic client.
-type DeploymentController struct {
-	client         kube.Client
-	clusterID      cluster.ID
-	env            *model.Environment
-	queue          controllers.Queue
-	patcher        patcher
-	gateways       kclient.Client[*gateway.Gateway]
-	gatewayClasses kclient.Client[*gateway.GatewayClass]
-
-	clients         map[schema.GroupVersionResource]getter
-	injectConfig    func() inject.WebhookConfig
-	deployments     kclient.Client[*appsv1.Deployment]
-	services        kclient.Client[*corev1.Service]
-	hpas            kclient.Client[*autoscalingv2.HorizontalPodAutoscaler]
-	pdbs            kclient.Client[*policyv1.PodDisruptionBudget]
-	configMaps      kclient.Client[*corev1.ConfigMap]
-	serviceAccounts kclient.Client[*corev1.ServiceAccount]
-	namespaces      kclient.Client[*corev1.Namespace]
-	tagWatcher      revisions.TagWatcher
-	revision        string
-	systemNamespace string
-}
-
-// Patcher is a function that abstracts patching logic. This is largely because client-go fakes do not handle patching
-type patcher func(gvr schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error
-
-// classInfo holds information about a gateway class
-type classInfo struct {
-	// controller name for this class
-	controller string
-	// description for this class
-	description string
-	// The key in the templates to use for this class
-	templates string
-
-	// defaultServiceType sets the default service type if one is not explicit set
-	defaultServiceType corev1.ServiceType
-
-	// disableRouteGeneration, if set, will make it so the controller ignores this class.
-	disableRouteGeneration bool
-
-	// disableNameSuffix, if set, will avoid appending -<class> to names
-	disableNameSuffix bool
-
-	// addressType is the default address type to report
-	addressType gateway.AddressType
-}
-
-var classInfos = getClassInfos()
-
-var builtinClasses = getBuiltinClasses()
-
-func getBuiltinClasses() map[gateway.ObjectName]gateway.GatewayController {
-	res := map[gateway.ObjectName]gateway.GatewayController{
-		gateway.ObjectName(features.GatewayAPIDefaultGatewayClass): gateway.GatewayController(features.ManagedGatewayController),
-	}
-
-	if features.MultiNetworkGatewayAPI {
-		res[constants.RemoteGatewayClassName] = constants.UnmanagedGatewayController
-	}
-
-	if features.EnableAmbientWaypoints {
-		res[constants.WaypointGatewayClassName] = constants.ManagedGatewayMeshController
-	}
-	return res
-}
-
-func getClassInfos() map[gateway.GatewayController]classInfo {
-	m := map[gateway.GatewayController]classInfo{
-		gateway.GatewayController(features.ManagedGatewayController): {
-			controller:         features.ManagedGatewayController,
-			description:        "The default Istio GatewayClass",
-			templates:          "kube-gateway",
-			defaultServiceType: corev1.ServiceTypeLoadBalancer,
-			addressType:        gateway.HostnameAddressType,
-		},
-	}
-
-	if features.MultiNetworkGatewayAPI {
-		m[constants.UnmanagedGatewayController] = classInfo{
-			// This represents a gateway that our control plane cannot discover directly via the API server.
-			// We shouldn't generate Istio resources for it. We aren't programming this gateway.
-			controller:             constants.UnmanagedGatewayController,
-			description:            "Remote to this cluster. Does not deploy or affect configuration.",
-			disableRouteGeneration: true,
-			addressType:            gateway.HostnameAddressType,
-		}
-	}
-	if features.EnableAmbientWaypoints {
-		m[constants.ManagedGatewayMeshController] = classInfo{
-			controller:         constants.ManagedGatewayMeshController,
-			description:        "The default Istio waypoint GatewayClass",
-			templates:          "waypoint",
-			disableNameSuffix:  true,
-			defaultServiceType: corev1.ServiceTypeClusterIP,
-			// Report both. Consumers of the gateways can choose which they want.
-			// In particular, Istio across different versions consumes different address types, so this retains compat
-			addressType: "",
-		}
-	}
-	return m
-}
-
-// NewDeploymentController constructs a DeploymentController and registers required informers.
-// The controller will not start until Run() is called.
-func NewDeploymentController(
-	client kube.Client,
-	clusterID cluster.ID,
-	env *model.Environment,
-	webhookConfig func() inject.WebhookConfig,
-	injectionHandler func(fn func()),
-	tw revisions.TagWatcher,
-	revision string,
-	systemNamespace string,
-) *DeploymentController {
-	filter := kclient.Filter{ObjectFilter: client.ObjectFilter()}
-	gateways := kclient.NewFiltered[*gateway.Gateway](client, filter)
-	gatewayClasses := kclient.New[*gateway.GatewayClass](client)
-	dc := &DeploymentController{
-		client:    client,
-		clusterID: clusterID,
-		clients:   map[schema.GroupVersionResource]getter{},
-		env:       env,
-		patcher: func(gvr schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error {
-			c := client.Dynamic().Resource(gvr).Namespace(namespace)
-			t := true
-			_, err := c.Patch(context.Background(), name, types.ApplyPatchType, data, metav1.PatchOptions{
-				Force:        &t,
-				FieldManager: features.ManagedGatewayController,
-			}, subresources...)
-			return err
-		},
-		gateways:        gateways,
-		gatewayClasses:  gatewayClasses,
-		injectConfig:    webhookConfig,
-		tagWatcher:      tw,
-		revision:        revision,
-		systemNamespace: systemNamespace,
-	}
-	gatewaysByParamsRef := kclient.CreateIndex(gateways, func(o *gateway.Gateway) []types.NamespacedName {
-		p, err := fetchParameters(o)
-		if p == nil || err != nil {
-			return nil
-		}
-		return []types.NamespacedName{*p}
-	})
-	dc.queue = controllers.NewQueue("gateway deployment",
-		controllers.WithReconciler(dc.Reconcile),
-		controllers.WithMaxAttempts(5))
-
-	// Set up a handler that will add the parent Gateway object onto the queue.
-	// The queue will only handle Gateway objects; if child resources (Service, etc) are updated we re-add
-	// the Gateway to the queue and reconcile the state of the world.
-	parentHandler := controllers.ObjectHandler(controllers.EnqueueForParentHandler(dc.queue, gvk.KubernetesGateway))
-
-	dc.services = kclient.NewFiltered[*corev1.Service](client, filter)
-	dc.services.AddEventHandler(parentHandler)
-	dc.clients[gvr.Service] = NewUntypedWrapper(dc.services)
-
-	dc.configMaps = kclient.NewFiltered[*corev1.ConfigMap](client, filter)
-	dc.configMaps.AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
-		// This could be a configmap referenced by a Gateway paramsRef
-		impacted := gatewaysByParamsRef.Lookup(config.NamespacedName(o))
-		for _, gw := range impacted {
-			dc.queue.AddObject(gw)
-		}
-		// Or it could also be a global GatewayClass config
-		classDefaults, classDefaultsF := o.GetLabels()[gatewayClassDefaults]
-		if classDefaultsF && o.GetNamespace() == dc.systemNamespace {
-			for _, gw := range dc.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
-				if string(gw.Spec.GatewayClassName) == classDefaults {
-					dc.queue.AddObject(gw)
-				}
-			}
-		}
-	}))
-
-	dc.deployments = kclient.NewFiltered[*appsv1.Deployment](client, filter)
-	dc.deployments.AddEventHandler(parentHandler)
-	dc.clients[gvr.Deployment] = NewUntypedWrapper(dc.deployments)
-
-	dc.serviceAccounts = kclient.NewFiltered[*corev1.ServiceAccount](client, filter)
-	dc.serviceAccounts.AddEventHandler(parentHandler)
-	dc.clients[gvr.ServiceAccount] = NewUntypedWrapper(dc.serviceAccounts)
-
-	dc.hpas = kclient.NewFiltered[*autoscalingv2.HorizontalPodAutoscaler](client, filter)
-	dc.hpas.AddEventHandler(parentHandler)
-	dc.clients[gvr.HorizontalPodAutoscaler] = NewUntypedWrapper(dc.hpas)
-
-	dc.pdbs = kclient.NewFiltered[*policyv1.PodDisruptionBudget](client, filter)
-	dc.pdbs.AddEventHandler(parentHandler)
-	dc.clients[gvr.PodDisruptionBudget] = NewUntypedWrapper(dc.pdbs)
-
-	dc.namespaces = kclient.NewFiltered[*corev1.Namespace](client, filter)
-	dc.namespaces.AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
-		// TODO: make this more intelligent, checking if something we care about has changed
-		// requeue this namespace
-		for _, gw := range dc.gateways.List(o.GetName(), klabels.Everything()) {
-			dc.queue.AddObject(gw)
-		}
-	}))
-
-	gateways.AddEventHandler(controllers.ObjectHandler(dc.queue.AddObject))
-	gatewayClasses.AddEventHandler(controllers.ObjectHandler(func(o controllers.Object) {
-		for _, g := range dc.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
-			if string(g.Spec.GatewayClassName) == o.GetName() {
-				dc.queue.AddObject(g)
-			}
-		}
-	}))
-
-	// On injection template change, requeue all gateways
-	injectionHandler(func() {
-		for _, gw := range dc.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
-			dc.queue.AddObject(gw)
-		}
-	})
-
-	dc.tagWatcher.AddHandler(dc.HandleTagChange)
-
-	return dc
-}
-
-func (d *DeploymentController) Run(stop <-chan struct{}) {
-	kube.WaitForCacheSync(
-		"deployment controller",
-		stop,
-		d.namespaces.HasSynced,
-		d.deployments.HasSynced,
-		d.services.HasSynced,
-		d.configMaps.HasSynced,
-		d.serviceAccounts.HasSynced,
-		d.hpas.HasSynced,
-		d.pdbs.HasSynced,
-		d.gateways.HasSynced,
-		d.gatewayClasses.HasSynced,
-		d.tagWatcher.HasSynced,
-	)
-	d.queue.Run(stop)
-	controllers.ShutdownAll(
-		d.namespaces,
-		d.deployments,
-		d.services,
-		d.configMaps,
-		d.serviceAccounts,
-		d.hpas,
-		d.pdbs,
-		d.gateways,
-		d.gatewayClasses,
-	)
-}
-
-// Reconcile takes in the name of a Gateway and ensures the cluster is in the desired state
-func (d *DeploymentController) Reconcile(req types.NamespacedName) error {
-	log := log.WithLabels("gateway", req)
-
-	gw := d.gateways.Get(req.Name, req.Namespace)
-	if gw == nil {
-		log.Debugf("gateway no longer exists")
-		// we'll ignore not-found errors, since they can't be fixed by an immediate
-		// requeue (we'll need to wait for a new notification), and we can get them
-		// on deleted requests.
-		return nil
-	}
-
-	var controller gateway.GatewayController
-	if gc := d.gatewayClasses.Get(string(gw.Spec.GatewayClassName), ""); gc != nil {
-		controller = gc.Spec.ControllerName
-	} else {
-		if builtin, f := builtinClasses[gw.Spec.GatewayClassName]; f {
-			controller = builtin
-		}
-	}
-	ci, f := classInfos[controller]
-	if !f {
-		log.Debugf("skipping unknown controller %q", controller)
-		return nil
-	}
-
-	// find the tag or revision indicated by the object
-	if !d.tagWatcher.IsMine(gw.ObjectMeta) {
-		log.Debugf("gateway is not for this revision, skipping")
-		return nil
-	}
-	// TODO: Here we could check if the tag is set and matches no known tags, and handle that if we are default.
-
-	// Matched class, reconcile it
-	return d.configureIstioGateway(log, *gw, ci)
-}
-
-func (d *DeploymentController) configureIstioGateway(log *istiolog.Scope, gw gateway.Gateway, gi classInfo) error {
-	// If user explicitly sets addresses, we are assuming they are pointing to an existing deployment.
-	// We will not manage it in this case
-	if gi.templates == "" {
-		log.Debug("skip gateway class without template")
-		return nil
-	}
-	if !IsManaged(&gw.Spec) {
-		log.Debug("skip disabled gateway")
-		return nil
-	}
-	existingControllerVersion, overwriteControllerVersion, shouldHandle := ManagedGatewayControllerVersion(gw)
-	if !shouldHandle {
-		log.Debugf("skipping gateway which is managed by controller version %v", existingControllerVersion)
-		return nil
-	}
-	log.Info("reconciling")
-
-	var ns *corev1.Namespace
-	if d.namespaces != nil {
-		ns = d.namespaces.Get(gw.Namespace, "")
-	}
-	proxyUID, proxyGID := inject.GetProxyIDs(ns)
-
-	defaultName := getDefaultName(gw.Name, &gw.Spec, gi.disableNameSuffix)
-
-	serviceType := gi.defaultServiceType
-	if o, f := gw.Annotations[annotation.NetworkingServiceType.Name]; f {
-		serviceType = corev1.ServiceType(o)
-	}
-
-	input := TemplateInput{
-		Gateway:        &gw,
-		DeploymentName: model.GetOrDefault(gw.Annotations[annotation.GatewayNameOverride.Name], defaultName),
-		ServiceAccount: model.GetOrDefault(gw.Annotations[annotation.GatewayServiceAccount.Name], defaultName),
-		Ports:          extractServicePorts(gw),
-		ClusterID:      d.clusterID.String(),
-
-		KubeVersion:               kube.GetVersionAsInt(d.client),
-		Revision:                  d.revision,
-		ServiceType:               serviceType,
-		ProxyUID:                  proxyUID,
-		ProxyGID:                  proxyGID,
-		CompliancePolicy:          common_features.CompliancePolicy,
-		InfrastructureLabels:      gw.GetLabels(),
-		InfrastructureAnnotations: gw.GetAnnotations(),
-		GatewayNameLabel:          label.IoK8sNetworkingGatewayGatewayName.Name,
-	}
-	// Default to the gateway labels/annotations and overwrite if infrastructure labels/annotations are set
-	input.InfrastructureLabels = extractInfrastructureLabels(gw)
-	input.InfrastructureAnnotations = extractInfrastructureAnnotations(gw)
-	d.setLabelOverrides(gw, input)
-
-	if overwriteControllerVersion {
-		log.Debugf("write controller version, existing=%v", existingControllerVersion)
-		if err := d.setGatewayControllerVersion(gw); err != nil {
-			return fmt.Errorf("update gateway annotation: %v", err)
-		}
-	} else {
-		log.Debugf("controller version existing=%v, no action needed", existingControllerVersion)
-	}
-
-	rendered, err := d.render(gi.templates, input)
-	if err != nil {
-		// Just log error, we do not need to retry since rendering errors are not ephemeral errors
-		log.Errorf("error rendering templates: %v", err)
-		return nil
-	}
-	for _, t := range rendered {
-		if err := d.apply(gi.controller, t); err != nil {
-			return fmt.Errorf("apply failed: %v", err)
-		}
-	}
-
-	log.Info("gateway updated")
-	return nil
-}
-
-func (d *DeploymentController) setLabelOverrides(gw gateway.Gateway, input TemplateInput) {
-	// TODO: Codify this API (i.e how to know if a specific gateway is an Istio waypoint gateway)
-	isWaypointGateway := strings.Contains(string(gw.Spec.GatewayClassName), "waypoint")
-
-	var hasAmbientLabel bool
-	if _, ok := gw.Labels[label.IoIstioDataplaneMode.Name]; ok {
-		hasAmbientLabel = true
-	}
-	if _, ok := input.InfrastructureLabels[label.IoIstioDataplaneMode.Name]; ok {
-		hasAmbientLabel = true
-	}
-	// If no ambient redirection label is set explicitly, explicitly disable.
-	// TODO this sprays ambient annotations/labels all over EVER gateway resource (serviceaccts, services, etc)
-	if features.EnableAmbientWaypoints && !isWaypointGateway && !hasAmbientLabel {
-		input.InfrastructureLabels[label.IoIstioDataplaneMode.Name] = constants.DataplaneModeNone
-	}
-
-	// Default the network label for waypoints if not explicitly set in gateway's labels
-	network := d.injectConfig().Values.Struct().GetGlobal().GetNetwork()
-	if _, ok := gw.GetLabels()[label.TopologyNetwork.Name]; !ok && network != "" && isWaypointGateway {
-		input.InfrastructureLabels[label.TopologyNetwork.Name] = d.injectConfig().Values.Struct().GetGlobal().GetNetwork()
-	}
-}
-
-func extractInfrastructureLabels(gw gateway.Gateway) map[string]string {
-	return extractInfrastructureMetadata(gw.Spec.Infrastructure, true, gw)
-}
-
-func extractInfrastructureAnnotations(gw gateway.Gateway) map[string]string {
-	return extractInfrastructureMetadata(gw.Spec.Infrastructure, false, gw)
-}
-
-func translateInfraMeta[K ~string, V ~string](meta map[K]V) map[string]string {
-	infra := make(map[string]string, len(meta))
-	for k, v := range meta {
-		if strings.HasPrefix(string(k), "gateway.networking.k8s.io/") {
-			continue // ignore this prefix to avoid conflicts
-		}
-		infra[string(k)] = string(v)
-	}
-	return infra
-}
-
-func extractInfrastructureMetadata(gwInfra *gatewayv1.GatewayInfrastructure, isLabel bool, gw gateway.Gateway) map[string]string {
-	if gwInfra != nil && isLabel && gwInfra.Labels != nil {
-		return translateInfraMeta(gwInfra.Labels)
-	}
-	if gwInfra != nil && !isLabel && gwInfra.Annotations != nil {
-		return translateInfraMeta(gwInfra.Annotations)
-	}
-	if isLabel {
-		if gw.GetLabels() == nil {
-			return make(map[string]string)
-		}
-		return maps.Clone(gw.GetLabels())
-	}
-	if gw.GetAnnotations() == nil {
-		return make(map[string]string)
-	}
-	return maps.Clone(gw.GetAnnotations())
-}
-
-const (
-	// ControllerVersionAnnotation is an annotation added to the Gateway by the controller specifying
-	// the "controller version". The original intent of this was to work around
-	// https://github.com/istio/istio/issues/44164, where we needed to transition from a global owner
-	// to a per-revision owner. The newer version number allows forcing ownership, even if the other
-	// version was otherwise expected to control the Gateway.
-	// The version number has no meaning other than "larger numbers win".
-	// Numbers are used to future-proof in case we need to do another migration in the future.
-	ControllerVersionAnnotation = "gateway.istio.io/controller-version"
-	// ControllerVersion is the current version of our controller logic. Known versions are:
-	//
-	// * 1.17 and older: version 1 OR no version at all, depending on patch release
-	// * 1.18+: version 5
-	//
-	// 2, 3, and 4 were intentionally skipped to allow for the (unlikely) event we need to insert
-	// another version between these
-	ControllerVersion = 5
-)
-
-// ManagedGatewayControllerVersion determines the version of the controller managing this Gateway,
-// and if we should manage this.
-// See ControllerVersionAnnotation for motivations.
-func ManagedGatewayControllerVersion(gw gateway.Gateway) (existing string, takeOver bool, manage bool) {
-	cur, f := gw.Annotations[ControllerVersionAnnotation]
-	if !f {
-		// No current owner, we should take it over.
-		return "", true, true
-	}
-	curNum, err := strconv.Atoi(cur)
-	if err != nil {
-		// We cannot parse it - must be some new schema we don't know about. We should assume we do not manage it.
-		// In theory, this should never happen, unless we decide a number was a bad idea in the future.
-		return cur, false, false
-	}
-	if curNum > ControllerVersion {
-		// A newer version owns this gateway, let them handle it
-		return cur, false, false
-	}
-	if curNum == ControllerVersion {
-		// We already manage this at this version
-		// We will manage it, but no need to attempt to apply the version annotation, which could race with newer versions
-		return cur, false, true
-	}
-	// We are either newer or the same version of the last owner - we can take over. We need to actually
-	// re-apply the annotation
-	return cur, true, true
-}
-
-type derivedInput struct {
-	TemplateInput
-
-	// Inserted from injection config
-	ProxyImage  string
-	ProxyConfig *meshapi.ProxyConfig
-	MeshConfig  *meshapi.MeshConfig
-	Values      map[string]any
-}
-
-func (d *DeploymentController) render(templateName string, mi TemplateInput) ([]string, error) {
-	cfg := d.injectConfig()
-
-	template := cfg.Templates[templateName]
-	if template == nil {
-		return nil, fmt.Errorf("no %q template defined", templateName)
-	}
-
-	var templateOverlays []map[string]string
-
-	classConfigs := d.configMaps.List(d.systemNamespace, klabels.SelectorFromValidatedSet(map[string]string{
-		gatewayClassDefaults: string(mi.Spec.GatewayClassName),
-	}))
-	if len(classConfigs) > 0 {
-		classConfig := controllers.OldestObject(classConfigs)
-		templateOverlays = append(templateOverlays, classConfig.Data)
-	}
-	params, err := fetchParameters(mi.Gateway)
-	if err != nil {
-		return nil, fmt.Errorf("invalid parameters: %v", err)
-	}
-	if params != nil {
-		cm := d.configMaps.Get(params.Name, params.Namespace)
-		if cm == nil {
-			return nil, fmt.Errorf("parametersRef targeting configmap %q, but configmap does not exist", params)
-		}
-		templateOverlays = append(templateOverlays, cm.Data)
-	}
-
-	labelToMatch := map[string]string{label.IoK8sNetworkingGatewayGatewayName.Name: mi.Name}
-	proxyConfig := d.env.GetProxyConfigOrDefault(mi.Namespace, labelToMatch, nil, cfg.MeshConfig)
-	input := derivedInput{
-		TemplateInput: mi,
-		ProxyImage: inject.ProxyImage(
-			cfg.Values.Struct(),
-			proxyConfig.GetImage(),
-			mi.Annotations,
-		),
-		ProxyConfig: proxyConfig,
-		MeshConfig:  cfg.MeshConfig,
-		Values:      cfg.Values.Map(),
-	}
-	results, err := tmpl.Execute(template, input)
-	if err != nil {
-		return nil, err
-	}
-
-	rawOutput := yml.SplitString(results)
-	transformedOutput := make([]string, 0, len(rawOutput))
-	for _, output := range rawOutput {
-		to, err := applyOverlay(output, templateOverlays)
-		if err != nil {
-			return nil, err
-		}
-		if to != "" {
-			transformedOutput = append(transformedOutput, to)
-		}
-	}
-	return transformedOutput, nil
-}
-
-var supportedOverlays = sets.New(
-	"deployment",
-	"service",
-	"serviceAccount",
-	"horizontalPodAutoscaler",
-	"podDisruptionBudget",
-)
-
-var requiredOverlays = sets.New(
-	"horizontalPodAutoscaler",
-	"podDisruptionBudget",
-)
-
-func applyOverlay(object string, overlaysList []map[string]string) (string, error) {
-	var ik crd.IstioKind
-	if err := yaml.Unmarshal([]byte(object), &ik); err != nil {
-		return "", fmt.Errorf("failed to find kind: %v", err)
-	}
-	gv, err := schema.ParseGroupVersion(ik.TypeMeta.APIVersion)
-	if err != nil {
-		return "", fmt.Errorf("failed to find kind: %v", err)
-	}
-	kind := &schema.GroupVersionKind{Group: gv.Group, Version: gv.Version, Kind: ik.TypeMeta.Kind}
-
-	var data any
-	var key string
-	switch kind.Kind {
-	case gvk.Deployment.Kind:
-		data = &appsv1.Deployment{}
-		key = "deployment"
-	case gvk.Service.Kind:
-		data = &corev1.Service{}
-		key = "service"
-	case gvk.ServiceAccount.Kind:
-		data = &corev1.ServiceAccount{}
-		key = "serviceAccount"
-	case gvk.HorizontalPodAutoscaler.Kind:
-		data = &autoscalingv2.HorizontalPodAutoscaler{}
-		key = "horizontalPodAutoscaler"
-	case gvk.PodDisruptionBudget.Kind:
-		data = &policyv1.PodDisruptionBudget{}
-		key = "podDisruptionBudget"
-	default:
-		return "", fmt.Errorf("unknown overlay kind %q", kind.Kind)
-	}
-	applied := false
-	for _, overlays := range overlaysList {
-		for k := range overlays {
-			if !supportedOverlays.Contains(k) {
-				return "", fmt.Errorf("unsupported overlay %q (supported: %v)", k, sets.SortedList(supportedOverlays))
-			}
-		}
-		overlay, f := overlays[key]
-		if !f {
-			continue
-		}
-		b, err := strategicMergePatchYAML([]byte(object), []byte(overlay), data)
-		if err != nil {
-			return "", fmt.Errorf("strategic merge patch failed: %v", err)
-		}
-		applied = true
-		object = string(b)
-	}
-	if !applied && requiredOverlays.Contains(key) {
-		return "", nil
-	}
-
-	var finalIK crd.IstioKind
-	if err := yaml.Unmarshal([]byte(object), &finalIK); err != nil {
-		return "", fmt.Errorf("failed to find final kind: %v", err)
-	}
-
-	a, b := ik.ObjectMeta, finalIK.ObjectMeta
-	if !(a.Name == b.Name &&
-		a.GenerateName == b.GenerateName &&
-		a.Namespace == b.Namespace &&
-		a.UID == b.UID &&
-		a.ResourceVersion == b.ResourceVersion &&
-		a.Generation == b.Generation &&
-		a.CreationTimestamp == b.CreationTimestamp &&
-		a.DeletionTimestamp == b.DeletionTimestamp &&
-		a.DeletionGracePeriodSeconds == b.DeletionGracePeriodSeconds &&
-		reflect.DeepEqual(a.OwnerReferences, b.OwnerReferences) &&
-		slices.Equal(a.Finalizers, b.Finalizers)) {
-		return "", fmt.Errorf("illegal metadata change")
-	}
-	// We could deep equal here but its a bit more tedious, so just never allow setting it
-	if len(a.ManagedFields) != 0 || len(b.ManagedFields) != 0 {
-		return "", fmt.Errorf("illegal metadata change")
-	}
-
-	return object, nil
-}
-
-// fetchParameters returns the infrastructure parameters for the Gateway. This is currently always a local configmap so we return the name only.
-// An error is returned if the parameter is invalid. This does not check the configmap exists, though.
-// If no parameter is specified, no name or error is returned.
-func fetchParameters(gw *gateway.Gateway) (*types.NamespacedName, error) {
-	if gw.Spec.Infrastructure != nil && gw.Spec.Infrastructure.ParametersRef != nil {
-		pr := gw.Spec.Infrastructure.ParametersRef
-		if string(pr.Kind) == gvk.ConfigMap.Kind && string(pr.Group) == gvk.ConfigMap.Group {
-			return &types.NamespacedName{
-				Namespace: gw.Namespace,
-				Name:      pr.Name,
-			}, nil
-		}
-		return nil, fmt.Errorf("unknown infrastructure parameters type %v/%v", pr.Group, pr.Kind)
-	}
-	return nil, nil
-}
-
-func (d *DeploymentController) setGatewayControllerVersion(gws gateway.Gateway) error {
-	patch := fmt.Sprintf(`{"apiVersion":"gateway.networking.k8s.io/v1beta1","kind":"Gateway","metadata":{"annotations":{"%s":"%d"}}}`,
-		ControllerVersionAnnotation, ControllerVersion)
-
-	log.Debugf("applying %v", patch)
-	// Use status RBAC so we do not require full Gateway write.
-	// `status` write can modify annotations, and we already need to write status anyway so we have the permission.
-	return d.patcher(gvr.KubernetesGateway, gws.GetName(), gws.GetNamespace(), []byte(patch), "status")
-}
-
-// apply server-side applies a template to the cluster.
-func (d *DeploymentController) apply(controller string, yml string) error {
-	data := map[string]any{}
-	err := yaml.Unmarshal([]byte(yml), &data)
-	if err != nil {
-		return err
-	}
-	us := unstructured.Unstructured{Object: data}
-	// set managed-by label
-	clabel := strings.ReplaceAll(controller, "/", "-")
-	err = unstructured.SetNestedField(us.Object, clabel, "metadata", "labels", label.GatewayManaged.Name)
-	if err != nil {
-		return err
-	}
-	gvr, err := controllers.UnstructuredToGVR(us)
-	if err != nil {
-		return err
-	}
-
-	canManage, resourceVersion := d.canManage(gvr, us.GetName(), us.GetNamespace())
-	if !canManage {
-		log.Debugf("skipping %v/%v/%v, already managed", gvr, us.GetName(), us.GetNamespace())
-		return nil
-	}
-	// Ensure our canManage assertion is not stale
-	us.SetResourceVersion(resourceVersion)
-
-	// Because in 1.24 we removed old label "istio.io/gateway-name", in order to not mutate the deployment.spec.Selector during upgrade.
-	// we always use the old `selector` value
-	if gvr.Resource == "deployments" {
-		deployment := d.deployments.Get(us.GetName(), us.GetNamespace())
-		if deployment != nil && deployment.Spec.Selector.MatchLabels["istio.io/gateway-name"] != "" {
-			us.Object["spec"].(map[string]any)["selector"] = deployment.Spec.Selector
-			// nolint lll
-			us.Object["spec"].(map[string]any)["template"].(map[string]any)["metadata"].(map[string]any)["labels"].(map[string]any)["istio.io/gateway-name"] = deployment.Spec.Template.ObjectMeta.Labels["istio.io/gateway-name"]
-		}
-	}
-
-	j, err := json.Marshal(us.Object)
-	if err != nil {
-		return err
-	}
-	log.Debugf("applying %v", string(j))
-	if err := d.patcher(gvr, us.GetName(), us.GetNamespace(), j); err != nil {
-		return fmt.Errorf("patch %v/%v/%v: %v", us.GroupVersionKind(), us.GetNamespace(), us.GetName(), err)
-	}
-	return nil
-}
-
-func (d *DeploymentController) HandleTagChange(newTags sets.String) {
-	for _, gw := range d.gateways.List(metav1.NamespaceAll, klabels.Everything()) {
-		d.queue.AddObject(gw)
-	}
-}
-
-// canManage checks if a resource we are about to write should be managed by us. If the resource already exists
-// but does not have the ManagedGatewayLabel, we won't overwrite it.
-// This ensures we don't accidentally take over some resource we weren't supposed to, which could cause outages.
-// Note K8s doesn't have a perfect way to "conditionally SSA", but its close enough (https://github.com/kubernetes/kubernetes/issues/116156).
-func (d *DeploymentController) canManage(gvr schema.GroupVersionResource, name, namespace string) (bool, string) {
-	store, f := d.clients[gvr]
-	if !f {
-		log.Warnf("unknown GVR %v", gvr)
-		// Even though we don't know what it is, allow users to put the resource. We won't be able to
-		// protect against overwrites though.
-		return true, ""
-	}
-	obj := store.Get(name, namespace)
-	if obj == nil {
-		// no object, we can manage it
-		return true, ""
-	}
-	_, managed := obj.GetLabels()[label.GatewayManaged.Name]
-	// If object already exists, we can only manage it if it has the label
-	return managed, obj.GetResourceVersion()
-}
-
-type TemplateInput struct {
-	*gateway.Gateway
-	DeploymentName            string
-	ServiceAccount            string
-	Ports                     []corev1.ServicePort
-	ServiceType               corev1.ServiceType
-	ClusterID                 string
-	KubeVersion               int
-	Revision                  string
-	ProxyUID                  int64
-	ProxyGID                  int64
-	CompliancePolicy          string
-	InfrastructureLabels      map[string]string
-	InfrastructureAnnotations map[string]string
-	GatewayNameLabel          string
-}
-
-func extractServicePorts(gw gateway.Gateway) []corev1.ServicePort {
-	tcp := strings.ToLower(string(protocol.TCP))
-	svcPorts := make([]corev1.ServicePort, 0, len(gw.Spec.Listeners)+1)
-	svcPorts = append(svcPorts, corev1.ServicePort{
-		Name:        "status-port",
-		Port:        int32(15021),
-		AppProtocol: &tcp,
-	})
-	portNums := sets.New[int32]()
-	for i, l := range gw.Spec.Listeners {
-		if portNums.Contains(int32(l.Port)) {
-			continue
-		}
-		portNums.Insert(int32(l.Port))
-		name := sanitizeListenerNameForPort(string(l.Name))
-		if name == "" {
-			// Should not happen since name is required, but in case an invalid resource gets in...
-			name = fmt.Sprintf("%s-%d", strings.ToLower(string(l.Protocol)), i)
-		}
-		appProtocol := strings.ToLower(string(l.Protocol))
-		svcPorts = append(svcPorts, corev1.ServicePort{
-			Name:        name,
-			Port:        int32(l.Port),
-			AppProtocol: &appProtocol,
-		})
-	}
-	return svcPorts
-}
-
-// ListenerName allows periods and 253 chars.
-// We map this to service port name which does not allow period and only 63 chars.
-func sanitizeListenerNameForPort(s string) string {
-	// In theory, this mapping can result in a duplicate, but probably not likely
-	s = strings.ReplaceAll(s, ".", "-")
-	if len(s) <= 63 {
-		return s
-	}
-	return s[:63]
-}
-
-// UntypedWrapper wraps a typed reader to an untyped one, since Go cannot do it automatically.
-type UntypedWrapper[T controllers.ComparableObject] struct {
-	reader kclient.Reader[T]
-}
-type getter interface {
-	Get(name, namespace string) controllers.Object
-}
-
-func NewUntypedWrapper[T controllers.ComparableObject](c kclient.Client[T]) getter {
-	return UntypedWrapper[T]{c}
-}
-
-func (u UntypedWrapper[T]) Get(name, namespace string) controllers.Object {
-	// DO NOT return u.reader.Get directly, or we run into issues with https://go.dev/tour/methods/12
-	res := u.reader.Get(name, namespace)
-	if controllers.IsNil(res) {
-		return nil
-	}
-	return res
-}
-
-var _ getter = UntypedWrapper[*corev1.Service]{}
-
-// strategicMergePatchYAML is a small fork of strategicpatch.StrategicMergePatch to allow YAML patches
-// This avoids expensive conversion from YAML to JSON
-func strategicMergePatchYAML(originalYAML []byte, patchYAML []byte, dataStruct any) ([]byte, error) {
-	schema, err := strategicpatch.NewPatchMetaFromStruct(dataStruct)
-	if err != nil {
-		return nil, err
-	}
-
-	originalMap, err := patchHandleUnmarshal(originalYAML)
-	if err != nil {
-		return nil, err
-	}
-	patchMap, err := patchHandleUnmarshal(patchYAML)
-	if err != nil {
-		return nil, err
-	}
-
-	result, err := strategicpatch.StrategicMergeMapPatchUsingLookupPatchMeta(originalMap, patchMap, schema)
-	if err != nil {
-		return nil, err
-	}
-
-	return json.Marshal(result)
-}
-
-func patchHandleUnmarshal(j []byte) (map[string]any, error) {
-	if j == nil {
-		j = []byte("{}")
-	}
-
-	m := map[string]any{}
-	err := yaml.Unmarshal(j, &m)
-	if err != nil {
-		return nil, mergepatch.ErrBadJSONDoc
-	}
-	return m, nil
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go b/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go
deleted file mode 100644
index 6dfaaf112..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/deploymentcontroller_test.go
+++ /dev/null
@@ -1,683 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"bytes"
-	"fmt"
-	"os"
-	"path/filepath"
-	"testing"
-	"time"
-
-	"go.uber.org/atomic"
-	appsv1 "k8s.io/api/apps/v1"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	kubeVersion "k8s.io/apimachinery/pkg/version"
-	fakediscovery "k8s.io/client-go/discovery/fake"
-	k8s "sigs.k8s.io/gateway-api/apis/v1"
-	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
-	"sigs.k8s.io/yaml"
-
-	"istio.io/api/annotation"
-	"istio.io/api/label"
-	istioio_networking_v1beta1 "istio.io/api/networking/v1beta1"
-	istio_type_v1beta1 "istio.io/api/type/v1beta1"
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pilot/test/util"
-	"istio.io/istio/pkg/cluster"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/mesh"
-	"istio.io/istio/pkg/config/schema/gvk"
-	"istio.io/istio/pkg/config/schema/gvr"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/controllers"
-	"istio.io/istio/pkg/kube/inject"
-	"istio.io/istio/pkg/kube/kclient"
-	"istio.io/istio/pkg/kube/kclient/clienttest"
-	"istio.io/istio/pkg/kube/kubetypes"
-	istiolog "istio.io/istio/pkg/log"
-	"istio.io/istio/pkg/revisions"
-	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/env"
-	"istio.io/istio/pkg/test/util/assert"
-	"istio.io/istio/pkg/test/util/file"
-	"istio.io/istio/pkg/test/util/retry"
-)
-
-func TestConfigureIstioGateway(t *testing.T) {
-	discoveryNamespacesFilter := buildFilter("default")
-	defaultNamespace := &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: "default"}}
-	customClass := &k8sbeta.GatewayClass{
-		ObjectMeta: metav1.ObjectMeta{
-			Name: "custom",
-		},
-		Spec: k8s.GatewayClassSpec{
-			ControllerName: k8s.GatewayController(features.ManagedGatewayController),
-		},
-	}
-	upgradeDeployment := &appsv1.Deployment{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "test-upgrade",
-			Namespace: "default",
-			Labels: map[string]string{
-				"gateway.istio.io/managed": "istio.io-mesh-controller",
-				"istio.io/gateway-name":    "test-upgrade",
-			},
-		},
-		Spec: appsv1.DeploymentSpec{
-			Selector: &metav1.LabelSelector{
-				MatchLabels: map[string]string{
-					"gateway.networking.k8s.io/gateway-name": "test-upgrade",
-					"istio.io/gateway-name":                  "test-upgrade",
-				},
-			},
-			Template: corev1.PodTemplateSpec{
-				ObjectMeta: metav1.ObjectMeta{
-					Labels: map[string]string{
-						"gateway.istio.io/managed":               "istio.io-mesh-controller",
-						"gateway.networking.k8s.io/gateway-name": "test-upgrade",
-						"istio.io/gateway-name":                  "test-upgrade",
-						"istio.io/dataplane-mode":                "none",
-						"service.istio.io/canonical-name":        "test-upgrade",
-						"service.istio.io/canonical-revision":    "latest",
-						"sidecar.istio.io/inject":                "false",
-						"topology.istio.io/network":              "network-1",
-					},
-				},
-			},
-		},
-	}
-
-	defaultObjects := []runtime.Object{defaultNamespace}
-	store := model.NewFakeStore()
-	if _, err := store.Create(config.Config{
-		Meta: config.Meta{
-			GroupVersionKind: gvk.ProxyConfig,
-			Name:             "test",
-			Namespace:        "default",
-		},
-		Spec: &istioio_networking_v1beta1.ProxyConfig{
-			Selector: &istio_type_v1beta1.WorkloadSelector{
-				MatchLabels: map[string]string{
-					label.IoK8sNetworkingGatewayGatewayName.Name: "default",
-				},
-			},
-			Image: &istioio_networking_v1beta1.ProxyImage{
-				ImageType: "distroless",
-			},
-		},
-	}); err != nil {
-		t.Fatalf("failed to create ProxyConfigs: %s", err)
-	}
-	proxyConfig := model.GetProxyConfigs(store, mesh.DefaultMeshConfig())
-	tests := []struct {
-		name                     string
-		gw                       k8sbeta.Gateway
-		objects                  []runtime.Object
-		pcs                      *model.ProxyConfigs
-		values                   string
-		discoveryNamespaceFilter kubetypes.DynamicObjectFilter
-		ignore                   bool
-	}{
-		{
-			name: "simple",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:        "default",
-					Namespace:   "default",
-					Labels:      map[string]string{"should": "see"},
-					Annotations: map[string]string{"should": "see"},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-				},
-			},
-			objects:                  defaultObjects,
-			discoveryNamespaceFilter: discoveryNamespacesFilter,
-		},
-		{
-			name: "simple",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "default",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-				},
-			},
-			objects:                  defaultObjects,
-			discoveryNamespaceFilter: buildFilter("not-default"),
-			ignore:                   true,
-		},
-		{
-			name: "manual-sa",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:        "default",
-					Namespace:   "default",
-					Annotations: map[string]string{annotation.GatewayServiceAccount.Name: "custom-sa"},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-				},
-			},
-			objects:                  defaultObjects,
-			discoveryNamespaceFilter: discoveryNamespacesFilter,
-		},
-		{
-			name: "manual-ip",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:        "default",
-					Namespace:   "default",
-					Annotations: map[string]string{annotation.GatewayNameOverride.Name: "default"},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-					Addresses: []k8s.GatewaySpecAddress{{
-						Type:  func() *k8s.AddressType { x := k8s.IPAddressType; return &x }(),
-						Value: "1.2.3.4",
-					}},
-				},
-			},
-			objects:                  defaultObjects,
-			discoveryNamespaceFilter: discoveryNamespacesFilter,
-		},
-		{
-			name: "cluster-ip",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "default",
-					Namespace: "default",
-					Annotations: map[string]string{
-						"networking.istio.io/service-type":  string(corev1.ServiceTypeClusterIP),
-						annotation.GatewayNameOverride.Name: "default",
-					},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-					Listeners: []k8s.Listener{{
-						Name:     "http",
-						Port:     k8s.PortNumber(80),
-						Protocol: k8s.HTTPProtocolType,
-					}},
-				},
-			},
-			objects:                  defaultObjects,
-			discoveryNamespaceFilter: discoveryNamespacesFilter,
-		},
-		{
-			name: "multinetwork",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:        "default",
-					Namespace:   "default",
-					Labels:      map[string]string{label.TopologyNetwork.Name: "network-1"},
-					Annotations: map[string]string{annotation.GatewayNameOverride.Name: "default"},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-					Listeners: []k8s.Listener{{
-						Name:     "http",
-						Port:     k8s.PortNumber(80),
-						Protocol: k8s.HTTPProtocolType,
-					}},
-				},
-			},
-			objects:                  defaultObjects,
-			discoveryNamespaceFilter: discoveryNamespacesFilter,
-		},
-		{
-			name: "waypoint",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "namespace",
-					Namespace: "default",
-					Labels: map[string]string{
-						label.TopologyNetwork.Name: "network-1", // explicitly set network won't be overwritten
-					},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: constants.WaypointGatewayClassName,
-					Listeners: []k8s.Listener{{
-						Name:     "mesh",
-						Port:     k8s.PortNumber(15008),
-						Protocol: "ALL",
-					}},
-				},
-			},
-			objects: defaultObjects,
-			values: `global:
-  hub: test
-  tag: test
-  network: network-2`,
-		},
-		{
-			name: "waypoint-no-network-label",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "namespace",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: constants.WaypointGatewayClassName,
-					Listeners: []k8s.Listener{{
-						Name:     "mesh",
-						Port:     k8s.PortNumber(15008),
-						Protocol: "ALL",
-					}},
-				},
-			},
-			objects: defaultObjects,
-			values: `global:
-  hub: test
-  tag: test
-  network: network-1`,
-		},
-		{
-			name: "proxy-config-crd",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "default",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-				},
-			},
-			objects: defaultObjects,
-			pcs:     proxyConfig,
-		},
-		{
-			name: "custom-class",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "default",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(customClass.Name),
-				},
-			},
-			objects: defaultObjects,
-		},
-		{
-			name: "infrastructure-labels-annotations",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:        "default",
-					Namespace:   "default",
-					Labels:      map[string]string{"should-not": "see"},
-					Annotations: map[string]string{"should-not": "see"},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-					Infrastructure: &k8s.GatewayInfrastructure{
-						Labels:      map[k8s.LabelKey]k8s.LabelValue{"foo": "bar", "gateway.networking.k8s.io/ignore": "true"},
-						Annotations: map[k8s.AnnotationKey]k8s.AnnotationValue{"fizz": "buzz", "gateway.networking.k8s.io/ignore": "true"},
-					},
-				},
-			},
-			objects: defaultObjects,
-		},
-		{
-			name: "kube-gateway-ambient-redirect",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "default",
-					Namespace: "default",
-					// TODO why are we setting this on gateways?
-					Labels: map[string]string{
-						label.IoIstioDataplaneMode.Name: constants.DataplaneModeAmbient,
-					},
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-				},
-			},
-			objects: defaultObjects,
-		},
-		{
-			name: "kube-gateway-ambient-redirect-infra",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "default",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-					Infrastructure: &k8s.GatewayInfrastructure{
-						Labels: map[k8s.LabelKey]k8s.LabelValue{
-							k8s.LabelKey(label.IoIstioDataplaneMode.Name): constants.DataplaneModeAmbient,
-						},
-					},
-				},
-			},
-			objects: defaultObjects,
-		},
-		{
-			name: "istio-upgrade-to-1.24",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "test-upgrade",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: constants.WaypointGatewayClassName,
-					Listeners: []k8s.Listener{{
-						Name:     "mesh",
-						Port:     k8s.PortNumber(15008),
-						Protocol: "ALL",
-					}},
-				},
-			},
-			objects: defaultObjects,
-			values: `global:
-  hub: test
-  tag: test
-  network: network-1`,
-		},
-		{
-			name: "customizations",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "namespace",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-					Infrastructure: &k8s.GatewayInfrastructure{
-						Labels: map[k8s.LabelKey]k8s.LabelValue{"foo": "bar"},
-						ParametersRef: &k8s.LocalParametersReference{
-							Group: "",
-							Kind:  "ConfigMap",
-							Name:  "gw-options",
-						},
-					},
-				},
-			},
-			objects: append(slices.Clone(defaultObjects), &corev1.ConfigMap{
-				ObjectMeta: metav1.ObjectMeta{Name: "gw-options", Namespace: "default"},
-				Data: map[string]string{
-					"podDisruptionBudget": `
-spec:
-  minAvailable: 1`,
-					"horizontalPodAutoscaler": `
-spec:
-  minReplicas: 2
-  maxReplicas: 2`,
-					"deployment": `
-metadata:
-  annotations:
-    cm-annotation: cm-annotation-value
-spec:
-  replicas: 4
-  template:
-    spec:
-      containers:
-      - name: istio-proxy
-        resources:
-          requests:
-            cpu: 222m`,
-				},
-			}),
-			values: ``,
-		},
-		{
-			name: "illegal_customizations",
-			gw: k8sbeta.Gateway{
-				ObjectMeta: metav1.ObjectMeta{
-					Name:      "namespace",
-					Namespace: "default",
-				},
-				Spec: k8s.GatewaySpec{
-					GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-					Infrastructure: &k8s.GatewayInfrastructure{
-						Labels: map[k8s.LabelKey]k8s.LabelValue{"foo": "bar"},
-						ParametersRef: &k8s.LocalParametersReference{
-							Group: "",
-							Kind:  "ConfigMap",
-							Name:  "gw-options",
-						},
-					},
-				},
-			},
-			objects: append(slices.Clone(defaultObjects), &corev1.ConfigMap{
-				ObjectMeta: metav1.ObjectMeta{Name: "gw-options", Namespace: "default"},
-				Data: map[string]string{
-					"deployment": `
-metadata:
-  name: not-allowed`,
-				},
-			}),
-			values: ``,
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			buf := &bytes.Buffer{}
-			client := kube.NewFakeClient(tt.objects...)
-			kube.SetObjectFilter(client, tt.discoveryNamespaceFilter)
-			client.Kube().Discovery().(*fakediscovery.FakeDiscovery).FakedServerVersion = &kubeVersion.Info{Major: "1", Minor: "28"}
-			kclient.NewWriteClient[*k8sbeta.GatewayClass](client).Create(customClass)
-			kclient.NewWriteClient[*k8sbeta.Gateway](client).Create(tt.gw.DeepCopy())
-			kclient.NewWriteClient[*appsv1.Deployment](client).Create(upgradeDeployment)
-			stop := test.NewStop(t)
-			env := model.NewEnvironment()
-			env.PushContext().ProxyConfigs = tt.pcs
-			tw := revisions.NewTagWatcher(client, "")
-			go tw.Run(stop)
-			d := NewDeploymentController(client, cluster.ID(features.ClusterName), env, testInjectionConfig(t, tt.values), func(fn func()) {
-			}, tw, "", "")
-			d.patcher = func(gvr schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error {
-				b, err := yaml.JSONToYAML(data)
-				if err != nil {
-					return err
-				}
-				buf.Write(b)
-				buf.WriteString("---\n")
-				return nil
-			}
-			client.RunAndWait(stop)
-			go d.Run(stop)
-			kube.WaitForCacheSync("test", stop, d.queue.HasSynced)
-
-			if tt.ignore {
-				assert.Equal(t, buf.String(), "")
-			} else {
-				resp := timestampRegex.ReplaceAll(buf.Bytes(), []byte("lastTransitionTime: fake"))
-				if util.Refresh() {
-					if err := os.WriteFile(filepath.Join("testdata", "deployment", tt.name+".yaml"), resp, 0o644); err != nil {
-						t.Fatal(err)
-					}
-				}
-				util.CompareContent(t, resp, filepath.Join("testdata", "deployment", tt.name+".yaml"))
-			}
-			// ensure we didn't mutate the object
-			if !tt.ignore {
-				assert.Equal(t, d.gateways.Get(tt.gw.Name, tt.gw.Namespace), &tt.gw)
-			}
-		})
-	}
-}
-
-func buildFilter(allowedNamespace string) kubetypes.DynamicObjectFilter {
-	return kubetypes.NewStaticObjectFilter(func(obj any) bool {
-		if ns, ok := obj.(string); ok {
-			return ns == allowedNamespace
-		}
-		object := controllers.ExtractObject(obj)
-		if object == nil {
-			return false
-		}
-		ns := object.GetNamespace()
-		if _, ok := object.(*corev1.Namespace); ok {
-			ns = object.GetName()
-		}
-		return ns == allowedNamespace
-	})
-}
-
-func TestVersionManagement(t *testing.T) {
-	log.SetOutputLevel(istiolog.DebugLevel)
-	writes := make(chan string, 10)
-	c := kube.NewFakeClient(&corev1.Namespace{
-		ObjectMeta: metav1.ObjectMeta{
-			Name: "default",
-		},
-	})
-	tw := revisions.NewTagWatcher(c, "default")
-	env := &model.Environment{}
-	d := NewDeploymentController(c, "", env, testInjectionConfig(t, ""), func(fn func()) {}, tw, "", "")
-	reconciles := atomic.NewInt32(0)
-	wantReconcile := int32(0)
-	expectReconciled := func() {
-		t.Helper()
-		wantReconcile++
-		assert.EventuallyEqual(t, reconciles.Load, wantReconcile, retry.Timeout(time.Second*5), retry.Message("no reconciliation"))
-	}
-
-	d.patcher = func(g schema.GroupVersionResource, name string, namespace string, data []byte, subresources ...string) error {
-		if g == gvr.Service {
-			reconciles.Inc()
-		}
-		if g == gvr.KubernetesGateway {
-			b, err := yaml.JSONToYAML(data)
-			if err != nil {
-				return err
-			}
-			writes <- string(b)
-		}
-		return nil
-	}
-	stop := test.NewStop(t)
-	gws := clienttest.Wrap(t, d.gateways)
-	go tw.Run(stop)
-	go d.Run(stop)
-	c.RunAndWait(stop)
-	kube.WaitForCacheSync("test", stop, d.queue.HasSynced)
-	// Create a gateway, we should mark our ownership
-	defaultGateway := &k8sbeta.Gateway{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:      "gw",
-			Namespace: "default",
-		},
-		Spec: k8s.GatewaySpec{
-			GatewayClassName: k8s.ObjectName(features.GatewayAPIDefaultGatewayClass),
-		},
-	}
-	gws.Create(defaultGateway)
-	assert.Equal(t, assert.ChannelHasItem(t, writes), buildPatch(ControllerVersion))
-	expectReconciled()
-	assert.ChannelIsEmpty(t, writes)
-	// Test fake doesn't actual do Apply, so manually do this
-	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(ControllerVersion)}
-	gws.Update(defaultGateway)
-	expectReconciled()
-	// We shouldn't write in response to our write.
-	assert.ChannelIsEmpty(t, writes)
-
-	defaultGateway.Annotations["foo"] = "bar"
-	gws.Update(defaultGateway)
-	expectReconciled()
-	// We should not be updating the version, its already set. Setting it introduces a possible race condition
-	// since we use SSA so there is no conflict checks.
-	assert.ChannelIsEmpty(t, writes)
-
-	// Somehow the annotation is removed - it should be added back
-	defaultGateway.Annotations = map[string]string{}
-	gws.Update(defaultGateway)
-	expectReconciled()
-	assert.Equal(t, assert.ChannelHasItem(t, writes), buildPatch(ControllerVersion))
-	assert.ChannelIsEmpty(t, writes)
-	// Test fake doesn't actual do Apply, so manually do this
-	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(ControllerVersion)}
-	gws.Update(defaultGateway)
-	expectReconciled()
-	// We shouldn't write in response to our write.
-	assert.ChannelIsEmpty(t, writes)
-
-	// Somehow the annotation is set to an older version - it should be added back
-	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(1)}
-	gws.Update(defaultGateway)
-	expectReconciled()
-	assert.Equal(t, assert.ChannelHasItem(t, writes), buildPatch(ControllerVersion))
-	assert.ChannelIsEmpty(t, writes)
-	// Test fake doesn't actual do Apply, so manually do this
-	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(ControllerVersion)}
-	gws.Update(defaultGateway)
-	expectReconciled()
-	// We shouldn't write in response to our write.
-	assert.ChannelIsEmpty(t, writes)
-
-	// Somehow the annotation is set to an new version - we should do nothing
-	defaultGateway.Annotations = map[string]string{ControllerVersionAnnotation: fmt.Sprint(10)}
-	gws.Update(defaultGateway)
-	assert.ChannelIsEmpty(t, writes)
-	// Do not expect reconcile
-	assert.Equal(t, reconciles.Load(), wantReconcile)
-}
-
-func testInjectionConfig(t test.Failer, values string) func() inject.WebhookConfig {
-	var vc inject.ValuesConfig
-	var err error
-	if values != "" {
-		vc, err = inject.NewValuesConfig(values)
-		if err != nil {
-			t.Fatal(err)
-		}
-	} else {
-		vc, err = inject.NewValuesConfig(`
-global:
-  hub: test
-  tag: test`)
-		if err != nil {
-			t.Fatal(err)
-		}
-
-	}
-	tmpl, err := inject.ParseTemplates(map[string]string{
-		"kube-gateway": file.AsStringOrFail(t, filepath.Join(env.IstioSrc, "manifests/charts/istio-control/istio-discovery/files/kube-gateway.yaml")),
-		"waypoint":     file.AsStringOrFail(t, filepath.Join(env.IstioSrc, "manifests/charts/istio-control/istio-discovery/files/waypoint.yaml")),
-	})
-	if err != nil {
-		t.Fatal(err)
-	}
-	injConfig := func() inject.WebhookConfig {
-		return inject.WebhookConfig{
-			Templates:  tmpl,
-			Values:     vc,
-			MeshConfig: mesh.DefaultMeshConfig(),
-		}
-	}
-	return injConfig
-}
-
-func buildPatch(version int) string {
-	return fmt.Sprintf(`apiVersion: gateway.networking.k8s.io/v1beta1
-kind: Gateway
-metadata:
-  annotations:
-    gateway.istio.io/controller-version: "%d"
-`, version)
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
index 615f58c14..feeea3fee 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
@@ -18,6 +18,7 @@ import (
 	"fmt"
 
 	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"istio.io/istio/pkg/config/constants"
 	corev1 "k8s.io/api/core/v1"
@@ -102,7 +103,7 @@ func (g PortBindings) ResourceName() string {
 
 func (g PortBindings) Equals(other PortBindings) bool {
 	return g.Gateway.Equals(other.Gateway) &&
-		g.port == other.port
+		g.Port == other.Port
 }
 
 type Gateway struct {
@@ -129,7 +130,7 @@ func GatewayCollection(
 	grants ReferenceGrants,
 	secrets krt.Collection[*corev1.Secret],
 	domainSuffix string,
-	opts krt.OptionsBuilder,
+	krtopts krtutil.KrtOptions,
 ) krt.Collection[Gateway] {
 	gw := krt.NewManyCollection(gateways, func(ctx krt.HandlerContext, obj *gateway.Gateway) []Gateway {
 		var result []Gateway
@@ -140,19 +141,10 @@ func GatewayCollection(
 			return nil
 		}
 		controllerName := class.Controller
-		classInfo, f := classInfos[controllerName]
-		if !f {
-			return nil
-		}
-		if classInfo.disableRouteGeneration {
-			// We found it, but don't want to handle this class
-			// TODO: log
-			return nil
-		}
 		var servers []*istio.Server
 
 		// Extract the addresses. A gateway will bind to a specific Service
-		gatewayServices, err := extractGatewayServices(domainSuffix, obj, classInfo)
+		gatewayServices, err := extractGatewayServices(domainSuffix, obj)
 		if len(gatewayServices) == 0 && err != nil {
 			// Short circuit if its a hard failure
 			// TODO: log
@@ -206,7 +198,7 @@ func GatewayCollection(
 		}
 
 		return result
-	}, opts.WithName("KubernetesGateway")...)
+	}, krtopts.ToOptions("KubernetesGateway")...)
 
 	return gw
 }
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go
deleted file mode 100644
index da5e4c603..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass.go
+++ /dev/null
@@ -1,118 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"github.com/hashicorp/go-multierror"
-	kerrors "k8s.io/apimachinery/pkg/api/errors"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	"k8s.io/apimachinery/pkg/types"
-	k8sv1 "sigs.k8s.io/gateway-api/apis/v1"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	"istio.io/istio/pilot/pkg/model/kstatus"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/controllers"
-	"istio.io/istio/pkg/kube/kclient"
-	"istio.io/istio/pkg/util/istiomultierror"
-)
-
-// ClassController is a controller that creates the default Istio GatewayClass(s). This will not
-// continually reconcile the full state of the GatewayClass object, and instead only create the class
-// if it doesn't exist. This allows users to manage it through other means or modify it as they wish.
-// If it is deleted, however, it will be added back.
-// This controller intentionally does not do leader election for simplicity. Because we only create
-// and not update there is no need; the first controller to create the GatewayClass wins.
-type ClassController struct {
-	queue   controllers.Queue
-	classes kclient.Client[*gateway.GatewayClass]
-}
-
-func NewClassController(kc kube.Client) *ClassController {
-	gc := &ClassController{}
-	gc.queue = controllers.NewQueue("gateway class",
-		controllers.WithReconciler(gc.Reconcile),
-		controllers.WithMaxAttempts(25))
-
-	gc.classes = kclient.New[*gateway.GatewayClass](kc)
-	gc.classes.AddEventHandler(controllers.FilteredObjectHandler(gc.queue.AddObject, func(o controllers.Object) bool {
-		_, f := builtinClasses[gateway.ObjectName(o.GetName())]
-		return f
-	}))
-	return gc
-}
-
-func (c *ClassController) Run(stop <-chan struct{}) {
-	// Ensure we initially reconcile the current state
-	c.queue.Add(types.NamespacedName{})
-	c.queue.Run(stop)
-}
-
-func (c *ClassController) Reconcile(types.NamespacedName) error {
-	err := istiomultierror.New()
-	for class := range builtinClasses {
-		err = multierror.Append(err, c.reconcileClass(class))
-	}
-	return err.ErrorOrNil()
-}
-
-func (c *ClassController) reconcileClass(class gateway.ObjectName) error {
-	if c.classes.Get(string(class), "") != nil {
-		log.Debugf("GatewayClass/%v already exists, no action", class)
-		return nil
-	}
-	controller := builtinClasses[class]
-	classInfo, f := classInfos[controller]
-	if !f {
-		// Should only happen when ambient is disabled; otherwise builtinClasses and classInfos should be consistent
-		return nil
-	}
-	gc := &gateway.GatewayClass{
-		ObjectMeta: metav1.ObjectMeta{
-			Name: string(class),
-		},
-		Spec: gateway.GatewayClassSpec{
-			ControllerName: gateway.GatewayController(classInfo.controller),
-			Description:    &classInfo.description,
-		},
-	}
-	_, err := c.classes.Create(gc)
-	if err != nil && !kerrors.IsConflict(err) {
-		return err
-	} else if err != nil && kerrors.IsConflict(err) {
-		// This is not really an error, just a race condition
-		log.Infof("Attempted to create GatewayClass/%v, but it was already created", class)
-	}
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func GetClassStatus(existing *k8sv1.GatewayClassStatus, gen int64) k8sv1.GatewayClassStatus {
-	if existing == nil {
-		existing = &k8sv1.GatewayClassStatus{}
-	}
-	existing.Conditions = kstatus.UpdateConditionIfChanged(existing.Conditions, metav1.Condition{
-		Type:               string(k8sv1.GatewayClassConditionStatusAccepted),
-		Status:             kstatus.StatusTrue,
-		ObservedGeneration: gen,
-		LastTransitionTime: metav1.Now(),
-		Reason:             string(k8sv1.GatewayClassConditionStatusAccepted),
-		Message:            "Handled by Istio controller",
-	})
-	return *existing
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
index d8cb8f7ae..808af3df2 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
@@ -1,30 +1,15 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 package gateway
 
 import (
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"istio.io/istio/pkg/kube/krt"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
-	"istio.io/istio/pkg/kube/krt"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 )
 
 type GatewayClass struct {
-	Name       string
-	Controller gateway.GatewayController
+	Name string
 }
 
 func (g GatewayClass) ResourceName() string {
@@ -36,13 +21,8 @@ func GatewayClassesCollection(
 	krtopts krtutil.KrtOptions,
 ) krt.Collection[GatewayClass] {
 	return krt.NewCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gateway.GatewayClass) *GatewayClass {
-		_, known := classInfos[obj.Spec.ControllerName]
-		if !known {
-			return nil
-		}
 		return &GatewayClass{
-			Name:       obj.Name,
-			Controller: obj.Spec.ControllerName,
+			Name: obj.Name,
 		}
 	}, krtopts.ToOptions("GatewayClasses")...)
 }
@@ -50,15 +30,9 @@ func GatewayClassesCollection(
 func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayClass], gc gatewayv1.ObjectName) *GatewayClass {
 	class := krt.FetchOne(ctx, gatewayClasses, krt.FilterKey(string(gc)))
 	if class == nil {
-		if bc, f := builtinClasses[gc]; f {
-			// We allow some classes to exist without being in the cluster
-			return &GatewayClass{
-				Name:       string(gc),
-				Controller: bc,
-			}
+		return &GatewayClass{
+			Name: string(gc),
 		}
-		// No gateway class found, this may be meant for another controller; should be skipped.
-		return nil
 	}
 	return class
 }
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go b/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go
deleted file mode 100644
index 90aadb89a..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_test.go
+++ /dev/null
@@ -1,93 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"fmt"
-	"testing"
-	"time"
-
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/kclient/clienttest"
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/util/retry"
-)
-
-func TestClassController(t *testing.T) {
-	client := kube.NewFakeClient()
-	cc := NewClassController(client)
-	classes := clienttest.Wrap(t, cc.classes)
-	stop := test.NewStop(t)
-	client.RunAndWait(stop)
-	go cc.Run(stop)
-	createClass := func(name, controller string) {
-		gc := &gateway.GatewayClass{
-			ObjectMeta: metav1.ObjectMeta{
-				Name: name,
-			},
-			Spec: gateway.GatewayClassSpec{
-				ControllerName: gateway.GatewayController(controller),
-			},
-		}
-		classes.CreateOrUpdate(gc)
-	}
-	deleteClass := func(name string) {
-		classes.Delete(name, "")
-	}
-	expectClass := func(name, controller string) {
-		t.Helper()
-		retry.UntilSuccessOrFail(t, func() error {
-			gc := classes.Get(name, "")
-			if controller == "" {
-				if gc == nil { // Expect none, got none
-					return nil
-				}
-				return fmt.Errorf("expected no class, got %v", gc.Spec.ControllerName)
-			}
-			if gc == nil {
-				return fmt.Errorf("expected class %v, got none", controller)
-			}
-			if gateway.GatewayController(controller) != gc.Spec.ControllerName {
-				return fmt.Errorf("expected class %v, got %v", controller, gc.Spec.ControllerName)
-			}
-			return nil
-		}, retry.Timeout(time.Second*3))
-	}
-
-	// Class should be created initially
-	expectClass(features.GatewayAPIDefaultGatewayClass, features.ManagedGatewayController)
-
-	// Once we delete it, it should be added back
-	deleteClass(features.GatewayAPIDefaultGatewayClass)
-	expectClass(features.GatewayAPIDefaultGatewayClass, features.ManagedGatewayController)
-
-	// Overwrite the class, controller should not reconcile it back
-	createClass(features.GatewayAPIDefaultGatewayClass, "different-controller")
-	expectClass(features.GatewayAPIDefaultGatewayClass, "different-controller")
-
-	// Once we delete it, it should be added back
-	deleteClass(features.GatewayAPIDefaultGatewayClass)
-	expectClass(features.GatewayAPIDefaultGatewayClass, features.ManagedGatewayController)
-
-	// Create an unrelated GatewayClass, we should not do anything to it
-	createClass("something-else", "different-controller")
-	expectClass("something-else", "different-controller")
-	deleteClass("something-else")
-	expectClass("something-else", "")
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/leak_test.go b/internal/kgateway/agentgatewaysyncer/gateway/leak_test.go
deleted file mode 100644
index b47fbbea2..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/leak_test.go
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"testing"
-
-	"istio.io/istio/tests/util/leak"
-)
-
-func TestMain(m *testing.M) {
-	leak.CheckMain(m)
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/model.go b/internal/kgateway/agentgatewaysyncer/gateway/model.go
index 84952b395..64ba6082c 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/model.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/model.go
@@ -1,68 +1,33 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 package gateway
 
 import (
-	"bytes"
 	"cmp"
+	"encoding/json"
 	"fmt"
 	"maps"
 	"reflect"
 	"slices"
 	"sort"
 	"strings"
-	"sync"
 	"time"
 
 	"github.com/agentgateway/agentgateway/go/api"
 	udpa "github.com/cncf/xds/go/udpa/type/v1"
-	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	gogoproto "github.com/gogo/protobuf/proto"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/reflect/protoreflect"
 	"google.golang.org/protobuf/types/known/structpb"
-	"istio.io/api/label"
-	"istio.io/istio/pilot/pkg/credentials"
-	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pilot/pkg/trustbundle"
-	"istio.io/istio/pilot/pkg/util/protoconv"
-	v3 "istio.io/istio/pilot/pkg/xds/v3"
-	"istio.io/istio/pkg/cluster"
-	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/mesh"
-	"istio.io/istio/pkg/config/mesh/meshwatcher"
-	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/kube/kubetypes"
-	"istio.io/istio/pkg/network"
-	"istio.io/istio/pkg/spiffe"
-	"istio.io/istio/pkg/util/gogoprotomarshal"
-	"istio.io/istio/pkg/util/identifier"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/schema/kind"
+	pm "istio.io/istio/pkg/model"
+	"istio.io/istio/pkg/util/hash"
+	netutil "istio.io/istio/pkg/util/net"
 	"istio.io/istio/pkg/util/protomarshal"
-	"istio.io/istio/pkg/xds"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/utils/ptr"
-
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/host"
-	"istio.io/istio/pkg/config/schema/collection"
-	"istio.io/istio/pkg/config/schema/kind"
-	"istio.io/istio/pkg/util/hash"
-	netutil "istio.io/istio/pkg/util/net"
-	"istio.io/istio/pkg/util/sets"
 )
 
 // Statically link protobuf descriptors from UDPA
@@ -93,105 +58,6 @@ func (key ConfigKey) String() string {
 	return key.Kind.String() + "/" + key.Namespace + "/" + key.Name
 }
 
-// ConfigsOfKind extracts configs of the specified kind.
-func ConfigsOfKind(configs sets.Set[ConfigKey], kind kind.Kind) sets.Set[ConfigKey] {
-	ret := make(sets.Set[ConfigKey])
-
-	for conf := range configs {
-		if conf.Kind == kind {
-			ret.Insert(conf)
-		}
-	}
-
-	return ret
-}
-
-// HasConfigsOfKind returns true if configs has changes of type kind
-func HasConfigsOfKind(configs sets.Set[ConfigKey], kind kind.Kind) bool {
-	for c := range configs {
-		if c.Kind == kind {
-			return true
-		}
-	}
-	return false
-}
-
-// ConfigNamesOfKind extracts config names of the specified kind.
-func ConfigNamesOfKind(configs sets.Set[ConfigKey], kind kind.Kind) sets.String {
-	ret := sets.New[string]()
-
-	for conf := range configs {
-		if conf.Kind == kind {
-			ret.Insert(conf.Name)
-		}
-	}
-
-	return ret
-}
-
-// ConfigStore describes a set of platform agnostic APIs that must be supported
-// by the underlying platform to store and retrieve Istio configuration.
-//
-// Configuration key is defined to be a combination of the type, name, and
-// namespace of the configuration object. The configuration key is guaranteed
-// to be unique in the store.
-//
-// The storage interface presented here assumes that the underlying storage
-// layer supports _Get_ (list), _Update_ (update), _Create_ (create) and
-// _Delete_ semantics but does not guarantee any transactional semantics.
-//
-// _Update_, _Create_, and _Delete_ are mutator operations. These operations
-// are asynchronous, and you might not see the effect immediately (e.g. _Get_
-// might not return the object by key immediately after you mutate the store.)
-// Intermittent errors might occur even though the operation succeeds, so you
-// should always check if the object store has been modified even if the
-// mutating operation returns an error.  Objects should be created with
-// _Create_ operation and updated with _Update_ operation.
-//
-// Resource versions record the last mutation operation on each object. If a
-// mutation is applied to a different revision of an object than what the
-// underlying storage expects as defined by pure equality, the operation is
-// blocked.  The client of this interface should not make assumptions about the
-// structure or ordering of the revision identifier.
-//
-// Object references supplied and returned from this interface should be
-// treated as read-only. Modifying them violates thread-safety.
-type ConfigStore interface {
-	// Schemas exposes the configuration type schema known by the config store.
-	// The type schema defines the bidirectional mapping between configuration
-	// types and the protobuf encoding schema.
-	Schemas() collection.Schemas
-
-	// Get retrieves a configuration element by a type and a key
-	Get(typ GroupVersionKind, name, namespace string) *Config
-
-	// List returns objects by type and namespace.
-	// Use "" for the namespace to list across namespaces.
-	List(typ GroupVersionKind, namespace string) []Config
-
-	// Create adds a new configuration object to the store. If an object with the
-	// same name and namespace for the type already exists, the operation fails
-	// with no side effects.
-	Create(config Config) (revision string, err error)
-
-	// Update modifies an existing configuration object in the store.  Update
-	// requires that the object has been created.  Resource version prevents
-	// overriding a value that has been changed between prior _Get_ and _Put_
-	// operation to achieve optimistic concurrency. This method returns a new
-	// revision if the operation succeeds.
-	Update(config Config) (newRevision string, err error)
-	UpdateStatus(config Config) (newRevision string, err error)
-
-	// Patch applies only the modifications made in the PatchFunc rather than doing a full replace. Useful to avoid
-	// read-modify-write conflicts when there are many concurrent-writers to the same resource.
-	Patch(orig Config, patchFn PatchFunc) (string, error)
-
-	// Delete removes an object from the store by key
-	// For k8s, resourceVersion must be fulfilled before a deletion is carried out.
-	// If not possible, a 409 Conflict status will be returned.
-	Delete(typ GroupVersionKind, name, namespace string, resourceVersion *string) error
-}
-
 // ResolveShortnameToFQDN uses metadata information to resolve a reference
 // to shortname of the service to FQDN
 func ResolveShortnameToFQDN(hostname string, meta Meta) host.Name {
@@ -261,7 +127,7 @@ func resolveGatewayName(gwname string, meta Meta) string {
 }
 
 // MostSpecificHostMatch compares the maps of specific and wildcard hosts to the needle, and returns the longest element
-// matching the needle and it's value, or false if no element in the maps matches the needle.
+// matching the needle, and it's value, or false if no element in the maps matches the needle.
 func MostSpecificHostMatch[V any](needle host.Name, specific map[host.Name]V, wildcard map[host.Name]V) (host.Name, V, bool) {
 	if needle.IsWildCarded() {
 		// exact match first
@@ -342,470 +208,6 @@ const (
 	Dual = pm.Dual
 )
 
-var _ mesh.Holder = &Environment{}
-
-func NewEnvironment() *Environment {
-	var cache XdsCache
-	if features.EnableXDSCaching {
-		cache = NewXdsCache()
-	} else {
-		cache = DisabledCache{}
-	}
-	return &Environment{
-		pushContext:   NewPushContext(),
-		Cache:         cache,
-		EndpointIndex: NewEndpointIndex(cache),
-	}
-}
-
-// Watcher is a type alias to keep the embedded type name stable.
-type Watcher = meshwatcher.WatcherCollection
-
-// Environment provides an aggregate environmental API for Pilot
-type Environment struct {
-	// Discovery interface for listing services and instances.
-	ServiceDiscovery
-
-	// Config interface for listing routing rules
-	ConfigStore
-
-	// Watcher is the watcher for the mesh config (to be merged into the config store)
-	Watcher
-
-	// NetworksWatcher (loaded from a config map) provides information about the
-	// set of networks inside a mesh and how to route to endpoints in each
-	// network. Each network provides information about the endpoints in a
-	// routable L3 network. A single routable L3 network can have one or more
-	// service registries.
-	NetworksWatcher mesh.NetworksWatcher
-
-	NetworkManager *NetworkManager
-
-	// mutex used for protecting Environment.pushContext
-	mutex sync.RWMutex
-	// pushContext holds information during push generation. It is reset on config change, at the beginning
-	// of the pushAll. It will hold all errors and stats and possibly caches needed during the entire cache computation.
-	// DO NOT USE EXCEPT FOR TESTS AND HANDLING OF NEW CONNECTIONS.
-	// ALL USE DURING A PUSH SHOULD USE THE ONE CREATED AT THE
-	// START OF THE PUSH, THE GLOBAL ONE MAY CHANGE AND REFLECT A DIFFERENT
-	// CONFIG AND PUSH
-	pushContext *PushContext
-
-	// DomainSuffix provides a default domain for the Istio server.
-	DomainSuffix string
-
-	// TrustBundle: List of Mesh TrustAnchors
-	TrustBundle *trustbundle.TrustBundle
-
-	clusterLocalServices ClusterLocalProvider
-
-	CredentialsController credentials.MulticlusterController
-
-	GatewayAPIController GatewayController
-
-	// EndpointShards for a service. This is a global (per-server) list, built from
-	// incremental updates. This is keyed by service and namespace
-	EndpointIndex *EndpointIndex
-
-	// Cache for XDS resources.
-	Cache XdsCache
-}
-
-func (e *Environment) Mesh() *meshMeshConfig {
-	if e != nil && e.Watcher != nil {
-		return e.Watcher.Mesh()
-	}
-	return nil
-}
-
-func (e *Environment) MeshNetworks() *meshMeshNetworks {
-	if e != nil && e.NetworksWatcher != nil {
-		return e.NetworksWatcher.Networks()
-	}
-	return nil
-}
-
-// SetPushContext sets the push context with lock protected
-func (e *Environment) SetPushContext(pc *PushContext) {
-	e.mutex.Lock()
-	defer e.mutex.Unlock()
-	e.pushContext = pc
-}
-
-// PushContext returns the push context with lock protected
-func (e *Environment) PushContext() *PushContext {
-	e.mutex.RLock()
-	defer e.mutex.RUnlock()
-	return e.pushContext
-}
-
-// GetDiscoveryAddress parses the DiscoveryAddress specified via Mesh
-func (e *Environment) GetDiscoveryAddress() (host.Name, string, error) {
-	proxyConfig := mesh.DefaultProxyConfig()
-	if e.Mesh().DefaultConfig != nil {
-		proxyConfig = e.Mesh().DefaultConfig
-	}
-	hostname, port, err := net.SplitHostPort(proxyDiscoveryAddress)
-	if err != nil {
-		return "", "", fmt.Errorf("invalid Istiod Address: %s, %v", proxyDiscoveryAddress, err)
-	}
-	if _, err := strconv.Atoi(port); err != nil {
-		return "", "", fmt.Errorf("invalid Istiod Port: %s, %s, %v", port, proxyDiscoveryAddress, err)
-	}
-	return host.Name(hostname), port, nil
-}
-
-func (e *Environment) AddMeshHandler(h func()) {
-	if e != nil && e.Watcher != nil {
-		e.Watcher.AddMeshHandler(h)
-	}
-}
-
-func (e *Environment) AddNetworksHandler(h func()) {
-	if e != nil && e.NetworksWatcher != nil {
-		e.NetworksWatcher.AddNetworksHandler(h)
-	}
-}
-
-func (e *Environment) AddMetric(metric monitoring.Metric, key string, proxyID, msg string) {
-	if e != nil {
-		e.PushContext().AddMetric(metric, key, proxyID, msg)
-	}
-}
-
-// Init initializes the Environment for use.
-func (e *Environment) Init() {
-	// Use a default DomainSuffix, if none was provided.
-	if len(e.DomainSuffix) == 0 {
-		e.DomainSuffix = constants.DefaultClusterLocalDomain
-	}
-
-	// Create the cluster-local service registry.
-	e.clusterLocalServices = NewClusterLocalProvider(e)
-}
-
-func (e *Environment) InitNetworksManager(updater XDSUpdater) (err error) {
-	e.NetworkManager, err = NewNetworkManager(e, updater)
-	return
-}
-
-func (e *Environment) ClusterLocal() ClusterLocalProvider {
-	return e.clusterLocalServices
-}
-
-func (e *Environment) GetProxyConfigOrDefault(ns string, labels, annotations map[string]string, meshConfig *meshMeshConfig) *meshProxyConfig {
-	push := e.PushContext()
-	if push != nil && push.ProxyConfigs != nil {
-		if generatedProxyConfig := push.ProxyConfigs.EffectiveProxyConfig(
-			&NodeMetadata{
-				Namespace:   ns,
-				Labels:      labels,
-				Annotations: annotations,
-			}, meshConfig); generatedProxyConfig != nil {
-			return generatedProxyConfig
-		}
-	}
-	return mesh.DefaultProxyConfig()
-}
-
-// Resources is an alias for array of marshaled resources.
-type Resources = []*discovery.Resource
-
-// DeletedResources is an alias for array of strings that represent removed resources in delta.
-type DeletedResources = []string
-
-func AnyToUnnamedResources(r []*anypb.Any) Resources {
-	a := make(Resources, 0, len(r))
-	for _, rr := range r {
-		a = append(a, &discovery.Resource{Resource: rr})
-	}
-	return a
-}
-
-// XdsUpdates include information about the subset of updated resources.
-// See for example EDS incremental updates.
-type XdsUpdates = sets.Set[ConfigKey]
-
-// XdsLogDetails contains additional metadata that is captured by Generators and used by xds processors
-// like Ads and Delta to uniformly log.
-type XdsLogDetails struct {
-	Incremental    bool
-	AdditionalInfo string
-}
-
-var DefaultXdsLogDetails = XdsLogDetails{}
-
-// XdsResourceGenerator creates the response for a typeURL DiscoveryRequest or DeltaDiscoveryRequest. If no generator
-// is associated with a Proxy, the default (a networking.core.ConfigGenerator instance) will be used.
-// The server may associate a different generator based on client metadata. Different
-// WatchedResources may use same or different Generator.
-// Note: any errors returned will completely close the XDS stream. Use with caution; typically and empty
-// or no response is preferred.
-type XdsResourceGenerator interface {
-	// Generate generates the Sotw resources for Xds.
-	Generate(proxy *Proxy, w *WatchedResource, req *PushRequest) (Resources, XdsLogDetails, error)
-}
-
-// XdsDeltaResourceGenerator generates Sotw and delta resources.
-type XdsDeltaResourceGenerator interface {
-	XdsResourceGenerator
-	// GenerateDeltas returns the changed and removed resources, along with whether or not delta was actually used.
-	GenerateDeltas(proxy *Proxy, req *PushRequest, w *WatchedResource) (Resources, DeletedResources, XdsLogDetails, bool, error)
-}
-
-// Proxy contains information about an specific instance of a proxy (envoy sidecar, gateway,
-// etc). The Proxy is initialized when a sidecar connects to Pilot, and populated from
-// 'node' info in the protocol as well as data extracted from registries.
-//
-// In current Istio implementation nodes use a 4-parts '~' delimited ID.
-// Type~IPAddress~ID~Domain
-type Proxy struct {
-	sync.RWMutex
-
-	// Type specifies the node type. First part of the ID.
-	Type NodeType
-
-	// IPAddresses is the IP addresses of the proxy used to identify it and its
-	// co-located service instances. Example: "10.60.1.6". In some cases, the host
-	// where the proxy and service instances reside may have more than one IP address
-	IPAddresses []string
-
-	// ID is the unique platform-specific sidecar proxy ID. For k8s it is the pod ID and
-	// namespace <podName.namespace>.
-	ID string
-
-	// Locality is the location of where Envoy proxy runs. This is extracted from
-	// the registry where possible. If the registry doesn't provide a locality for the
-	// proxy it will use the one sent via ADS that can be configured in the Envoy bootstrap
-	Locality *core.Locality
-
-	// DNSDomain defines the DNS domain suffix for short hostnames (e.g.
-	// "default.svc.cluster.local")
-	DNSDomain string
-
-	// ConfigNamespace defines the namespace where this proxy resides
-	// for the purposes of network scoping.
-	// NOTE: DO NOT USE THIS FIELD TO CONSTRUCT DNS NAMES
-	ConfigNamespace string
-
-	// Labels specifies the set of workload instance (ex: k8s pod) labels associated with this node.
-	// Labels can be different from that in Metadata because of pod labels update after startup,
-	// while NodeMetadata.Labels are set during bootstrap.
-	Labels map[string]string
-
-	// Metadata key-value pairs extending the Node identifier
-	Metadata *NodeMetadata
-
-	// the sidecarScope associated with the proxy
-	SidecarScope *SidecarScope
-
-	// the sidecarScope associated with the proxy previously
-	PrevSidecarScope *SidecarScope
-
-	// The merged gateways associated with the proxy if this is a Router
-	MergedGateway *MergedGateway
-
-	// PrevMergedGateway contains information about merged gateway associated with the proxy previously
-	PrevMergedGateway *PrevMergedGateway
-
-	// ServiceTargets contains a list of all Services associated with the proxy, contextualized for this particular proxy.
-	// These are unique to this proxy, as the port information is specific to it - while a ServicePort is shared with the
-	// service, the target port may be distinct per-endpoint. So this maintains a view specific to this proxy.
-	// ServiceTargets will maintain a list entry for each Service-port, so if we have 2 services each with 3 ports, we
-	// would have 6 entries.
-	ServiceTargets []ServiceTarget
-
-	// Istio version associated with the Proxy
-	IstioVersion *IstioVersion
-
-	// VerifiedIdentity determines whether a proxy had its identity verified. This
-	// generally occurs by JWT or mTLS authentication. This can be false when
-	// connecting over plaintext. If this is set to true, we can verify the proxy has
-	// access to ConfigNamespace namespace. However, other options such as node type
-	// are not part of an Istio identity and thus are not verified.
-	VerifiedIdentity *spiffe.Identity
-
-	// IPMode of proxy.
-	ipMode IPMode
-
-	// GlobalUnicastIP stores the global unicast IP if available, otherwise nil
-	GlobalUnicastIP string
-
-	// XdsResourceGenerator is used to generate resources for the node, based on the PushContext.
-	// If nil, the default networking/core v2 generator is used. This field can be set
-	// at connect time, based on node metadata, to trigger generation of a different style
-	// of configuration.
-	XdsResourceGenerator XdsResourceGenerator
-
-	// WatchedResources contains the list of watched resources for the proxy, keyed by the DiscoveryRequest TypeUrl.
-	WatchedResources map[string]*WatchedResource
-
-	// XdsNode is the xDS node identifier
-	XdsNode *core.Node
-
-	workloadEntryName        string
-	workloadEntryAutoCreated bool
-
-	// LastPushContext stores the most recent push context for this proxy. This will be monotonically
-	// increasing in version. Requests should send config based on this context; not the global latest.
-	// Historically, the latest was used which can cause problems when computing whether a push is
-	// required, as the computed sidecar scope version would not monotonically increase.
-	LastPushContext *PushContext
-	// LastPushTime records the time of the last push. This is used in conjunction with
-	// LastPushContext; the XDS cache depends on knowing the time of the PushContext to determine if a
-	// key is stale or not.
-	LastPushTime time.Time
-}
-
-type WatchedResource = xds.WatchedResource
-
-// GetView returns a restricted view of the mesh for this proxy. The view can be
-// restricted by network (via ISTIO_META_REQUESTED_NETWORK_VIEW).
-// If not set, we assume that the proxy wants to see endpoints in any network.
-func (node *Proxy) GetView() ProxyView {
-	return newProxyView(node)
-}
-
-// InNetwork returns true if the proxy is on the given network, or if either
-// the proxy's network or the given network is unspecified ("").
-func (node *Proxy) InNetwork(network network.ID) bool {
-	return node == nil || identifier.IsSameOrEmpty(network.String(), node.Metadata.Network.String())
-}
-
-// InCluster returns true if the proxy is in the given cluster, or if either
-// the proxy's cluster id or the given cluster id is unspecified ("").
-func (node *Proxy) InCluster(cluster cluster.ID) bool {
-	return node == nil || identifier.IsSameOrEmpty(cluster.String(), node.Metadata.ClusterID.String())
-}
-
-// IsWaypointProxy returns true if the proxy is acting as a waypoint proxy in an ambient mesh.
-func (node *Proxy) IsWaypointProxy() bool {
-	return node.Type == Waypoint
-}
-
-// IsZTunnel returns true if the proxy is acting as a ztunnel in an ambient mesh.
-func (node *Proxy) IsZTunnel() bool {
-	return node.Type == Ztunnel
-}
-
-// IsAmbient returns true if the proxy is acting as either a ztunnel or a waypoint proxy in an ambient mesh.
-func (node *Proxy) IsAmbient() bool {
-	return node.IsWaypointProxy() || node.IsZTunnel()
-}
-
-var NodeTypes = [...]NodeType{SidecarProxy, Router, Waypoint, Ztunnel}
-
-// SetGatewaysForProxy merges the Gateway objects associated with this
-// proxy and caches the merged object in the proxy Node. This is a convenience hack so that
-// callers can simply call push.MergedGateways(node) instead of having to
-// fetch all the gateways and invoke the merge call in multiple places (lds/rds).
-// Must be called after ServiceTargets are set
-func (node *Proxy) SetGatewaysForProxy(ps *PushContext) {
-	if node.Type != Router {
-		return
-	}
-	var prevMergedGateway MergedGateway
-	if node.MergedGateway != nil {
-		prevMergedGateway = *node.MergedGateway
-	}
-	node.MergedGateway = ps.mergeGateways(node)
-	node.PrevMergedGateway = &PrevMergedGateway{
-		ContainsAutoPassthroughGateways: prevMergedGateway.ContainsAutoPassthroughGateways,
-		AutoPassthroughSNIHosts:         prevMergedGateway.GetAutoPassthroughGatewaySNIHosts(),
-	}
-}
-
-func (node *Proxy) ShouldUpdateServiceTargets(updates sets.Set[ConfigKey]) bool {
-	// we only care for services which can actually select this proxy
-	for config := range updates {
-		if Kind == kind.ServiceEntry || Namespace == node.Metadata.Namespace {
-			return true
-		}
-	}
-
-	return false
-}
-
-func (node *Proxy) SetServiceTargets(serviceDiscovery ServiceDiscovery) {
-	instances := serviceDiscovery.GetProxyServiceTargets(node)
-
-	// Keep service instances in order of creation/hostname.
-	sort.SliceStable(instances, func(i, j int) bool {
-		if instances[i].Service != nil && instances[j].Service != nil {
-			if !instances[i].Service.CreationTime.Equal(instances[j].Service.CreationTime) {
-				return instances[i].Service.CreationTime.Before(instances[j].Service.CreationTime)
-			}
-			// Additionally, sort by hostname just in case services created automatically at the same second.
-			return instances[i].Service.Hostname < instances[j].Service.Hostname
-		}
-		return true
-	})
-
-	node.ServiceTargets = instances
-}
-
-// SetWorkloadLabels will set the node.Labels.
-// It merges both node meta labels and workload labels and give preference to workload labels.
-func (node *Proxy) SetWorkloadLabels(env *Environment) {
-	// If this is VM proxy, do not override labels at all, because in istio test we use pod to simulate VM.
-	if node.IsVM() {
-		node.Labels = node.Metadata.Labels
-		return
-	}
-	labels := env.GetProxyWorkloadLabels(node)
-	if labels != nil {
-		node.Labels = make(map[string]string, len(labels)+len(node.Metadata.StaticLabels))
-		// we can't just equate proxy workload labels to node meta labels as it may be customized by user
-		// with `ISTIO_METAJSON_LABELS` env (pkg/bootstrap/go extractAttributesMetadata).
-		// so, we fill the `ISTIO_METAJSON_LABELS` as well.
-		for k, v := range node.Metadata.StaticLabels {
-			node.Labels[k] = v
-		}
-		for k, v := range labels {
-			node.Labels[k] = v
-		}
-	} else {
-		// If could not find pod labels, fallback to use the node metadata labels.
-		node.Labels = node.Metadata.Labels
-	}
-}
-
-// DiscoverIPMode discovers the IP Versions supported by Proxy based on its IP addresses.
-func (node *Proxy) DiscoverIPMode() {
-	node.ipMode = pm.DiscoverIPMode(node.IPAddresses)
-	node.GlobalUnicastIP = networkutil.GlobalUnicastIP(node.IPAddresses)
-}
-
-// SupportsIPv4 returns true if proxy supports IPv4 addresses.
-func (node *Proxy) SupportsIPv4() bool {
-	return node.ipMode == IPv4 || node.ipMode == Dual
-}
-
-// SupportsIPv6 returns true if proxy supports IPv6 addresses.
-func (node *Proxy) SupportsIPv6() bool {
-	return node.ipMode == IPv6 || node.ipMode == Dual
-}
-
-// IsIPv6 returns true if proxy only supports IPv6 addresses.
-func (node *Proxy) IsIPv6() bool {
-	return node.ipMode == IPv6
-}
-
-func (node *Proxy) IsDualStack() bool {
-	return node.ipMode == Dual
-}
-
-// GetIPMode returns proxy's ipMode
-func (node *Proxy) GetIPMode() IPMode {
-	return node.ipMode
-}
-
-// SetIPMode set node's ip mode
-// Note: Donot use this function directly in most cases, use DiscoverIPMode instead.
-func (node *Proxy) SetIPMode(mode IPMode) {
-	node.ipMode = mode
-}
-
 // ParseMetadata parses the opaque Metadata from an Envoy Node into string key-value pairs.
 // Any non-string values are ignored.
 func ParseMetadata(metadata *structpb.Struct) (*NodeMetadata, error) {
@@ -837,73 +239,6 @@ func ParseBootstrapNodeMetadata(metadata *structpb.Struct) (*BootstrapNodeMetada
 	return meta, nil
 }
 
-// ParseServiceNodeWithMetadata parse the Envoy Node from the string generated by ServiceNode
-// function and the metadata.
-func ParseServiceNodeWithMetadata(nodeID string, metadata *NodeMetadata) (*Proxy, error) {
-	parts := strings.Split(nodeID, serviceNodeSeparator)
-	out := &Proxy{
-		Metadata: metadata,
-	}
-
-	if len(parts) != 4 {
-		return out, fmt.Errorf("missing parts in the service node %q", nodeID)
-	}
-
-	if !pm.IsApplicationNodeType(NodeType(parts[0])) {
-		return out, fmt.Errorf("invalid node type (valid types: %v) in the service node %q", NodeTypes, nodeID)
-	}
-	out.Type = NodeType(parts[0])
-
-	// Get all IP Addresses from Metadata
-	if hasValidIPAddresses(metadata.InstanceIPs) {
-		out.IPAddresses = metadata.InstanceIPs
-	} else if netutil.IsValidIPAddress(parts[1]) {
-		// Fall back, use IP from node id, it's only for backward-compatibility, IP should come from metadata
-		out.IPAddresses = append(out.IPAddresses, parts[1])
-	}
-
-	// Does query from ingress or router have to carry valid IP address?
-	if len(out.IPAddresses) == 0 {
-		return out, fmt.Errorf("no valid IP address in the service node id or metadata")
-	}
-
-	out.ID = parts[2]
-	out.DNSDomain = parts[3]
-	if len(metadata.IstioVersion) == 0 {
-		log.Warnf("Istio Version is not found in metadata for %v, which may have undesirable side effects", out.ID)
-	}
-	out.IstioVersion = ParseIstioVersion(metadata.IstioVersion)
-	return out, nil
-}
-
-// GetOrDefault returns either the value, or the default if the value is empty. Useful when retrieving node metadata fields.
-func GetOrDefault(s string, def string) string {
-	return pm.GetOrDefault(s, def)
-}
-
-// GetProxyConfigNamespace extracts the namespace associated with the proxy
-// from the proxy metadata or the proxy ID
-func GetProxyConfigNamespace(proxy *Proxy) string {
-	if proxy == nil {
-		return ""
-	}
-
-	// First look for ISTIO_META_CONFIG_NAMESPACE
-	// All newer proxies (from Istio 1.1 onwards) are supposed to supply this
-	if len(proxy.Metadata.Namespace) > 0 {
-		return proxy.Metadata.Namespace
-	}
-
-	// if not found, for backward compatibility, extract the namespace from
-	// the proxy domain. this is a k8s specific hack and should be enabled
-	parts := strings.Split(proxy.DNSDomain, ".")
-	if len(parts) > 1 { // k8s will have namespace.<domain>
-		return parts[0]
-	}
-
-	return ""
-}
-
 const (
 	serviceNodeSeparator = "~"
 )
@@ -933,310 +268,14 @@ const (
 	InterceptionRedirect TrafficInterceptionMode = "REDIRECT"
 )
 
-// GetInterceptionMode extracts the interception mode associated with the proxy
-// from the proxy metadata
-func (node *Proxy) GetInterceptionMode() TrafficInterceptionMode {
-	if node == nil {
-		return InterceptionRedirect
-	}
-
-	switch node.Metadata.InterceptionMode {
-	case "TPROXY":
-		return InterceptionTproxy
-	case "REDIRECT":
-		return InterceptionRedirect
-	case "NONE":
-		return InterceptionNone
-	}
-
-	return InterceptionRedirect
-}
-
-// IsUnprivileged returns true if the proxy has explicitly indicated that it is
-// unprivileged, i.e. it cannot bind to the privileged ports 1-1023.
-func (node *Proxy) IsUnprivileged() bool {
-	if node == nil || node.Metadata == nil {
-		return false
-	}
-	// expect explicit "true" value
-	unprivileged, _ := strconv.ParseBool(node.Metadata.UnprivilegedPod)
-	return unprivileged
-}
-
-// CanBindToPort returns true if the proxy can bind to a given port.
-// canbind indicates whether the proxy can bind to the port.
-// knownlistener indicates whether the check failed if the proxy is trying to bind to a port that is reserved for a static listener or virtual listener.
-func (node *Proxy) CanBindToPort(bindTo bool, proxy *Proxy, push *PushContext,
-	bind string, port int, protocol protocol.Instance, wildcard string,
-) (canbind bool, knownlistener bool) {
-	if bindTo {
-		if isPrivilegedPort(port) && node.IsUnprivileged() {
-			return false, false
-		}
-	}
-	if conflictWithReservedListener(proxy, push, bind, port, protocol, wildcard) {
-		return false, true
-	}
-	return true, false
-}
-
-// conflictWithReservedListener checks whether the listener address bind:port conflicts with
-// - static listener port：default is 15021 and 15090
-// - virtual listener port: default is 15001 and 15006 (only need to check for outbound listener)
-func conflictWithReservedListener(proxy *Proxy, push *PushContext, bind string, port int, protocol protocol.Instance, wildcard string) bool {
-	if bind != "" {
-		if bind != wildcard {
-			return false
-		}
-	} else if !protocol.IsHTTP() {
-		// if the protocol is HTTP and bind == "", the listener address will be 0.0.0.0:port
-		return false
-	}
-
-	var conflictWithStaticListener, conflictWithVirtualListener bool
-
-	// bind == wildcard
-	// or bind unspecified, but protocol is HTTP
-	if proxy.Metadata != nil {
-		conflictWithStaticListener = proxy.Metadata.EnvoyStatusPort == port || proxy.Metadata.EnvoyPrometheusPort == port
-	}
-	if push != nil {
-		conflictWithVirtualListener = int(push.Mesh.ProxyListenPort) == port || int(push.Mesh.ProxyInboundListenPort) == port
-	}
-	return conflictWithStaticListener || conflictWithVirtualListener
-}
-
-// isPrivilegedPort returns true if a given port is in the range 1-1023.
-func isPrivilegedPort(port int) bool {
-	// check for 0 is important because:
-	// 1) technically, 0 is not a privileged port; any process can ask to bind to 0
-	// 2) this function will be receiving 0 on input in the case of UDS listeners
-	return 0 < port && port < 1024
-}
-
-func (node *Proxy) IsVM() bool {
-	// TODO use node metadata to indicate that this is a VM instead of the TestVMLabel
-	return node.Metadata.Labels[constants.TestVMLabel] != ""
-}
-
-func (node *Proxy) IsProxylessGrpc() bool {
-	return node.Metadata != nil && node.Metadata.Generator == "grpc"
-}
-
-func (node *Proxy) GetNodeName() string {
-	if node.Metadata != nil && len(node.Metadata.NodeName) > 0 {
-		return node.Metadata.NodeName
-	}
-	return ""
-}
-
-func (node *Proxy) GetClusterID() cluster.ID {
-	if node == nil || node.Metadata == nil {
-		return ""
-	}
-	return node.Metadata.ClusterID
-}
-
-func (node *Proxy) GetNamespace() string {
-	if node == nil || node.Metadata == nil {
-		return ""
-	}
-	return node.Metadata.Namespace
-}
-
-func (node *Proxy) GetID() string {
-	if node == nil {
-		return ""
-	}
-	return node.ID
-}
-
-func (node *Proxy) FuzzValidate() bool {
-	if node.Metadata == nil {
-		return false
-	}
-	found := false
-	for _, t := range NodeTypes {
-		if node.Type == t {
-			found = true
-			break
-		}
-	}
-	if !found {
-		return false
-	}
-	return len(node.IPAddresses) != 0
-}
-
-func (node *Proxy) EnableHBONEListen() bool {
-	return node.IsAmbient() || (features.EnableSidecarHBONEListening && bool(node.Metadata.EnableHBONE))
-}
-
-func (node *Proxy) SetWorkloadEntry(name string, create bool) {
-	node.Lock()
-	defer node.Unlock()
-	node.workloadEntryName = name
-	node.workloadEntryAutoCreated = create
-}
-
-func (node *Proxy) WorkloadEntry() (string, bool) {
-	node.RLock()
-	defer node.RUnlock()
-	return node.workloadEntryName, node.workloadEntryAutoCreated
-}
-
-// ShallowCloneWatchedResources clones the watched resources, both the keys and values are shallow copy.
-func (node *Proxy) ShallowCloneWatchedResources() map[string]*WatchedResource {
-	node.RLock()
-	defer node.RUnlock()
-	return maps.Clone(node.WatchedResources)
-}
-
-// DeepCloneWatchedResources clones the watched resources
-func (node *Proxy) DeepCloneWatchedResources() map[string]WatchedResource {
-	node.RLock()
-	defer node.RUnlock()
-	m := make(map[string]WatchedResource, len(node.WatchedResources))
-	for k, v := range node.WatchedResources {
-		m[k] = *v
-	}
-	return m
-}
-
-func (node *Proxy) GetWatchedResourceTypes() sets.String {
-	node.RLock()
-	defer node.RUnlock()
-
-	ret := sets.NewWithLength[string](len(node.WatchedResources))
-	for typeURL := range node.WatchedResources {
-		ret.Insert(typeURL)
-	}
-	return ret
-}
-
-func (node *Proxy) GetWatchedResource(typeURL string) *WatchedResource {
-	node.RLock()
-	defer node.RUnlock()
-
-	return node.WatchedResources[typeURL]
-}
-
-func (node *Proxy) NonceSent(typeURL string) string {
-	node.RLock()
-	defer node.RUnlock()
-
-	wr := node.WatchedResources[typeURL]
-	if wr != nil {
-		return wr.NonceSent
-	}
-	return ""
-}
-
-func (node *Proxy) NonceAcked(typeURL string) string {
-	node.RLock()
-	defer node.RUnlock()
-
-	wr := node.WatchedResources[typeURL]
-	if wr != nil {
-		return wr.NonceAcked
-	}
-	return ""
-}
-
-func (node *Proxy) Clusters() []string {
-	node.RLock()
-	defer node.RUnlock()
-	wr := node.WatchedResources[v3.EndpointType]
-	if wr != nil {
-		return wr.ResourceNames.UnsortedList()
-	}
-	return nil
-}
-
-func (node *Proxy) NewWatchedResource(typeURL string, names []string) {
-	node.Lock()
-	defer node.Unlock()
-
-	node.WatchedResources[typeURL] = &WatchedResource{TypeUrl: typeURL, ResourceNames: sets.New(names...)}
-	// For all EDS requests that we have already responded with in the same stream let us
-	// force the response. It is important to respond to those requests for Envoy to finish
-	// warming of those resources(Clusters).
-	// This can happen with the following sequence
-	// 1. Envoy disconnects and reconnects to Istiod.
-	// 2. Envoy sends EDS request and we respond with it.
-	// 3. Envoy sends CDS request and we respond with clusters.
-	// 4. Envoy detects a change in cluster state and tries to warm those clusters and send EDS request for them.
-	// 5. We should respond to the EDS request with Endpoints to let Envoy finish cluster warming.
-	// Refer to https://github.com/envoyproxy/envoy/issues/13009 for more details.
-	for _, dependent := range WarmingDependencies(typeURL) {
-		if dwr, exists := node.WatchedResources[dependent]; exists {
-			dwr.AlwaysRespond = true
-		}
-	}
-}
-
-// WarmingDependencies returns the dependent typeURLs that need to be responded with
-// for warming of this typeURL.
-func WarmingDependencies(typeURL string) []string {
-	switch typeURL {
-	case v3.ClusterType:
-		return []string{v3.EndpointType}
-	default:
-		return nil
-	}
-}
-
-func (node *Proxy) AddOrUpdateWatchedResource(r *WatchedResource) {
-	if r == nil {
-		return
-	}
-	node.Lock()
-	defer node.Unlock()
-	node.WatchedResources[r.TypeUrl] = r
-}
-
-func (node *Proxy) UpdateWatchedResource(typeURL string, updateFn func(*WatchedResource) *WatchedResource) {
-	node.Lock()
-	defer node.Unlock()
-	r := node.WatchedResources[typeURL]
-	r = updateFn(r)
-	if r != nil {
-		node.WatchedResources[typeURL] = r
-	} else {
-		delete(node.WatchedResources, typeURL)
-	}
-}
-
-func (node *Proxy) DeleteWatchedResource(typeURL string) {
-	node.Lock()
-	defer node.Unlock()
-
-	delete(node.WatchedResources, typeURL)
-}
-
-type GatewayController interface {
-	ConfigStoreController
-	// Reconcile updates the internal state of the gateway controller for a given input. This should be
-	// called before any List/Get calls if the state has changed
-	Reconcile(ctx *PushContext)
-	// SecretAllowed determines if a SDS credential is accessible to a given namespace.
-	// For example, for resourceName of `kubernetes-gateway://ns-name/secret-name` and namespace of `ingress-ns`,
-	// this would return true only if there was a policy allowing `ingress-ns` to access Secrets in the `ns-name` namespace.
-	SecretAllowed(resourceName string, namespace string) bool
-	Collection() krt.Collection[ADPResource]
-}
-
-// OutboundListenerClass is a helper to turn a NodeType for outbound to a ListenerClass.
-func OutboundListenerClass(t NodeType) istionetworking.ListenerClass {
-	if t == Router {
-		return istionetworking.ListenerClassGateway
-	}
-	return istionetworking.ListenerClassSidecarOutbound
-}
-
 type ADPResource struct {
 	Resource *api.Resource        `json:"resource"`
 	Gateway  types.NamespacedName `json:"gateway"`
+
+	// TODO: separate addresses?
+	Address *api.Address `json:"address"`
+
+	reports reports.ReportMap
 }
 
 func (g ADPResource) ResourceName() string {
@@ -1255,51 +294,6 @@ func (g ADPResource) Equals(other ADPResource) bool {
 	return proto.Equal(g.Resource, other.Resource) && g.Gateway == other.Gateway
 }
 
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package config
-
-import (
-"bytes"
-"encoding/json"
-"fmt"
-"reflect"
-"time"
-
-gogojsonpb "github.com/gogo/protobuf/jsonpb" // nolint: depguard
-gogoproto "github.com/gogo/protobuf/proto"   // nolint: depguard
-gogotypes "github.com/gogo/protobuf/types"   // nolint: depguard
-"google.golang.org/protobuf/proto"
-"google.golang.org/protobuf/reflect/protoreflect"
-"google.golang.org/protobuf/types/known/anypb"
-"google.golang.org/protobuf/types/known/structpb"
-metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-"k8s.io/apimachinery/pkg/runtime/schema"
-kubetypes "k8s.io/apimachinery/pkg/types"
-"sigs.k8s.io/yaml"
-
-"istio.io/api/label"
-"istio.io/istio/pilot/pkg/util/protoconv"
-"istio.io/istio/pkg/maps"
-"istio.io/istio/pkg/ptr"
-"istio.io/istio/pkg/slices"
-"istio.io/istio/pkg/util/gogoprotomarshal"
-"istio.io/istio/pkg/util/protomarshal"
-"istio.io/istio/pkg/util/sets"
-)
-
 // Meta is metadata attached to each configuration unit.
 // The revision is optional, and if provided, identifies the
 // last update operation on the object.
@@ -1367,32 +361,21 @@ type Config struct {
 	Status Status
 }
 
-func LabelsInRevision(lbls map[string]string, rev string) bool {
-	configEnv, f := lbls[label.IoIstioRev.Name]
-	if !f {
-		// This is a global object, and always included
-		return true
-	}
-	// If the revision is empty, this means we don't specify a revision, and
-	// we should always include it
-	if rev == "" {
-		return true
-	}
-	// Otherwise, only return true if revisions equal
-	return configEnv == rev
+type Namer interface {
+	GetName() string
+	GetNamespace() string
 }
 
-func LabelsInRevisionOrTags(lbls map[string]string, rev string, tags sets.Set[string]) bool {
-	if LabelsInRevision(lbls, rev) {
-		return true
-	}
-	configEnv := lbls[label.IoIstioRev.Name]
-	// Otherwise, only return true if revisions equal
-	return tags.Contains(configEnv)
+type TypedResource struct {
+	Kind schema.GroupVersionKind
+	Name types.NamespacedName
 }
 
-func ObjectInRevision(o *Config, rev string) bool {
-	return LabelsInRevision(o.Labels, rev)
+func NamespacedName[T Namer](o T) types.NamespacedName {
+	return types.NamespacedName{
+		Namespace: o.GetNamespace(),
+		Name:      o.GetName(),
+	}
 }
 
 // Spec defines the spec for the  In order to use below helper methods,
@@ -1402,191 +385,6 @@ func ObjectInRevision(o *Config, rev string) bool {
 // * Able to marshal/unmarshal using json
 type Spec any
 
-func ToProto(s Spec) (*anypb.Any, error) {
-	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
-	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
-	// but also not used by Istio at all.
-	if pb, ok := s.(protoreflect.ProtoMessage); ok {
-		return protoconv.MessageToAnyWithError(pb)
-	}
-
-	// gogo protobuf
-	if pb, ok := s.(gogoproto.Message); ok {
-		gogoany, err := gogotypes.MarshalAny(pb)
-		if err != nil {
-			return nil, err
-		}
-		return &anypb.Any{
-			TypeUrl: gogoany.TypeUrl,
-			Value:   gogoany.Value,
-		}, nil
-	}
-
-	js, err := json.Marshal(s)
-	if err != nil {
-		return nil, err
-	}
-	pbs := &structpb.Struct{}
-	if err := protomarshal.Unmarshal(js, pbs); err != nil {
-		return nil, err
-	}
-	return protoconv.MessageToAnyWithError(pbs)
-}
-
-func ToMap(s Spec) (map[string]any, error) {
-	js, err := ToJSON(s)
-	if err != nil {
-		return nil, err
-	}
-
-	// Unmarshal from json bytes to go map
-	var data map[string]any
-	err = json.Unmarshal(js, &data)
-	if err != nil {
-		return nil, err
-	}
-
-	return data, nil
-}
-
-func ToRaw(s Spec) (json.RawMessage, error) {
-	js, err := ToJSON(s)
-	if err != nil {
-		return nil, err
-	}
-
-	// Unmarshal from json bytes to go map
-	return js, nil
-}
-
-func ToJSON(s Spec) ([]byte, error) {
-	return toJSON(s, false)
-}
-
-func ToPrettyJSON(s Spec) ([]byte, error) {
-	return toJSON(s, true)
-}
-
-func toJSON(s Spec, pretty bool) ([]byte, error) {
-	indent := ""
-	if pretty {
-		indent = "    "
-	}
-
-	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
-	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
-	// but also not used by Istio at all.
-	if _, ok := s.(protoreflect.ProtoMessage); ok {
-		if pb, ok := s.(proto.Message); ok {
-			b, err := protomarshal.MarshalIndent(pb, indent)
-			return b, err
-		}
-	}
-
-	b := &bytes.Buffer{}
-	// gogo protobuf
-	if pb, ok := s.(gogoproto.Message); ok {
-		err := (&gogojsonpb.Marshaler{Indent: indent}).Marshal(b, pb)
-		return b.Bytes(), err
-	}
-	if pretty {
-		return json.MarshalIndent(s, "", indent)
-	}
-	return json.Marshal(s)
-}
-
-type deepCopier interface {
-	DeepCopyInterface() any
-}
-
-func ApplyYAML(s Spec, yml string) error {
-	js, err := yaml.YAMLToJSON([]byte(yml))
-	if err != nil {
-		return err
-	}
-	return ApplyJSON(s, string(js))
-}
-
-func ApplyJSONStrict(s Spec, js string) error {
-	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
-	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
-	// but also not used by Istio at all.
-	if _, ok := s.(protoreflect.ProtoMessage); ok {
-		if pb, ok := s.(proto.Message); ok {
-			err := protomarshal.ApplyJSONStrict(js, pb)
-			return err
-		}
-	}
-
-	// gogo protobuf
-	if pb, ok := s.(gogoproto.Message); ok {
-		err := gogoprotomarshal.ApplyJSONStrict(js, pb)
-		return err
-	}
-
-	d := json.NewDecoder(bytes.NewReader([]byte(js)))
-	d.DisallowUnknownFields()
-	return d.Decode(&s)
-}
-
-func ApplyJSON(s Spec, js string) error {
-	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
-	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
-	// but also not used by Istio at all.
-	if _, ok := s.(protoreflect.ProtoMessage); ok {
-		if pb, ok := s.(proto.Message); ok {
-			err := protomarshal.ApplyJSON(js, pb)
-			return err
-		}
-	}
-
-	// gogo protobuf
-	if pb, ok := s.(gogoproto.Message); ok {
-		err := gogoprotomarshal.ApplyJSON(js, pb)
-		return err
-	}
-
-	return json.Unmarshal([]byte(js), &s)
-}
-
-func DeepCopy(s any) any {
-	if s == nil {
-		return nil
-	}
-	// If deep copy is defined, use that
-	if dc, ok := s.(deepCopier); ok {
-		return dc.DeepCopyInterface()
-	}
-
-	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
-	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
-	// but also not used by Istio at all.
-	if _, ok := s.(protoreflect.ProtoMessage); ok {
-		if pb, ok := s.(proto.Message); ok {
-			return protomarshal.Clone(pb)
-		}
-	}
-
-	// gogo protobuf
-	if pb, ok := s.(gogoproto.Message); ok {
-		return gogoproto.Clone(pb)
-	}
-
-	// If we don't have a deep copy method, we will have to do some reflection magic. Its not ideal,
-	// but all Istio types have an efficient deep copy.
-	js, err := json.Marshal(s)
-	if err != nil {
-		return nil
-	}
-
-	data := reflect.New(reflect.TypeOf(s)).Interface()
-	if err := json.Unmarshal(js, data); err != nil {
-		return nil
-	}
-	data = reflect.ValueOf(data).Elem().Interface()
-	return data
-}
-
 func (c *Config) Equals(other *Config) bool {
 	am, bm := c.Meta, other.Meta
 	if am.GroupVersionKind != bm.GroupVersionKind {
@@ -1681,7 +479,7 @@ func (meta *Meta) ToObjectMeta() metav1.ObjectMeta {
 	return metav1.ObjectMeta{
 		Name:              meta.Name,
 		Namespace:         meta.Namespace,
-		UID:               kubetypes.UID(meta.UID),
+		UID:               types.UID(meta.UID),
 		ResourceVersion:   meta.ResourceVersion,
 		Generation:        meta.Generation,
 		CreationTimestamp: metav1.NewTime(meta.CreationTimestamp),
@@ -1703,6 +501,48 @@ func (c Config) DeepCopy() Config {
 	return clone
 }
 
+type deepCopier interface {
+	DeepCopyInterface() any
+}
+
+func DeepCopy(s any) any {
+	if s == nil {
+		return nil
+	}
+	// If deep copy is defined, use that
+	if dc, ok := s.(deepCopier); ok {
+		return dc.DeepCopyInterface()
+	}
+
+	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
+	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
+	// but also not used by Istio at all.
+	if _, ok := s.(protoreflect.ProtoMessage); ok {
+		if pb, ok := s.(proto.Message); ok {
+			return protomarshal.Clone(pb)
+		}
+	}
+
+	// gogo protobuf
+	if pb, ok := s.(gogoproto.Message); ok {
+		return gogoproto.Clone(pb)
+	}
+
+	// If we don't have a deep copy method, we will have to do some reflection magic. Its not ideal,
+	// but all Istio types have an efficient deep copy.
+	js, err := json.Marshal(s)
+	if err != nil {
+		return nil
+	}
+
+	data := reflect.New(reflect.TypeOf(s)).Interface()
+	if err := json.Unmarshal(js, data); err != nil {
+		return nil
+	}
+	data = reflect.ValueOf(data).Elem().Interface()
+	return data
+}
+
 func (c Config) GetName() string {
 	return c.Name
 }
@@ -1715,8 +555,8 @@ func (c Config) GetCreationTimestamp() time.Time {
 	return c.CreationTimestamp
 }
 
-func (c Config) NamespacedName() kubetypes.NamespacedName {
-	return kubetypes.NamespacedName{
+func (c Config) NamespacedName() types.NamespacedName {
+	return types.NamespacedName{
 		Namespace: c.Namespace,
 		Name:      c.Name,
 	}
@@ -1772,19 +612,27 @@ func (g GroupVersionKind) CanonicalGroup() string {
 	return CanonicalGroup(g.Group)
 }
 
-// PatchFunc provides the cached config as a base for modification. Only diff the between the cfg
-// parameter and the returned Config will be applied.
-type PatchFunc func(cfg Config) (Config, kubetypes.PatchType)
+type Index[K comparable, O any] interface {
+	Lookup(k K) []O
+	// AsCollection(opts ...CollectionOption) Collection[IndexObject[K, O]]
+	objectHasKey(obj O, k K) bool
+	extractKeys(o O) []K
+	LookupCount(k K) int
+}
 
-type Namer interface {
-	GetName() string
-	GetNamespace() string
+type IndexObject[K comparable, O any] struct {
+	Key     K
+	Objects []O
 }
 
-func NamespacedName[T Namer](o T) kubetypes.NamespacedName {
-	return kubetypes.NamespacedName{
-		Namespace: o.GetNamespace(),
-		Name:      o.GetName(),
-	}
+func (i IndexObject[K, O]) ResourceName() string {
+	return toString(i.Key)
 }
 
+func toString(rk any) string {
+	tk, ok := rk.(string)
+	if !ok {
+		return rk.(fmt.Stringer).String()
+	}
+	return tk
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go b/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
index 14cb43abe..bb8ef79b4 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
@@ -17,6 +17,7 @@ package gateway
 import (
 	"fmt"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"k8s.io/apimachinery/pkg/types"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
@@ -49,7 +50,7 @@ type ReferenceGrants struct {
 	index      krt.Index[ReferencePair, ReferenceGrant]
 }
 
-func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.ReferenceGrant], opts krt.OptionsBuilder) krt.Collection[ReferenceGrant] {
+func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.ReferenceGrant], krtopts krtutil.KrtOptions) krt.Collection[ReferenceGrant] {
 	return krt.NewManyCollection(referenceGrants, func(ctx krt.HandlerContext, obj *gateway.ReferenceGrant) []ReferenceGrant {
 		rp := obj.Spec
 		results := make([]ReferenceGrant, 0, len(rp.From)*len(rp.To))
@@ -99,7 +100,7 @@ func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.Reference
 			}
 		}
 		return results
-	}, opts.WithName("ReferenceGrants")...)
+	}, krtopts.ToOptions("ReferenceGrants")...)
 }
 
 func BuildReferenceGrants(collection krt.Collection[ReferenceGrant]) ReferenceGrants {
@@ -130,7 +131,7 @@ func (g ReferenceGrant) ResourceName() string {
 func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName string, namespace string) bool {
 	p, err := creds.ParseResourceName(resourceName, "", "", "")
 	if err != nil {
-		log.Warnf("failed to parse resource name %q: %v", resourceName, err)
+		logger.Warn("failed to parse resource name", "resourceName", resourceName, "error", err)
 		return false
 	}
 	from := Reference{Kind: gvk.KubernetesGateway, Namespace: gateway.Namespace(namespace)}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go b/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
index 89fa45a38..6f1a0d22c 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
@@ -1,17 +1,3 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
 package gateway
 
 import (
@@ -19,7 +5,10 @@ import (
 	"iter"
 	"strings"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
@@ -42,9 +31,9 @@ import (
 func HTTPRouteCollection(
 	httpRoutes krt.Collection[*gateway.HTTPRoute],
 	inputs RouteContextInputs,
-	opts krt.OptionsBuilder,
+	krtopts krtutil.KrtOptions,
 ) RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, httpRoutes, gvk.HTTPRoute, opts)
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, httpRoutes, wellknown.HTTPRouteGVK, krtopts)
 	baseVirtualServices := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []RouteWithKey {
 		ctx := inputs.WithCtx(krtctx)
 		route := obj.Spec
@@ -110,9 +99,9 @@ func HTTPRouteCollection(
 			}
 		}
 		return virtualServices
-	}, opts.WithName("HTTPRoute")...)
+	}, krtopts.ToOptions("HTTPRoute")...)
 
-	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, opts.WithName("HTTPRouteMerged")...)
+	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, krtopts.ToOptions("HTTPRouteMerged")...)
 	return RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus]{
 		VirtualServices:  finalVirtualServices,
 		RouteAttachments: routeCount,
@@ -122,7 +111,7 @@ func HTTPRouteCollection(
 func ADPRouteCollection(
 	httpRoutes krt.Collection[*gateway.HTTPRoute],
 	inputs RouteContextInputs,
-	opts krt.OptionsBuilder,
+	krtopts krtutil.KrtOptions,
 ) krt.Collection[ADPResource] {
 	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []ADPResource {
 		ctx := inputs.WithCtx(krtctx)
@@ -169,7 +158,7 @@ func ADPRouteCollection(
 			})...)
 		}
 		return res
-	}, opts.WithName("ADPRoutes")...)
+	}, krtopts.ToOptions("ADPRoutes")...)
 
 	return routes
 }
@@ -485,8 +474,8 @@ func (r *RouteAttachment) Equals(other RouteAttachment) bool {
 func gatewayRouteAttachmentCountCollection[T controllers.Object](
 	inputs RouteContextInputs,
 	col krt.Collection[T],
-	kind config.GroupVersionKind,
-	opts krt.OptionsBuilder,
+	kind schema.GroupVersionKind,
+	krtopts krtutil.KrtOptions,
 ) krt.Collection[*RouteAttachment] {
 	return krt.NewManyCollection(col, func(krtctx krt.HandlerContext, obj T) []*RouteAttachment {
 		ctx := inputs.WithCtx(krtctx)
@@ -497,7 +486,7 @@ func gatewayRouteAttachmentCountCollection[T controllers.Object](
 
 		parentRefs := extractParentReferenceInfo(ctx, inputs.RouteParents, obj)
 		return slices.MapFilter(filteredReferences(parentRefs), func(e routeParentReference) **RouteAttachment {
-			if e.ParentKey.Kind != gvk.KubernetesGateway {
+			if e.ParentKey.Kind != wellknown.GatewayGVK {
 				return nil
 			}
 			return ptr.Of(&RouteAttachment{
@@ -509,7 +498,7 @@ func gatewayRouteAttachmentCountCollection[T controllers.Object](
 				ListenerName: string(e.ParentSection),
 			})
 		})
-	}, opts.WithName(kind.Kind+"/count")...)
+	}, krtopts.ToOptions(kind.Kind+"/count")...)
 }
 
 // mergeHTTPRoutes merges HTTProutes by key. Gateway API has semantics for the ordering of `match` rules, that merges across resource.
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/service.go b/internal/kgateway/agentgatewaysyncer/gateway/service.go
new file mode 100644
index 000000000..b475c075f
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/gateway/service.go
@@ -0,0 +1,1452 @@
+package gateway
+
+import (
+	"bytes"
+	"fmt"
+	"net/netip"
+	"sort"
+	"strconv"
+	"strings"
+	"sync"
+	"time"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/types/known/anypb"
+	"k8s.io/apimachinery/pkg/types"
+
+	"istio.io/api/label"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/serviceregistry/provider"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/labels"
+	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/maps"
+	pm "istio.io/istio/pkg/model"
+	"istio.io/istio/pkg/network"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/protomarshal"
+	"istio.io/istio/pkg/util/sets"
+)
+
+// Service describes an Istio service (e.g., catalog.mystore.com:8080)
+// Each service has a fully qualified domain name (FQDN) and one or more
+// ports where the service is listening for connections. *Optionally*, a
+// service can have a single load balancer/virtual IP address associated
+// with it, such that the DNS queries for the FQDN resolves to the virtual
+// IP address (a load balancer IP).
+//
+// E.g., in kubernetes, a service foo is associated with
+// foo.default.svc.cluster.local hostname, has a virtual IP of 10.0.1.1 and
+// listens on ports 80, 8080
+type Service struct {
+	// Attributes contains additional attributes associated with the service
+	// used mostly by RBAC for policy enforcement purposes.
+	Attributes ServiceAttributes
+
+	// Ports is the set of network ports where the service is listening for
+	// connections
+	Ports PortList `json:"ports,omitempty"`
+
+	// ServiceAccounts specifies the service accounts that run the service.
+	ServiceAccounts []string `json:"serviceAccounts,omitempty"`
+
+	// CreationTime records the time this service was created, if available.
+	CreationTime time.Time `json:"creationTime,omitempty"`
+
+	// Name of the service, e.g. "catalog.mystore.com"
+	Hostname host.Name `json:"hostname"`
+
+	// ClusterVIPs specifies the service address of the load balancer
+	// in each of the clusters where the service resides
+	ClusterVIPs AddressMap `json:"clusterVIPs,omitempty"`
+
+	// DefaultAddress specifies the default service IP of the load balancer.
+	// Do not access directly. Use GetAddressForProxy
+	DefaultAddress string `json:"defaultAddress,omitempty"`
+
+	// AutoAllocatedIPv4Address and AutoAllocatedIPv6Address specifies
+	// the automatically allocated IPv4/IPv6 address out of the reserved
+	// Class E subnet (240.240.0.0/16) or reserved Benchmarking IP range
+	// (2001:2::/48) in RFC5180.for service entries with non-wildcard
+	// hostnames. The IPs assigned to services are not
+	// synchronized across istiod replicas as the DNS resolution
+	// for these service entries happens completely inside a pod
+	// whose proxy is managed by one istiod. That said, the algorithm
+	// to allocate IPs is pretty deterministic that at stable state, two
+	// istiods will allocate the exact same set of IPs for a given set of
+	// service entries.
+	AutoAllocatedIPv4Address string `json:"autoAllocatedIPv4Address,omitempty"`
+	AutoAllocatedIPv6Address string `json:"autoAllocatedIPv6Address,omitempty"`
+
+	// Resolution indicates how the service instances need to be resolved before routing
+	// traffic. Most services in the service registry will use static load balancing wherein
+	// the proxy will decide the service instance that will receive the traffic. Service entries
+	// could either use DNS load balancing (i.e. proxy will query DNS server for the IP of the service)
+	// or use the passthrough model (i.e. proxy will forward the traffic to the network endpoint requested
+	// by the caller)
+	Resolution Resolution
+
+	// MeshExternal (if true) indicates that the service is external to the mesh.
+	// These services are defined using Istio's ServiceEntry spec.
+	MeshExternal bool
+
+	// ResourceVersion represents the internal version of this object.
+	ResourceVersion string
+}
+
+func (s *Service) NamespacedName() types.NamespacedName {
+	return types.NamespacedName{Name: s.Attributes.Name, Namespace: s.Attributes.Namespace}
+}
+
+func (s *Service) Key() string {
+	if s == nil {
+		return ""
+	}
+
+	return s.Attributes.Namespace + "/" + string(s.Hostname)
+}
+
+var serviceCmpOpts = []cmp.Option{cmpopts.IgnoreFields(AddressMap{}, "mutex")}
+
+func (s *Service) CmpOpts() []cmp.Option {
+	return serviceCmpOpts
+}
+
+func (s *Service) SupportsDrainingEndpoints() bool {
+	return (features.PersistentSessionLabel != "" && s.Attributes.Labels[features.PersistentSessionLabel] != "") ||
+		(features.PersistentSessionHeaderLabel != "" && s.Attributes.Labels[features.PersistentSessionHeaderLabel] != "")
+}
+
+// SupportsUnhealthyEndpoints marks if this service should send unhealthy endpoints
+func (s *Service) SupportsUnhealthyEndpoints() bool {
+	if features.GlobalSendUnhealthyEndpoints.Load() {
+		// Enable process-wide
+		return true
+	}
+	if s != nil && s.Attributes.TrafficDistribution != TrafficDistributionAny {
+		// When we are doing location aware routing, we need some way to indicate if endpoints are healthy, otherwise we don't
+		// know when to spill over to other zones.
+		// For the older DestinationRule localityLB, we do this by requiring outlier detection.
+		// If they use the newer Kubernetes-native TrafficDistribution we don't want to require an Istio-specific outlier rule,
+		// and instead will use endpoint health which requires sending unhealthy endpoints.
+		return true
+	}
+	return false
+}
+
+// Resolution indicates how the service instances need to be resolved before routing traffic.
+type Resolution int
+
+const (
+	// ClientSideLB implies that the proxy will decide the endpoint from its local lb pool
+	ClientSideLB Resolution = iota
+	// DNSLB implies that the proxy will resolve a DNS address and forward to the resolved address
+	DNSLB
+	// Passthrough implies that the proxy should forward traffic to the destination IP requested by the caller
+	Passthrough
+	// DNSRoundRobinLB implies that the proxy will resolve a DNS address and forward to the resolved address
+	DNSRoundRobinLB
+	// Alias defines a Service that is an alias for another.
+	Alias
+)
+
+// String converts Resolution in to String.
+func (resolution Resolution) String() string {
+	switch resolution {
+	case ClientSideLB:
+		return "ClientSide"
+	case DNSLB:
+		return "DNS"
+	case DNSRoundRobinLB:
+		return "DNSRoundRobin"
+	case Passthrough:
+		return "Passthrough"
+	default:
+		return fmt.Sprintf("%d", int(resolution))
+	}
+}
+
+const (
+	// LocalityLabel indicates the region/zone/subzone of an instance. It is used to override the native
+	// registry's value.
+	//
+	// Note: because k8s labels does not support `/`, so we use `.` instead in k8s.
+	LocalityLabel = pm.LocalityLabel
+)
+
+const (
+	// TunnelLabel defines the label workloads describe to indicate that they support tunneling.
+	// Values are expected to be a CSV list, sorted by preference, of protocols supported.
+	// Currently supported values:
+	// * "http": indicates tunneling over HTTP over TCP. HTTP/2 vs HTTP/1.1 may be supported by ALPN negotiation.
+	// Planned future values:
+	// * "http3": indicates tunneling over HTTP over QUIC. This is distinct from "http", since we cannot do ALPN
+	//   negotiation for QUIC vs TCP.
+	// Users should appropriately parse the full list rather than doing a string literal check to
+	// ensure future-proofing against new protocols being added.
+	TunnelLabel = "networking.istio.io/tunnel"
+	// TunnelLabelShortName is a short name for TunnelLabel to be used in optimized scenarios.
+	TunnelLabelShortName = "tunnel"
+	// TunnelHTTP indicates tunneling over HTTP over TCP. HTTP/2 vs HTTP/1.1 may be supported by ALPN
+	// negotiation. Note: ALPN negotiation is not currently implemented; HTTP/2 will always be used.
+	// This is future-proofed, however, because only the `h2` ALPN is exposed.
+	TunnelHTTP = "http"
+)
+
+const (
+	// TLSModeLabelShortname name used for determining endpoint level tls transport socket configuration
+	TLSModeLabelShortname = "tlsMode"
+
+	// DisabledTLSModeLabel implies that this endpoint should receive traffic as is (mostly plaintext)
+	DisabledTLSModeLabel = "disabled"
+
+	// IstioMutualTLSModeLabel implies that the endpoint is ready to receive Istio mTLS connections.
+	IstioMutualTLSModeLabel = "istio"
+
+	// IstioCanonicalServiceLabelName is the name of label for the Istio Canonical Service for a workload instance.
+	IstioCanonicalServiceLabelName = pm.IstioCanonicalServiceLabelName
+
+	// IstioCanonicalServiceRevisionLabelName is the name of label for the Istio Canonical Service revision for a workload instance.
+	IstioCanonicalServiceRevisionLabelName = pm.IstioCanonicalServiceRevisionLabelName
+)
+
+func SupportsTunnel(labels map[string]string, tunnelType string) bool {
+	tl, f := labels[TunnelLabel]
+	if !f {
+		return false
+	}
+	if tl == tunnelType {
+		// Fast-path the case where we have only one label
+		return true
+	}
+	// Else check everything. Tunnel label is a comma-separated list.
+	return sets.New(strings.Split(tl, ",")...).Contains(tunnelType)
+}
+
+// Port represents a network port where a service is listening for
+// connections. The port should be annotated with the type of protocol
+// used by the port.
+type Port struct {
+	// Name ascribes a human readable name for the port object. When a
+	// service has multiple ports, the name field is mandatory
+	Name string `json:"name,omitempty"`
+
+	// Port number where the service can be reached. Does not necessarily
+	// map to the corresponding port numbers for the instances behind the
+	// service.
+	Port int `json:"port"`
+
+	// Protocol to be used for the port.
+	Protocol protocol.Instance `json:"protocol,omitempty"`
+}
+
+func (p Port) String() string {
+	return fmt.Sprintf("Name:%s Port:%d Protocol:%v", p.Name, p.Port, p.Protocol)
+}
+
+// PortList is a set of ports
+type PortList []*Port
+
+// TrafficDirection defines whether traffic exists a service instance or enters a service instance
+type TrafficDirection string
+
+const (
+	// TrafficDirectionInbound indicates inbound traffic
+	TrafficDirectionInbound TrafficDirection = "inbound"
+	// TrafficDirectionInboundVIP indicates inbound traffic for vip
+	TrafficDirectionInboundVIP TrafficDirection = "inbound-vip"
+	// TrafficDirectionOutbound indicates outbound traffic
+	TrafficDirectionOutbound TrafficDirection = "outbound"
+
+	// trafficDirectionOutboundSrvPrefix the prefix for a DNS SRV type subset key
+	trafficDirectionOutboundSrvPrefix = string(TrafficDirectionOutbound) + "_"
+	// trafficDirectionInboundSrvPrefix the prefix for a DNS SRV type subset key
+	trafficDirectionInboundSrvPrefix = string(TrafficDirectionInbound) + "_"
+)
+
+// ServiceInstance represents an individual instance of a specific version
+// of a service. It binds a network endpoint (ip:port), the service
+// description (which is oblivious to various versions) and a set of labels
+// that describe the service version associated with this instance.
+//
+// Since a ServiceInstance has a single IstioEndpoint, which has a single port,
+// multiple ServiceInstances are required to represent a workload that listens
+// on multiple ports.
+//
+// The labels associated with a service instance are unique per a network endpoint.
+// There is one well defined set of labels for each service instance network endpoint.
+//
+// For example, the set of service instances associated with catalog.mystore.com
+// are modeled like this
+//
+//	--> IstioEndpoint(172.16.0.1:8888), Service(catalog.myservice.com), Labels(foo=bar)
+//	--> IstioEndpoint(172.16.0.2:8888), Service(catalog.myservice.com), Labels(foo=bar)
+//	--> IstioEndpoint(172.16.0.3:8888), Service(catalog.myservice.com), Labels(kitty=cat)
+//	--> IstioEndpoint(172.16.0.4:8888), Service(catalog.myservice.com), Labels(kitty=cat)
+type ServiceInstance struct {
+	Service     *Service       `json:"service,omitempty"`
+	ServicePort *Port          `json:"servicePort,omitempty"`
+	Endpoint    *IstioEndpoint `json:"endpoint,omitempty"`
+}
+
+func (instance *ServiceInstance) CmpOpts() []cmp.Option {
+	res := []cmp.Option{}
+	res = append(res, serviceCmpOpts...)
+	return res
+}
+
+// ServiceTarget includes a Service object, along with a specific service port
+// and target port. This is basically a smaller version of ServiceInstance,
+// intended to avoid the need to have the full object when only port information
+// is needed.
+type ServiceTarget struct {
+	Service *Service
+	Port    ServiceInstancePort
+}
+
+type (
+	ServicePort = *Port
+	// ServiceInstancePort defines a port that has both a port and targetPort (which distinguishes it from model.Port)
+	// Note: ServiceInstancePort only makes sense in the context of a specific ServiceInstance, because TargetPort depends on a specific instance.
+	ServiceInstancePort struct {
+		ServicePort
+		TargetPort uint32
+	}
+)
+
+func ServiceInstanceToTarget(e *ServiceInstance) ServiceTarget {
+	return ServiceTarget{
+		Service: e.Service,
+		Port: ServiceInstancePort{
+			ServicePort: e.ServicePort,
+			TargetPort:  e.Endpoint.EndpointPort,
+		},
+	}
+}
+
+// DeepCopy creates a copy of ServiceInstance.
+func (instance *ServiceInstance) DeepCopy() *ServiceInstance {
+	return &ServiceInstance{
+		Service:  instance.Service.DeepCopy(),
+		Endpoint: instance.Endpoint.DeepCopy(),
+		ServicePort: &Port{
+			Name:     instance.ServicePort.Name,
+			Port:     instance.ServicePort.Port,
+			Protocol: instance.ServicePort.Protocol,
+		},
+	}
+}
+
+type workloadKind int
+
+const (
+	// PodKind indicates the workload is from pod
+	PodKind workloadKind = iota
+	// WorkloadEntryKind indicates the workload is from workloadentry
+	WorkloadEntryKind
+)
+
+func (k workloadKind) String() string {
+	if k == PodKind {
+		return "Pod"
+	}
+
+	if k == WorkloadEntryKind {
+		return "WorkloadEntry"
+	}
+	return ""
+}
+
+type WorkloadInstance struct {
+	Name      string `json:"name,omitempty"`
+	Namespace string `json:"namespace,omitempty"`
+	// Where the workloadInstance come from, valid values are`Pod` or `WorkloadEntry`
+	Kind     workloadKind      `json:"kind"`
+	Endpoint *IstioEndpoint    `json:"endpoint,omitempty"`
+	PortMap  map[string]uint32 `json:"portMap,omitempty"`
+	// Can only be selected by service entry of DNS type.
+	DNSServiceEntryOnly bool `json:"dnsServiceEntryOnly,omitempty"`
+}
+
+// DeepCopy creates a copy of WorkloadInstance.
+func (instance *WorkloadInstance) DeepCopy() *WorkloadInstance {
+	out := *instance
+	out.PortMap = maps.Clone(instance.PortMap)
+	out.Endpoint = instance.Endpoint.DeepCopy()
+	return &out
+}
+
+// WorkloadInstancesEqual is a custom comparison of workload instances based on the fields that we need.
+// Returns true if equal, false otherwise.
+func WorkloadInstancesEqual(first, second *WorkloadInstance) bool {
+	if first.Endpoint == nil || second.Endpoint == nil {
+		return first.Endpoint == second.Endpoint
+	}
+
+	if !slices.EqualUnordered(first.Endpoint.Addresses, second.Endpoint.Addresses) {
+		return false
+	}
+
+	if first.Endpoint.Network != second.Endpoint.Network {
+		return false
+	}
+	if first.Endpoint.TLSMode != second.Endpoint.TLSMode {
+		return false
+	}
+	if !first.Endpoint.Labels.Equals(second.Endpoint.Labels) {
+		return false
+	}
+	if first.Endpoint.ServiceAccount != second.Endpoint.ServiceAccount {
+		return false
+	}
+	if first.Endpoint.Locality != second.Endpoint.Locality {
+		return false
+	}
+	if first.Endpoint.GetLoadBalancingWeight() != second.Endpoint.GetLoadBalancingWeight() {
+		return false
+	}
+	if first.Namespace != second.Namespace {
+		return false
+	}
+	if first.Name != second.Name {
+		return false
+	}
+	if first.Kind != second.Kind {
+		return false
+	}
+	if !maps.Equal(first.PortMap, second.PortMap) {
+		return false
+	}
+	return true
+}
+
+// GetLocalityLabel returns the locality from the supplied label. Because Kubernetes
+// labels don't support `/`, we replace "." with "/" in the supplied label as a workaround.
+func GetLocalityLabel(label string) string {
+	return pm.GetLocalityLabel(label)
+}
+
+// Locality information for an IstioEndpoint
+type Locality struct {
+	// Label for locality on the endpoint. This is a "/" separated string.
+	Label string
+
+	// ClusterID where the endpoint is located
+	ClusterID cluster.ID
+}
+
+// HealthStatus indicates the status of the Endpoint.
+type HealthStatus int32
+
+const (
+	// Healthy indicates an endpoint is ready to accept traffic
+	Healthy HealthStatus = 1
+	// UnHealthy indicates an endpoint is not ready to accept traffic
+	UnHealthy HealthStatus = 2
+	// Draining is a special case, which is used only when persistent sessions are enabled. This indicates an endpoint
+	// was previously healthy, but is now shutting down.
+	// Without persistent sessions, an endpoint that is shutting down will be marked as Terminating.
+	Draining HealthStatus = 3
+	// Terminating marks an endpoint as shutting down. Similar to "unhealthy", this means we should not send it traffic.
+	// But unlike "unhealthy", this means we do not consider it when calculating failover.
+	Terminating HealthStatus = 4
+)
+
+// IstioEndpoint defines a network address (IP:port) associated with an instance of the
+// service. A service has one or more instances each running in a
+// container/VM/pod. If a service has multiple ports, then the same
+// instance IP is expected to be listening on multiple ports (one per each
+// service port). Note that the port associated with an instance does not
+// have to be the same as the port associated with the service. Depending
+// on the network setup (NAT, overlays), this could vary.
+//
+// For e.g., if catalog.mystore.com is accessible through port 80 and 8080,
+// and it maps to an instance with IP 172.16.0.1, such that connections to
+// port 80 are forwarded to port 55446, and connections to port 8080 are
+// forwarded to port 33333,
+//
+// then internally, we have two endpoint structs for the
+// service catalog.mystore.com
+//
+//	--> 172.16.0.1:55446 (with ServicePort pointing to 80) and
+//	--> 172.16.0.1:33333 (with ServicePort pointing to 8080)
+type IstioEndpoint struct {
+	// Labels points to the workload or deployment labels.
+	Labels labels.Instance
+
+	// Addresses are the addresses of the endpoint, using envoy proto:
+	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/endpoint/v3/endpoint_components.proto#config-endpoint-v3-endpoint-additionaladdress
+	// This field can support multiple addresses for an Dual Stack endpoint, especially for an endpoint which contains both ipv4 or ipv6 addresses.
+	// There should be some constraints below:
+	// 1. Each address of the endpoint must have the same metadata.
+	// 2. The function Key() of IstioEndpoint returns the first IP address of this field in string format.
+	// 3. The IP address of field `address` in Envoy Endpoint is equal to the first address of this field.
+	// When the additional_addresses field is populated for EDS in Envoy configuration, Envoy will use an Happy Eyeballs algorithm.
+	// Therefore Envoy will first attempt connecting to the IP address in the `address` field of Envoy Endpoint.
+	// If the first attempt fails, then it will interleave IP addresses in the `additional_addresses` field based on IP version, as described in rfc8305,
+	// and attempt connections with them with a delay of 300ms each. The first connection to succeed will be used.
+	// Note: it uses Hash Based Load Balancing Policies for multiple addresses support Endpoint, and only the first address of the
+	// endpoint will be used as the hash key for the ring or maglev list, however, the upstream address that load balancer ends up
+	// connecting to will depend on the one that ends up "winning" using the Happy Eyeballs algorithm.
+	// Please refer to https://docs.google.com/document/d/1AjmTcMWwb7nia4rAgqE-iqIbSbfiXCI4h1vk-FONFdM/ for more details.
+	Addresses []string
+
+	// ServicePortName tracks the name of the port, this is used to select the IstioEndpoint by service port.
+	ServicePortName string
+	// LegacyClusterPortKey provides an alternative key from ServicePortName to support legacy quirks in the API.
+	// Basically, EDS merges by port name, but CDS historically ignored port name and matched on number.
+	// Note that for Kubernetes Service, this is identical - its only ServiceEntry where these checks can differ
+	LegacyClusterPortKey int
+
+	// ServiceAccount holds the associated service account.
+	ServiceAccount string
+
+	// Network holds the network where this endpoint is present
+	Network network.ID
+
+	// The locality where the endpoint is present.
+	Locality Locality
+
+	// EndpointPort is the port where the workload is listening, can be different
+	// from the service port.
+	EndpointPort uint32
+
+	// The load balancing weight associated with this endpoint.
+	LbWeight uint32
+
+	// TLSMode endpoint is injected with istio sidecar and ready to configure Istio mTLS
+	TLSMode string
+
+	// Namespace that this endpoint belongs to. This is for telemetry purpose.
+	Namespace string
+
+	// Name of the workload that this endpoint belongs to. This is for telemetry purpose.
+	WorkloadName string
+
+	// Specifies the hostname of the Pod, empty for vm workload.
+	HostName string
+
+	// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
+	SubDomain string
+
+	// Indicates the endpoint health status.
+	HealthStatus HealthStatus
+
+	// SendUnhealthyEndpoints indicates whether this endpoint should be sent when it is unhealthy
+	// Note: this is more appropriate at the Service level, but some codepaths require this in areas without the service
+	// object present.
+	SendUnhealthyEndpoints bool
+
+	// If in k8s, the node where the pod resides
+	NodeName string
+}
+
+func (ep *IstioEndpoint) SupportsTunnel(tunnelType string) bool {
+	return SupportsTunnel(ep.Labels, tunnelType)
+}
+
+// GetLoadBalancingWeight returns the weight for this endpoint, normalized to always be > 0.
+func (ep *IstioEndpoint) GetLoadBalancingWeight() uint32 {
+	if ep.LbWeight > 0 {
+		return ep.LbWeight
+	}
+	return 1
+}
+
+// MetadataClone returns the cloned endpoint metadata used for telemetry purposes.
+// This should be used when the endpoint labels should be updated.
+func (ep *IstioEndpoint) MetadataClone() *EndpointMetadata {
+	return &EndpointMetadata{
+		Network:      ep.Network,
+		TLSMode:      ep.TLSMode,
+		WorkloadName: ep.WorkloadName,
+		Namespace:    ep.Namespace,
+		Labels:       maps.Clone(ep.Labels),
+		ClusterID:    ep.Locality.ClusterID,
+	}
+}
+
+// Metadata returns the endpoint metadata used for telemetry purposes.
+func (ep *IstioEndpoint) Metadata() *EndpointMetadata {
+	return &EndpointMetadata{
+		Network:      ep.Network,
+		TLSMode:      ep.TLSMode,
+		WorkloadName: ep.WorkloadName,
+		Namespace:    ep.Namespace,
+		Labels:       ep.Labels,
+		ClusterID:    ep.Locality.ClusterID,
+	}
+}
+
+func (ep *IstioEndpoint) FirstAddressOrNil() string {
+	if ep == nil || len(ep.Addresses) == 0 {
+		return ""
+	}
+	return ep.Addresses[0]
+}
+
+// Key returns a function suitable for usage to distinguish this IstioEndpoint from another
+func (ep *IstioEndpoint) Key() string {
+	return ep.FirstAddressOrNil() + "/" + ep.WorkloadName + "/" + ep.ServicePortName
+}
+
+// EndpointMetadata represents metadata set on Envoy LbEndpoint used for telemetry purposes.
+type EndpointMetadata struct {
+	// Network holds the network where this endpoint is present
+	Network network.ID
+
+	// TLSMode endpoint is injected with istio sidecar and ready to configure Istio mTLS
+	TLSMode string
+
+	// Name of the workload that this endpoint belongs to. This is for telemetry purpose.
+	WorkloadName string
+
+	// Namespace that this endpoint belongs to. This is for telemetry purpose.
+	Namespace string
+
+	// Labels points to the workload or deployment labels.
+	Labels labels.Instance
+
+	// ClusterID where the endpoint is located
+	ClusterID cluster.ID
+}
+
+// ServiceAttributes represents a group of custom attributes of the service.
+type ServiceAttributes struct {
+	// ServiceRegistry indicates the backing service registry system where this service
+	// was sourced from.
+	// TODO: move the ServiceRegistry type from platform.go to model
+	ServiceRegistry provider.ID
+	// Name is "destination.service.name" attribute
+	Name string
+	// Namespace is "destination.service.namespace" attribute
+	Namespace string
+	// Labels applied to the service
+	Labels map[string]string
+	// ExportTo defines the visibility of Service in
+	// a namespace when the namespace is imported.
+	ExportTo sets.Set[visibility.Instance]
+
+	// LabelSelectors are the labels used by the service to select workloads.
+	// Applicable to both Kubernetes and ServiceEntries.
+	LabelSelectors map[string]string
+
+	// Aliases is the resolved set of aliases for this service. This is computed based on a global view of all Service's `AliasFor`
+	// fields.
+	// For example, if I had two Services with `externalName: foo`, "a" and "b", then the "foo" service would have Aliases=[a,b].
+	Aliases []NamespacedHostname
+
+	// For Kubernetes platform
+
+	// ClusterExternalAddresses is a mapping between a cluster name and the external
+	// address(es) to access the service from outside the cluster.
+	// Used by the aggregator to aggregate the Attributes.ClusterExternalAddresses
+	// for clusters where the service resides
+	ClusterExternalAddresses *AddressMap
+
+	// ClusterExternalPorts is a mapping between a cluster name and the service port
+	// to node port mappings for a given service. When accessing the service via
+	// node port IPs, we need to use the kubernetes assigned node ports of the service
+	// The port that the user provides in the meshNetworks config is the service port.
+	// We translate that to the appropriate node port here.
+	ClusterExternalPorts map[cluster.ID]map[uint32]uint32
+
+	PassthroughTargetPorts map[uint32]uint32
+
+	K8sAttributes
+}
+
+type NamespacedHostname struct {
+	Hostname  host.Name
+	Namespace string
+}
+
+type K8sAttributes struct {
+	// Type holds the value of the corev1.Type of the Kubernetes service
+	// spec.Type
+	Type string
+
+	// spec.ExternalName
+	ExternalName string
+
+	// NodeLocal means the proxy will only forward traffic to node local endpoints
+	// spec.InternalTrafficPolicy == Local
+	NodeLocal bool
+
+	// TrafficDistribution determines the service-level traffic distribution.
+	// This may be overridden by locality load balancing settings.
+	TrafficDistribution TrafficDistribution
+
+	// ObjectName is the object name of the underlying object. This may differ from the Service.Attributes.Name for legacy semantics.
+	ObjectName string
+
+	// spec.PublishNotReadyAddresses
+	PublishNotReadyAddresses bool
+}
+
+type TrafficDistribution int
+
+const (
+	// TrafficDistributionAny allows any destination
+	TrafficDistributionAny TrafficDistribution = iota
+	// TrafficDistributionPreferClose prefers traffic in same region/zone/network if possible, with failover allowed.
+	TrafficDistributionPreferClose TrafficDistribution = iota
+)
+
+// DeepCopy creates a deep copy of ServiceAttributes, but skips internal mutexes.
+func (s *ServiceAttributes) DeepCopy() ServiceAttributes {
+	// AddressMap contains a mutex, which is safe to copy in this case.
+	// nolint: govet
+	out := *s
+
+	out.Labels = maps.Clone(s.Labels)
+	if s.ExportTo != nil {
+		out.ExportTo = s.ExportTo.Copy()
+	}
+
+	out.LabelSelectors = maps.Clone(s.LabelSelectors)
+	out.ClusterExternalAddresses = s.ClusterExternalAddresses.DeepCopy()
+
+	if s.ClusterExternalPorts != nil {
+		out.ClusterExternalPorts = make(map[cluster.ID]map[uint32]uint32, len(s.ClusterExternalPorts))
+		for k, m := range s.ClusterExternalPorts {
+			out.ClusterExternalPorts[k] = maps.Clone(m)
+		}
+	}
+
+	out.Aliases = slices.Clone(s.Aliases)
+	out.PassthroughTargetPorts = maps.Clone(out.PassthroughTargetPorts)
+
+	// AddressMap contains a mutex, which is safe to return a copy in this case.
+	// nolint: govet
+	return out
+}
+
+// Equals checks whether the attributes are equal from the passed in service.
+func (s *ServiceAttributes) Equals(other *ServiceAttributes) bool {
+	if s == nil {
+		return other == nil
+	}
+	if other == nil {
+		return s == nil
+	}
+
+	if !maps.Equal(s.Labels, other.Labels) {
+		return false
+	}
+
+	if !maps.Equal(s.LabelSelectors, other.LabelSelectors) {
+		return false
+	}
+
+	if !maps.Equal(s.ExportTo, other.ExportTo) {
+		return false
+	}
+
+	if !slices.Equal(s.Aliases, other.Aliases) {
+		return false
+	}
+
+	if s.ClusterExternalAddresses.Len() != other.ClusterExternalAddresses.Len() {
+		return false
+	}
+
+	for k, v1 := range s.ClusterExternalAddresses.GetAddresses() {
+		if v2, ok := other.ClusterExternalAddresses.Addresses[k]; !ok || !slices.Equal(v1, v2) {
+			return false
+		}
+	}
+
+	if len(s.ClusterExternalPorts) != len(other.ClusterExternalPorts) {
+		return false
+	}
+
+	for k, v1 := range s.ClusterExternalPorts {
+		if v2, ok := s.ClusterExternalPorts[k]; !ok || !maps.Equal(v1, v2) {
+			return false
+		}
+	}
+	return s.Name == other.Name && s.Namespace == other.Namespace &&
+		s.ServiceRegistry == other.ServiceRegistry && s.K8sAttributes == other.K8sAttributes
+}
+
+type AddressInfo struct {
+	*api.Address
+	Marshaled *anypb.Any
+}
+
+func (i AddressInfo) Equals(other AddressInfo) bool {
+	return protoconv.Equals(i.Address, other.Address)
+}
+
+func (i AddressInfo) Aliases() []string {
+	switch addr := i.Type.(type) {
+	case *api.Address_Workload:
+		aliases := make([]string, 0, len(addr.Workload.Addresses))
+		network := addr.Workload.Network
+		for _, workloadAddr := range addr.Workload.Addresses {
+			ip, _ := netip.AddrFromSlice(workloadAddr)
+			aliases = append(aliases, network+"/"+ip.String())
+		}
+		return aliases
+	case *api.Address_Service:
+		aliases := make([]string, 0, len(addr.Service.Addresses))
+		for _, networkAddr := range addr.Service.Addresses {
+			ip, _ := netip.AddrFromSlice(networkAddr.Address)
+			aliases = append(aliases, networkAddr.Network+"/"+ip.String())
+		}
+		return aliases
+	}
+	return nil
+}
+
+func (i AddressInfo) ResourceName() string {
+	var name string
+	switch addr := i.Type.(type) {
+	case *api.Address_Workload:
+		name = workloadResourceName(addr.Workload)
+	case *api.Address_Service:
+		name = serviceResourceName(addr.Service)
+	}
+	return name
+}
+
+type TypedObject struct {
+	types.NamespacedName
+	Kind kind.Kind
+}
+
+type ServicePortName struct {
+	PortName       string
+	TargetPortName string
+}
+
+type ServiceInfo struct {
+	Service *api.Service
+	// LabelSelectors for the Service. Note these are only used internally, not sent over XDS
+	LabelSelector LabelSelector
+	// PortNames provides a mapping of ServicePort -> port names. Note these are only used internally, not sent over XDS
+	PortNames map[int32]ServicePortName
+	// Source is the type that introduced this service.
+	Source TypedObject
+	// MarshaledAddress contains the pre-marshaled representation.
+	// Note: this is an Address -- not a Service.
+	MarshaledAddress *anypb.Any
+	// AsAddress contains a pre-created AddressInfo representation. This ensures we do not need repeated conversions on
+	// the hotpath
+	AsAddress AddressInfo
+}
+
+func (i ServiceInfo) GetLabelSelector() map[string]string {
+	return i.LabelSelector.Labels
+}
+
+func (i ServiceInfo) GetStatusTarget() TypedObject {
+	return i.Source
+}
+
+type StatusMessage struct {
+	Reason  string
+	Message string
+}
+
+func (i ServiceInfo) NamespacedName() types.NamespacedName {
+	return types.NamespacedName{Name: i.Service.Name, Namespace: i.Service.Namespace}
+}
+
+func (i ServiceInfo) GetNamespace() string {
+	return i.Service.Namespace
+}
+
+func (i ServiceInfo) Equals(other ServiceInfo) bool {
+	return equalUsingPremarshaled(i.Service, i.MarshaledAddress, other.Service, other.MarshaledAddress) &&
+		maps.Equal(i.LabelSelector.Labels, other.LabelSelector.Labels) &&
+		maps.Equal(i.PortNames, other.PortNames) &&
+		i.Source == other.Source
+}
+
+func (i ServiceInfo) ResourceName() string {
+	return serviceResourceName(i.Service)
+}
+
+func serviceResourceName(s *api.Service) string {
+	return s.Namespace + "/" + s.Hostname
+}
+
+type WorkloadInfo struct {
+	Workload *api.Workload
+	// Labels for the workload. Note these are only used internally, not sent over XDS
+	Labels map[string]string
+	// Source is the type that introduced this workload.
+	Source kind.Kind
+	// CreationTime is the time when the workload was created. Note this is used internally only.
+	CreationTime time.Time
+	// MarshaledAddress contains the pre-marshaled representation.
+	// Note: this is an Address -- not a Workload.
+	MarshaledAddress *anypb.Any
+	// AsAddress contains a pre-created AddressInfo representation. This ensures we do not need repeated conversions on
+	// the hotpath
+	AsAddress AddressInfo
+}
+
+func (i WorkloadInfo) Equals(other WorkloadInfo) bool {
+	return equalUsingPremarshaled(i.Workload, i.MarshaledAddress, other.Workload, other.MarshaledAddress) &&
+		maps.Equal(i.Labels, other.Labels) &&
+		i.Source == other.Source &&
+		i.CreationTime == other.CreationTime
+}
+
+func workloadResourceName(w *api.Workload) string {
+	return w.Uid
+}
+
+func (i *WorkloadInfo) Clone() *WorkloadInfo {
+	return &WorkloadInfo{
+		Workload:     protomarshal.Clone(i.Workload),
+		Labels:       maps.Clone(i.Labels),
+		Source:       i.Source,
+		CreationTime: i.CreationTime,
+	}
+}
+
+func (i WorkloadInfo) ResourceName() string {
+	return workloadResourceName(i.Workload)
+}
+
+type LabelSelector struct {
+	Labels map[string]string
+}
+
+func NewSelector(l map[string]string) LabelSelector {
+	return LabelSelector{l}
+}
+
+func (l LabelSelector) GetLabelSelector() map[string]string {
+	return l.Labels
+}
+
+func ExtractWorkloadsFromAddresses(addrs []AddressInfo) []WorkloadInfo {
+	return slices.MapFilter(addrs, func(a AddressInfo) *WorkloadInfo {
+		switch addr := a.Type.(type) {
+		case *api.Address_Workload:
+			return &WorkloadInfo{Workload: addr.Workload}
+		default:
+			return nil
+		}
+	})
+}
+
+func SortWorkloadsByCreationTime(workloads []WorkloadInfo) []WorkloadInfo {
+	sort.SliceStable(workloads, func(i, j int) bool {
+		if workloads[i].CreationTime.Equal(workloads[j].CreationTime) {
+			return workloads[i].Workload.Uid < workloads[j].Workload.Uid
+		}
+		return workloads[i].CreationTime.Before(workloads[j].CreationTime)
+	})
+	return workloads
+}
+
+type NamespaceInfo struct {
+	Name               string
+	IngressUseWaypoint bool
+}
+
+func (i NamespaceInfo) ResourceName() string {
+	return i.Name
+}
+
+func (i NamespaceInfo) Equals(other NamespaceInfo) bool {
+	return i == other
+}
+
+// MCSServiceInfo combines the name of a service with a particular Kubernetes cluster. This
+// is used for debug information regarding the state of Kubernetes Multi-Cluster Services (MCS).
+type MCSServiceInfo struct {
+	Cluster         cluster.ID
+	Name            string
+	Namespace       string
+	Exported        bool
+	Imported        bool
+	ClusterSetVIP   string
+	Discoverability map[host.Name]string
+}
+
+// GetNames returns port names
+func (ports PortList) GetNames() []string {
+	names := make([]string, 0, len(ports))
+	for _, port := range ports {
+		names = append(names, port.Name)
+	}
+	return names
+}
+
+// Get retrieves a port declaration by name
+func (ports PortList) Get(name string) (*Port, bool) {
+	for _, port := range ports {
+		if port.Name == name {
+			return port, true
+		}
+	}
+	return nil, false
+}
+
+// GetByPort retrieves a port declaration by port value
+func (ports PortList) GetByPort(num int) (*Port, bool) {
+	for _, port := range ports {
+		if port.Port == num && port.Protocol != protocol.UDP {
+			return port, true
+		}
+	}
+	return nil, false
+}
+
+func (p *Port) Equals(other *Port) bool {
+	if p == nil {
+		return other == nil
+	}
+	if other == nil {
+		return p == nil
+	}
+	return p.Name == other.Name && p.Port == other.Port && p.Protocol == other.Protocol
+}
+
+func (ports PortList) Equals(other PortList) bool {
+	return slices.EqualFunc(ports, other, func(a, b *Port) bool {
+		return a.Equals(b)
+	})
+}
+
+func (ports PortList) String() string {
+	sp := make([]string, 0, len(ports))
+	for _, p := range ports {
+		sp = append(sp, p.String())
+	}
+	return strings.Join(sp, ", ")
+}
+
+// External predicate checks whether the service is external
+func (s *Service) External() bool {
+	return s.MeshExternal
+}
+
+// BuildSubsetKey generates a unique string referencing service instances for a given service name, a subset and a port.
+// The proxy queries Pilot with this key to obtain the list of instances in a subset.
+func BuildSubsetKey(direction TrafficDirection, subsetName string, hostname host.Name, port int) string {
+	return string(direction) + "|" + strconv.Itoa(port) + "|" + subsetName + "|" + string(hostname)
+}
+
+// BuildInboundSubsetKey generates a unique string referencing service instances with port.
+func BuildInboundSubsetKey(port int) string {
+	return BuildSubsetKey(TrafficDirectionInbound, "", "", port)
+}
+
+// BuildDNSSrvSubsetKey generates a unique string referencing service instances for a given service name, a subset and a port.
+// The proxy queries Pilot with this key to obtain the list of instances in a subset.
+// This is used only for the SNI-DNAT router. Do not use for other purposes.
+// The DNS Srv format of the cluster is also used as the default SNI string for Istio mTLS connections
+func BuildDNSSrvSubsetKey(direction TrafficDirection, subsetName string, hostname host.Name, port int) string {
+	return string(direction) + "_." + strconv.Itoa(port) + "_." + subsetName + "_." + string(hostname)
+}
+
+// IsValidSubsetKey checks if a string is valid for subset key parsing.
+func IsValidSubsetKey(s string) bool {
+	return strings.Count(s, "|") == 3
+}
+
+// IsDNSSrvSubsetKey checks whether the given key is a DNSSrv key (built by BuildDNSSrvSubsetKey).
+func IsDNSSrvSubsetKey(s string) bool {
+	if strings.HasPrefix(s, trafficDirectionOutboundSrvPrefix) ||
+		strings.HasPrefix(s, trafficDirectionInboundSrvPrefix) {
+		return true
+	}
+	return false
+}
+
+// ParseSubsetKeyHostname is an optimized specialization of ParseSubsetKey that only returns the hostname.
+// This is created as this is used in some hot paths and is about 2x faster than ParseSubsetKey; for typical use ParseSubsetKey is sufficient (and zero-alloc).
+func ParseSubsetKeyHostname(s string) (hostname string) {
+	idx := strings.LastIndex(s, "|")
+	if idx == -1 {
+		// Could be DNS SRV format.
+		// Do not do LastIndex("_."), as those are valid characters in the hostname (unlike |)
+		// Fallback to the full parser.
+		_, _, hostname, _ := ParseSubsetKey(s)
+		return string(hostname)
+	}
+	return s[idx+1:]
+}
+
+// ParseSubsetKey is the inverse of the BuildSubsetKey method
+func ParseSubsetKey(s string) (direction TrafficDirection, subsetName string, hostname host.Name, port int) {
+	sep := "|"
+	// This could be the DNS srv form of the cluster that uses outbound_.port_.subset_.hostname
+	// Since we do not want every callsite to implement the logic to differentiate between the two forms
+	// we add an alternate parser here.
+	if strings.HasPrefix(s, trafficDirectionOutboundSrvPrefix) ||
+		strings.HasPrefix(s, trafficDirectionInboundSrvPrefix) {
+		sep = "_."
+	}
+
+	// Format: dir|port|subset|hostname
+	dir, s, ok := strings.Cut(s, sep)
+	if !ok {
+		return
+	}
+	direction = TrafficDirection(dir)
+
+	p, s, ok := strings.Cut(s, sep)
+	if !ok {
+		return
+	}
+	port, _ = strconv.Atoi(p)
+
+	ss, s, ok := strings.Cut(s, sep)
+	if !ok {
+		return
+	}
+	subsetName = ss
+
+	// last part. No | remains -- verify this
+	if strings.Contains(s, sep) {
+		return
+	}
+	hostname = host.Name(s)
+	return
+}
+
+// HasAddressOrAssigned returns whether the service has an IP address.
+// This includes auto-allocated IP addresses. Note that not all proxies support auto-allocated IP addresses;
+// typically GetAllAddressesForProxy should be used which automatically filters addresses to account for that.
+func (s *Service) HasAddressOrAssigned(id cluster.ID) bool {
+	if id != "" {
+		if len(s.ClusterVIPs.GetAddressesFor(id)) > 0 {
+			return true
+		}
+	}
+	if s.DefaultAddress != constants.UnspecifiedIP {
+		return true
+	}
+	if s.AutoAllocatedIPv4Address != "" {
+		return true
+	}
+	if s.AutoAllocatedIPv6Address != "" {
+		return true
+	}
+	return false
+}
+
+func filterAddresses(addresses []string, supportsV4, supportsV6 bool) []string {
+	var ipv4Addresses []string
+	var ipv6Addresses []string
+	for _, addr := range addresses {
+		// check if an address is a CIDR range
+		if strings.Contains(addr, "/") {
+			if prefix, err := netip.ParsePrefix(addr); err != nil {
+				logger.Warn("failed to parse prefix address", "addr", addr, "error", err)
+				continue
+			} else if supportsV4 && prefix.Addr().Is4() {
+				ipv4Addresses = append(ipv4Addresses, addr)
+			} else if supportsV6 && prefix.Addr().Is6() {
+				ipv6Addresses = append(ipv6Addresses, addr)
+			}
+		} else {
+			if ipAddr, err := netip.ParseAddr(addr); err != nil {
+				logger.Warn("failed to parse address", "addr", addr, "error", err)
+				continue
+			} else if supportsV4 && ipAddr.Is4() {
+				ipv4Addresses = append(ipv4Addresses, addr)
+			} else if supportsV6 && ipAddr.Is6() {
+				ipv6Addresses = append(ipv6Addresses, addr)
+			}
+		}
+	}
+	if len(ipv4Addresses) > 0 {
+		return ipv4Addresses
+	}
+	return ipv6Addresses
+}
+
+// GetTLSModeFromEndpointLabels returns the value of the label
+// security.istio.io/tlsMode if set. Do not return Enums or constants
+// from this function as users could provide values other than istio/disabled
+// and apply custom transport socket matchers here.
+func GetTLSModeFromEndpointLabels(labels map[string]string) string {
+	if labels != nil {
+		if val, exists := labels[label.SecurityTlsMode.Name]; exists {
+			return val
+		}
+	}
+	return DisabledTLSModeLabel
+}
+
+// DeepCopy creates a clone of Service.
+func (s *Service) DeepCopy() *Service {
+	// nolint: govet
+	out := *s
+	out.Attributes = s.Attributes.DeepCopy()
+	if s.Ports != nil {
+		out.Ports = make(PortList, len(s.Ports))
+		for i, port := range s.Ports {
+			if port != nil {
+				out.Ports[i] = &Port{
+					Name:     port.Name,
+					Port:     port.Port,
+					Protocol: port.Protocol,
+				}
+			} else {
+				out.Ports[i] = nil
+			}
+		}
+	}
+
+	out.ServiceAccounts = slices.Clone(s.ServiceAccounts)
+	out.ClusterVIPs = *s.ClusterVIPs.DeepCopy()
+	return &out
+}
+
+// Equals compares two service objects.
+func (s *Service) Equals(other *Service) bool {
+	if s == nil {
+		return other == nil
+	}
+	if other == nil {
+		return s == nil
+	}
+
+	if !s.Attributes.Equals(&other.Attributes) {
+		return false
+	}
+
+	if !s.Ports.Equals(other.Ports) {
+		return false
+	}
+	if !slices.Equal(s.ServiceAccounts, other.ServiceAccounts) {
+		return false
+	}
+
+	if len(s.ClusterVIPs.Addresses) != len(other.ClusterVIPs.Addresses) {
+		return false
+	}
+	for k, v1 := range s.ClusterVIPs.Addresses {
+		if v2, ok := other.ClusterVIPs.Addresses[k]; !ok || !slices.Equal(v1, v2) {
+			return false
+		}
+	}
+
+	return s.DefaultAddress == other.DefaultAddress && s.AutoAllocatedIPv4Address == other.AutoAllocatedIPv4Address &&
+		s.AutoAllocatedIPv6Address == other.AutoAllocatedIPv6Address && s.Hostname == other.Hostname &&
+		s.Resolution == other.Resolution && s.MeshExternal == other.MeshExternal
+}
+
+// DeepCopy creates a clone of IstioEndpoint.
+func (ep *IstioEndpoint) DeepCopy() *IstioEndpoint {
+	if ep == nil {
+		return nil
+	}
+
+	out := *ep
+	out.Labels = maps.Clone(ep.Labels)
+	out.Addresses = slices.Clone(ep.Addresses)
+
+	return &out
+}
+
+// ShallowCopy creates a shallow clone of IstioEndpoint.
+func (ep *IstioEndpoint) ShallowCopy() *IstioEndpoint {
+	// nolint: govet
+	cpy := *ep
+	return &cpy
+}
+
+// Equals checks whether the attributes are equal from the passed in service.
+func (ep *IstioEndpoint) Equals(other *IstioEndpoint) bool {
+	if ep == nil {
+		return other == nil
+	}
+	if other == nil {
+		return ep == nil
+	}
+
+	// Check things we can directly compare...
+	eq := ep.ServicePortName == other.ServicePortName &&
+		ep.LegacyClusterPortKey == other.LegacyClusterPortKey &&
+		ep.ServiceAccount == other.ServiceAccount &&
+		ep.Network == other.Network &&
+		ep.Locality == other.Locality &&
+		ep.EndpointPort == other.EndpointPort &&
+		ep.LbWeight == other.LbWeight &&
+		ep.TLSMode == other.TLSMode &&
+		ep.Namespace == other.Namespace &&
+		ep.WorkloadName == other.WorkloadName &&
+		ep.HostName == other.HostName &&
+		ep.SubDomain == other.SubDomain &&
+		ep.HealthStatus == other.HealthStatus &&
+		ep.SendUnhealthyEndpoints == other.SendUnhealthyEndpoints &&
+		ep.NodeName == other.NodeName
+	if !eq {
+		return false
+	}
+
+	// check everything else
+	if !slices.EqualUnordered(ep.Addresses, other.Addresses) {
+		return false
+	}
+	if !maps.Equal(ep.Labels, other.Labels) {
+		return false
+	}
+
+	return true
+}
+
+func equalUsingPremarshaled[T proto.Message](a T, am *anypb.Any, b T, bm *anypb.Any) bool {
+	// If they are both pre-marshaled, use the marshaled representation. This is orders of magnitude faster
+	if am != nil && bm != nil {
+		return bytes.Equal(am.Value, bm.Value)
+	}
+
+	// Fallback to equals
+	return protoconv.Equals(a, b)
+}
+
+// AddressMap provides a thread-safe mapping of addresses for each Kubernetes cluster.
+type AddressMap struct {
+	// Addresses hold the underlying map. Most code should only access this through the available methods.
+	// Should only be used by tests and construction/initialization logic, where there is no concern
+	// for race conditions.
+	Addresses map[cluster.ID][]string
+
+	// NOTE: The copystructure library is not able to copy unexported fields, so the mutex will not be copied.
+	mutex sync.RWMutex
+}
+
+func (m *AddressMap) Len() int {
+	if m == nil {
+		return 0
+	}
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	return len(m.Addresses)
+}
+
+func (m *AddressMap) DeepCopy() *AddressMap {
+	if m == nil {
+		return nil
+	}
+	return &AddressMap{
+		Addresses: m.GetAddresses(),
+	}
+}
+
+// GetAddresses returns the mapping of clusters to addresses.
+func (m *AddressMap) GetAddresses() map[cluster.ID][]string {
+	if m == nil {
+		return nil
+	}
+
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	if m.Addresses == nil {
+		return nil
+	}
+
+	out := make(map[cluster.ID][]string)
+	for k, v := range m.Addresses {
+		out[k] = slices.Clone(v)
+	}
+	return out
+}
+
+// SetAddresses sets the addresses per cluster.
+func (m *AddressMap) SetAddresses(addrs map[cluster.ID][]string) {
+	if len(addrs) == 0 {
+		addrs = nil
+	}
+
+	m.mutex.Lock()
+	m.Addresses = addrs
+	m.mutex.Unlock()
+}
+
+func (m *AddressMap) GetAddressesFor(c cluster.ID) []string {
+	if m == nil {
+		return nil
+	}
+
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	if m.Addresses == nil {
+		return nil
+	}
+
+	// Copy the Addresses array.
+	return append([]string{}, m.Addresses[c]...)
+}
+
+func (m *AddressMap) SetAddressesFor(c cluster.ID, addresses []string) *AddressMap {
+	m.mutex.Lock()
+	defer m.mutex.Unlock()
+
+	if len(addresses) == 0 {
+		// Setting an empty array for the cluster. Remove the entry for the cluster if it exists.
+		if m.Addresses != nil {
+			delete(m.Addresses, c)
+
+			// Delete the map if there's nothing left.
+			if len(m.Addresses) == 0 {
+				m.Addresses = nil
+			}
+		}
+	} else {
+		// Create the map if it doesn't already exist.
+		if m.Addresses == nil {
+			m.Addresses = make(map[cluster.ID][]string)
+		}
+		m.Addresses[c] = addresses
+	}
+	return m
+}
+
+func (m *AddressMap) AddAddressesFor(c cluster.ID, addresses []string) *AddressMap {
+	if len(addresses) == 0 {
+		return m
+	}
+
+	m.mutex.Lock()
+	defer m.mutex.Unlock()
+
+	// Create the map if nil.
+	if m.Addresses == nil {
+		m.Addresses = make(map[cluster.ID][]string)
+	}
+
+	m.Addresses[c] = append(m.Addresses[c], addresses...)
+	return m
+}
+
+func (m *AddressMap) ForEach(fn func(c cluster.ID, addresses []string)) {
+	if m == nil {
+		return
+	}
+
+	m.mutex.RLock()
+	defer m.mutex.RUnlock()
+
+	if m.Addresses == nil {
+		return
+	}
+
+	for c, addresses := range m.Addresses {
+		fn(c, addresses)
+	}
+}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/status.go b/internal/kgateway/agentgatewaysyncer/gateway/status.go
deleted file mode 100644
index be976097b..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/status.go
+++ /dev/null
@@ -1,90 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"strconv"
-	"sync"
-
-	"istio.io/istio/pilot/pkg/status"
-	schematypes "istio.io/istio/pkg/config/schema/kubetypes"
-	"istio.io/istio/pkg/kube/controllers"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/slices"
-)
-
-type StatusRegistration = func(statusWriter status.Queue) krt.HandlerRegistration
-
-// StatusCollections stores a variety of collections that can write status.
-// These can be fed into a queue which can be dynamically changed (to handle leader election)
-type StatusCollections struct {
-	mu           sync.Mutex
-	constructors []func(statusWriter status.Queue) krt.HandlerRegistration
-	active       []krt.HandlerRegistration
-	queue        status.Queue
-}
-
-func (s *StatusCollections) Register(sr StatusRegistration) {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	s.constructors = append(s.constructors, sr)
-}
-
-func (s *StatusCollections) UnsetQueue() {
-	// Now we are disabled
-	s.queue = nil
-	for _, act := range s.active {
-		act.UnregisterHandler()
-	}
-	s.active = nil
-}
-
-func (s *StatusCollections) SetQueue(queue status.Queue) []krt.Syncer {
-	s.mu.Lock()
-	defer s.mu.Unlock()
-	// Now we are enabled!
-	s.queue = queue
-	// Register all constructors
-	s.active = slices.Map(s.constructors, func(reg StatusRegistration) krt.HandlerRegistration {
-		return reg(queue)
-	})
-	return slices.Map(s.active, func(e krt.HandlerRegistration) krt.Syncer {
-		return e
-	})
-}
-
-// registerStatus takes a status collection and registers it to be managed by the status queue.
-func registerStatus[I controllers.Object, IS any](c *Controller, statusCol krt.StatusCollection[I, IS]) {
-	reg := func(statusWriter status.Queue) krt.HandlerRegistration {
-		h := statusCol.Register(func(o krt.Event[krt.ObjectWithStatus[I, IS]]) {
-			l := o.Latest()
-			enqueueStatus(statusWriter, l.Obj, &l.Status)
-		})
-		return h
-	}
-	c.status.Register(reg)
-}
-
-func enqueueStatus[T any](sw status.Queue, obj controllers.Object, ws T) {
-	// TODO: this is a bit awkward since the status controller is reading from crdstore. I suppose it works -- it just means
-	// we cannot remove Gateway API types from there.
-	res := status.Resource{
-		GroupVersionResource: schematypes.GvrFromObject(obj),
-		Namespace:            obj.GetNamespace(),
-		Name:                 obj.GetName(),
-		Generation:           strconv.FormatInt(obj.GetGeneration(), 10),
-	}
-	sw.EnqueueStatusUpdateResource(ws, res)
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/status_test.go b/internal/kgateway/agentgatewaysyncer/gateway/status_test.go
deleted file mode 100644
index e68a5e29a..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/status_test.go
+++ /dev/null
@@ -1,104 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"testing"
-
-	v1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/runtime"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-
-	"istio.io/istio/pilot/pkg/networking/core"
-	"istio.io/istio/pilot/pkg/serviceregistry/kube/controller"
-	"istio.io/istio/pilot/pkg/status"
-	"istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/slices"
-	"istio.io/istio/pkg/test"
-	"istio.io/istio/pkg/test/util/assert"
-)
-
-func TestStatusCollections(t *testing.T) {
-	stop := test.NewStop(t)
-	fetch := func(q *TestStatusQueue) []string {
-		return slices.Sort(slices.Map(q.Statuses(), func(e any) string {
-			return *(e.(*string))
-		}))
-	}
-
-	type Status = krt.ObjectWithStatus[*v1.ConfigMap, string]
-	c := setupControllerWithoutGatewayClasses(t)
-	obj1 := Status{
-		Obj:    &v1.ConfigMap{},
-		Status: "hello world",
-	}
-	fakeCol := krt.NewStaticCollection[Status](nil, []Status{obj1}, krt.WithStop(stop))
-	registerStatus(c, fakeCol)
-
-	sq1 := &TestStatusQueue{state: map[status.Resource]any{}}
-	setAndWait(t, c, sq1)
-	assert.Equal(t, fetch(sq1), []string{"hello world"})
-
-	c.status.UnsetQueue()
-
-	// We should not get an update on the un-registered queue
-	fakeCol.UpdateObject(Status{
-		Obj:    &v1.ConfigMap{},
-		Status: "hello world2",
-	})
-	assert.Equal(t, fetch(sq1), []string{"hello world"})
-
-	// New queue should send new events, including existing state
-	sq2 := &TestStatusQueue{state: map[status.Resource]any{}}
-	setAndWait(t, c, sq2)
-	assert.Equal(t, fetch(sq2), []string{"hello world2"})
-	// And any new state
-	fakeCol.UpdateObject(Status{
-		Obj:    &v1.ConfigMap{},
-		Status: "hello world3",
-	})
-	// New event, so this is eventually consistent
-	assert.EventuallyEqual(t, func() []string {
-		return fetch(sq2)
-	}, []string{"hello world3"})
-}
-
-func setAndWait(t test.Failer, c *Controller, q status.Queue) {
-	stop := test.NewStop(t)
-	for _, syncer := range c.status.SetQueue(q) {
-		syncer.WaitUntilSynced(stop)
-	}
-}
-
-func setupControllerWithoutGatewayClasses(t *testing.T, objs ...runtime.Object) *Controller {
-	kc := kube.NewFakeClient(objs...)
-	setupClientCRDs(t, kc)
-	stop := test.NewStop(t)
-	controller := NewController(
-		kc,
-		func(class schema.GroupVersionResource, stop <-chan struct{}) bool {
-			return false
-		},
-		controller.Options{KrtDebugger: krt.GlobalDebugHandler},
-		nil)
-	kc.RunAndWait(stop)
-	go controller.Run(stop)
-	cg := core.NewConfigGenTest(t, core.TestOptions{})
-	controller.Reconcile(cg.PushContext())
-	kube.WaitForCacheSync("test", stop, controller.HasSynced)
-
-	return controller
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/supported_features.go b/internal/kgateway/agentgatewaysyncer/gateway/supported_features.go
deleted file mode 100644
index e71988cac..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/supported_features.go
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"sigs.k8s.io/gateway-api/pkg/features"
-)
-
-var SupportedFeatures = features.AllFeatures
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/gateway/syncer.go
similarity index 73%
rename from internal/kgateway/agentgatewaysyncer/syncer.go
rename to internal/kgateway/agentgatewaysyncer/gateway/syncer.go
index a23c21012..c5face6c1 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/syncer.go
@@ -1,25 +1,22 @@
-package agentgatewaysyncer
+package gateway
 
 import (
 	"context"
 	"fmt"
 	"maps"
 	"slices"
+	"strconv"
 
 	"github.com/agentgateway/agentgateway/go/api"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer/gateway"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pkg/config/schema/gvr"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/kclient"
@@ -27,10 +24,13 @@ import (
 	"istio.io/istio/pkg/kube/kubetypes"
 	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/apimachinery/pkg/util/sets"
 	"k8s.io/client-go/tools/cache"
 	"sigs.k8s.io/controller-runtime/pkg/manager"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 )
 
 var logger = logging.New("agentgateway/syncer")
@@ -40,9 +40,10 @@ var logger = logging.New("agentgateway/syncer")
 type AgentGwSyncer struct {
 	commonCols     *common.CommonCollections
 	controllerName string
-	xDS            krt.Collection[agentGwXdsResources]
+	xDS            krt.Collection[ADPResource]
 	xdsCache       envoycache.SnapshotCache
-	istioClient    kube.Client
+	client         kube.Client
+	domainSuffix   string
 
 	waitForSync []cache.InformerSynced
 }
@@ -61,7 +62,7 @@ func NewAgentGwSyncer(
 		controllerName: controllerName,
 		xdsCache:       xdsCache,
 		// mgr:            mgr,
-		istioClient: client,
+		client: client,
 	}
 }
 
@@ -146,41 +147,59 @@ func (r report) Equals(in report) bool {
 		maps.Equal(r.reportMap.TCPRoutes, in.reportMap.TCPRoutes)
 }
 
+type Inputs struct {
+	Namespaces krt.Collection[*corev1.Namespace]
+
+	Services krt.Collection[*corev1.Service]
+	Secrets  krt.Collection[*corev1.Secret]
+
+	GatewayClasses  krt.Collection[*gateway.GatewayClass]
+	Gateways        krt.Collection[*gateway.Gateway]
+	HTTPRoutes      krt.Collection[*gateway.HTTPRoute]
+	GRPCRoutes      krt.Collection[*gatewayv1.GRPCRoute]
+	TCPRoutes       krt.Collection[*gatewayalpha.TCPRoute]
+	TLSRoutes       krt.Collection[*gatewayalpha.TLSRoute]
+	ReferenceGrants krt.Collection[*gateway.ReferenceGrant]
+	ServiceEntries  krt.Collection[*networkingclient.ServiceEntry]
+	InferencePools  krt.Collection[*inf.InferencePool]
+}
+
 func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	logger.Debug("init agentgateway Syncer", "controllername", s.controllerName)
 
-	inputs := gateway.Inputs{
-		Namespaces: krt.NewInformer[*corev1.Namespace](s.istioClient),
+	inputs := Inputs{
+		Namespaces: krt.NewInformer[*corev1.Namespace](s.client),
 		Secrets: krt.WrapClient[*corev1.Secret](
-			kclient.NewFiltered[*corev1.Secret](s.istioClient, kubetypes.Filter{
+			kclient.NewFiltered[*corev1.Secret](s.client, kubetypes.Filter{
 				//FieldSelector: kubesecrets.SecretsFieldSelector,
-				ObjectFilter: s.istioClient.ObjectFilter(),
+				ObjectFilter: s.client.ObjectFilter(),
 			}),
 		),
 		Services: krt.WrapClient[*corev1.Service](
-			kclient.NewFiltered[*corev1.Service](s.istioClient, kubetypes.Filter{ObjectFilter: s.istioClient.ObjectFilter()}),
+			kclient.NewFiltered[*corev1.Service](s.client, kubetypes.Filter{ObjectFilter: s.client.ObjectFilter()}),
 		),
-		GatewayClasses: buildClient[*gateway.GatewayClass](c, kc, gvr.GatewayClass, opts, "informer/GatewayClasses"),
-		Gateways:       buildClient[*gateway.Gateway](c, kc, gvr.KubernetesGateway, opts, "informer/Gateways"),
-		HTTPRoutes:     buildClient[*gateway.HTTPRoute](c, kc, gvr.HTTPRoute, opts, "informer/HTTPRoutes"),
-		GRPCRoutes:     buildClient[*gatewayv1.GRPCRoute](c, kc, gvr.GRPCRoute, opts, "informer/GRPCRoutes"),
-
-		ReferenceGrants: buildClient[*gateway.ReferenceGrant](c, kc, gvr.ReferenceGrant, opts, "informer/ReferenceGrants"),
-		ServiceEntries:  buildClient[*networkingclient.ServiceEntry](c, kc, gvr.ServiceEntry, opts, "informer/ServiceEntries"),
-		//InferencePools:  buildClient[*inf.InferencePool](c, kc, gvr.InferencePool, opts, "informer/InferencePools"),
+
+		GatewayClasses: krt.WrapClient(kclient.New[*gateway.GatewayClass](s.client), krtopts.ToOptions("informer/GatewayClasses")...),
+		Gateways:       krt.WrapClient(kclient.New[*gateway.Gateway](s.client), krtopts.ToOptions("informer/Gateways")...),
+		HTTPRoutes:     krt.WrapClient(kclient.New[*gateway.HTTPRoute](s.client), krtopts.ToOptions("informer/HTTPRoutes")...),
+		GRPCRoutes:     krt.WrapClient(kclient.New[*gatewayv1.GRPCRoute](s.client), krtopts.ToOptions("informer/GRPCRoutes")...),
+
+		ReferenceGrants: krt.WrapClient(kclient.New[*gateway.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
+		ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
+		InferencePools:  krt.WrapClient(kclient.New[*inf.InferencePool](s.client), krtopts.ToOptions("informer/InferencePools")...),
 	}
 	if features.EnableAlphaGatewayAPI {
-		inputs.TCPRoutes = buildClient[*gatewayalpha.TCPRoute](c, kc, gvr.TCPRoute, opts, "informer/TCPRoutes")
-		inputs.TLSRoutes = buildClient[*gatewayalpha.TLSRoute](c, kc, gvr.TLSRoute, opts, "informer/TLSRoutes")
+		inputs.TCPRoutes = krt.WrapClient(kclient.New[*gatewayalpha.TCPRoute](s.client), krtopts.ToOptions("informer/TCPRoutes")...)
+		inputs.TLSRoutes = krt.WrapClient(kclient.New[*gatewayalpha.TLSRoute](s.client), krtopts.ToOptions("informer/TLSRoutes")...)
 	} else {
 		// If disabled, still build a collection but make it always empty
-		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, opts.WithName("disable/TCPRoutes")...)
-		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, opts.WithName("disable/TLSRoutes")...)
+		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, krtopts.ToOptions("disable/TCPRoutes")...)
+		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, krtopts.ToOptions("disable/TLSRoutes")...)
 	}
 
-	GatewayClasses := gateway.GatewayClassesCollection(inputs.GatewayClasses, opts)
+	GatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, krtopts)
 
-	RefGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, opts))
+	RefGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, krtopts))
 
 	// Note: not fully complete until its join with route attachments to report attachedRoutes.
 	// Do not register yet.
@@ -190,8 +209,8 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		inputs.Namespaces,
 		RefGrants,
 		inputs.Secrets,
-		options.DomainSuffix,
-		opts,
+		s.domainSuffix,
+		krtopts,
 	)
 	ports := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
 		port := fmt.Sprint(obj.parentInfo.Port)
@@ -199,7 +218,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 			Key:     port,
 			Objects: []Gateway{obj},
 		}
-	}, opts.WithName("ports")...)
+	}, krtopts.ToOptions("ports")...)
 
 	Binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object IndexObject[string, Gateway]) []ADPResource {
 		port, _ := strconv.Atoi(object.Key)
@@ -210,18 +229,20 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 				Name:      gw.parent.Name,
 			})
 		}
-		return slices.Map(uniq.UnsortedList(), func(e types.NamespacedName) ADPResource {
+		var binds []ADPResource
+		for _, obj := range uniq.UnsortedList() {
 			bind := Bind{
 				Bind: &api.Bind{
-					Key:  object.Key + "/" + e.String(),
+					Key:  object.Key + "/" + obj.String(),
 					Port: uint32(port),
 				},
 			}
-			return toResource(e, bind)
-		})
-	}, opts.WithName("Binds")...)
+			binds = append(binds, toResource(obj, bind))
+		}
+		return binds
+	}, krtopts.ToOptions("Binds")...)
 
-	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj gateway.Gateway) *gateway.ADPResource {
+	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *ADPResource {
 		l := &api.Listener{
 			Key:         obj.ResourceName(),
 			Name:        string(obj.parentInfo.SectionName),
@@ -259,29 +280,41 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		return toResourcep(types.NamespacedName{
 			Namespace: obj.parent.Namespace,
 			Name:      obj.parent.Name,
-		}, gateway.ADPListener{l})
-	}, krtopts.WithName("Listeners")...)
+		}, ADPListener{l})
+	}, krtopts.ToOptions("Listeners")...)
 
-	routeParents := gateway.BuildRouteParents(Gateways)
+	routeParents := BuildRouteParents(Gateways)
 
-	routeInputs := gateway.RouteContextInputs{
+	routeInputs := RouteContextInputs{
 		Grants:         RefGrants,
 		RouteParents:   routeParents,
-		DomainSuffix:   options.DomainSuffix,
+		DomainSuffix:   s.domainSuffix,
 		Services:       inputs.Services,
 		Namespaces:     inputs.Namespaces,
 		ServiceEntries: inputs.ServiceEntries,
 		InferencePools: inputs.InferencePools,
 	}
-	ADPRoutes := gateway.ADPRouteCollection(
+	ADPRoutes := ADPRouteCollection(
 		inputs.HTTPRoutes,
 		routeInputs,
-		opts,
+		krtopts,
 	)
+	//httpRoutes := HTTPRouteCollection(
+	//	inputs.HTTPRoutes,
+	//	routeInputs,
+	//	krtopts,
+	//)
+
+	// TODO: inference pool
+
+	resources = krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, ADPRoutes}, krtopts.ToOptions("ADPResources")...)
+	s.xDS = krt.NewCollection([]krt.Collection[envoycache.Resources])
 
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
-		gatewaysCol.HasSynced,
+		Binds.HasSynced,
+		Listeners.HasSynced,
+		ADPRoutes.HasSynced,
 		s.xDS.HasSynced,
 	}
 }
@@ -295,7 +328,7 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		return fmt.Errorf("agentgateway syncer waiting for cache to sync failed")
 	}
 
-	s.xDS.RegisterBatch(func(events []krt.Event[agentGwXdsResources], _ bool) {
+	s.xDS.RegisterBatch(func(events []krt.Event[ADPResource], _ bool) {
 		for _, e := range events {
 			r := e.Latest()
 			if e.Event == controllers.EventDelete {
diff --git a/internal/kgateway/agentgatewaysyncer/syncer_test.go b/internal/kgateway/agentgatewaysyncer/gateway/syncer_test.go
similarity index 97%
rename from internal/kgateway/agentgatewaysyncer/syncer_test.go
rename to internal/kgateway/agentgatewaysyncer/gateway/syncer_test.go
index aeeeea27c..debe02bf8 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer_test.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway/syncer_test.go
@@ -1,4 +1,4 @@
-package agentgatewaysyncer
+package gateway
 
 import (
 	"context"
diff --git a/internal/kgateway/controller/start.go b/internal/kgateway/controller/start.go
index 82ccf371c..55f02af4e 100644
--- a/internal/kgateway/controller/start.go
+++ b/internal/kgateway/controller/start.go
@@ -21,7 +21,7 @@ import (
 	metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
 	infextv1a2 "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer/gateway"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/registry"
@@ -210,7 +210,7 @@ func NewControllerBuilder(ctx context.Context, cfg StartConfig) (*ControllerBuil
 	proxySyncer.Init(ctx, cfg.KrtOptions)
 
 	if cfg.SetupOpts.GlobalSettings.EnableAgentGateway {
-		agentGatewaySyncer := agentgatewaysyncer.NewAgentGwSyncer(
+		agentGatewaySyncer := gateway.NewAgentGwSyncer(
 			ctx,
 			cfg.ControllerName,
 			cfg.AgentGatewayClassName,
-- 
2.39.5 (Apple Git-154)


From 56356a096a18a1021bb366e505b321a0add202f1 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 11:22:40 -0700
Subject: [PATCH 05/17] wip

---
 .../api/v1alpha1/awsauth.go                   |   3 +-
 .../api/v1alpha1/backend.go                   |   5 +-
 .../api/v1alpha1/backendconfigpolicy.go       |   5 +-
 .../api/v1alpha1/directresponse.go            |   5 +-
 .../api/v1alpha1/extauthpolicy.go             |   3 +-
 .../api/v1alpha1/gatewayextension.go          |   5 +-
 .../api/v1alpha1/gatewayparameters.go         |   5 +-
 .../api/v1alpha1/httplistenerpolicy.go        |   5 +-
 .../api/v1alpha1/loadbalancer.go              |   3 +-
 .../api/v1alpha1/service.go                   |   3 +-
 .../api/v1alpha1/singleauthtoken.go           |   3 +-
 .../api/v1alpha1/trafficpolicy.go             |   5 +-
 api/applyconfiguration/utils.go               |   7 +-
 go.mod                                        |  14 +-
 go.sum                                        |  26 +-
 hack/utils/oss_compliance/osa_provided.md     |   3 +-
 .../{gateway => }/README.md                   |   0
 .../agentgatewaysyncer/{gateway => }/adp.go   |   9 +-
 .../{gateway => }/conditions.go               |  23 +-
 internal/kgateway/agentgatewaysyncer/const.go |   7 +
 .../{gateway => }/conversion.go               | 458 +++++-------------
 .../agentgatewaysyncer/gateway/const.go       |   6 -
 .../agentgatewaysyncer/gateway/context.go     | 160 ------
 .../{gateway => }/gateway_collection.go       |  47 +-
 .../{gateway => }/gatewayclass_collection.go  |  13 +-
 .../agentgatewaysyncer/{gateway => }/model.go | 284 +----------
 .../{gateway => }/references_collection.go    |  60 +--
 .../{gateway => }/route_collections.go        |  62 ++-
 .../{gateway => }/service.go                  |  41 +-
 .../{gateway => }/syncer.go                   |  82 ++--
 .../{gateway => }/syncer_test.go              |   2 +-
 internal/kgateway/controller/start.go         |   7 +-
 internal/kgateway/query/mocks/mock_queries.go |   5 +-
 internal/kgateway/setup/agentgateway_test.go  | 350 +++++++++++++
 .../testdata/agentgateway/httproute.yaml      |  91 ++++
 internal/kgateway/wellknown/gwapi.go          |  11 +
 pkg/client/clientset/versioned/clientset.go   |   3 +-
 .../clientset/versioned/fake/register.go      |   3 +-
 .../clientset/versioned/scheme/register.go    |   3 +-
 .../typed/api/v1alpha1/api_client.go          |   3 +-
 .../versioned/typed/api/v1alpha1/backend.go   |   7 +-
 .../typed/api/v1alpha1/backendconfigpolicy.go |   7 +-
 .../typed/api/v1alpha1/directresponse.go      |   7 +-
 .../api/v1alpha1/fake/fake_api_client.go      |   3 +-
 .../typed/api/v1alpha1/fake/fake_backend.go   |   3 +-
 .../v1alpha1/fake/fake_backendconfigpolicy.go |   3 +-
 .../api/v1alpha1/fake/fake_directresponse.go  |   3 +-
 .../v1alpha1/fake/fake_gatewayextension.go    |   3 +-
 .../v1alpha1/fake/fake_gatewayparameters.go   |   3 +-
 .../v1alpha1/fake/fake_httplistenerpolicy.go  |   3 +-
 .../api/v1alpha1/fake/fake_trafficpolicy.go   |   3 +-
 .../typed/api/v1alpha1/gatewayextension.go    |   7 +-
 .../typed/api/v1alpha1/gatewayparameters.go   |   7 +-
 .../typed/api/v1alpha1/httplistenerpolicy.go  |   7 +-
 .../typed/api/v1alpha1/trafficpolicy.go       |   7 +-
 55 files changed, 838 insertions(+), 1065 deletions(-)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/README.md (100%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/adp.go (97%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/conditions.go (90%)
 create mode 100644 internal/kgateway/agentgatewaysyncer/const.go
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/conversion.go (83%)
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/const.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/gateway/context.go
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/gateway_collection.go (77%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/gatewayclass_collection.go (73%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/model.go (57%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/references_collection.go (66%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/route_collections.go (92%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/service.go (97%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/syncer.go (89%)
 rename internal/kgateway/agentgatewaysyncer/{gateway => }/syncer_test.go (97%)
 create mode 100644 internal/kgateway/setup/testdata/agentgateway/httproute.yaml

diff --git a/api/applyconfiguration/api/v1alpha1/awsauth.go b/api/applyconfiguration/api/v1alpha1/awsauth.go
index 02689bc08..6ec76eb77 100644
--- a/api/applyconfiguration/api/v1alpha1/awsauth.go
+++ b/api/applyconfiguration/api/v1alpha1/awsauth.go
@@ -3,8 +3,9 @@
 package v1alpha1
 
 import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/api/core/v1"
+
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // AwsAuthApplyConfiguration represents a declarative configuration of the AwsAuth type for use
diff --git a/api/applyconfiguration/api/v1alpha1/backend.go b/api/applyconfiguration/api/v1alpha1/backend.go
index 2f0e01292..467cd9f59 100644
--- a/api/applyconfiguration/api/v1alpha1/backend.go
+++ b/api/applyconfiguration/api/v1alpha1/backend.go
@@ -3,12 +3,13 @@
 package v1alpha1
 
 import (
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
+
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // BackendApplyConfiguration represents a declarative configuration of the Backend type for use
diff --git a/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go b/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go
index 95912d942..7b80b4d32 100644
--- a/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/backendconfigpolicy.go
@@ -3,13 +3,14 @@
 package v1alpha1
 
 import (
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
 	v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
+
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // BackendConfigPolicyApplyConfiguration represents a declarative configuration of the BackendConfigPolicy type for use
diff --git a/api/applyconfiguration/api/v1alpha1/directresponse.go b/api/applyconfiguration/api/v1alpha1/directresponse.go
index 655c042ba..280fea8c1 100644
--- a/api/applyconfiguration/api/v1alpha1/directresponse.go
+++ b/api/applyconfiguration/api/v1alpha1/directresponse.go
@@ -3,12 +3,13 @@
 package v1alpha1
 
 import (
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
+
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // DirectResponseApplyConfiguration represents a declarative configuration of the DirectResponse type for use
diff --git a/api/applyconfiguration/api/v1alpha1/extauthpolicy.go b/api/applyconfiguration/api/v1alpha1/extauthpolicy.go
index a8f061ee8..37b993ddf 100644
--- a/api/applyconfiguration/api/v1alpha1/extauthpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/extauthpolicy.go
@@ -3,8 +3,9 @@
 package v1alpha1
 
 import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/api/core/v1"
+
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // ExtAuthPolicyApplyConfiguration represents a declarative configuration of the ExtAuthPolicy type for use
diff --git a/api/applyconfiguration/api/v1alpha1/gatewayextension.go b/api/applyconfiguration/api/v1alpha1/gatewayextension.go
index 461eb2d62..2b592e530 100644
--- a/api/applyconfiguration/api/v1alpha1/gatewayextension.go
+++ b/api/applyconfiguration/api/v1alpha1/gatewayextension.go
@@ -3,12 +3,13 @@
 package v1alpha1
 
 import (
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
+
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // GatewayExtensionApplyConfiguration represents a declarative configuration of the GatewayExtension type for use
diff --git a/api/applyconfiguration/api/v1alpha1/gatewayparameters.go b/api/applyconfiguration/api/v1alpha1/gatewayparameters.go
index 8d5277208..40f16258a 100644
--- a/api/applyconfiguration/api/v1alpha1/gatewayparameters.go
+++ b/api/applyconfiguration/api/v1alpha1/gatewayparameters.go
@@ -3,12 +3,13 @@
 package v1alpha1
 
 import (
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
+
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // GatewayParametersApplyConfiguration represents a declarative configuration of the GatewayParameters type for use
diff --git a/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go b/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go
index e498eebe7..e16e41b38 100644
--- a/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/httplistenerpolicy.go
@@ -3,13 +3,14 @@
 package v1alpha1
 
 import (
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
 	v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
+
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // HTTPListenerPolicyApplyConfiguration represents a declarative configuration of the HTTPListenerPolicy type for use
diff --git a/api/applyconfiguration/api/v1alpha1/loadbalancer.go b/api/applyconfiguration/api/v1alpha1/loadbalancer.go
index ef46aa1f1..97e3a905a 100644
--- a/api/applyconfiguration/api/v1alpha1/loadbalancer.go
+++ b/api/applyconfiguration/api/v1alpha1/loadbalancer.go
@@ -3,8 +3,9 @@
 package v1alpha1
 
 import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // LoadBalancerApplyConfiguration represents a declarative configuration of the LoadBalancer type for use
diff --git a/api/applyconfiguration/api/v1alpha1/service.go b/api/applyconfiguration/api/v1alpha1/service.go
index 257ec8246..f4d546ace 100644
--- a/api/applyconfiguration/api/v1alpha1/service.go
+++ b/api/applyconfiguration/api/v1alpha1/service.go
@@ -3,8 +3,9 @@
 package v1alpha1
 
 import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/api/core/v1"
+
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // ServiceApplyConfiguration represents a declarative configuration of the Service type for use
diff --git a/api/applyconfiguration/api/v1alpha1/singleauthtoken.go b/api/applyconfiguration/api/v1alpha1/singleauthtoken.go
index 2747befc3..6e65af715 100644
--- a/api/applyconfiguration/api/v1alpha1/singleauthtoken.go
+++ b/api/applyconfiguration/api/v1alpha1/singleauthtoken.go
@@ -3,8 +3,9 @@
 package v1alpha1
 
 import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/api/core/v1"
+
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // SingleAuthTokenApplyConfiguration represents a declarative configuration of the SingleAuthToken type for use
diff --git a/api/applyconfiguration/api/v1alpha1/trafficpolicy.go b/api/applyconfiguration/api/v1alpha1/trafficpolicy.go
index 7fc71076f..bfc34f877 100644
--- a/api/applyconfiguration/api/v1alpha1/trafficpolicy.go
+++ b/api/applyconfiguration/api/v1alpha1/trafficpolicy.go
@@ -3,13 +3,14 @@
 package v1alpha1
 
 import (
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
 	v1 "k8s.io/client-go/applyconfigurations/meta/v1"
 	v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
+
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // TrafficPolicyApplyConfiguration represents a declarative configuration of the TrafficPolicy type for use
diff --git a/api/applyconfiguration/utils.go b/api/applyconfiguration/utils.go
index da00e29e8..407b61e5d 100644
--- a/api/applyconfiguration/utils.go
+++ b/api/applyconfiguration/utils.go
@@ -3,12 +3,13 @@
 package applyconfiguration
 
 import (
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
-	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	testing "k8s.io/client-go/testing"
+
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	internal "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/internal"
+	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 // ForKind returns an apply configuration type for the given GroupVersionKind, or nil if no
diff --git a/go.mod b/go.mod
index 968ebe42b..3a09babb9 100644
--- a/go.mod
+++ b/go.mod
@@ -63,20 +63,12 @@ require (
 	github.com/dlclark/regexp2 v1.11.5 // indirect
 	github.com/elliotchance/orderedmap v1.8.0 // indirect
 	github.com/goccy/go-yaml v1.17.1 // indirect
-	github.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc // indirect
-	github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3 // indirect
 	github.com/jinzhu/copier v0.4.0 // indirect
 	github.com/manuelarte/funcorder v0.2.1 // indirect
 	github.com/mikefarah/yq/v4 v4.45.4 // indirect
-	github.com/openshift/api v0.0.0-20250122093221-e6cc8f6fd74c // indirect
-	github.com/prometheus/prometheus v0.301.0 // indirect
-	github.com/yl2chen/cidranger v1.0.2 // indirect
 	github.com/yuin/gopher-lua v1.1.1 // indirect
 	go.augendre.info/fatcontext v0.8.0 // indirect
-	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.34.0 // indirect
-	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.34.0 // indirect
 	gopkg.in/op/go-logging.v1 v1.0.0-20160211212156-b2cb9fa56473 // indirect
-	sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.1 // indirect
 )
 
 require (
@@ -302,7 +294,7 @@ require (
 	github.com/gobwas/glob v0.2.3 // indirect
 	github.com/goccy/go-json v0.10.5 // indirect
 	github.com/gofrs/flock v0.12.1 // indirect
-	github.com/gogo/protobuf v1.3.2 // indirect
+	github.com/gogo/protobuf v1.3.2
 	github.com/golang-jwt/jwt/v4 v4.5.1 // indirect
 	github.com/golang-jwt/jwt/v5 v5.2.1 // indirect
 	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
@@ -349,7 +341,7 @@ require (
 	github.com/hashicorp/errwrap v1.1.0 // indirect
 	github.com/hashicorp/go-cleanhttp v0.5.2 // indirect
 	github.com/hashicorp/go-immutable-radix/v2 v2.1.0 // indirect
-	github.com/hashicorp/go-multierror v1.1.1
+	github.com/hashicorp/go-multierror v1.1.1 // indirect
 	github.com/hashicorp/go-retryablehttp v0.7.7 // indirect
 	github.com/hashicorp/go-version v1.7.0 // indirect
 	github.com/hashicorp/golang-lru v1.0.2 // indirect
@@ -573,7 +565,7 @@ require (
 	go.opentelemetry.io/otel/sdk/metric v1.34.0 // indirect
 	go.opentelemetry.io/otel/trace v1.34.0 // indirect
 	go.opentelemetry.io/proto/otlp v1.6.0 // indirect
-	go.uber.org/atomic v1.11.0
+	go.uber.org/atomic v1.11.0 // indirect
 	go.uber.org/automaxprocs v1.6.0 // indirect
 	go.uber.org/multierr v1.11.0 // indirect
 	gocloud.dev v0.40.0 // indirect
diff --git a/go.sum b/go.sum
index 1250a13da..e20f4b337 100644
--- a/go.sum
+++ b/go.sum
@@ -219,8 +219,6 @@ github.com/a8m/envsubst v1.4.3/go.mod h1:4jjHWQlZoaXPoLQUb7H2qT4iLkZDdmEQiOUogdU
 github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d h1:licZJFw2RwpHMqeKTCYkitsPqHNxTmd4SNR5r94FGM8=
 github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d/go.mod h1:asat636LX7Bqt5lYEZ27JNDcqxfjdBQuJ/MM4CN/Lzo=
 github.com/alcortesm/tgz v0.0.0-20161220082320-9c5fe88206d7/go.mod h1:6zEj6s6u/ghQa61ZWa/C2Aw3RkjiTBOix7dkqa1VLIs=
-github.com/alecholmes/xfccparser v0.4.0 h1:IFB4bP34oorjcV3n8utZtBhEwlAw9rZ43pb4LgT23Vo=
-github.com/alecholmes/xfccparser v0.4.0/go.mod h1:J9fzzUOtjw74IwNdGVbjnOVj1UDlwGQj1zZzgQRlRDY=
 github.com/alecthomas/assert/v2 v2.11.0 h1:2Q9r3ki8+JYXvGsDyBXwH3LcJ+WK5D0gc5E8vS6K3D0=
 github.com/alecthomas/assert/v2 v2.11.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=
 github.com/alecthomas/chroma/v2 v2.17.2 h1:Rm81SCZ2mPoH+Q8ZCc/9YvzPUN/E7HgPiPJD8SLV6GI=
@@ -472,13 +470,8 @@ github.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkE
 github.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
 github.com/coreos/etcd v3.3.13+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
 github.com/coreos/go-oidc v2.1.0+incompatible/go.mod h1:CgnwVTmzoESiwO9qyAFEMiHoZ1nMCKZlZ9V6mm3/LKc=
-github.com/coreos/go-oidc v2.2.1+incompatible h1:mh48q/BqXqgjVHpy2ZY7WnWAbenxRjsz9N1i1YxjHAk=
-github.com/coreos/go-oidc/v3 v3.12.0 h1:sJk+8G2qq94rDI6ehZ71Bol3oUHy63qNYmkiSjrc/Jo=
-github.com/coreos/go-oidc/v3 v3.12.0/go.mod h1:gE3LgjOgFoHi9a4ce4/tJczr0Ai2/BoDhf0r5lltWI0=
 github.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
 github.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
-github.com/coreos/go-semver v0.3.1 h1:yi21YpKnrx1gt5R+la8n5WgS0kCrsPp33dmEyHReZr4=
-github.com/coreos/go-semver v0.3.1/go.mod h1:irMmmIw/7yzSRPWryHsK7EYSg09caPQL03VsM8rvUec=
 github.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
 github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e h1:Wf6HqHfScWJN9/ZjdUKyjop4mf3Qdd+1TvvltAvM3m8=
 github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
@@ -1004,8 +997,6 @@ github.com/gostaticanalysis/testutil v0.5.0 h1:Dq4wT1DdTwTGCQQv3rl3IvD5Ld0E6HiY+
 github.com/gostaticanalysis/testutil v0.5.0/go.mod h1:OLQSbuM6zw2EvCcXTz1lVq5unyoNft372msDY0nY5Hs=
 github.com/gosuri/uitable v0.0.4 h1:IG2xLKRvErL3uhY6e1BylFzG+aJiwQviDDTfOKeKTpY=
 github.com/gosuri/uitable v0.0.4/go.mod h1:tKR86bXuXPZazfOTG1FIzvjIdXzd0mo4Vtn16vt0PJo=
-github.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc h1:GN2Lv3MGO7AS6PrRoT6yV5+wkrOpcszoIsO4+4ds248=
-github.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc/go.mod h1:+JKpmjMGhpgPL+rXZ5nsZieVzvarn86asRlBg4uNGnk=
 github.com/gregjones/httpcache v0.0.0-20180305231024-9cad4c3443a7/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=
 github.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79 h1:+ngKgrYPPJrOjhax5N+uePQ0Fh1Z7PheYoUI/0nzkPA=
 github.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=
@@ -1013,11 +1004,11 @@ github.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmg
 github.com/grpc-ecosystem/go-grpc-middleware v1.0.1-0.20190118093823-f849b5445de4/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=
 github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 h1:UH//fgunKIs4JdUbpDl1VZCDaL56wXCB/5+wF6uHfaI=
 github.com/grpc-ecosystem/go-grpc-middleware v1.4.0/go.mod h1:g5qyo/la0ALbONm6Vbp88Yd8NsDy6rZz+RcrMPxvld8=
-github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=
 github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
 github.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
 github.com/grpc-ecosystem/grpc-gateway v1.9.5/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
 github.com/grpc-ecosystem/grpc-gateway v1.14.6/go.mod h1:zdiPV4Yse/1gnckTHtghG4GkDEdKCRJduHpTxT3/jcw=
+github.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=
 github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
 github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3 h1:5ZPtiqj0JL5oKWmcsq4VMaAW5ukBEgSGXEN89zeH1Jo=
 github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3/go.mod h1:ndYquD05frm2vACXE1nsccT4oJzjhw2arTS2cpUD1PI=
@@ -1432,8 +1423,6 @@ github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQ
 github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
 github.com/opencontainers/runc v1.1.14 h1:rgSuzbmgz5DUJjeSnw337TxDbRuqjs6iqQck/2weR6w=
 github.com/opencontainers/runc v1.1.14/go.mod h1:E4C2z+7BxR7GHXp0hAY53mek+x49X1LjPNeMTfRGvOA=
-github.com/openshift/api v0.0.0-20250122093221-e6cc8f6fd74c h1:45L32MUt1dn8TyHT1SN61srou4D5/EmFPCTPhnPhxz4=
-github.com/openshift/api v0.0.0-20250122093221-e6cc8f6fd74c/go.mod h1:Shkl4HanLwDiiBzakv+con/aMGnVE2MAGvoKp5oyYUo=
 github.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=
 github.com/opentracing/opentracing-go v1.2.0 h1:uEJPy/1a5RIPAJ0Ov+OIO8OxWu77jEv+1B0VhjKrZUs=
 github.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=
@@ -1538,8 +1527,6 @@ github.com/prometheus/procfs v0.7.3/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1
 github.com/prometheus/procfs v0.8.0/go.mod h1:z7EfXMXOkbkqb9IINtpCn86r/to3BnA0uaxHdg830/4=
 github.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=
 github.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=
-github.com/prometheus/prometheus v0.301.0 h1:0z8dgegmILivNomCd79RKvVkIols8vBGPKmcIBc7OyY=
-github.com/prometheus/prometheus v0.301.0/go.mod h1:BJLjWCKNfRfjp7Q48DrAjARnCi7GhfUVvUFEAWTssZM=
 github.com/prometheus/statsd_exporter v0.21.0/go.mod h1:rbT83sZq2V+p73lHhPZfMc3MLCHmSHelCh9hSGYNLTQ=
 github.com/prometheus/statsd_exporter v0.22.7/go.mod h1:N/TevpjkIh9ccs6nuzY3jQn9dFqnUakOjnEuMPJJJnI=
 github.com/prometheus/statsd_exporter v0.25.0 h1:gpVF1TMf1UqMJmBDpzBYrEaGOFMpbMBYYYUDwM38Y/I=
@@ -1593,8 +1580,6 @@ github.com/ryancurrah/gomodguard v1.4.1/go.mod h1:qnMJwV1hX9m+YJseXEBhd2s90+1Xn6
 github.com/ryanrolds/sqlclosecheck v0.5.1 h1:dibWW826u0P8jNLsLN+En7+RqWWTYrjCB9fJfSfdyCU=
 github.com/ryanrolds/sqlclosecheck v0.5.1/go.mod h1:2g3dUjoS6AL4huFdv6wn55WpLIDjY7ZgUR4J8HOO/XQ=
 github.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=
-github.com/ryanuber/go-glob v1.0.0 h1:iQh3xXAumdQ+4Ufa5b25cRpC5TYKlno6hsv6Cb3pkBk=
-github.com/ryanuber/go-glob v1.0.0/go.mod h1:807d1WSdnB0XRJzKNil9Om6lcp/3a0v4qIHxIXzX/Yc=
 github.com/sagikazarmark/locafero v0.6.0 h1:ON7AQg37yzcRPU69mt7gwhFEBwxI6P9T4Qu3N51bwOk=
 github.com/sagikazarmark/locafero v0.6.0/go.mod h1:77OmuIc6VTraTXKXIs/uvUxKGUXjE1GbemJYHqdNjX0=
 github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6gto+ugjYE=
@@ -1825,8 +1810,6 @@ github.com/yeya24/promlinter v0.3.0 h1:JVDbMp08lVCP7Y6NP3qHroGAO6z2yGKQtS5Jsjqto
 github.com/yeya24/promlinter v0.3.0/go.mod h1:cDfJQQYv9uYciW60QT0eeHlFodotkYZlL+YcPQN+mW4=
 github.com/ykadowak/zerologlint v0.1.5 h1:Gy/fMz1dFQN9JZTPjv1hxEk+sRWm05row04Yoolgdiw=
 github.com/ykadowak/zerologlint v0.1.5/go.mod h1:KaUskqF3e/v59oPmdq1U1DnKcuHokl2/K1U4pmIELKg=
-github.com/yl2chen/cidranger v1.0.2 h1:lbOWZVCG1tCRX4u24kuM1Tb4nHqWkDxwLdoS+SevawU=
-github.com/yl2chen/cidranger v1.0.2/go.mod h1:9U1yz7WPYDwf0vpNWFaeRh0bjwz5RVgRy/9UEQfHl0g=
 github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
 github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
 github.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
@@ -1855,14 +1838,7 @@ go.augendre.info/fatcontext v0.8.0/go.mod h1:oVJfMgwngMsHO+KB2MdgzcO+RvtNdiCEOlW
 go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
 go.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
 go.etcd.io/bbolt v1.3.5/go.mod h1:G5EMThwa9y8QZGBClrRx5EY+Yw9kAhnjy3bSjsnlVTQ=
-go.etcd.io/etcd v0.5.0-alpha.5.0.20200910180754-dd1b699fc489 h1:1JFLBqwIgdyHN1ZtgjTBwO+blA6gVOmZurpiMEsETKo=
 go.etcd.io/etcd v0.5.0-alpha.5.0.20200910180754-dd1b699fc489/go.mod h1:yVHk9ub3CSBatqGNg7GRmsnfLWtoW60w4eDYfh7vHDg=
-go.etcd.io/etcd/api/v3 v3.5.16 h1:WvmyJVbjWqK4R1E+B12RRHz3bRGy9XVfh++MgbN+6n0=
-go.etcd.io/etcd/api/v3 v3.5.16/go.mod h1:1P4SlIP/VwkDmGo3OlOD7faPeP8KDIFhqvciH5EfN28=
-go.etcd.io/etcd/client/pkg/v3 v3.5.16 h1:ZgY48uH6UvB+/7R9Yf4x574uCO3jIx0TRDyetSfId3Q=
-go.etcd.io/etcd/client/pkg/v3 v3.5.16/go.mod h1:V8acl8pcEK0Y2g19YlOV9m9ssUe6MgiDSobSoaBAM0E=
-go.etcd.io/etcd/client/v3 v3.5.16 h1:sSmVYOAHeC9doqi0gv7v86oY/BTld0SEFGaxsU9eRhE=
-go.etcd.io/etcd/client/v3 v3.5.16/go.mod h1:X+rExSGkyqxvu276cr2OwPLBaeqFu1cIl4vmRjAD/50=
 go.mongodb.org/mongo-driver v1.14.0 h1:P98w8egYRjYe3XDjxhYJagTokP/H6HzlsnojRgZRd80=
 go.mongodb.org/mongo-driver v1.14.0/go.mod h1:Vzb0Mk/pa7e6cWw85R4F/endUC3u0U9jGcNU603k65c=
 go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
diff --git a/hack/utils/oss_compliance/osa_provided.md b/hack/utils/oss_compliance/osa_provided.md
index 453e80b89..4f0e4baee 100644
--- a/hack/utils/oss_compliance/osa_provided.md
+++ b/hack/utils/oss_compliance/osa_provided.md
@@ -1,6 +1,6 @@
 Name|Version|License
 ---|---|---
-[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.4.31-0.20250519135723-61536c2b3fa0|Apache License 2.0
+[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.0.0-20250626235044-bb6ced925fc3|Apache License 2.0
 [avast/retry-go](https://github.com/avast/retry-go)|v2.4.3+incompatible|MIT License
 [retry-go/v4](https://github.com/avast/retry-go)|v4.3.3|MIT License
 [caarlos0/log](https://github.com/caarlos0/log)|v0.4.6|MIT License
@@ -13,6 +13,7 @@ Name|Version|License
 [ghodss/yaml](https://github.com/ghodss/yaml)|v1.0.1-0.20190212211648-25d852aebe32|MIT License
 [go-logr/logr](https://github.com/go-logr/logr)|v1.4.2|Apache License 2.0
 [go-logr/zapr](https://github.com/go-logr/zapr)|v1.3.0|Apache License 2.0
+[gogo/protobuf](https://github.com/gogo/protobuf)|v1.3.2|BSD 3-clause "New" or "Revised" License
 [google/go-cmp](https://github.com/google/go-cmp)|v0.7.0|BSD 3-clause "New" or "Revised" License
 [grpc-ecosystem/go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)|v1.4.0|Apache License 2.0
 [kelseyhightower/envconfig](https://github.com/kelseyhightower/envconfig)|v1.4.0|MIT License
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/README.md b/internal/kgateway/agentgatewaysyncer/README.md
similarity index 100%
rename from internal/kgateway/agentgatewaysyncer/gateway/README.md
rename to internal/kgateway/agentgatewaysyncer/README.md
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/adp.go b/internal/kgateway/agentgatewaysyncer/adp.go
similarity index 97%
rename from internal/kgateway/agentgatewaysyncer/gateway/adp.go
rename to internal/kgateway/agentgatewaysyncer/adp.go
index 138ae6475..912e49aae 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/adp.go
+++ b/internal/kgateway/agentgatewaysyncer/adp.go
@@ -1,4 +1,4 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"fmt"
@@ -6,6 +6,7 @@ import (
 
 	"github.com/agentgateway/agentgateway/go/api"
 	"istio.io/istio/pkg/slices"
+	"k8s.io/apimachinery/pkg/runtime/schema"
 	k8s "sigs.k8s.io/gateway-api/apis/v1"
 )
 
@@ -170,7 +171,7 @@ func createADPMirrorFilter(
 	ctx RouteContext,
 	filter *k8s.HTTPRequestMirrorFilter,
 	ns string,
-	k GroupVersionKind,
+	k schema.GroupVersionKind,
 ) (*api.RouteFilter, *ConfigError) {
 	if filter == nil {
 		return nil, nil
@@ -203,9 +204,9 @@ func createADPMirrorFilter(
 	rm := &api.RequestMirror{
 		Kind:       nil,
 		Percentage: percent,
-		Port:       dst.Port,
+		Port:       dst.GetPort(),
 	}
-	switch dk := dst.Kind.(type) {
+	switch dk := dst.GetKind().(type) {
 	case *api.RouteBackend_Service:
 		rm.Kind = &api.RequestMirror_Service{
 			Service: dk.Service,
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conditions.go b/internal/kgateway/agentgatewaysyncer/conditions.go
similarity index 90%
rename from internal/kgateway/agentgatewaysyncer/gateway/conditions.go
rename to internal/kgateway/agentgatewaysyncer/conditions.go
index b39696417..ed85a2e6c 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/conditions.go
+++ b/internal/kgateway/agentgatewaysyncer/conditions.go
@@ -1,12 +1,13 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	k8s "sigs.k8s.io/gateway-api/apis/v1"
 	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+
 	"istio.io/istio/pilot/pkg/model/kstatus"
-	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/maps"
 	"istio.io/istio/pkg/slices"
 )
@@ -44,14 +45,6 @@ const (
 	DeprecateFieldUsage  ConfigErrorReason = "DeprecatedField"
 )
 
-const (
-	// This condition indicates whether a route's parent reference has
-	// a waypoint configured by resolving the "istio.io/use-waypoint" label
-	// on either the referenced parent or the parent's namespace.
-	RouteConditionResolvedWaypoints k8s.RouteConditionType   = "ResolvedWaypoints"
-	RouteReasonResolvedWaypoints    k8s.RouteConditionReason = "ResolvedWaypoints"
-)
-
 // ParentError represents that a parent could not be referenced
 type ParentError struct {
 	Reason  ParentErrorReason
@@ -153,16 +146,16 @@ func generateSupportedKinds(l k8s.Listener) ([]k8s.RouteGroupKind, bool) {
 	case k8s.HTTPProtocolType, k8s.HTTPSProtocolType:
 		// Only terminate allowed, so its always HTTP
 		supported = []k8s.RouteGroupKind{
-			toRouteKind(gvk.HTTPRoute),
-			toRouteKind(gvk.GRPCRoute),
+			toRouteKind(wellknown.HTTPRouteGVK),
+			toRouteKind(wellknown.GRPCRouteGVK),
 		}
 	case k8s.TCPProtocolType:
-		supported = []k8s.RouteGroupKind{toRouteKind(gvk.TCPRoute)}
+		supported = []k8s.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
 	case k8s.TLSProtocolType:
 		if l.TLS != nil && l.TLS.Mode != nil && *l.TLS.Mode == k8s.TLSModePassthrough {
-			supported = []k8s.RouteGroupKind{toRouteKind(gvk.TLSRoute)}
+			supported = []k8s.RouteGroupKind{toRouteKind(wellknown.TLSRouteGVK)}
 		} else {
-			supported = []k8s.RouteGroupKind{toRouteKind(gvk.TCPRoute)}
+			supported = []k8s.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
 		}
 		// UDP route not support
 	}
diff --git a/internal/kgateway/agentgatewaysyncer/const.go b/internal/kgateway/agentgatewaysyncer/const.go
new file mode 100644
index 000000000..30605e493
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/const.go
@@ -0,0 +1,7 @@
+package agentgatewaysyncer
+
+const (
+	TargetTypeResourceUrl = "type.googleapis.com/agentgateway.dev.resource.Resource"
+	TargetTypeAddressUrl  = "type.googleapis.com/agentgateway.dev.workload.Address"
+	AgentgatewayName      = "agentgateway-autogenerated-k8s-gateway"
+)
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
similarity index 83%
rename from internal/kgateway/agentgatewaysyncer/gateway/conversion.go
rename to internal/kgateway/agentgatewaysyncer/conversion.go
index 9e221004f..ec49e21cc 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -1,17 +1,15 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"cmp"
 	"crypto/tls"
 	"fmt"
-	"net"
-	"net/netip"
+	"log"
 	"sort"
 	"strconv"
 	"strings"
 	"time"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"google.golang.org/protobuf/types/known/durationpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 	corev1 "k8s.io/api/core/v1"
@@ -22,6 +20,8 @@ import (
 	k8salpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+
 	"github.com/agentgateway/agentgateway/go/api"
 	"istio.io/api/annotation"
 	"istio.io/api/label"
@@ -32,11 +32,9 @@ import (
 	creds "istio.io/istio/pilot/pkg/model/credentials"
 	"istio.io/istio/pilot/pkg/model/kstatus"
 	"istio.io/istio/pilot/pkg/serviceregistry/kube"
-	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
-	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/schema/kind"
 	schematypes "istio.io/istio/pkg/config/schema/kubetypes"
 	"istio.io/istio/pkg/kube/controllers"
@@ -95,7 +93,7 @@ func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 		if err != nil {
 			return nil, err
 		}
-		res.Matches = append(res.Matches, &api.RouteMatch{
+		res.Matches = append(res.GetMatches(), &api.RouteMatch{
 			Path:        path,
 			Headers:     headers,
 			Method:      method,
@@ -113,13 +111,13 @@ func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 		if r.Timeouts.Request != nil {
 			request, _ := time.ParseDuration(string(*r.Timeouts.Request))
 			if request > 0 {
-				res.TrafficPolicy.RequestTimeout = durationpb.New(request)
+				res.GetTrafficPolicy().RequestTimeout = durationpb.New(request)
 			}
 		}
 		if r.Timeouts.BackendRequest != nil {
 			request, _ := time.ParseDuration(string(*r.Timeouts.BackendRequest))
 			if request > 0 {
-				res.TrafficPolicy.RequestTimeout = durationpb.New(request)
+				res.GetTrafficPolicy().RequestTimeout = durationpb.New(request)
 			}
 		}
 	}
@@ -164,7 +162,7 @@ func buildADPFilters(
 			}
 			filters = append(filters, h)
 		case k8s.HTTPRouteFilterRequestMirror:
-			h, err := createADPMirrorFilter(ctx, filter.RequestMirror, ns, gvk.HTTPRoute)
+			h, err := createADPMirrorFilter(ctx, filter.RequestMirror, ns, wellknown.HTTPRouteGVK)
 			if err != nil {
 				mirrorBackendErr = err
 			} else {
@@ -229,7 +227,7 @@ func buildADPDestination(
 	ctx RouteContext,
 	to k8s.HTTPBackendRef,
 	ns string,
-	ref schema.GroupVersionKind,
+	k schema.GroupVersionKind,
 ) (*api.RouteBackend, *ConfigError) {
 	// check if the reference is allowed
 	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
@@ -255,8 +253,9 @@ func buildADPDestination(
 		Weight: weight,
 	}
 	var port *k8s.PortNumber
+	ref := normalizeReference(to.Group, to.Kind, wellknown.ServiceGVK)
 	switch ref {
-	//case gvk.InferencePool:
+	//case wellknown.InferencePoolGVK:
 	//	if strings.Contains(string(to.Name), ".") {
 	//		return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
 	//	}
@@ -328,7 +327,7 @@ func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
 		if err != nil {
 			return nil, err
 		}
-		vs.Match = append(vs.Match, &istio.HTTPMatchRequest{
+		vs.Match = append(vs.GetMatch(), &istio.HTTPMatchRequest{
 			Uri:         uri,
 			Headers:     headers,
 			QueryParams: qp,
@@ -343,27 +342,27 @@ func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
 			if h == nil {
 				continue
 			}
-			if vs.Headers == nil {
+			if vs.GetHeaders() == nil {
 				vs.Headers = &istio.Headers{}
 			}
-			vs.Headers.Request = h
+			vs.GetHeaders().Request = h
 		case k8s.HTTPRouteFilterResponseHeaderModifier:
 			h := createHeadersFilter(filter.ResponseHeaderModifier)
 			if h == nil {
 				continue
 			}
-			if vs.Headers == nil {
+			if vs.GetHeaders() == nil {
 				vs.Headers = &istio.Headers{}
 			}
-			vs.Headers.Response = h
+			vs.GetHeaders().Response = h
 		case k8s.HTTPRouteFilterRequestRedirect:
 			vs.Redirect = createRedirectFilter(filter.RequestRedirect)
 		case k8s.HTTPRouteFilterRequestMirror:
-			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, gvk.HTTPRoute)
+			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, wellknown.HTTPRouteGVK)
 			if err != nil {
 				mirrorBackendErr = err
 			} else {
-				vs.Mirrors = append(vs.Mirrors, mirror)
+				vs.Mirrors = append(vs.GetMirrors(), mirror)
 			}
 		case k8s.HTTPRouteFilterURLRewrite:
 			vs.Rewrite = createRewriteFilter(filter.URLRewrite)
@@ -392,9 +391,9 @@ func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
 			PerTryTimeout: nil,
 			RetryOn:       strings.Join(retryOn, ","),
 		}
-		if vs.Retries.Attempts == 0 {
+		if vs.GetRetries().GetAttempts() == 0 {
 			// Invalid to set this when there are no attempts
-			vs.Retries.RetryOn = ""
+			vs.GetRetries().RetryOn = ""
 		}
 		//if r.Retry.Backoff != nil {
 		//	retrybackOff, _ := time.ParseDuration(string(*r.Retry.Backoff))
@@ -413,15 +412,15 @@ func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
 			backendRequest, _ := time.ParseDuration(string(*r.Timeouts.BackendRequest))
 			if backendRequest != 0 {
 				timeout := durationpb.New(backendRequest)
-				if vs.Retries != nil {
-					vs.Retries.PerTryTimeout = timeout
+				if vs.GetRetries() != nil {
+					vs.GetRetries().PerTryTimeout = timeout
 				} else {
 					vs.Timeout = timeout
 				}
 			}
 		}
 	}
-	if weightSum(r.BackendRefs) == 0 && vs.Redirect == nil {
+	if weightSum(r.BackendRefs) == 0 && vs.GetRedirect() == nil {
 		// The spec requires us to return 500 when there are no >0 weight backends
 		vs.DirectResponse = &istio.HTTPDirectResponse{
 			Status: 500,
@@ -470,7 +469,7 @@ func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
 		if err != nil {
 			return nil, err
 		}
-		vs.Match = append(vs.Match, &istio.HTTPMatchRequest{
+		vs.Match = append(vs.GetMatch(), &istio.HTTPMatchRequest{
 			Uri:     uri,
 			Headers: headers,
 		})
@@ -482,25 +481,25 @@ func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
 			if h == nil {
 				continue
 			}
-			if vs.Headers == nil {
+			if vs.GetHeaders() == nil {
 				vs.Headers = &istio.Headers{}
 			}
-			vs.Headers.Request = h
+			vs.GetHeaders().Request = h
 		case k8s.GRPCRouteFilterResponseHeaderModifier:
 			h := createHeadersFilter(filter.ResponseHeaderModifier)
 			if h == nil {
 				continue
 			}
-			if vs.Headers == nil {
+			if vs.GetHeaders() == nil {
 				vs.Headers = &istio.Headers{}
 			}
-			vs.Headers.Response = h
+			vs.GetHeaders().Response = h
 		case k8s.GRPCRouteFilterRequestMirror:
-			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, gvk.GRPCRoute)
+			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, wellknown.GRPCRouteGVK)
 			if err != nil {
 				return nil, err
 			}
-			vs.Mirrors = append(vs.Mirrors, mirror)
+			vs.Mirrors = append(vs.GetMirrors(), mirror)
 		default:
 			return nil, &ConfigError{
 				Reason:  InvalidFilter,
@@ -509,7 +508,7 @@ func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
 		}
 	}
 
-	if grpcWeightSum(r.BackendRefs) == 0 && vs.Redirect == nil {
+	if grpcWeightSum(r.BackendRefs) == 0 && vs.GetRedirect() == nil {
 		// The spec requires us to return 500 when there are no >0 weight backends
 		vs.DirectResponse = &istio.HTTPDirectResponse{
 			Status: 500,
@@ -526,76 +525,6 @@ func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
 	return vs, nil
 }
 
-func augmentPortMatch(routes []*istio.HTTPRoute, port k8s.PortNumber) []*istio.HTTPRoute {
-	res := make([]*istio.HTTPRoute, 0, len(routes))
-	for _, r := range routes {
-		r = r.DeepCopy()
-		for _, m := range r.Match {
-			m.Port = uint32(port)
-		}
-		if len(r.Match) == 0 {
-			r.Match = []*istio.HTTPMatchRequest{{
-				Port: uint32(port),
-			}}
-		}
-		res = append(res, r)
-	}
-	return res
-}
-
-func augmentTCPPortMatch(routes []*istio.TCPRoute, port k8s.PortNumber) []*istio.TCPRoute {
-	res := make([]*istio.TCPRoute, 0, len(routes))
-	for _, r := range routes {
-		r = r.DeepCopy()
-		for _, m := range r.Match {
-			m.Port = uint32(port)
-		}
-		if len(r.Match) == 0 {
-			r.Match = []*istio.L4MatchAttributes{{
-				Port: uint32(port),
-			}}
-		}
-		res = append(res, r)
-	}
-	return res
-}
-
-func augmentTLSPortMatch(routes []*istio.TLSRoute, port *k8s.PortNumber, parentHosts []string) []*istio.TLSRoute {
-	res := make([]*istio.TLSRoute, 0, len(routes))
-	for _, r := range routes {
-		r = r.DeepCopy()
-		if len(r.Match) == 1 && slices.Equal(r.Match[0].SniHosts, []string{"*"}) {
-			// For mesh, we use parent hosts for SNI if TLSRroute.hostnames were not specified.
-			r.Match[0].SniHosts = parentHosts
-		}
-		for _, m := range r.Match {
-			if port != nil {
-				m.Port = uint32(*port)
-			}
-		}
-		res = append(res, r)
-	}
-	return res
-}
-
-func compatibleRoutesForHost(routes []*istio.TLSRoute, parentHost string) []*istio.TLSRoute {
-	res := make([]*istio.TLSRoute, 0, len(routes))
-	for _, r := range routes {
-		if len(r.Match) == 1 && len(r.Match[0].SniHosts) > 1 {
-			r = r.DeepCopy()
-			sniHosts := []string{}
-			for _, h := range r.Match[0].SniHosts {
-				if host.Name(parentHost).Matches(host.Name(h)) {
-					sniHosts = append(sniHosts, h)
-				}
-			}
-			r.Match[0].SniHosts = sniHosts
-		}
-		res = append(res, r)
-	}
-	return res
-}
-
 func routeMeta(obj controllers.Object) map[string]string {
 	m := parentMeta(obj, nil)
 	m[constants.InternalRouteSemantics] = constants.RouteSemanticsGateway
@@ -606,13 +535,13 @@ func routeMeta(obj controllers.Object) map[string]string {
 // see https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.HTTPRouteRule
 func sortHTTPRoutes(routes []*istio.HTTPRoute) {
 	sort.SliceStable(routes, func(i, j int) bool {
-		if len(routes[i].Match) == 0 {
+		if len(routes[i].GetMatch()) == 0 {
 			return false
-		} else if len(routes[j].Match) == 0 {
+		} else if len(routes[j].GetMatch()) == 0 {
 			return true
 		}
 		// Only look at match[0], we always generate only one match
-		m1, m2 := routes[i].Match[0], routes[j].Match[0]
+		m1, m2 := routes[i].GetMatch()[0], routes[j].GetMatch()[0]
 		r1, r2 := getURIRank(m1), getURIRank(m2)
 		len1, len2 := getURILength(m1), getURILength(m2)
 		switch {
@@ -622,24 +551,24 @@ func sortHTTPRoutes(routes []*istio.HTTPRoute) {
 		case len1 != len2:
 			return len1 > len2
 			// 2: method math
-		case (m1.Method == nil) != (m2.Method == nil):
-			return m1.Method != nil
+		case (m1.GetMethod() == nil) != (m2.GetMethod() == nil):
+			return m1.GetMethod() != nil
 			// 3: number of header matches
-		case len(m1.Headers) != len(m2.Headers):
-			return len(m1.Headers) > len(m2.Headers)
+		case len(m1.GetHeaders()) != len(m2.GetHeaders()):
+			return len(m1.GetHeaders()) > len(m2.GetHeaders())
 			// 4: number of query matches
 		default:
-			return len(m1.QueryParams) > len(m2.QueryParams)
+			return len(m1.GetQueryParams()) > len(m2.GetQueryParams())
 		}
 	})
 }
 
 // getURIRank ranks a URI match type. Exact > Prefix > Regex
 func getURIRank(match *istio.HTTPMatchRequest) int {
-	if match.Uri == nil {
+	if match.GetUri() == nil {
 		return -1
 	}
-	switch match.Uri.MatchType.(type) {
+	switch match.GetUri().GetMatchType().(type) {
 	case *istio.StringMatch_Exact:
 		return 3
 	case *istio.StringMatch_Prefix:
@@ -652,16 +581,16 @@ func getURIRank(match *istio.HTTPMatchRequest) int {
 }
 
 func getURILength(match *istio.HTTPMatchRequest) int {
-	if match.Uri == nil {
+	if match.GetUri() == nil {
 		return 0
 	}
-	switch match.Uri.MatchType.(type) {
+	switch match.GetUri().GetMatchType().(type) {
 	case *istio.StringMatch_Prefix:
-		return len(match.Uri.GetPrefix())
+		return len(match.GetUri().GetPrefix())
 	case *istio.StringMatch_Exact:
-		return len(match.Uri.GetExact())
+		return len(match.GetUri().GetExact())
 	case *istio.StringMatch_Regex:
-		return len(match.Uri.GetRegex())
+		return len(match.GetUri().GetRegex())
 	}
 	// should not happen
 	return -1
@@ -688,14 +617,37 @@ func hostnameToStringList(h []k8s.Hostname) []string {
 }
 
 var allowedParentReferences = sets.New(
-	gvk.KubernetesGateway,
-	gvk.Service,
-	gvk.ServiceEntry,
+	wellknown.GatewayGVK,
+	wellknown.ServiceGVK,
+	wellknown.ServiceEntryGVK,
 )
 
+// normalizeReference normalizes group and kind references to a standard GVK format.
+// If group or kind are nil/empty, it uses the default GVK's group/kind.
+// Empty group is treated as "core" API group.
+func normalizeReference(group *k8s.Group, kind *k8s.Kind, defaultGVK schema.GroupVersionKind) schema.GroupVersionKind {
+	result := defaultGVK
+
+	if kind != nil && *kind != "" {
+		result.Kind = string(*kind)
+	}
+
+	if group != nil {
+		groupStr := string(*group)
+		if groupStr == "" {
+			// Empty group means "core" API group
+			result.Group = ""
+		} else {
+			result.Group = groupStr
+		}
+	}
+
+	return result
+}
+
 func toInternalParentReference(p k8s.ParentReference, localNamespace string) (parentKey, error) {
-	ref := normalizeReference(p.Group, p.Kind, gvk.KubernetesGateway)
-	if !allowedParentReferences.Contains(ref) {
+	ref := normalizeReference(p.Group, p.Kind, wellknown.GatewayGVK)
+	if !allowedParentReferences.Contains(wellknown.GatewayGVK) {
 		return parentKey{}, fmt.Errorf("unsupported parent: %v/%v", p.Group, p.Kind)
 	}
 	return parentKey{
@@ -717,12 +669,12 @@ func waypointConfigured(labels map[string]string) bool {
 func referenceAllowed(
 	ctx RouteContext,
 	parent *parentInfo,
-	routeKind config.GroupVersionKind,
+	routeKind schema.GroupVersionKind,
 	parentRef parentReference,
 	hostnames []k8s.Hostname,
 	localNamespace string,
 ) *ParentError {
-	if parentRef.Kind == gvk.Service {
+	if parentRef.Kind == wellknown.ServiceGVK {
 
 		key := parentRef.Namespace + "/" + parentRef.Name
 		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
@@ -734,7 +686,7 @@ func referenceAllowed(
 				Message: fmt.Sprintf("parent service: %q not found", parentRef.Name),
 			}
 		}
-	} else if parentRef.Kind == gvk.ServiceEntry {
+	} else if parentRef.Kind == wellknown.ServiceEntryGVK {
 		// check that the referenced svc entry exists
 		key := parentRef.Namespace + "/" + parentRef.Name
 		svcEntry := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.ServiceEntries, krt.FilterKey(key)))
@@ -808,7 +760,7 @@ func referenceAllowed(
 	// Also make sure this route kind is allowed
 	matched := false
 	for _, ak := range parent.AllowedKinds {
-		if string(ak.Kind) == routeKind.Kind && ptr.OrDefault((*string)(ak.Group), gvk.GatewayClass.Group) == routeKind.Group {
+		if string(ak.Kind) == routeKind.Kind && ptr.OrDefault((*string)(ak.Group), wellknown.GatewayClassGVK.Group) == routeKind.Group {
 			matched = true
 			break
 		}
@@ -838,9 +790,6 @@ func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj cont
 			Port:        ptr.OrEmpty(ref.Port),
 		}
 		gk := ir
-		if ir.Kind == gvk.Service || ir.Kind == gvk.ServiceEntry {
-			gk = meshParentKey
-		}
 		currentParents := parents.fetch(ctx.Krt, gk)
 		appendParent := func(pr *parentInfo, pk parentReference) {
 			bannedHostnames := sets.New[string]()
@@ -898,7 +847,7 @@ func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TC
 			}},
 		}, nil
 	}
-	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, gvk.TCPRoute)
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, wellknown.TCPRouteGVK)
 	if err != nil {
 		return nil, err
 	}
@@ -922,7 +871,7 @@ func convertTLSRoute(ctx RouteContext, r k8salpha.TLSRouteRule, obj *k8salpha.TL
 			}},
 		}, nil
 	}
-	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, gvk.TLSRoute)
+	dest, backendErr, err := buildTCPDestination(ctx, r.BackendRefs, obj.Namespace, wellknown.TLSRouteGVK)
 	if err != nil {
 		return nil, err
 	}
@@ -936,7 +885,7 @@ func buildTCPDestination(
 	ctx RouteContext,
 	forwardTo []k8s.BackendRef,
 	ns string,
-	k config.GroupVersionKind,
+	k schema.GroupVersionKind,
 ) ([]*istio.RouteDestination, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
 		return nil, nil, nil
@@ -1043,7 +992,7 @@ func buildHTTPDestination(
 	var invalidBackendErr *ConfigError
 	res := []*istio.HTTPRouteDestination{}
 	for i, fwd := range action {
-		dst, err := buildDestination(ctx, fwd.BackendRef, ns, gvk.HTTPRoute)
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, wellknown.HTTPRouteGVK)
 		if err != nil {
 			if isInvalidBackend(err) {
 				invalidBackendErr = err
@@ -1063,19 +1012,19 @@ func buildHTTPDestination(
 				if h == nil {
 					continue
 				}
-				if rd.Headers == nil {
+				if rd.GetHeaders() == nil {
 					rd.Headers = &istio.Headers{}
 				}
-				rd.Headers.Request = h
+				rd.GetHeaders().Request = h
 			case k8s.HTTPRouteFilterResponseHeaderModifier:
 				h := createHeadersFilter(filter.ResponseHeaderModifier)
 				if h == nil {
 					continue
 				}
-				if rd.Headers == nil {
+				if rd.GetHeaders() == nil {
 					rd.Headers = &istio.Headers{}
 				}
-				rd.Headers.Response = h
+				rd.GetHeaders().Response = h
 			default:
 				return nil, nil, &ConfigError{Reason: InvalidFilter, Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
 			}
@@ -1110,7 +1059,7 @@ func buildGRPCDestination(
 	var invalidBackendErr *ConfigError
 	res := []*istio.HTTPRouteDestination{}
 	for i, fwd := range action {
-		dst, err := buildDestination(ctx, fwd.BackendRef, ns, gvk.GRPCRoute)
+		dst, err := buildDestination(ctx, fwd.BackendRef, ns, wellknown.GRPCRouteGVK)
 		if err != nil {
 			if isInvalidBackend(err) {
 				invalidBackendErr = err
@@ -1130,19 +1079,19 @@ func buildGRPCDestination(
 				if h == nil {
 					continue
 				}
-				if rd.Headers == nil {
+				if rd.GetHeaders() == nil {
 					rd.Headers = &istio.Headers{}
 				}
-				rd.Headers.Request = h
+				rd.GetHeaders().Request = h
 			case k8s.GRPCRouteFilterResponseHeaderModifier:
 				h := createHeadersFilter(filter.ResponseHeaderModifier)
 				if h == nil {
 					continue
 				}
-				if rd.Headers == nil {
+				if rd.GetHeaders() == nil {
 					rd.Headers = &istio.Headers{}
 				}
-				rd.Headers.Response = h
+				rd.GetHeaders().Response = h
 			default:
 				return nil, nil, &ConfigError{Reason: InvalidFilter, Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
 			}
@@ -1152,7 +1101,7 @@ func buildGRPCDestination(
 	return res, invalidBackendErr, nil
 }
 
-func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, k config.GroupVersionKind) (*istio.Destination, *ConfigError) {
+func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, k schema.GroupVersionKind) (*istio.Destination, *ConfigError) {
 	// check if the reference is allowed
 	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
 		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
@@ -1166,9 +1115,9 @@ func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, k config.G
 	namespace := ptr.OrDefault((*string)(to.Namespace), ns)
 	var invalidBackendErr *ConfigError
 	var hostname string
-	ref := normalizeReference(to.Group, to.Kind, gvk.Service)
+	ref := normalizeReference(to.Group, to.Kind, wellknown.ServiceGVK)
 	switch ref {
-	//case gvk.InferencePool: // TODO: add validation
+	//case wellknown.InferencePoolGVK: // TODO: add validation
 	//	if strings.Contains(string(to.Name), ".") {
 	//		return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
 	//	}
@@ -1178,7 +1127,7 @@ func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, k config.G
 	//	if svc == nil {
 	//		invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
 	//	}
-	case gvk.Service:
+	case wellknown.ServiceGVK:
 		if strings.Contains(string(to.Name), ".") {
 			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
 		}
@@ -1188,15 +1137,13 @@ func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, k config.G
 		if svc == nil {
 			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
 		}
-	case config.GroupVersionKind{Group: gvk.ServiceEntry.Group, Kind: "Hostname"}:
+	case schema.GroupVersionKind{Group: wellknown.ServiceEntryGVK.Group, Kind: "Hostname"}:
 		if to.Namespace != nil {
 			return nil, &ConfigError{Reason: InvalidDestination, Message: "namespace may not be set with Hostname type"}
 		}
 		hostname = string(to.Name)
-		if ctx.LookupHostname(hostname, namespace) == nil {
-			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
-		}
-	case config.GroupVersionKind{Group: features.MCSAPIGroup, Kind: "ServiceImport"}:
+		// TODO: check hostname is valid
+	case schema.GroupVersionKind{Group: features.MCSAPIGroup, Kind: "ServiceImport"}:
 		hostname = fmt.Sprintf("%s.%s.svc.clusterset.local", to.Name, namespace)
 		if !features.EnableMCSHost {
 			// They asked for ServiceImport, but actually don't have full support enabled...
@@ -1251,7 +1198,7 @@ func headerListToMap(hl []k8s.HTTPHeader) map[string]string {
 }
 
 func createMirrorFilter(ctx RouteContext, filter *k8s.HTTPRequestMirrorFilter, ns string,
-	k config.GroupVersionKind,
+	k schema.GroupVersionKind,
 ) (*istio.HTTPMirrorPolicy, *ConfigError) {
 	if filter == nil {
 		return nil, nil
@@ -1282,7 +1229,7 @@ func createRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *istio.HTTPRewrite {
 		switch filter.Path.Type {
 		case k8s.PrefixMatchHTTPPathModifier:
 			rewrite.Uri = strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")
-			if rewrite.Uri == "" {
+			if rewrite.GetUri() == "" {
 				// `/` means removing the prefix
 				rewrite.Uri = "/"
 			}
@@ -1297,7 +1244,7 @@ func createRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *istio.HTTPRewrite {
 		rewrite.Authority = string(*filter.Hostname)
 	}
 	// Nothing done
-	if rewrite.Uri == "" && rewrite.UriRegexRewrite == nil && rewrite.Authority == "" {
+	if rewrite.GetUri() == "" && rewrite.GetUriRegexRewrite() == nil && rewrite.GetAuthority() == "" {
 		return nil
 	}
 	return rewrite
@@ -1315,7 +1262,7 @@ func createCorsFilter(filter *k8s.HTTPCORSFilter) *istio.CorsPolicy {
 		}
 
 		// TODO: support wildcards (https://github.com/kubernetes-sigs/gateway-api/issues/3648)
-		res.AllowOrigins = append(res.AllowOrigins, &istio.StringMatch{
+		res.AllowOrigins = append(res.GetAllowOrigins(), &istio.StringMatch{
 			MatchType: &istio.StringMatch_Exact{Exact: string(r)},
 		})
 	}
@@ -1323,13 +1270,13 @@ func createCorsFilter(filter *k8s.HTTPCORSFilter) *istio.CorsPolicy {
 		res.AllowCredentials = wrappers.Bool(true)
 	}
 	for _, r := range filter.AllowMethods {
-		res.AllowMethods = append(res.AllowMethods, string(r))
+		res.AllowMethods = append(res.GetAllowMethods(), string(r))
 	}
 	for _, r := range filter.AllowHeaders {
-		res.AllowHeaders = append(res.AllowHeaders, string(r))
+		res.AllowHeaders = append(res.GetAllowHeaders(), string(r))
 	}
 	for _, r := range filter.ExposeHeaders {
-		res.ExposeHeaders = append(res.ExposeHeaders, string(r))
+		res.ExposeHeaders = append(res.GetExposeHeaders(), string(r))
 	}
 	if filter.MaxAge > 0 {
 		res.MaxAge = durationpb.New(time.Duration(filter.MaxAge) * time.Second)
@@ -1588,21 +1535,10 @@ func (p parentReference) String() string {
 	return p.parentKey.String() + "/" + string(p.SectionName) + "/" + fmt.Sprint(p.Port)
 }
 
-var meshGVK = config.GroupVersionKind{
-	Group:   gvk.KubernetesGateway.Group,
-	Version: gvk.KubernetesGateway.Version,
-	Kind:    "Mesh",
-}
-
-var meshParentKey = parentKey{
-	Kind: meshGVK,
-	Name: "istio",
-}
-
 // parentInfo holds info about a "parent" - something that can be referenced as a ParentRef in the API.
-// Today, this is just Gateway and Mesh.
+// Today, this is just Gateway
 type parentInfo struct {
-	// InternalName refers to the internal name we can reference it by. For example, "mesh" or "my-ns/my-gateway"
+	// InternalName refers to the internal name we can reference it by. For example "my-ns/my-gateway"
 	InternalName string
 	// AllowedKinds indicates which kinds can be admitted by this parent
 	AllowedKinds []k8s.RouteGroupKind
@@ -1619,10 +1555,10 @@ type parentInfo struct {
 
 // routeParentReference holds information about a route's parent reference
 type routeParentReference struct {
-	// InternalName refers to the internal name of the parent we can reference it by. For example, "mesh" or "my-ns/my-gateway"
+	// InternalName refers to the internal name of the parent we can reference it by. For example "my-ns/my-gateway"
 	InternalName string
 	// InternalKind is the Group/Kind of the parent
-	InternalKind config.GroupVersionKind
+	InternalKind schema.GroupVersionKind
 	// DeniedReason, if present, indicates why the reference was not valid
 	DeniedReason *ParentError
 	// OriginalReference contains the original reference
@@ -1634,10 +1570,6 @@ type routeParentReference struct {
 	ParentSection   k8s.SectionName
 }
 
-func (r routeParentReference) IsMesh() bool {
-	return r.InternalName == "mesh"
-}
-
 func (r routeParentReference) hostnameAllowedByIsolation(rawRouteHost string) bool {
 	routeHost := host.Name(rawRouteHost)
 	ourListener := host.Name(r.Hostname)
@@ -1710,144 +1642,6 @@ func getListenerNames(spec *k8s.GatewaySpec) sets.Set[k8s.SectionName] {
 	return res
 }
 
-func reportGatewayStatus(
-	r *GatewayContext,
-	obj *k8sbeta.Gateway,
-	gs *k8sbeta.GatewayStatus,
-	classInfo classInfo,
-	gatewayServices []string,
-	servers []*istio.Server,
-	gatewayErr *ConfigError,
-) {
-	// TODO: we lose address if servers is empty due to an error
-	internal, internalIP, external, pending, warnings, allUsable := r.ResolveGatewayInstances(obj.Namespace, gatewayServices, servers)
-
-	// Setup initial conditions to the success state. If we encounter errors, we will update this.
-	// We have two status
-	// Accepted: is the configuration valid. We only have errors in listeners, and the status is not supposed to
-	// be tied to listeners, so this is always accepted
-	// Programmed: is the data plane "ready" (note: eventually consistent)
-	gatewayConditions := map[string]*condition{
-		string(k8s.GatewayConditionAccepted): {
-			reason:  string(k8s.GatewayReasonAccepted),
-			message: "Resource accepted",
-		},
-		string(k8s.GatewayConditionProgrammed): {
-			reason:  string(k8s.GatewayReasonProgrammed),
-			message: "Resource programmed",
-		},
-	}
-
-	if gatewayErr != nil {
-		gatewayConditions[string(k8s.GatewayConditionAccepted)].error = gatewayErr
-	}
-
-	if len(internal) > 0 {
-		msg := fmt.Sprintf("Resource programmed, assigned to service(s) %s", humanReadableJoin(internal))
-		gatewayConditions[string(k8s.GatewayConditionProgrammed)].message = msg
-	}
-
-	if len(gatewayServices) == 0 {
-		gatewayConditions[string(k8s.GatewayConditionProgrammed)].error = &ConfigError{
-			Reason:  InvalidAddress,
-			Message: "Failed to assign to any requested addresses",
-		}
-	} else if len(warnings) > 0 {
-		var msg string
-		var reason string
-		if len(internal) != 0 {
-			msg = fmt.Sprintf("Assigned to service(s) %s, but failed to assign to all requested addresses: %s",
-				humanReadableJoin(internal), strings.Join(warnings, "; "))
-		} else {
-			msg = fmt.Sprintf("Failed to assign to any requested addresses: %s", strings.Join(warnings, "; "))
-		}
-		if allUsable {
-			reason = string(k8s.GatewayReasonAddressNotAssigned)
-		} else {
-			reason = string(k8s.GatewayReasonAddressNotUsable)
-		}
-		gatewayConditions[string(k8s.GatewayConditionProgrammed)].error = &ConfigError{
-			// TODO: this only checks Service ready, we should also check Deployment ready?
-			Reason:  reason,
-			Message: msg,
-		}
-	}
-
-	addressesToReport := external
-	if len(addressesToReport) == 0 {
-		wantAddressType := classInfo.addressType
-		if override, ok := obj.Annotations[addressTypeOverride]; ok {
-			wantAddressType = k8s.AddressType(override)
-		}
-		// There are no external addresses, so report the internal ones
-		// This can be IP, Hostname, or both (indicated by empty wantAddressType)
-		if wantAddressType != k8s.HostnameAddressType {
-			addressesToReport = internalIP
-		}
-		if wantAddressType != k8s.IPAddressType {
-			for _, hostport := range internal {
-				svchost, _, _ := net.SplitHostPort(hostport)
-				if !slices.Contains(pending, svchost) && !slices.Contains(addressesToReport, svchost) {
-					addressesToReport = append(addressesToReport, svchost)
-				}
-			}
-		}
-	}
-	// Do not report an address until we are ready. But once we are ready, never remove the address.
-	if len(addressesToReport) > 0 {
-		gs.Addresses = make([]k8s.GatewayStatusAddress, 0, len(addressesToReport))
-		for _, addr := range addressesToReport {
-			var addrType k8s.AddressType
-			if _, err := netip.ParseAddr(addr); err == nil {
-				addrType = k8s.IPAddressType
-			} else {
-				addrType = k8s.HostnameAddressType
-			}
-			gs.Addresses = append(gs.Addresses, k8s.GatewayStatusAddress{
-				Value: addr,
-				Type:  &addrType,
-			})
-		}
-	}
-	// Prune listeners that have been removed
-	haveListeners := getListenerNames(&obj.Spec)
-	listeners := make([]k8s.ListenerStatus, 0, len(gs.Listeners))
-	for _, l := range gs.Listeners {
-		if haveListeners.Contains(l.Name) {
-			haveListeners.Delete(l.Name)
-			listeners = append(listeners, l)
-		}
-	}
-	gs.Listeners = listeners
-	gs.Conditions = setConditions(obj.Generation, gs.Conditions, gatewayConditions)
-}
-
-// reportUnmanagedGatewayStatus reports a status message for an unmanaged gateway.
-// For these gateways, we don't deploy them. However, all gateways ought to have a status message, even if its basically
-// just to say something read it
-func reportUnmanagedGatewayStatus(
-	status *k8sbeta.GatewayStatus,
-	obj *k8sbeta.Gateway,
-) {
-	gatewayConditions := map[string]*condition{
-		string(k8s.GatewayConditionAccepted): {
-			reason:  string(k8s.GatewayReasonAccepted),
-			message: "Resource accepted",
-		},
-		string(k8s.GatewayConditionProgrammed): {
-			reason: string(k8s.GatewayReasonProgrammed),
-			// Set to true anyway since this is basically declaring it as valid
-			message: "This Gateway is remote; Istio will not program it",
-		},
-	}
-
-	status.Addresses = slices.Map(obj.Spec.Addresses, func(e k8s.GatewaySpecAddress) k8s.GatewayStatusAddress {
-		return k8s.GatewayStatusAddress(e)
-	})
-	status.Listeners = nil
-	status.Conditions = setConditions(obj.Generation, status.Conditions, gatewayConditions)
-}
-
 // IsManaged checks if a Gateway is managed (ie we create the Deployment and Service) or unmanaged.
 // This is based on the address field of the spec. If address is set with a Hostname type, it should point to an existing
 // Service that handles the gateway traffic. If it is not set, or refers to only a single IP, we will consider it managed and provision the Service.
@@ -1969,7 +1763,7 @@ func buildListener(
 	}
 
 	hostnames := buildHostnameMatch(ctx, obj.Namespace, namespaces, l)
-	protocol, perr := listenerProtocolToIstio(controllerName, l.Protocol)
+	protocol, perr := listenerProtocolToAgentgateway(controllerName, l.Protocol)
 	if perr != nil {
 		listenerConditions[string(k8s.ListenerConditionAccepted)].error = &ConfigError{
 			Reason:  string(k8s.ListenerReasonUnsupportedProtocol),
@@ -1977,14 +1771,6 @@ func buildListener(
 		}
 		ok = false
 	}
-	if controllerName == constants.ManagedGatewayMeshController {
-		if unexpectedWaypointListener(l) {
-			listenerConditions[string(k8s.ListenerConditionAccepted)].error = &ConfigError{
-				Reason:  string(k8s.ListenerReasonUnsupportedProtocol),
-				Message: `Expected a single listener on port 15008 with protocol "HBONE"`,
-			}
-		}
-	}
 	server := &istio.Server{
 		Port: &istio.Port{
 			// Name is required. We only have one server per Gateway, so we can just name them all the same
@@ -2007,7 +1793,7 @@ var supportedProtocols = sets.New(
 	k8s.TCPProtocolType,
 	k8s.ProtocolType(protocol.HBONE))
 
-func listenerProtocolToIstio(name k8s.GatewayController, p k8s.ProtocolType) (string, error) {
+func listenerProtocolToAgentgateway(name k8s.GatewayController, p k8s.ProtocolType) (string, error) {
 	switch p {
 	// Standard protocol types
 	case k8s.HTTPProtocolType:
@@ -2019,12 +1805,6 @@ func listenerProtocolToIstio(name k8s.GatewayController, p k8s.ProtocolType) (st
 			return "", fmt.Errorf("protocol %q is supported, but only when %v=true is configured", p, features.EnableAlphaGatewayAPIName)
 		}
 		return string(p), nil
-	// Our own custom types
-	case k8s.ProtocolType(protocol.HBONE):
-		if name != constants.ManagedGatewayMeshController {
-			return "", fmt.Errorf("protocol %q is only supported for waypoint proxies", p)
-		}
-		return string(p), nil
 	}
 	up := k8s.ProtocolType(strings.ToUpper(string(p)))
 	if supportedProtocols.Contains(up) {
@@ -2103,7 +1883,7 @@ func buildSecretReference(
 	gw *k8sbeta.Gateway,
 	secrets krt.Collection[*corev1.Secret],
 ) (string, TLSInfo, *ConfigError) {
-	if normalizeReference(ref.Group, ref.Kind, gvk.Secret) != gvk.Secret {
+	if normalizeReference(ref.Group, ref.Kind, wellknown.SecretGVK) != wellknown.SecretGVK {
 		return "", TLSInfo{}, &ConfigError{Reason: InvalidTLS, Message: fmt.Sprintf("invalid certificate reference %v, only secret is allowed", objectReferenceString(ref))}
 	}
 
@@ -2249,19 +2029,19 @@ func toNamespaceSet(name string, labels map[string]string) klabels.Set {
 	return ret
 }
 
-func GetCommonRouteInfo(spec any) ([]k8s.ParentReference, []k8s.Hostname, config.GroupVersionKind) {
+func GetCommonRouteInfo(spec any) ([]k8s.ParentReference, []k8s.Hostname, schema.GroupVersionKind) {
 	switch t := spec.(type) {
 	case *k8salpha.TCPRoute:
-		return t.Spec.ParentRefs, nil, gvk.TCPRoute
+		return t.Spec.ParentRefs, nil, wellknown.TCPRouteGVK
 	case *k8salpha.TLSRoute:
-		return t.Spec.ParentRefs, t.Spec.Hostnames, gvk.TLSRoute
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.TLSRouteGVK
 	case *k8sbeta.HTTPRoute:
-		return t.Spec.ParentRefs, t.Spec.Hostnames, gvk.HTTPRoute
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.HTTPRouteGVK
 	case *k8s.GRPCRoute:
-		return t.Spec.ParentRefs, t.Spec.Hostnames, gvk.GRPCRoute
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.GRPCRouteGVK
 	default:
 		log.Fatalf("unknown type %T", t)
-		return nil, nil, config.GroupVersionKind{}
+		return nil, nil, schema.GroupVersionKind{}
 	}
 }
 
@@ -2288,7 +2068,7 @@ func defaultString[T ~string](s *T, def string) string {
 	return string(*s)
 }
 
-func toRouteKind(g config.GroupVersionKind) k8s.RouteGroupKind {
+func toRouteKind(g schema.GroupVersionKind) k8s.RouteGroupKind {
 	return k8s.RouteGroupKind{Group: (*k8s.Group)(&g.Group), Kind: k8s.Kind(g.Kind)}
 }
 
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/const.go b/internal/kgateway/agentgatewaysyncer/gateway/const.go
deleted file mode 100644
index 2442b6413..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/const.go
+++ /dev/null
@@ -1,6 +0,0 @@
-package gateway
-
-const (
-	TargetTypeResourceUrl = "type.googleapis.com/istio.adp.Resource"
-	TargetTypeAddressUrl  = "type.googleapis.com/istio.workload.Address"
-)
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/context.go b/internal/kgateway/agentgatewaysyncer/gateway/context.go
deleted file mode 100644
index 5519c3620..000000000
--- a/internal/kgateway/agentgatewaysyncer/gateway/context.go
+++ /dev/null
@@ -1,160 +0,0 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
-
-import (
-	"fmt"
-	"sort"
-	"strconv"
-	"strings"
-
-	corev1 "k8s.io/api/core/v1"
-
-	"istio.io/api/label"
-	networking "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/model"
-	"istio.io/istio/pkg/cluster"
-	"istio.io/istio/pkg/config/host"
-	"istio.io/istio/pkg/util/sets"
-)
-
-// GatewayContext contains a minimal subset of push context functionality to be exposed to GatewayAPIControllers
-type GatewayContext struct {
-	ps      *model.PushContext
-	cluster cluster.ID
-}
-
-func NewGatewayContext(ps *model.PushContext, cluster cluster.ID) GatewayContext {
-	return GatewayContext{ps, cluster}
-}
-
-// ResolveGatewayInstances attempts to resolve all instances that a gateway will be exposed on.
-// Note: this function considers *all* instances of the service; its possible those instances will not actually be properly functioning
-// gateways, so this is not 100% accurate, but sufficient to expose intent to users.
-// The actual configuration generation is done on a per-workload basis and will get the exact set of matched instances for that workload.
-// Four sets are exposed:
-// * Internal addresses (eg istio-ingressgateway.istio-system.svc.cluster.local:80).
-// * Internal IP addresses (eg 1.2.3.4). This comes from ClusterIP.
-// * External addresses (eg 1.2.3.4), this comes from LoadBalancer services. There may be multiple in some cases (especially multi cluster).
-// * Pending addresses (eg istio-ingressgateway.istio-system.svc), are LoadBalancer-type services with pending external addresses.
-// * Warnings for references that could not be resolved. These are intended to be user facing.
-func (gc GatewayContext) ResolveGatewayInstances(
-	namespace string,
-	gwsvcs []string,
-	servers []*networking.Server,
-) (internal, internalIP, external, pending, warns []string, allUsable bool) {
-	ports := map[int]struct{}{}
-	for _, s := range servers {
-		ports[int(s.Port.Number)] = struct{}{}
-	}
-	foundInternal := sets.New[string]()
-	foundInternalIP := sets.New[string]()
-	foundExternal := sets.New[string]()
-	foundPending := sets.New[string]()
-	warnings := []string{}
-	foundUnusable := false
-	logger.Debug("Resolving gateway instances for gateway service", "svc", gwsvcs, "ns", namespace)
-	for _, g := range gwsvcs {
-		svc, f := gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(g)][namespace]
-		if !f {
-			otherNamespaces := []string{}
-			for ns := range gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(g)] {
-				otherNamespaces = append(otherNamespaces, `"`+ns+`"`) // Wrap in quotes for output
-			}
-			if len(otherNamespaces) > 0 {
-				sort.Strings(otherNamespaces)
-				warnings = append(warnings, fmt.Sprintf("hostname %q not found in namespace %q, but it was found in namespace(s) %v",
-					g, namespace, strings.Join(otherNamespaces, ", ")))
-			} else {
-				warnings = append(warnings, fmt.Sprintf("hostname %q not found", g))
-			}
-			foundUnusable = true
-			continue
-		}
-		svcKey := svc.Key()
-		for port := range ports {
-			instances := gc.ps.ServiceEndpointsByPort(svc, port, nil)
-			if len(instances) > 0 {
-				foundInternal.Insert(fmt.Sprintf("%s:%d", g, port))
-				dummyProxy := &model.Proxy{Metadata: &model.NodeMetadata{ClusterID: gc.cluster}}
-				dummyProxy.SetIPMode(model.Dual)
-				foundInternalIP.InsertAll(svc.GetAllAddressesForProxy(dummyProxy)...)
-				if svc.Attributes.ClusterExternalAddresses.Len() > 0 {
-					// Fetch external IPs from all clusters
-					svc.Attributes.ClusterExternalAddresses.ForEach(func(c cluster.ID, externalIPs []string) {
-						foundExternal.InsertAll(externalIPs...)
-					})
-				} else if corev1.ServiceType(svc.Attributes.Type) == corev1.ServiceTypeLoadBalancer {
-					if !foundPending.Contains(g) {
-						warnings = append(warnings, fmt.Sprintf("address pending for hostname %q", g))
-						foundPending.Insert(g)
-					}
-				}
-			} else {
-				instancesByPort := gc.ps.ServiceEndpoints(svcKey)
-				if instancesEmpty(instancesByPort) {
-					warnings = append(warnings, fmt.Sprintf("no instances found for hostname %q", g))
-				} else {
-					hintPort := sets.New[string]()
-					for servicePort, instances := range instancesByPort {
-						for _, i := range instances {
-							if i.EndpointPort == uint32(port) {
-								hintPort.Insert(strconv.Itoa(servicePort))
-							}
-						}
-					}
-					if hintPort.Len() > 0 {
-						warnings = append(warnings, fmt.Sprintf(
-							"port %d not found for hostname %q (hint: the service port should be specified, not the workload port. Did you mean one of these ports: %v?)",
-							port, g, sets.SortedList(hintPort)))
-						foundUnusable = true
-					} else {
-						_, isManaged := svc.Attributes.Labels[label.GatewayManaged.Name]
-						var portExistsOnService bool
-						for _, p := range svc.Ports {
-							if p.Port == port {
-								portExistsOnService = true
-								break
-							}
-						}
-						// If this is a managed gateway, the only possible explanation for no instances for the port
-						// is a delay in endpoint sync. Therefore, we don't want to warn/change the Programmed condition
-						// in this case as long as the port exists on the `Service` object.
-						if !isManaged || !portExistsOnService {
-							warnings = append(warnings, fmt.Sprintf("port %d not found for hostname %q", port, g))
-							foundUnusable = true
-						}
-					}
-				}
-			}
-		}
-	}
-	sort.Strings(warnings)
-	return sets.SortedList(foundInternal), sets.SortedList(foundInternalIP), sets.SortedList(foundExternal), sets.SortedList(foundPending),
-		warnings, !foundUnusable
-}
-
-func (gc GatewayContext) GetService(hostname, namespace string) *model.Service {
-	return gc.ps.ServiceIndex.HostnameAndNamespace[host.Name(hostname)][namespace]
-}
-
-func instancesEmpty(m map[int][]*model.IstioEndpoint) bool {
-	for _, instances := range m {
-		if len(instances) > 0 {
-			return false
-		}
-	}
-	return true
-}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
similarity index 77%
rename from internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
rename to internal/kgateway/agentgatewaysyncer/gateway_collection.go
index feeea3fee..b76b2b840 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
@@ -1,33 +1,19 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
+package agentgatewaysyncer
 
 import (
 	"fmt"
 
 	"github.com/agentgateway/agentgateway/go/api"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-	"istio.io/istio/pkg/config/constants"
 	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+
 	istio "istio.io/api/networking/v1alpha3"
 	"istio.io/istio/pilot/pkg/util/protoconv"
-	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/ptr"
 	"istio.io/istio/pkg/slices"
@@ -160,7 +146,7 @@ func GatewayCollection(
 			gatewayConfig := Config{
 				Meta: Meta{
 					CreationTimestamp: obj.CreationTimestamp.Time,
-					GroupVersionKind:  GroupVersionKind{Group: wellknown.GatewayGroup, Kind: wellknown.GatewayKind},
+					GroupVersionKind:  schema.GroupVersionKind{Group: wellknown.GatewayGroup, Kind: wellknown.GatewayKind},
 					Name:              InternalGatewayName(obj.Name, string(l.Name)),
 					Annotations:       meta,
 					Namespace:         obj.Namespace,
@@ -173,14 +159,14 @@ func GatewayCollection(
 
 			allowed, _ := generateSupportedKinds(l)
 			ref := parentKey{
-				Kind:      gvk.KubernetesGateway,
+				Kind:      wellknown.GatewayGVK,
 				Name:      obj.Name,
 				Namespace: obj.Namespace,
 			}
 			pri := parentInfo{
 				InternalName:     obj.Namespace + "/" + gatewayConfig.Name,
 				AllowedKinds:     allowed,
-				Hostnames:        server.Hosts,
+				Hostnames:        server.GetHosts(),
 				OriginalHostname: string(ptr.OrEmpty(l.Hostname)),
 				SectionName:      l.Name,
 				Port:             l.Port,
@@ -210,21 +196,6 @@ type RouteParents struct {
 }
 
 func (p RouteParents) fetch(ctx krt.HandlerContext, pk parentKey) []*parentInfo {
-	if pk == meshParentKey {
-		// Special case
-		return []*parentInfo{
-			{
-				InternalName: "mesh",
-				// Mesh has no configurable AllowedKinds, so allow all supported
-				AllowedKinds: []gateway.RouteGroupKind{
-					{Group: (*gateway.Group)(ptr.Of(gvk.HTTPRoute.Group)), Kind: gateway.Kind(gvk.HTTPRoute.Kind)},
-					{Group: (*gateway.Group)(ptr.Of(gvk.GRPCRoute.Group)), Kind: gateway.Kind(gvk.GRPCRoute.Kind)},
-					{Group: (*gateway.Group)(ptr.Of(gvk.TCPRoute.Group)), Kind: gateway.Kind(gvk.TCPRoute.Kind)},
-					{Group: (*gateway.Group)(ptr.Of(gvk.TLSRoute.Group)), Kind: gateway.Kind(gvk.TLSRoute.Kind)},
-				},
-			},
-		}
-	}
 	return slices.Map(krt.Fetch(ctx, p.gateways, krt.FilterIndex(p.gatewayIndex, pk)), func(gw Gateway) *parentInfo {
 		return &gw.parentInfo
 	})
@@ -245,5 +216,5 @@ func BuildRouteParents(
 // InternalGatewayName returns the name of the internal Istio Gateway corresponding to the
 // specified gateway-api gateway and listener.
 func InternalGatewayName(gwName, lName string) string {
-	return fmt.Sprintf("%s-%s-%s", gwName, constants.KubernetesGatewayName, lName)
+	return fmt.Sprintf("%s-%s-%s", gwName, AgentgatewayName, lName)
 }
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
similarity index 73%
rename from internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
rename to internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
index 808af3df2..77313b789 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/gatewayclass_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
@@ -1,15 +1,18 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"istio.io/istio/pkg/kube/krt"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 )
 
 type GatewayClass struct {
-	Name string
+	Name       string
+	Controller gateway.GatewayController
 }
 
 func (g GatewayClass) ResourceName() string {
@@ -22,7 +25,8 @@ func GatewayClassesCollection(
 ) krt.Collection[GatewayClass] {
 	return krt.NewCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gateway.GatewayClass) *GatewayClass {
 		return &GatewayClass{
-			Name: obj.Name,
+			Name:       obj.Name,
+			Controller: obj.Spec.ControllerName,
 		}
 	}, krtopts.ToOptions("GatewayClasses")...)
 }
@@ -31,7 +35,8 @@ func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayCla
 	class := krt.FetchOne(ctx, gatewayClasses, krt.FilterKey(string(gc)))
 	if class == nil {
 		return &GatewayClass{
-			Name: string(gc),
+			Name:       string(gc),
+			Controller: wellknown.GatewayControllerName, // TODO: make this configurable
 		}
 	}
 	return class
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/model.go b/internal/kgateway/agentgatewaysyncer/model.go
similarity index 57%
rename from internal/kgateway/agentgatewaysyncer/gateway/model.go
rename to internal/kgateway/agentgatewaysyncer/model.go
index 64ba6082c..11a0880c7 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/model.go
+++ b/internal/kgateway/agentgatewaysyncer/model.go
@@ -1,4 +1,4 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"cmp"
@@ -8,26 +8,23 @@ import (
 	"reflect"
 	"slices"
 	"sort"
-	"strings"
 	"time"
 
 	"github.com/agentgateway/agentgateway/go/api"
 	udpa "github.com/cncf/xds/go/udpa/type/v1"
+	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
 	gogoproto "github.com/gogo/protobuf/proto"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/reflect/protoreflect"
-	"google.golang.org/protobuf/types/known/structpb"
-	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/schema/kind"
-	pm "istio.io/istio/pkg/model"
 	"istio.io/istio/pkg/util/hash"
-	netutil "istio.io/istio/pkg/util/net"
 	"istio.io/istio/pkg/util/protomarshal"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/utils/ptr"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 )
 
 // Statically link protobuf descriptors from UDPA
@@ -58,116 +55,6 @@ func (key ConfigKey) String() string {
 	return key.Kind.String() + "/" + key.Namespace + "/" + key.Name
 }
 
-// ResolveShortnameToFQDN uses metadata information to resolve a reference
-// to shortname of the service to FQDN
-func ResolveShortnameToFQDN(hostname string, meta Meta) host.Name {
-	if len(hostname) == 0 {
-		// only happens when the gateway-api BackendRef is invalid
-		return ""
-	}
-	out := hostname
-	// Treat the wildcard hostname as fully qualified. Any other variant of a wildcard hostname will contain a `.` too,
-	// and skip the next if, so we only need to check for the literal wildcard itself.
-	if hostname == "*" {
-		return host.Name(out)
-	}
-
-	// if the hostname is a valid ipv4 or ipv6 address, do not append domain or namespace
-	if netutil.IsValidIPAddress(hostname) {
-		return host.Name(out)
-	}
-
-	// if FQDN is specified, do not append domain or namespace to hostname
-	if !strings.Contains(hostname, ".") {
-		if meta.Namespace != "" {
-			out = out + "." + meta.Namespace
-		}
-
-		// FIXME this is a gross hack to hardcode a service's domain name in kubernetes
-		// BUG this will break non kubernetes environments if they use shortnames in the
-		// rules.
-		if meta.Domain != "" {
-			out = out + ".svc." + meta.Domain
-		}
-	}
-
-	return host.Name(out)
-}
-
-// resolveGatewayName uses metadata information to resolve a reference
-// to shortname of the gateway to FQDN
-func resolveGatewayName(gwname string, meta Meta) string {
-	out := gwname
-
-	// New way of binding to a gateway in remote namespace
-	// is ns/name. Old way is either FQDN or short name
-	if !strings.Contains(gwname, "/") {
-		if !strings.Contains(gwname, ".") {
-			// we have a short name. Resolve to a gateway in same namespace
-			out = meta.Namespace + "/" + gwname
-		} else {
-			// parse namespace from FQDN. This is very hacky, but meant for backward compatibility only
-			// This is a legacy FQDN format. Transform name.ns.svc.cluster.local -> ns/name
-			i := strings.Index(gwname, ".")
-			fqdn := strings.Index(gwname[i+1:], ".")
-			if fqdn == -1 {
-				out = gwname[i+1:] + "/" + gwname[:i]
-			} else {
-				out = gwname[i+1:i+1+fqdn] + "/" + gwname[:i]
-			}
-		}
-	} else {
-		// remove the . from ./gateway and substitute it with the namespace name
-		i := strings.Index(gwname, "/")
-		if gwname[:i] == "." {
-			out = meta.Namespace + "/" + gwname[i+1:]
-		}
-	}
-	return out
-}
-
-// MostSpecificHostMatch compares the maps of specific and wildcard hosts to the needle, and returns the longest element
-// matching the needle, and it's value, or false if no element in the maps matches the needle.
-func MostSpecificHostMatch[V any](needle host.Name, specific map[host.Name]V, wildcard map[host.Name]V) (host.Name, V, bool) {
-	if needle.IsWildCarded() {
-		// exact match first
-		if v, ok := wildcard[needle]; ok {
-			return needle, v, true
-		}
-
-		return mostSpecificHostWildcardMatch(string(needle[1:]), wildcard)
-	}
-
-	// exact match first
-	if v, ok := specific[needle]; ok {
-		return needle, v, true
-	}
-
-	// check wildcard
-	return mostSpecificHostWildcardMatch(string(needle), wildcard)
-}
-
-func mostSpecificHostWildcardMatch[V any](needle string, wildcard map[host.Name]V) (host.Name, V, bool) {
-	found := false
-	var matchHost host.Name
-	var matchValue V
-
-	for h, v := range wildcard {
-		if strings.HasSuffix(needle, string(h[1:])) {
-			if !found {
-				matchHost = h
-				matchValue = wildcard[h]
-				found = true
-			} else if host.MoreSpecific(h, matchHost) {
-				matchHost = h
-				matchValue = v
-			}
-		}
-	}
-
-	return matchHost, matchValue, found
-}
-
 // sortConfigByCreationTime sorts the list of config objects in ascending order by their creation time (if available)
 func sortConfigByCreationTime(configs []Config) []Config {
 	sort.Slice(configs, func(i, j int) bool {
@@ -185,107 +72,42 @@ func sortConfigByCreationTime(configs []Config) []Config {
 	return configs
 }
 
-type (
-	Node                    = pm.Node
-	NodeMetadata            = pm.NodeMetadata
-	NodeMetaProxyConfig     = pm.NodeMetaProxyConfig
-	NodeType                = pm.NodeType
-	BootstrapNodeMetadata   = pm.BootstrapNodeMetadata
-	TrafficInterceptionMode = pm.TrafficInterceptionMode
-	PodPort                 = pm.PodPort
-	StringBool              = pm.StringBool
-	IPMode                  = pm.IPMode
-)
-
-const (
-	SidecarProxy = pm.SidecarProxy
-	Router       = pm.Router
-	Waypoint     = pm.Waypoint
-	Ztunnel      = pm.Ztunnel
-
-	IPv4 = pm.IPv4
-	IPv6 = pm.IPv6
-	Dual = pm.Dual
-)
+type ADPCacheResource struct {
+	Gateway types.NamespacedName `json:"gateway"`
+	reports reports.ReportMap
 
-// ParseMetadata parses the opaque Metadata from an Envoy Node into string key-value pairs.
-// Any non-string values are ignored.
-func ParseMetadata(metadata *structpb.Struct) (*NodeMetadata, error) {
-	if metadata == nil {
-		return &NodeMetadata{}, nil
-	}
+	Resources envoycache.Resources
+	Addresses envoycache.Resources
 
-	bootstrapNodeMeta, err := ParseBootstrapNodeMetadata(metadata)
-	if err != nil {
-		return nil, err
-	}
-	return &bootstrapNodeMeta.NodeMetadata, nil
+	VersionMap map[string]map[string]string
 }
 
-// ParseBootstrapNodeMetadata parses the opaque Metadata from an Envoy Node into string key-value pairs.
-func ParseBootstrapNodeMetadata(metadata *structpb.Struct) (*BootstrapNodeMetadata, error) {
-	if metadata == nil {
-		return &BootstrapNodeMetadata{}, nil
-	}
-
-	b, err := protomarshal.MarshalProtoNames(metadata)
-	if err != nil {
-		return nil, fmt.Errorf("failed to read node metadata %v: %v", metadata, err)
-	}
-	meta := &BootstrapNodeMetadata{}
-	if err := json.Unmarshal(b, meta); err != nil {
-		return nil, fmt.Errorf("failed to unmarshal node metadata (%v): %v", string(b), err)
-	}
-	return meta, nil
+func (r ADPCacheResource) ResourceName() string {
+	return fmt.Sprintf("%s~%s", r.Gateway.Namespace, r.Gateway.Name)
 }
 
-const (
-	serviceNodeSeparator = "~"
-)
-
-// hasValidIPAddresses returns true if the input ips are all valid, otherwise returns false.
-func hasValidIPAddresses(ipAddresses []string) bool {
-	if len(ipAddresses) == 0 {
-		return false
-	}
-	for _, ipAddress := range ipAddresses {
-		if !netutil.IsValidIPAddress(ipAddress) {
-			return false
-		}
-	}
-	return true
+func (r ADPCacheResource) Equals(in ADPCacheResource) bool {
+	return r.Gateway == in.Gateway &&
+		report{r.reports}.Equals(report{in.reports}) &&
+		r.Resources.Version == in.Resources.Version &&
+		r.Addresses.Version == in.Addresses.Version
 }
 
-const (
-	// InterceptionNone indicates that the workload is not using IPtables for traffic interception
-	InterceptionNone TrafficInterceptionMode = "NONE"
-
-	// InterceptionTproxy implies traffic intercepted by IPtables with TPROXY mode
-	InterceptionTproxy TrafficInterceptionMode = "TPROXY"
-
-	// InterceptionRedirect implies traffic intercepted by IPtables with REDIRECT mode
-	// This is our default mode
-	InterceptionRedirect TrafficInterceptionMode = "REDIRECT"
-)
-
 type ADPResource struct {
 	Resource *api.Resource        `json:"resource"`
 	Gateway  types.NamespacedName `json:"gateway"`
 
-	// TODO: separate addresses?
-	Address *api.Address `json:"address"`
-
 	reports reports.ReportMap
 }
 
 func (g ADPResource) ResourceName() string {
-	switch t := g.Resource.Kind.(type) {
+	switch t := g.Resource.GetKind().(type) {
 	case *api.Resource_Bind:
-		return "bind/" + t.Bind.Key
+		return "bind/" + t.Bind.GetKey()
 	case *api.Resource_Listener:
-		return "listener/" + t.Listener.Key
+		return "listener/" + t.Listener.GetKey()
 	case *api.Resource_Route:
-		return "route/" + t.Route.Key
+		return "route/" + t.Route.GetKey()
 	}
 	panic("unknown resource kind")
 }
@@ -300,7 +122,7 @@ func (g ADPResource) Equals(other ADPResource) bool {
 type Meta struct {
 	// GroupVersionKind is a short configuration name that matches the content message type
 	// (e.g. "route-rule")
-	GroupVersionKind GroupVersionKind `json:"type,omitempty"`
+	GroupVersionKind schema.GroupVersionKind `json:"type,omitempty"`
 
 	// UID
 	UID string `json:"uid,omitempty"`
@@ -361,23 +183,11 @@ type Config struct {
 	Status Status
 }
 
-type Namer interface {
-	GetName() string
-	GetNamespace() string
-}
-
 type TypedResource struct {
 	Kind schema.GroupVersionKind
 	Name types.NamespacedName
 }
 
-func NamespacedName[T Namer](o T) types.NamespacedName {
-	return types.NamespacedName{
-		Namespace: o.GetNamespace(),
-		Name:      o.GetName(),
-	}
-}
-
 // Spec defines the spec for the  In order to use below helper methods,
 // this must be one of:
 // * golang/protobuf Message
@@ -562,56 +372,6 @@ func (c Config) NamespacedName() types.NamespacedName {
 	}
 }
 
-var _ fmt.Stringer = GroupVersionKind{}
-
-type GroupVersionKind struct {
-	Group   string `json:"group"`
-	Version string `json:"version"`
-	Kind    string `json:"kind"`
-}
-
-func (g GroupVersionKind) String() string {
-	return g.CanonicalGroup() + "/" + g.Version + "/" + g.Kind
-}
-
-// GroupVersion returns the group/version similar to what would be found in the apiVersion field of a Kubernetes resource.
-func (g GroupVersionKind) GroupVersion() string {
-	if g.Group == "" {
-		return g.Version
-	}
-	return g.Group + "/" + g.Version
-}
-
-func FromKubernetesGVK(gvk schema.GroupVersionKind) GroupVersionKind {
-	return GroupVersionKind{
-		Group:   gvk.Group,
-		Version: gvk.Version,
-		Kind:    gvk.Kind,
-	}
-}
-
-// Kubernetes returns the same GVK, using the Kubernetes object type
-func (g GroupVersionKind) Kubernetes() schema.GroupVersionKind {
-	return schema.GroupVersionKind{
-		Group:   g.Group,
-		Version: g.Version,
-		Kind:    g.Kind,
-	}
-}
-
-func CanonicalGroup(group string) string {
-	if group != "" {
-		return group
-	}
-	return "core"
-}
-
-// CanonicalGroup returns the group with defaulting applied. This means an empty group will
-// be treated as "core", following Kubernetes API standards
-func (g GroupVersionKind) CanonicalGroup() string {
-	return CanonicalGroup(g.Group)
-}
-
 type Index[K comparable, O any] interface {
 	Lookup(k K) []O
 	// AsCollection(opts ...CollectionOption) Collection[IndexObject[K, O]]
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go b/internal/kgateway/agentgatewaysyncer/references_collection.go
similarity index 66%
rename from internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
rename to internal/kgateway/agentgatewaysyncer/references_collection.go
index bb8ef79b4..b4a93f233 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/references_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/references_collection.go
@@ -1,35 +1,23 @@
-// Copyright Istio Authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package gateway
+package agentgatewaysyncer
 
 import (
 	"fmt"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+
 	creds "istio.io/istio/pilot/pkg/model/credentials"
 	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/kube/krt"
 )
 
 // Reference stores a reference to a namespaced GVK, as used by ReferencePolicy
 type Reference struct {
-	Kind      config.GroupVersionKind
+	Kind      schema.GroupVersionKind
 	Namespace gateway.Namespace
 }
 
@@ -58,16 +46,16 @@ func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.Reference
 			fromKey := Reference{
 				Namespace: from.Namespace,
 			}
-			if string(from.Group) == gvk.KubernetesGateway.Group && string(from.Kind) == gvk.KubernetesGateway.Kind {
-				fromKey.Kind = gvk.KubernetesGateway
-			} else if string(from.Group) == gvk.HTTPRoute.Group && string(from.Kind) == gvk.HTTPRoute.Kind {
-				fromKey.Kind = gvk.HTTPRoute
-			} else if string(from.Group) == gvk.GRPCRoute.Group && string(from.Kind) == gvk.GRPCRoute.Kind {
-				fromKey.Kind = gvk.GRPCRoute
-			} else if string(from.Group) == gvk.TLSRoute.Group && string(from.Kind) == gvk.TLSRoute.Kind {
-				fromKey.Kind = gvk.TLSRoute
-			} else if string(from.Group) == gvk.TCPRoute.Group && string(from.Kind) == gvk.TCPRoute.Kind {
-				fromKey.Kind = gvk.TCPRoute
+			if string(from.Group) == wellknown.GatewayGVK.Group && string(from.Kind) == wellknown.GatewayKind {
+				fromKey.Kind = wellknown.GatewayGVK
+			} else if string(from.Group) == wellknown.HTTPRouteGVK.Group && string(from.Kind) == wellknown.HTTPRouteKind {
+				fromKey.Kind = wellknown.HTTPRouteGVK
+			} else if string(from.Group) == wellknown.GRPCRouteGVK.Group && string(from.Kind) == wellknown.GRPCRouteKind {
+				fromKey.Kind = wellknown.GRPCRouteGVK
+			} else if string(from.Group) == wellknown.TLSRouteGVK.Group && string(from.Kind) == wellknown.TLSRouteKind {
+				fromKey.Kind = wellknown.TLSRouteGVK
+			} else if string(from.Group) == wellknown.TCPRouteGVK.Group && string(from.Kind) == wellknown.TCPRouteKind {
+				fromKey.Kind = wellknown.TCPRouteGVK
 			} else {
 				// Not supported type. Not an error; may be for another controller
 				continue
@@ -76,10 +64,10 @@ func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.Reference
 				toKey := Reference{
 					Namespace: gateway.Namespace(obj.Namespace),
 				}
-				if to.Group == "" && string(to.Kind) == gvk.Secret.Kind {
-					toKey.Kind = gvk.Secret
-				} else if to.Group == "" && string(to.Kind) == gvk.Service.Kind {
-					toKey.Kind = gvk.Service
+				if to.Group == "" && string(to.Kind) == wellknown.SecretGVK.Kind {
+					toKey.Kind = wellknown.SecretGVK
+				} else if to.Group == "" && string(to.Kind) == wellknown.ServiceKind {
+					toKey.Kind = wellknown.ServiceGVK
 				} else {
 					// Not supported type. Not an error; may be for another controller
 					continue
@@ -134,8 +122,8 @@ func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName s
 		logger.Warn("failed to parse resource name", "resourceName", resourceName, "error", err)
 		return false
 	}
-	from := Reference{Kind: gvk.KubernetesGateway, Namespace: gateway.Namespace(namespace)}
-	to := Reference{Kind: gvk.Secret, Namespace: gateway.Namespace(p.Namespace)}
+	from := Reference{Kind: wellknown.GatewayGVK, Namespace: gateway.Namespace(namespace)}
+	to := Reference{Kind: wellknown.SecretGVK, Namespace: gateway.Namespace(p.Namespace)}
 	pair := ReferencePair{From: from, To: to}
 	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
 	for _, g := range grants {
@@ -147,13 +135,13 @@ func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName s
 }
 
 func (refs ReferenceGrants) BackendAllowed(ctx krt.HandlerContext,
-	k config.GroupVersionKind,
+	k schema.GroupVersionKind,
 	backendName gateway.ObjectName,
 	backendNamespace gateway.Namespace,
 	routeNamespace string,
 ) bool {
 	from := Reference{Kind: k, Namespace: gateway.Namespace(routeNamespace)}
-	to := Reference{Kind: gvk.Service, Namespace: backendNamespace}
+	to := Reference{Kind: wellknown.SecretGVK, Namespace: backendNamespace}
 	pair := ReferencePair{From: from, To: to}
 	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
 	for _, g := range grants {
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
similarity index 92%
rename from internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
rename to internal/kgateway/agentgatewaysyncer/route_collections.go
index 6f1a0d22c..fa2d1e30a 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -1,12 +1,10 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"fmt"
 	"iter"
 	"strings"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
@@ -15,12 +13,13 @@ import (
 	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+
 	istio "istio.io/api/networking/v1alpha3"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
-	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
-	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/ptr"
@@ -74,7 +73,7 @@ func HTTPRouteCollection(
 					// TODO: standardize a status message for this upstream and report
 					continue
 				}
-				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, constants.KubernetesGatewayName)
+				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, AgentgatewayName)
 				sortHTTPRoutes(routes)
 				cfg := &Config{
 					Meta: Meta{
@@ -153,7 +152,7 @@ func ADPRouteCollection(
 				inner := protomarshal.Clone(e.Route)
 				_, name, _ := strings.Cut(parent.InternalName, "/")
 				inner.ListenerKey = name
-				inner.Key = inner.Key + "." + string(parent.ParentSection)
+				inner.Key = inner.GetKey() + "." + string(parent.ParentSection)
 				return toResource(gw, ADPRoute{Route: inner})
 			})...)
 		}
@@ -168,12 +167,18 @@ type conversionResult[O any] struct {
 	routes []O
 }
 
+// IsNil works around comparing generic types
+func IsNil[O comparable](o O) bool {
+	var t O
+	return o == t
+}
+
 func GRPCRouteCollection(
 	grpcRoutes krt.Collection[*gatewayv1.GRPCRoute],
 	inputs RouteContextInputs,
-	opts krt.OptionsBuilder,
+	krtopts krtutil.KrtOptions,
 ) RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, grpcRoutes, gvk.GRPCRoute, opts)
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, grpcRoutes, wellknown.GRPCRouteGVK, krtopts)
 	baseVirtualServices := krt.NewManyCollection(grpcRoutes, func(krtctx krt.HandlerContext, obj *gatewayv1.GRPCRoute) []RouteWithKey {
 		ctx := inputs.WithCtx(krtctx)
 		route := obj.Spec
@@ -214,7 +219,7 @@ func GRPCRouteCollection(
 					// TODO: standardize a status message for this upstream and report
 					continue
 				}
-				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, constants.KubernetesGatewayName)
+				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, AgentgatewayName)
 				sortHTTPRoutes(routes)
 				cfg := &Config{
 					Meta: Meta{
@@ -239,9 +244,9 @@ func GRPCRouteCollection(
 			}
 		}
 		return virtualServices
-	}, opts.WithName("GRPCRoute")...)
+	}, krtopts.ToOptions("GRPCRoute")...)
 
-	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, opts.WithName("GRPCRouteMerged")...)
+	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, krtopts.ToOptions("GRPCRouteMerged")...)
 	return RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus]{
 		VirtualServices:  finalVirtualServices,
 		RouteAttachments: routeCount,
@@ -251,9 +256,9 @@ func GRPCRouteCollection(
 func TCPRouteCollection(
 	tcpRoutes krt.Collection[*gatewayalpha.TCPRoute],
 	inputs RouteContextInputs,
-	opts krt.OptionsBuilder,
+	krtopts krtutil.KrtOptions,
 ) RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, tcpRoutes, gvk.TCPRoute, opts)
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, tcpRoutes, wellknown.TCPRouteGVK, krtopts)
 	virtualServices := krt.NewManyCollection(tcpRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TCPRoute) []*Config {
 		ctx := inputs.WithCtx(krtctx)
 		route := obj.Spec
@@ -273,7 +278,7 @@ func TCPRouteCollection(
 			routes := gwResult.routes
 			vsHosts := []string{"*"}
 			for i, host := range vsHosts {
-				name := fmt.Sprintf("%s-tcp-%d-%s", obj.Name, i, constants.KubernetesGatewayName)
+				name := fmt.Sprintf("%s-tcp-%d-%s", obj.Name, i, AgentgatewayName)
 				// Create one VS per hostname with a single hostname.
 				// This ensures we can treat each hostname independently, as the spec requires
 				vs = append(vs, &Config{
@@ -296,7 +301,7 @@ func TCPRouteCollection(
 			}
 		}
 		return vs
-	}, opts.WithName("TCPRoute")...)
+	}, krtopts.ToOptions("TCPRoute")...)
 
 	return RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus]{
 		VirtualServices:  virtualServices,
@@ -307,9 +312,9 @@ func TCPRouteCollection(
 func TLSRouteCollection(
 	tlsRoutes krt.Collection[*gatewayalpha.TLSRoute],
 	inputs RouteContextInputs,
-	opts krt.OptionsBuilder,
+	krtopts krtutil.KrtOptions,
 ) RouteResult[*gatewayalpha.TLSRoute, gatewayalpha.TLSRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, tlsRoutes, gvk.TLSRoute, opts)
+	routeCount := gatewayRouteAttachmentCountCollection(inputs, tlsRoutes, wellknown.TLSRouteGVK, krtopts)
 	virtualServices := krt.NewManyCollection(tlsRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TLSRoute) []*Config {
 		ctx := inputs.WithCtx(krtctx)
 		route := obj.Spec
@@ -329,7 +334,7 @@ func TLSRouteCollection(
 			routes := gwResult.routes
 			vsHosts := hostnameToStringList(route.Hostnames)
 			for i, host := range vsHosts {
-				name := fmt.Sprintf("%s-tls-%d-%s", obj.Name, i, constants.KubernetesGatewayName)
+				name := fmt.Sprintf("%s-tls-%d-%s", obj.Name, i, AgentgatewayName)
 				filteredRoutes := routes
 				// Create one VS per hostname with a single hostname.
 				// This ensures we can treat each hostname independently, as the spec requires
@@ -369,7 +374,7 @@ func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, t
 		res := conversionResult[O]{}
 		for vs, err := range translator(obj) {
 			// This was a hard error
-			if vs == nil {
+			if IsNil(vs) {
 				res.error = err
 				return conversionResult[O]{error: err}
 			}
@@ -381,7 +386,7 @@ func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, t
 		}
 		return res
 	}
-	gwResult := buildMeshAndGatewayRoutes(parentRefs, convertRules)
+	gwResult := buildGatewayRoutes(parentRefs, convertRules)
 
 	return parentRefs, gwResult
 }
@@ -394,13 +399,6 @@ type RouteContext struct {
 	RouteContextInputs
 }
 
-func (r RouteContext) LookupHostname(hostname string, namespace string) *model.Service {
-	if c := r.internalContext.Get(r.Krt).Load(); c != nil {
-		return c.GetService(hostname, namespace)
-	}
-	return nil
-}
-
 type RouteContextInputs struct {
 	Grants         ReferenceGrants
 	RouteParents   RouteParents
@@ -431,8 +429,8 @@ func (r RouteWithKey) Equals(o RouteWithKey) bool {
 	return r.Config.Equals(o.Config)
 }
 
-// buildMeshAndGatewayRoutes contains common logic to build a set of routes with gateway semantics
-func buildMeshAndGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func() T) T {
+// buildGatewayRoutes contains common logic to build a set of routes with gateway semantics
+func buildGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func() T) T {
 	return convertRules()
 }
 
@@ -520,12 +518,12 @@ func mergeHTTPRoutes(baseVirtualServices krt.Collection[RouteWithKey], opts ...k
 		baseVS := base.Spec.(*istio.VirtualService)
 		for _, config := range configs[1:] {
 			thisVS := config.Spec.(*istio.VirtualService)
-			baseVS.Http = append(baseVS.Http, thisVS.Http...)
+			baseVS.Http = append(baseVS.GetHttp(), thisVS.GetHttp()...)
 			// append parents
 			base.Annotations[constants.InternalParentNames] = fmt.Sprintf("%s,%s",
 				base.Annotations[constants.InternalParentNames], config.Annotations[constants.InternalParentNames])
 		}
-		sortHTTPRoutes(baseVS.Http)
+		sortHTTPRoutes(baseVS.GetHttp())
 		return ptr.Of(&base)
 	}, opts...)
 	return finalVirtualServices
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/service.go b/internal/kgateway/agentgatewaysyncer/service.go
similarity index 97%
rename from internal/kgateway/agentgatewaysyncer/gateway/service.go
rename to internal/kgateway/agentgatewaysyncer/service.go
index b475c075f..0e19a42bc 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -1,4 +1,4 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"bytes"
@@ -94,10 +94,6 @@ type Service struct {
 	// by the caller)
 	Resolution Resolution
 
-	// MeshExternal (if true) indicates that the service is external to the mesh.
-	// These services are defined using Istio's ServiceEntry spec.
-	MeshExternal bool
-
 	// ResourceVersion represents the internal version of this object.
 	ResourceVersion string
 }
@@ -655,8 +651,6 @@ type ServiceAttributes struct {
 	// ClusterExternalPorts is a mapping between a cluster name and the service port
 	// to node port mappings for a given service. When accessing the service via
 	// node port IPs, we need to use the kubernetes assigned node ports of the service
-	// The port that the user provides in the meshNetworks config is the service port.
-	// We translate that to the appropriate node port here.
 	ClusterExternalPorts map[cluster.ID]map[uint32]uint32
 
 	PassthroughTargetPorts map[uint32]uint32
@@ -790,18 +784,18 @@ func (i AddressInfo) Equals(other AddressInfo) bool {
 func (i AddressInfo) Aliases() []string {
 	switch addr := i.Type.(type) {
 	case *api.Address_Workload:
-		aliases := make([]string, 0, len(addr.Workload.Addresses))
-		network := addr.Workload.Network
-		for _, workloadAddr := range addr.Workload.Addresses {
+		aliases := make([]string, 0, len(addr.Workload.GetAddresses()))
+		network := addr.Workload.GetNetwork()
+		for _, workloadAddr := range addr.Workload.GetAddresses() {
 			ip, _ := netip.AddrFromSlice(workloadAddr)
 			aliases = append(aliases, network+"/"+ip.String())
 		}
 		return aliases
 	case *api.Address_Service:
-		aliases := make([]string, 0, len(addr.Service.Addresses))
-		for _, networkAddr := range addr.Service.Addresses {
-			ip, _ := netip.AddrFromSlice(networkAddr.Address)
-			aliases = append(aliases, networkAddr.Network+"/"+ip.String())
+		aliases := make([]string, 0, len(addr.Service.GetAddresses()))
+		for _, networkAddr := range addr.Service.GetAddresses() {
+			ip, _ := netip.AddrFromSlice(networkAddr.GetAddress())
+			aliases = append(aliases, networkAddr.GetNetwork()+"/"+ip.String())
 		}
 		return aliases
 	}
@@ -859,11 +853,11 @@ type StatusMessage struct {
 }
 
 func (i ServiceInfo) NamespacedName() types.NamespacedName {
-	return types.NamespacedName{Name: i.Service.Name, Namespace: i.Service.Namespace}
+	return types.NamespacedName{Name: i.Service.GetName(), Namespace: i.Service.GetNamespace()}
 }
 
 func (i ServiceInfo) GetNamespace() string {
-	return i.Service.Namespace
+	return i.Service.GetNamespace()
 }
 
 func (i ServiceInfo) Equals(other ServiceInfo) bool {
@@ -878,7 +872,7 @@ func (i ServiceInfo) ResourceName() string {
 }
 
 func serviceResourceName(s *api.Service) string {
-	return s.Namespace + "/" + s.Hostname
+	return s.GetNamespace() + "/" + s.GetHostname()
 }
 
 type WorkloadInfo struct {
@@ -905,7 +899,7 @@ func (i WorkloadInfo) Equals(other WorkloadInfo) bool {
 }
 
 func workloadResourceName(w *api.Workload) string {
-	return w.Uid
+	return w.GetUid()
 }
 
 func (i *WorkloadInfo) Clone() *WorkloadInfo {
@@ -947,7 +941,7 @@ func ExtractWorkloadsFromAddresses(addrs []AddressInfo) []WorkloadInfo {
 func SortWorkloadsByCreationTime(workloads []WorkloadInfo) []WorkloadInfo {
 	sort.SliceStable(workloads, func(i, j int) bool {
 		if workloads[i].CreationTime.Equal(workloads[j].CreationTime) {
-			return workloads[i].Workload.Uid < workloads[j].Workload.Uid
+			return workloads[i].Workload.GetUid() < workloads[j].Workload.GetUid()
 		}
 		return workloads[i].CreationTime.Before(workloads[j].CreationTime)
 	})
@@ -1032,11 +1026,6 @@ func (ports PortList) String() string {
 	return strings.Join(sp, ", ")
 }
 
-// External predicate checks whether the service is external
-func (s *Service) External() bool {
-	return s.MeshExternal
-}
-
 // BuildSubsetKey generates a unique string referencing service instances for a given service name, a subset and a port.
 // The proxy queries Pilot with this key to obtain the list of instances in a subset.
 func BuildSubsetKey(direction TrafficDirection, subsetName string, hostname host.Name, port int) string {
@@ -1243,7 +1232,7 @@ func (s *Service) Equals(other *Service) bool {
 
 	return s.DefaultAddress == other.DefaultAddress && s.AutoAllocatedIPv4Address == other.AutoAllocatedIPv4Address &&
 		s.AutoAllocatedIPv6Address == other.AutoAllocatedIPv6Address && s.Hostname == other.Hostname &&
-		s.Resolution == other.Resolution && s.MeshExternal == other.MeshExternal
+		s.Resolution == other.Resolution
 }
 
 // DeepCopy creates a clone of IstioEndpoint.
@@ -1309,7 +1298,7 @@ func (ep *IstioEndpoint) Equals(other *IstioEndpoint) bool {
 func equalUsingPremarshaled[T proto.Message](a T, am *anypb.Any, b T, bm *anypb.Any) bool {
 	// If they are both pre-marshaled, use the marshaled representation. This is orders of magnitude faster
 	if am != nil && bm != nil {
-		return bytes.Equal(am.Value, bm.Value)
+		return bytes.Equal(am.GetValue(), bm.GetValue())
 	}
 
 	// Fallback to equals
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
similarity index 89%
rename from internal/kgateway/agentgatewaysyncer/gateway/syncer.go
rename to internal/kgateway/agentgatewaysyncer/syncer.go
index c5face6c1..2724d1801 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -1,19 +1,14 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"context"
 	"fmt"
 	"maps"
-	"slices"
 	"strconv"
 
 	"github.com/agentgateway/agentgateway/go/api"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
-	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
@@ -31,6 +26,12 @@ import (
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 )
 
 var logger = logging.New("agentgateway/syncer")
@@ -40,7 +41,7 @@ var logger = logging.New("agentgateway/syncer")
 type AgentGwSyncer struct {
 	commonCols     *common.CommonCollections
 	controllerName string
-	xDS            krt.Collection[ADPResource]
+	xDS            krt.Collection[ADPCacheResource]
 	xdsCache       envoycache.SnapshotCache
 	client         kube.Client
 	domainSuffix   string
@@ -55,6 +56,7 @@ func NewAgentGwSyncer(
 	client kube.Client,
 	commonCols *common.CommonCollections,
 	xdsCache envoycache.SnapshotCache,
+	domainSuffix string,
 ) *AgentGwSyncer {
 	// TODO: register types (auth, policy, etc.) if necessary
 	return &AgentGwSyncer{
@@ -62,29 +64,11 @@ func NewAgentGwSyncer(
 		controllerName: controllerName,
 		xdsCache:       xdsCache,
 		// mgr:            mgr,
-		client: client,
+		client:       client,
+		domainSuffix: domainSuffix,
 	}
 }
 
-type agentGwXdsResources struct {
-	types.NamespacedName
-
-	reports   reports.ReportMap
-	Resources envoycache.Resources
-	Addresses envoycache.Resources
-}
-
-func (r agentGwXdsResources) ResourceName() string {
-	return fmt.Sprintf("%s~%s", r.Namespace, r.Name)
-}
-
-func (r agentGwXdsResources) Equals(in agentGwXdsResources) bool {
-	return r.NamespacedName == in.NamespacedName &&
-		report{r.reports}.Equals(report{in.reports}) &&
-		r.Resources.Version == in.Resources.Version &&
-		r.Addresses.Version == in.Addresses.Version
-}
-
 type envoyResourceWithName struct {
 	inner   envoytypes.ResourceWithName
 	version uint64
@@ -118,20 +102,6 @@ func (r envoyResourceWithCustomName) Equals(in envoyResourceWithCustomName) bool
 
 var _ envoytypes.ResourceWithName = envoyResourceWithCustomName{}
 
-type agentGwService struct {
-	krt.Named
-	ip       string
-	port     int
-	path     string
-	protocol string // currently only A2A and MCP
-	// The listeners which are allowed to connect to the target.
-	allowedListeners []string
-}
-
-func (r agentGwService) Equals(in agentGwService) bool {
-	return r.ip == in.ip && r.port == in.port && r.path == in.path && r.protocol == in.protocol && slices.Equal(r.allowedListeners, in.allowedListeners)
-}
-
 type report struct {
 	// lower case so krt doesn't error in debug handler
 	reportMap reports.ReportMap
@@ -177,7 +147,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		),
 		Services: krt.WrapClient[*corev1.Service](
 			kclient.NewFiltered[*corev1.Service](s.client, kubetypes.Filter{ObjectFilter: s.client.ObjectFilter()}),
-		),
+			krtopts.ToOptions("informer/Services")...),
 
 		GatewayClasses: krt.WrapClient(kclient.New[*gateway.GatewayClass](s.client), krtopts.ToOptions("informer/GatewayClasses")...),
 		Gateways:       krt.WrapClient(kclient.New[*gateway.Gateway](s.client), krtopts.ToOptions("informer/Gateways")...),
@@ -186,7 +156,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 		ReferenceGrants: krt.WrapClient(kclient.New[*gateway.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
 		ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
-		InferencePools:  krt.WrapClient(kclient.New[*inf.InferencePool](s.client), krtopts.ToOptions("informer/InferencePools")...),
+		//InferencePools:  krt.WrapClient(kclient.New[*inf.InferencePool](s.client), krtopts.ToOptions("informer/InferencePools")...),
 	}
 	if features.EnableAlphaGatewayAPI {
 		inputs.TCPRoutes = krt.WrapClient(kclient.New[*gatewayalpha.TCPRoute](s.client), krtopts.ToOptions("informer/TCPRoutes")...)
@@ -307,8 +277,28 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 	// TODO: inference pool
 
-	resources = krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, ADPRoutes}, krtopts.ToOptions("ADPResources")...)
-	s.xDS = krt.NewCollection([]krt.Collection[envoycache.Resources])
+	resources := krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, ADPRoutes}, krtopts.ToOptions("ADPResources")...)
+	s.xDS = krt.NewCollection(resources, func(ctx krt.HandlerContext, obj ADPResource) *ADPCacheResource {
+		var cacheResources []envoytypes.Resource
+		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
+			Message: obj.Resource,
+			Name:    obj.ResourceName(),
+			version: utils.HashProto(obj.Resource),
+		})
+
+		// Create the resource wrappers
+		var resourceVersion uint64
+		for _, res := range cacheResources {
+			resourceVersion ^= res.(*envoyResourceWithCustomName).version
+		}
+
+		result := &ADPCacheResource{
+			Gateway:   obj.Gateway,
+			Resources: envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
+		}
+		logger.Debug("created XDS resources for gateway with ID", "gwname", fmt.Sprintf("%s,%s", obj.Gateway.Name, obj.Gateway.Namespace), "resourceid", result.ResourceName())
+		return result
+	})
 
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
@@ -328,7 +318,7 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		return fmt.Errorf("agentgateway syncer waiting for cache to sync failed")
 	}
 
-	s.xDS.RegisterBatch(func(events []krt.Event[ADPResource], _ bool) {
+	s.xDS.RegisterBatch(func(events []krt.Event[ADPCacheResource], _ bool) {
 		for _, e := range events {
 			r := e.Latest()
 			if e.Event == controllers.EventDelete {
diff --git a/internal/kgateway/agentgatewaysyncer/gateway/syncer_test.go b/internal/kgateway/agentgatewaysyncer/syncer_test.go
similarity index 97%
rename from internal/kgateway/agentgatewaysyncer/gateway/syncer_test.go
rename to internal/kgateway/agentgatewaysyncer/syncer_test.go
index debe02bf8..aeeeea27c 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway/syncer_test.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer_test.go
@@ -1,4 +1,4 @@
-package gateway
+package agentgatewaysyncer
 
 import (
 	"context"
diff --git a/internal/kgateway/controller/start.go b/internal/kgateway/controller/start.go
index 55f02af4e..50d028874 100644
--- a/internal/kgateway/controller/start.go
+++ b/internal/kgateway/controller/start.go
@@ -21,7 +21,8 @@ import (
 	metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
 	infextv1a2 "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer/gateway"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/deployer"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/registry"
@@ -210,7 +211,8 @@ func NewControllerBuilder(ctx context.Context, cfg StartConfig) (*ControllerBuil
 	proxySyncer.Init(ctx, cfg.KrtOptions)
 
 	if cfg.SetupOpts.GlobalSettings.EnableAgentGateway {
-		agentGatewaySyncer := gateway.NewAgentGwSyncer(
+		domainSuffix := "cluster.local" // TODO: don't hard code
+		agentGatewaySyncer := agentgatewaysyncer.NewAgentGwSyncer(
 			ctx,
 			cfg.ControllerName,
 			cfg.AgentGatewayClassName,
@@ -218,6 +220,7 @@ func NewControllerBuilder(ctx context.Context, cfg StartConfig) (*ControllerBuil
 			cfg.Client,
 			commoncol,
 			cfg.SetupOpts.Cache,
+			domainSuffix,
 		)
 		agentGatewaySyncer.Init(cfg.KrtOptions)
 
diff --git a/internal/kgateway/query/mocks/mock_queries.go b/internal/kgateway/query/mocks/mock_queries.go
index 59811ed02..fc492f632 100644
--- a/internal/kgateway/query/mocks/mock_queries.go
+++ b/internal/kgateway/query/mocks/mock_queries.go
@@ -9,11 +9,12 @@ import (
 	reflect "reflect"
 
 	gomock "github.com/golang/mock/gomock"
-	query "github.com/kgateway-dev/kgateway/v2/internal/kgateway/query"
-	ir "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/ir"
 	krt "istio.io/istio/pkg/kube/krt"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	v1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	query "github.com/kgateway-dev/kgateway/v2/internal/kgateway/query"
+	ir "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/ir"
 )
 
 // MockGatewayQueries is a mock of GatewayQueries interface.
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index a5b645de5..ea1600fef 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -1 +1,351 @@
 package setup_test
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"os"
+	"path/filepath"
+	"strings"
+	"testing"
+	"time"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	envoycore "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
+	discovery_v3 "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
+	"google.golang.org/grpc"
+	"google.golang.org/grpc/credentials/insecure"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/types/known/structpb"
+	istiokube "istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/test/util/retry"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/settings"
+)
+
+func TestAgentGatewayScenarioDump(t *testing.T) {
+	st, err := settings.BuildSettings()
+	st.EnableAgentGateway = true
+
+	if err != nil {
+		t.Fatalf("can't get settings %v", err)
+	}
+
+	// Use the runScenario approach to test agent gateway scenarios
+	runAgentGatewayScenario(t, "testdata/agentgateway", st)
+}
+
+func runAgentGatewayScenario(t *testing.T, scenarioDir string, globalSettings *settings.Settings) {
+	setupEnvTestAndRun(t, globalSettings, func(t *testing.T, ctx context.Context, kdbg *krt.DebugHandler, client istiokube.CLIClient, xdsPort int) {
+		// list all yamls in test data
+		files, err := os.ReadDir(scenarioDir)
+		if err != nil {
+			t.Fatalf("failed to read dir: %v", err)
+		}
+		for _, f := range files {
+			// run tests with the yaml files (but not -out.yaml files)
+			parentT := t
+			if strings.HasSuffix(f.Name(), ".yaml") && !strings.HasSuffix(f.Name(), "-out.yaml") {
+				if os.Getenv("TEST_PREFIX") != "" && !strings.HasPrefix(f.Name(), os.Getenv("TEST_PREFIX")) {
+					continue
+				}
+				fullpath := filepath.Join(scenarioDir, f.Name())
+				t.Run(strings.TrimSuffix(f.Name(), ".yaml"), func(t *testing.T) {
+					writer.set(t)
+					t.Cleanup(func() {
+						writer.set(parentT)
+					})
+					testAgentGatewayScenario(t, ctx, kdbg, client, xdsPort, fullpath)
+				})
+			}
+		}
+	})
+}
+
+func testAgentGatewayScenario(
+	t *testing.T,
+	ctx context.Context,
+	kdbg *krt.DebugHandler,
+	client istiokube.CLIClient,
+	xdsPort int,
+	f string,
+) {
+	fext := filepath.Ext(f)
+	fpre := strings.TrimSuffix(f, fext)
+	t.Logf("running agent gateway scenario for test file: %s", f)
+
+	// read the out file
+	fout := fpre + "-out" + fext
+	write := false
+	_, err := os.ReadFile(fout)
+	// if not exist
+	if os.IsNotExist(err) {
+		write = true
+		err = nil
+	}
+	if os.Getenv("REFRESH_GOLDEN") == "true" {
+		write = true
+	}
+	if err != nil {
+		t.Fatalf("failed to read file %s: %v", fout, err)
+	}
+
+	const gwname = "http-gw-for-test"
+	testgwname := "http-" + filepath.Base(fpre)
+	testyamlbytes, err := os.ReadFile(f)
+	if err != nil {
+		t.Fatalf("failed to read file: %v", err)
+	}
+	// change the gw name, so we could potentially run multiple tests in parallel (though currently
+	// it has other issues, so we don't run them in parallel)
+	testyaml := strings.ReplaceAll(string(testyamlbytes), gwname, testgwname)
+
+	yamlfile := filepath.Join(t.TempDir(), "test.yaml")
+	os.WriteFile(yamlfile, []byte(testyaml), 0o644)
+
+	err = client.ApplyYAMLFiles("", yamlfile)
+
+	t.Cleanup(func() {
+		// always delete yamls, even if there was an error applying them; to prevent test pollution.
+		err := client.DeleteYAMLFiles("", yamlfile)
+		if err != nil {
+			t.Fatalf("failed to delete yaml: %v", err)
+		}
+		t.Log("deleted yamls", t.Name())
+	})
+
+	if err != nil {
+		t.Fatalf("failed to apply yaml: %v", err)
+	}
+	t.Log("applied yamls", t.Name())
+
+	// wait at least a second before the first check
+	// to give the CP time to process
+	time.Sleep(time.Second)
+
+	t.Cleanup(func() {
+		if t.Failed() {
+			logKrtState(t, fmt.Sprintf("krt state for failed test: %s", t.Name()), kdbg)
+		} else if os.Getenv("KGW_DUMP_KRT_ON_SUCCESS") == "true" {
+			logKrtState(t, fmt.Sprintf("krt state for successful test: %s", t.Name()), kdbg)
+		}
+	})
+
+	// Use retry to wait for the agent gateway to be ready
+	retry.UntilSuccessOrFail(t, func() error {
+		dumper := newAgentGatewayXdsDumper(t, ctx, xdsPort, testgwname, "gwtest")
+		defer dumper.Close()
+		dump := dumper.DumpAgentGateway(t, ctx)
+		if len(dump.Resources) == 0 {
+			return fmt.Errorf("timed out waiting for agent gateway resources")
+		}
+
+		if write {
+			t.Logf("writing out file")
+			// Use proto dump instead of manual YAML writing
+			dumpProtoToJSON(t, dump, fpre)
+			return fmt.Errorf("wrote out file - nothing to test")
+		}
+
+		// Output the config dump
+		t.Logf("Agent Gateway Config Dump for %s:", testgwname)
+		t.Logf("Total resources: %d", len(dump.Resources))
+
+		// Count different types of resources
+		var bindCount, listenerCount, routeCount, worklodCount, serviceCount int
+		for _, resource := range dump.Resources {
+			switch resource.GetKind().(type) {
+			case *api.Resource_Bind:
+				bindCount++
+				t.Logf("Bind resource: %+v", resource.GetBind())
+			case *api.Resource_Listener:
+				listenerCount++
+				t.Logf("Listener resource: %+v", resource.GetListener())
+			case *api.Resource_Route:
+				routeCount++
+				t.Logf("Route resource: %+v", resource.GetRoute())
+			}
+		}
+		t.Logf("Resource counts - Binds: %d, Listeners: %d, Routes: %d", bindCount, listenerCount, routeCount)
+
+		for _, resource := range dump.Addresses {
+			switch resource.Type.(type) {
+			case *api.Address_Workload:
+				worklodCount++
+				t.Logf("workload resource: %+v", resource.GetWorkload())
+			case *api.Address_Service:
+				serviceCount++
+				t.Logf("service resource: %+v", resource.GetService())
+			}
+		}
+		t.Logf("Address counts - Workload: %d, Service: %d", worklodCount, serviceCount)
+
+		return nil
+	}, retry.Converge(2), retry.BackoffDelay(2*time.Second), retry.Timeout(10*time.Second))
+
+	t.Logf("%s finished", t.Name())
+}
+
+// dumpProtoToJSON dumps the agentgateway resources to JSON format
+func dumpProtoToJSON(t *testing.T, dump agentGwDump, fpre string) {
+	jsonFile := fpre + "-out.json"
+
+	// Create a structured dump map
+	dumpMap := map[string]interface{}{
+		"resources": dump.Resources,
+		"addresses": dump.Addresses,
+	}
+
+	// Marshal to JSON using regular JSON marshaling
+	jsonData, err := json.MarshalIndent(dumpMap, "", "  ")
+	if err != nil {
+		t.Logf("failed to marshal to JSON: %v", err)
+		return
+	}
+
+	err = os.WriteFile(jsonFile, jsonData, 0o644)
+	if err != nil {
+		t.Logf("failed to write JSON file: %v", err)
+		return
+	}
+
+	t.Logf("wrote JSON dump to: %s", jsonFile)
+}
+
+func newAgentGatewayXdsDumper(t *testing.T, ctx context.Context, xdsPort int, gwname, gwnamespace string) xdsDumper {
+	conn, err := grpc.NewClient(fmt.Sprintf("localhost:%d", xdsPort),
+		grpc.WithTransportCredentials(insecure.NewCredentials()),
+		grpc.WithIdleTimeout(time.Second*10),
+	)
+	if err != nil {
+		t.Fatalf("failed to connect to xds server: %v", err)
+	}
+
+	d := xdsDumper{
+		conn: conn,
+		dr: &discovery_v3.DiscoveryRequest{
+			Node: &envoycore.Node{
+				Id: "gateway.gwtest",
+				Metadata: &structpb.Struct{
+					Fields: map[string]*structpb.Value{
+						"role": structpb.NewStringValue(fmt.Sprintf("%s~%s", gwnamespace, gwname)),
+					},
+				},
+			},
+		},
+	}
+
+	ads := discovery_v3.NewAggregatedDiscoveryServiceClient(d.conn)
+	ctx, cancel := context.WithTimeout(ctx, time.Second*30) // long timeout - just in case. we should never reach it.
+	adsClient, err := ads.StreamAggregatedResources(ctx)
+	if err != nil {
+		t.Fatalf("failed to get ads client: %v", err)
+	}
+	d.adsClient = adsClient
+	d.cancel = cancel
+
+	return d
+}
+
+type agentGwDump struct {
+	Resources []*api.Resource
+	Addresses []*api.Address
+}
+
+func (x xdsDumper) DumpAgentGateway(t *testing.T, ctx context.Context) agentGwDump {
+	// get resources
+	resources := x.GetResources(t, ctx)
+	addresses := x.GetAddress(t, ctx)
+
+	return agentGwDump{
+		Resources: resources,
+		Addresses: addresses,
+	}
+}
+
+func (x xdsDumper) GetResources(t *testing.T, ctx context.Context) []*api.Resource {
+	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
+	dr.TypeUrl = agentgatewaysyncer.TargetTypeResourceUrl
+	x.adsClient.Send(dr)
+	var resources []*api.Resource
+	// run this in parallel with a 5s timeout
+	done := make(chan struct{})
+	go func() {
+		defer close(done)
+		sent := 1
+		for i := 0; i < sent; i++ {
+			dresp, err := x.adsClient.Recv()
+			if err != nil {
+				t.Errorf("failed to get response from xds server: %v", err)
+			}
+			t.Logf("got response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
+			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeResourceUrl {
+				for _, anyResource := range dresp.GetResources() {
+					var resource api.Resource
+					if err := anyResource.UnmarshalTo(&resource); err != nil {
+						t.Errorf("failed to unmarshal resource: %v", err)
+					}
+					resources = append(resources, &resource)
+				}
+			}
+		}
+	}()
+	select {
+	case <-done:
+	case <-time.After(5 * time.Second):
+		// don't fatal yet as we want to dump the state while still connected
+		t.Error("timed out waiting for resources for agent gateway xds dump")
+		return nil
+	}
+	if len(resources) == 0 {
+		t.Error("no resources found")
+		return nil
+	}
+	t.Logf("xds: found %d resources", len(resources))
+	return resources
+}
+
+func (x xdsDumper) GetAddress(t *testing.T, ctx context.Context) []*api.Address {
+	dr := proto.Clone(x.dr).(*discovery_v3.DiscoveryRequest)
+	dr.TypeUrl = agentgatewaysyncer.TargetTypeAddressUrl
+	x.adsClient.Send(dr)
+	var address []*api.Address
+	// run this in parallel with a 5s timeout
+	done := make(chan struct{})
+	go func() {
+		defer close(done)
+		sent := 1
+		for i := 0; i < sent; i++ {
+			dresp, err := x.adsClient.Recv()
+			if err != nil {
+				t.Errorf("failed to get response from xds server: %v", err)
+			}
+			t.Logf("got address response: %s len: %d", dresp.GetTypeUrl(), len(dresp.GetResources()))
+			if dresp.GetTypeUrl() == agentgatewaysyncer.TargetTypeAddressUrl {
+				for _, anyResource := range dresp.GetResources() {
+					var resource api.Address
+					if err := anyResource.UnmarshalTo(&resource); err != nil {
+						t.Errorf("failed to unmarshal resource: %v", err)
+					}
+					address = append(address, &resource)
+				}
+			}
+		}
+	}()
+	select {
+	case <-done:
+	case <-time.After(5 * time.Second):
+		// don't fatal yet as we want to dump the state while still connected
+		t.Error("timed out waiting for address resources for agent gateway xds dump")
+		return nil
+	}
+	if len(address) == 0 {
+		t.Error("no address resources found")
+		return nil
+	}
+	t.Logf("xds: found %d address resources", len(address))
+	return address
+}
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute.yaml b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
new file mode 100644
index 000000000..8c80a033a
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
@@ -0,0 +1,91 @@
+kind: Gateway
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: http-gw-for-test
+  namespace: gwtest
+spec:
+  gatewayClassName: agentgateway
+  listeners:
+    - protocol: HTTP
+      port: 8080
+      name: http
+      allowedRoutes:
+        namespaces:
+          from: All
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: reviews
+  namespace: gwtest
+  labels:
+    app: reviews
+    service: reviews
+spec:
+  ports:
+    - name: http
+      port: 8000
+      targetPort: 8080
+    - name: tcp
+      port: 9090
+  selector:
+    app: reviews
+---
+apiVersion: discovery.k8s.io/v1
+kind: EndpointSlice
+metadata:
+  name: reviews-slice
+  namespace: gwtest
+  labels:
+    kubernetes.io/service-name: reviews
+    app: reviews
+    service: reviews
+addressType: IPv4
+endpoints:
+  - addresses:
+      - 10.244.1.11
+    conditions:
+      ready: true
+    nodeName: worker
+    targetRef:
+      kind: Pod
+      name: reviews-1
+      namespace: default
+ports:
+  - name: http
+    port: 8080
+    protocol: TCP
+---
+apiVersion: gateway.networking.k8s.io/v1beta1
+kind: HTTPRoute
+metadata:
+  name: my-route
+  namespace: gwtest
+spec:
+  parentRefs:
+    - name: http-gw-for-test
+  hostnames:
+    - "www.example.com"
+  rules:
+    - matches:
+        - path:
+            type: PathPrefix
+            value: /myapp
+      backendRefs:
+        - name: reviews
+          port: 8080
+---
+apiVersion: gateway.networking.k8s.io/v1beta1
+kind: HTTPRoute
+metadata:
+  name: my-route2
+  namespace: gwtest
+spec:
+  parentRefs:
+    - name: http-gw-for-test
+  hostnames:
+    - "www.example2.com"
+  rules:
+    - backendRefs:
+        - name: reviews
+          port: 8080
\ No newline at end of file
diff --git a/internal/kgateway/wellknown/gwapi.go b/internal/kgateway/wellknown/gwapi.go
index aa1eabb48..e5d4f8439 100644
--- a/internal/kgateway/wellknown/gwapi.go
+++ b/internal/kgateway/wellknown/gwapi.go
@@ -6,6 +6,7 @@ import (
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	infextv1a2 "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	apiv1 "sigs.k8s.io/gateway-api/apis/v1"
+	apiv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	apiv1alpha3 "sigs.k8s.io/gateway-api/apis/v1alpha3"
 	apiv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 	apixv1alpha1 "sigs.k8s.io/gateway-api/apisx/v1alpha1"
@@ -59,6 +60,16 @@ var (
 		Version: apiv1.GroupVersion.Version,
 		Kind:    HTTPRouteKind,
 	}
+	TLSRouteGVK = schema.GroupVersionKind{
+		Group:   GatewayGroup,
+		Version: apiv1alpha2.GroupVersion.Version,
+		Kind:    TLSRouteKind,
+	}
+	TCPRouteGVK = schema.GroupVersionKind{
+		Group:   GatewayGroup,
+		Version: apiv1alpha2.GroupVersion.Version,
+		Kind:    TCPRouteKind,
+	}
 	GRPCRouteGVK = schema.GroupVersionKind{
 		Group:   GatewayGroup,
 		Version: apiv1.GroupVersion.Version,
diff --git a/pkg/client/clientset/versioned/clientset.go b/pkg/client/clientset/versioned/clientset.go
index 657495743..383394268 100644
--- a/pkg/client/clientset/versioned/clientset.go
+++ b/pkg/client/clientset/versioned/clientset.go
@@ -6,10 +6,11 @@ import (
 	fmt "fmt"
 	http "net/http"
 
-	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 	discovery "k8s.io/client-go/discovery"
 	rest "k8s.io/client-go/rest"
 	flowcontrol "k8s.io/client-go/util/flowcontrol"
+
+	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 )
 
 type Interface interface {
diff --git a/pkg/client/clientset/versioned/fake/register.go b/pkg/client/clientset/versioned/fake/register.go
index 07654aded..cca1527a7 100644
--- a/pkg/client/clientset/versioned/fake/register.go
+++ b/pkg/client/clientset/versioned/fake/register.go
@@ -3,12 +3,13 @@
 package fake
 
 import (
-	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	serializer "k8s.io/apimachinery/pkg/runtime/serializer"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
+
+	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 var scheme = runtime.NewScheme()
diff --git a/pkg/client/clientset/versioned/scheme/register.go b/pkg/client/clientset/versioned/scheme/register.go
index 29eef6163..80797f75c 100644
--- a/pkg/client/clientset/versioned/scheme/register.go
+++ b/pkg/client/clientset/versioned/scheme/register.go
@@ -3,12 +3,13 @@
 package scheme
 
 import (
-	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	runtime "k8s.io/apimachinery/pkg/runtime"
 	schema "k8s.io/apimachinery/pkg/runtime/schema"
 	serializer "k8s.io/apimachinery/pkg/runtime/serializer"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
+
+	gatewayv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 )
 
 var Scheme = runtime.NewScheme()
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
index 93755431d..5145d2df3 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
@@ -5,9 +5,10 @@ package v1alpha1
 import (
 	http "net/http"
 
+	rest "k8s.io/client-go/rest"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
-	rest "k8s.io/client-go/rest"
 )
 
 type GatewayV1alpha1Interface interface {
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go
index 8fa2933db..b89745996 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/backend.go
@@ -5,13 +5,14 @@ package v1alpha1
 import (
 	context "context"
 
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
+
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // BackendsGetter has a method to return a BackendInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go
index 0b6fb9918..8f2334a71 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/backendconfigpolicy.go
@@ -5,13 +5,14 @@ package v1alpha1
 import (
 	context "context"
 
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
+
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // BackendConfigPoliciesGetter has a method to return a BackendConfigPolicyInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go
index bf2c2affc..a23e9360f 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/directresponse.go
@@ -5,13 +5,14 @@ package v1alpha1
 import (
 	context "context"
 
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
+
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // DirectResponsesGetter has a method to return a DirectResponseInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go
index 3c78200b4..c9d2aa367 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_api_client.go
@@ -3,9 +3,10 @@
 package fake
 
 import (
-	v1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 	rest "k8s.io/client-go/rest"
 	testing "k8s.io/client-go/testing"
+
+	v1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
 )
 
 type FakeGatewayV1alpha1 struct {
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go
index 773f5d9a7..1fa501faa 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backend.go
@@ -3,10 +3,11 @@
 package fake
 
 import (
+	gentype "k8s.io/client-go/gentype"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
-	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeBackends implements BackendInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go
index cf732d330..26cb4a939 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_backendconfigpolicy.go
@@ -3,10 +3,11 @@
 package fake
 
 import (
+	gentype "k8s.io/client-go/gentype"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
-	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeBackendConfigPolicies implements BackendConfigPolicyInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go
index 02825770b..83a9c87d5 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_directresponse.go
@@ -3,10 +3,11 @@
 package fake
 
 import (
+	gentype "k8s.io/client-go/gentype"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
-	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeDirectResponses implements DirectResponseInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go
index 37312c1e5..711f46f35 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayextension.go
@@ -3,10 +3,11 @@
 package fake
 
 import (
+	gentype "k8s.io/client-go/gentype"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
-	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeGatewayExtensions implements GatewayExtensionInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go
index ca41c4fee..d2ba16ea9 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_gatewayparameters.go
@@ -3,10 +3,11 @@
 package fake
 
 import (
+	gentype "k8s.io/client-go/gentype"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
-	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeGatewayParameterses implements GatewayParametersInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go
index d463a8733..2aa6e09b0 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_httplistenerpolicy.go
@@ -3,10 +3,11 @@
 package fake
 
 import (
+	gentype "k8s.io/client-go/gentype"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
-	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeHTTPListenerPolicies implements HTTPListenerPolicyInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go
index f119c271d..0ebaa2a19 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/fake/fake_trafficpolicy.go
@@ -3,10 +3,11 @@
 package fake
 
 import (
+	gentype "k8s.io/client-go/gentype"
+
 	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
 	v1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
 	typedapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/typed/api/v1alpha1"
-	gentype "k8s.io/client-go/gentype"
 )
 
 // fakeTrafficPolicies implements TrafficPolicyInterface
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go
index 637bc7752..c8c1fd535 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayextension.go
@@ -5,13 +5,14 @@ package v1alpha1
 import (
 	context "context"
 
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
+
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // GatewayExtensionsGetter has a method to return a GatewayExtensionInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go
index 066fd0635..c4db750a1 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/gatewayparameters.go
@@ -5,13 +5,14 @@ package v1alpha1
 import (
 	context "context"
 
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
+
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // GatewayParametersesGetter has a method to return a GatewayParametersInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go
index 365bbc6e7..415171c6f 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/httplistenerpolicy.go
@@ -5,13 +5,14 @@ package v1alpha1
 import (
 	context "context"
 
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
+
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // HTTPListenerPoliciesGetter has a method to return a HTTPListenerPolicyInterface.
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go
index 750779b73..ad5242ca8 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/trafficpolicy.go
@@ -5,13 +5,14 @@ package v1alpha1
 import (
 	context "context"
 
-	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
-	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
-	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	types "k8s.io/apimachinery/pkg/types"
 	watch "k8s.io/apimachinery/pkg/watch"
 	gentype "k8s.io/client-go/gentype"
+
+	applyconfigurationapiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/applyconfiguration/api/v1alpha1"
+	apiv1alpha1 "github.com/kgateway-dev/kgateway/v2/api/v1alpha1"
+	scheme "github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned/scheme"
 )
 
 // TrafficPoliciesGetter has a method to return a TrafficPolicyInterface.
-- 
2.39.5 (Apple Git-154)


From e1cc50821dcc6322fb79f9d1323733aba7a0cb35 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 14:13:43 -0700
Subject: [PATCH 06/17] wip

---
 .../kgateway/agentgatewaysyncer/conversion.go |  61 +-
 internal/kgateway/agentgatewaysyncer/model.go |  22 +-
 .../kgateway/agentgatewaysyncer/service.go    | 710 ++++----------
 .../kgateway/agentgatewaysyncer/syncer.go     | 133 ++-
 .../kgateway/agentgatewaysyncer/workloads.go  | 927 ++++++++++++++++++
 .../testdata/agentgateway/httproute-out.json  |  35 +
 6 files changed, 1304 insertions(+), 584 deletions(-)
 create mode 100644 internal/kgateway/agentgatewaysyncer/workloads.go
 create mode 100644 internal/kgateway/setup/testdata/agentgateway/httproute-out.json

diff --git a/internal/kgateway/agentgatewaysyncer/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
index ec49e21cc..c169c7a29 100644
--- a/internal/kgateway/agentgatewaysyncer/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -45,9 +45,7 @@ import (
 )
 
 const (
-	gatewayTLSTerminateModeKey = "gateway.istio.io/tls-terminate-mode"
-	addressTypeOverride        = "networking.istio.io/address-type"
-	gatewayClassDefaults       = "gateway.istio.io/defaults-for-class"
+	gatewayTLSTerminateModeKey = "gateway.agentgateway.io/tls-terminate-mode"
 )
 
 func sortRoutesByCreationTime(configs []RouteWithKey) {
@@ -62,10 +60,6 @@ func sortRoutesByCreationTime(configs []RouteWithKey) {
 	})
 }
 
-func sortedConfigByCreationTime(configs []Config) []Config {
-	return sortConfigByCreationTime(configs)
-}
-
 func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 	obj *k8sbeta.HTTPRoute, pos int, matchPos int,
 ) (*api.Route, *ConfigError) {
@@ -1620,28 +1614,6 @@ func getDefaultName(name string, kgw *k8s.GatewaySpec) string {
 	return fmt.Sprintf("%v-%v", name, kgw.GatewayClassName)
 }
 
-// Gateway currently requires a listener (https://github.com/kubernetes-sigs/gateway-api/pull/1596).
-// We don't *really* care about the listener, but it may make sense to add a warning if users do not
-// configure it in an expected way so that we have consistency and can make changes in the future as needed.
-// We could completely reject but that seems more likely to cause pain.
-func unexpectedWaypointListener(l k8s.Listener) bool {
-	if l.Port != 15008 {
-		return true
-	}
-	if l.Protocol != k8s.ProtocolType(protocol.HBONE) {
-		return true
-	}
-	return false
-}
-
-func getListenerNames(spec *k8s.GatewaySpec) sets.Set[k8s.SectionName] {
-	res := sets.New[k8s.SectionName]()
-	for _, l := range spec.Listeners {
-		res.Insert(l.Name)
-	}
-	return res
-}
-
 // IsManaged checks if a Gateway is managed (ie we create the Deployment and Service) or unmanaged.
 // This is based on the address field of the spec. If address is set with a Hostname type, it should point to an existing
 // Service that handles the gateway traffic. If it is not set, or refers to only a single IP, we will consider it managed and provision the Service.
@@ -1887,7 +1859,7 @@ func buildSecretReference(
 		return "", TLSInfo{}, &ConfigError{Reason: InvalidTLS, Message: fmt.Sprintf("invalid certificate reference %v, only secret is allowed", objectReferenceString(ref))}
 	}
 
-	secret := model.ConfigKey{
+	secret := ConfigKey{
 		Kind:      kind.Secret,
 		Name:      string(ref.Name),
 		Namespace: ptr.OrDefault((*string)(ref.Namespace), gw.Namespace),
@@ -1997,19 +1969,6 @@ func namespacesFromSelector(ctx krt.HandlerContext, localNamespace string, names
 	return namespaces
 }
 
-func humanReadableJoin(ss []string) string {
-	switch len(ss) {
-	case 0:
-		return ""
-	case 1:
-		return ss[0]
-	case 2:
-		return ss[0] + " and " + ss[1]
-	default:
-		return strings.Join(ss[:len(ss)-1], ", ") + ", and " + ss[len(ss)-1]
-	}
-}
-
 // NamespaceNameLabel represents that label added automatically to namespaces is newer Kubernetes clusters
 const NamespaceNameLabel = "kubernetes.io/metadata.name"
 
@@ -2045,22 +2004,6 @@ func GetCommonRouteInfo(spec any) ([]k8s.ParentReference, []k8s.Hostname, schema
 	}
 }
 
-func GetCommonRouteStateParents(spec any) []k8s.RouteParentStatus {
-	switch t := spec.(type) {
-	case *k8salpha.TCPRoute:
-		return t.Status.Parents
-	case *k8salpha.TLSRoute:
-		return t.Status.Parents
-	case *k8sbeta.HTTPRoute:
-		return t.Status.Parents
-	case *k8s.GRPCRoute:
-		return t.Status.Parents
-	default:
-		log.Fatalf("unknown type %T", t)
-		return nil
-	}
-}
-
 func defaultString[T ~string](s *T, def string) string {
 	if s == nil {
 		return def
diff --git a/internal/kgateway/agentgatewaysyncer/model.go b/internal/kgateway/agentgatewaysyncer/model.go
index 11a0880c7..6fa2a474e 100644
--- a/internal/kgateway/agentgatewaysyncer/model.go
+++ b/internal/kgateway/agentgatewaysyncer/model.go
@@ -77,7 +77,6 @@ type ADPCacheResource struct {
 	reports reports.ReportMap
 
 	Resources envoycache.Resources
-	Addresses envoycache.Resources
 
 	VersionMap map[string]map[string]string
 }
@@ -89,8 +88,25 @@ func (r ADPCacheResource) ResourceName() string {
 func (r ADPCacheResource) Equals(in ADPCacheResource) bool {
 	return r.Gateway == in.Gateway &&
 		report{r.reports}.Equals(report{in.reports}) &&
-		r.Resources.Version == in.Resources.Version &&
-		r.Addresses.Version == in.Addresses.Version
+		r.Resources.Version == in.Resources.Version
+}
+
+type ADPCacheAddress struct {
+	NamespacedName types.NamespacedName
+	Address        envoycache.Resources `json:"address"`
+	proxyKey       string
+
+	reports    reports.ReportMap
+	VersionMap map[string]map[string]string
+}
+
+func (r ADPCacheAddress) ResourceName() string {
+	return r.proxyKey
+}
+
+func (r ADPCacheAddress) Equals(in ADPCacheAddress) bool {
+	return report{r.reports}.Equals(report{in.reports}) &&
+		r.Address.Version == in.Address.Version
 }
 
 type ADPResource struct {
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
index 0e19a42bc..37386186a 100644
--- a/internal/kgateway/agentgatewaysyncer/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -4,8 +4,6 @@ import (
 	"bytes"
 	"fmt"
 	"net/netip"
-	"sort"
-	"strconv"
 	"strings"
 	"sync"
 	"time"
@@ -13,29 +11,221 @@ import (
 	"github.com/agentgateway/agentgateway/go/api"
 	"github.com/google/go-cmp/cmp"
 	"github.com/google/go-cmp/cmp/cmpopts"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/anypb"
-	"k8s.io/apimachinery/pkg/types"
-
+	apiannotation "istio.io/api/annotation"
 	"istio.io/api/label"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube"
 	"istio.io/istio/pilot/pkg/serviceregistry/provider"
 	"istio.io/istio/pilot/pkg/util/protoconv"
 	"istio.io/istio/pkg/cluster"
+	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
-	"istio.io/istio/pkg/config/labels"
+	kubeutil "istio.io/istio/pkg/config/kube"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/kind"
 	"istio.io/istio/pkg/config/visibility"
+	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/maps"
 	pm "istio.io/istio/pkg/model"
-	"istio.io/istio/pkg/network"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/protomarshal"
 	"istio.io/istio/pkg/util/sets"
+	v1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/types"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 )
 
+func (a *index) ServicesCollection(
+	services krt.Collection[*v1.Service],
+	serviceEntries krt.Collection[*networkingclient.ServiceEntry],
+	namespaces krt.Collection[*v1.Namespace],
+	krtopts krtutil.KrtOptions,
+) krt.Collection[ServiceInfo] {
+	ServicesInfo := krt.NewCollection(services, a.serviceServiceBuilder(namespaces),
+		krtopts.ToOptions("ServicesInfo")...)
+	ServiceEntriesInfo := krt.NewManyCollection(serviceEntries, a.serviceEntryServiceBuilder(namespaces),
+		krtopts.ToOptions("ServiceEntriesInfo")...)
+	// TODO: add inference pool to svc collection
+	WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{ServicesInfo, ServiceEntriesInfo}, krtopts.ToOptions("WorkloadService")...)
+	return WorkloadServices
+}
+
+func (a *index) serviceServiceBuilder(
+	namespaces krt.Collection[*v1.Namespace],
+) krt.TransformationSingle[*v1.Service, ServiceInfo] {
+	return func(ctx krt.HandlerContext, s *v1.Service) *ServiceInfo {
+		if s.Spec.Type == v1.ServiceTypeExternalName {
+			// ExternalName services are not implemented by ambient (but will still work).
+			// The DNS requests will forward to the upstream DNS server, then Ztunnel can handle the request based on the target
+			// hostname.
+			// In theory we could add support for native 'DNS alias' into Ztunnel's DNS proxy. This would give the same behavior
+			// but let the DNS proxy handle it instead of forwarding upstream. However, at this time we do not do so.
+			return nil
+		}
+		portNames := map[int32]ServicePortName{}
+		for _, p := range s.Spec.Ports {
+			portNames[p.Port] = ServicePortName{
+				PortName:       p.Name,
+				TargetPortName: p.TargetPort.StrVal,
+			}
+		}
+
+		svc := a.constructService(ctx, s)
+		return precomputeServicePtr(&ServiceInfo{
+			Service:       svc,
+			PortNames:     portNames,
+			LabelSelector: NewSelector(s.Spec.Selector),
+			Source:        MakeSource(s),
+		})
+	}
+}
+
+// ServiceHostname produces FQDN for a k8s service
+func InferenceHostname(name, namespace, domainSuffix string) host.Name {
+	return host.Name(name + "." + namespace + "." + "inference" + "." + domainSuffix) // Format: "%s.%s.svc.%s"
+}
+
+func (a *index) inferencePoolBuilder(
+	namespaces krt.Collection[*v1.Namespace],
+) krt.TransformationSingle[*inf.InferencePool, ServiceInfo] {
+	return func(ctx krt.HandlerContext, s *inf.InferencePool) *ServiceInfo {
+		portNames := map[int32]ServicePortName{}
+		ports := []*api.Port{{
+			ServicePort: uint32(s.Spec.TargetPortNumber),
+			TargetPort:  uint32(s.Spec.TargetPortNumber),
+			AppProtocol: api.AppProtocol_HTTP11,
+		}}
+
+		// TODO this is only checking one controller - we may be missing service vips for instances in another cluster
+		svc := &api.Service{
+			Name:      s.Name,
+			Namespace: s.Namespace,
+			Hostname:  string(InferenceHostname(s.Name, s.Namespace, a.DomainSuffix)),
+			Ports:     ports,
+		}
+
+		selector := make(map[string]string, len(s.Spec.Selector))
+		for k, v := range s.Spec.Selector {
+			selector[string(k)] = string(v)
+		}
+		return precomputeServicePtr(&ServiceInfo{
+			Service:       svc,
+			PortNames:     portNames,
+			LabelSelector: NewSelector(selector),
+			Source:        MakeSource(s),
+		})
+	}
+}
+
+func (a *index) serviceEntryServiceBuilder(
+	namespaces krt.Collection[*v1.Namespace],
+) krt.TransformationMulti[*networkingclient.ServiceEntry, ServiceInfo] {
+	return func(ctx krt.HandlerContext, s *networkingclient.ServiceEntry) []ServiceInfo {
+		return a.serviceEntriesInfo(ctx, s)
+	}
+}
+
+func toAppProtocolFromKube(p v1.ServicePort) api.AppProtocol {
+	return toAppProtocolFromProtocol(string(kubeutil.ConvertProtocol(p.Port, p.Name, p.Protocol, p.AppProtocol)))
+}
+
+func (a *index) constructService(ctx krt.HandlerContext, svc *v1.Service) *api.Service {
+	ports := make([]*api.Port, 0, len(svc.Spec.Ports))
+	for _, p := range svc.Spec.Ports {
+		ports = append(ports, &api.Port{
+			ServicePort: uint32(p.Port),
+			TargetPort:  uint32(p.TargetPort.IntVal),
+			AppProtocol: toAppProtocolFromKube(p),
+		})
+	}
+
+	addresses, err := slices.MapErr(getVIPs(svc), func(e string) (*api.NetworkAddress, error) {
+		return a.toNetworkAddress(ctx, e)
+	})
+	if err != nil {
+		logger.Warn("fail to parse service", "svc", config.NamespacedName(svc), "error", err)
+		return nil
+	}
+
+	var lb *api.LoadBalancing
+
+	// The TrafficDistribution field is quite new, so we allow a legacy annotation option as well
+	preferClose := strings.EqualFold(svc.Annotations[apiannotation.NetworkingTrafficDistribution.Name], v1.ServiceTrafficDistributionPreferClose)
+	if svc.Spec.TrafficDistribution != nil {
+		preferClose = *svc.Spec.TrafficDistribution == v1.ServiceTrafficDistributionPreferClose
+	}
+	if preferClose {
+		lb = preferCloseLoadBalancer
+	}
+	if itp := svc.Spec.InternalTrafficPolicy; itp != nil && *itp == v1.ServiceInternalTrafficPolicyLocal {
+		lb = &api.LoadBalancing{
+			// Only allow endpoints on the same node.
+			RoutingPreference: []api.LoadBalancing_Scope{
+				api.LoadBalancing_NODE,
+			},
+			Mode: api.LoadBalancing_STRICT,
+		}
+	}
+	if svc.Spec.PublishNotReadyAddresses {
+		if lb == nil {
+			lb = &api.LoadBalancing{}
+		}
+		lb.HealthPolicy = api.LoadBalancing_ALLOW_ALL
+	}
+
+	ipFamily := api.IPFamilies_AUTOMATIC
+	if len(svc.Spec.IPFamilies) == 2 {
+		ipFamily = api.IPFamilies_DUAL
+	} else if len(svc.Spec.IPFamilies) == 1 {
+		family := svc.Spec.IPFamilies[0]
+		if family == v1.IPv4Protocol {
+			ipFamily = api.IPFamilies_IPV4_ONLY
+		} else {
+			ipFamily = api.IPFamilies_IPV6_ONLY
+		}
+	}
+	// TODO this is only checking one controller - we may be missing service vips for instances in another cluster
+	return &api.Service{
+		Name:          svc.Name,
+		Namespace:     svc.Namespace,
+		Hostname:      string(kube.ServiceHostname(svc.Name, svc.Namespace, a.DomainSuffix)),
+		Addresses:     addresses,
+		Ports:         ports,
+		LoadBalancing: lb,
+		IpFamilies:    ipFamily,
+	}
+}
+
+var preferCloseLoadBalancer = &api.LoadBalancing{
+	// Prefer endpoints in close zones, but allow spilling over to further endpoints where required.
+	RoutingPreference: []api.LoadBalancing_Scope{
+		api.LoadBalancing_NETWORK,
+		api.LoadBalancing_REGION,
+		api.LoadBalancing_ZONE,
+		api.LoadBalancing_SUBZONE,
+	},
+	Mode: api.LoadBalancing_FAILOVER,
+}
+
+func getVIPs(svc *v1.Service) []string {
+	res := []string{}
+	cips := svc.Spec.ClusterIPs
+	if len(cips) == 0 {
+		cips = []string{svc.Spec.ClusterIP}
+	}
+	for _, cip := range cips {
+		if cip != "" && cip != v1.ClusterIPNone {
+			res = append(res, cip)
+		}
+	}
+	return res
+}
+
 // Service describes an Istio service (e.g., catalog.mystore.com:8080)
 // Each service has a fully qualified domain name (FQDN) and one or more
 // ports where the service is listening for connections. *Optionally*, a
@@ -170,14 +360,6 @@ func (resolution Resolution) String() string {
 	}
 }
 
-const (
-	// LocalityLabel indicates the region/zone/subzone of an instance. It is used to override the native
-	// registry's value.
-	//
-	// Note: because k8s labels does not support `/`, so we use `.` instead in k8s.
-	LocalityLabel = pm.LocalityLabel
-)
-
 const (
 	// TunnelLabel defines the label workloads describe to indicate that they support tunneling.
 	// Values are expected to be a CSV list, sorted by preference, of protocols supported.
@@ -206,12 +388,6 @@ const (
 
 	// IstioMutualTLSModeLabel implies that the endpoint is ready to receive Istio mTLS connections.
 	IstioMutualTLSModeLabel = "istio"
-
-	// IstioCanonicalServiceLabelName is the name of label for the Istio Canonical Service for a workload instance.
-	IstioCanonicalServiceLabelName = pm.IstioCanonicalServiceLabelName
-
-	// IstioCanonicalServiceRevisionLabelName is the name of label for the Istio Canonical Service revision for a workload instance.
-	IstioCanonicalServiceRevisionLabelName = pm.IstioCanonicalServiceRevisionLabelName
 )
 
 func SupportsTunnel(labels map[string]string, tunnelType string) bool {
@@ -231,7 +407,7 @@ func SupportsTunnel(labels map[string]string, tunnelType string) bool {
 // connections. The port should be annotated with the type of protocol
 // used by the port.
 type Port struct {
-	// Name ascribes a human readable name for the port object. When a
+	// Name ascribes a human-readable name for the port object. When a
 	// service has multiple ports, the name field is mandatory
 	Name string `json:"name,omitempty"`
 
@@ -268,37 +444,6 @@ const (
 	trafficDirectionInboundSrvPrefix = string(TrafficDirectionInbound) + "_"
 )
 
-// ServiceInstance represents an individual instance of a specific version
-// of a service. It binds a network endpoint (ip:port), the service
-// description (which is oblivious to various versions) and a set of labels
-// that describe the service version associated with this instance.
-//
-// Since a ServiceInstance has a single IstioEndpoint, which has a single port,
-// multiple ServiceInstances are required to represent a workload that listens
-// on multiple ports.
-//
-// The labels associated with a service instance are unique per a network endpoint.
-// There is one well defined set of labels for each service instance network endpoint.
-//
-// For example, the set of service instances associated with catalog.mystore.com
-// are modeled like this
-//
-//	--> IstioEndpoint(172.16.0.1:8888), Service(catalog.myservice.com), Labels(foo=bar)
-//	--> IstioEndpoint(172.16.0.2:8888), Service(catalog.myservice.com), Labels(foo=bar)
-//	--> IstioEndpoint(172.16.0.3:8888), Service(catalog.myservice.com), Labels(kitty=cat)
-//	--> IstioEndpoint(172.16.0.4:8888), Service(catalog.myservice.com), Labels(kitty=cat)
-type ServiceInstance struct {
-	Service     *Service       `json:"service,omitempty"`
-	ServicePort *Port          `json:"servicePort,omitempty"`
-	Endpoint    *IstioEndpoint `json:"endpoint,omitempty"`
-}
-
-func (instance *ServiceInstance) CmpOpts() []cmp.Option {
-	res := []cmp.Option{}
-	res = append(res, serviceCmpOpts...)
-	return res
-}
-
 // ServiceTarget includes a Service object, along with a specific service port
 // and target port. This is basically a smaller version of ServiceInstance,
 // intended to avoid the need to have the full object when only port information
@@ -310,7 +455,7 @@ type ServiceTarget struct {
 
 type (
 	ServicePort = *Port
-	// ServiceInstancePort defines a port that has both a port and targetPort (which distinguishes it from model.Port)
+	// ServiceInstancePort defines a port that has both a port and targetPort (which distinguishes it from Port)
 	// Note: ServiceInstancePort only makes sense in the context of a specific ServiceInstance, because TargetPort depends on a specific instance.
 	ServiceInstancePort struct {
 		ServicePort
@@ -318,29 +463,6 @@ type (
 	}
 )
 
-func ServiceInstanceToTarget(e *ServiceInstance) ServiceTarget {
-	return ServiceTarget{
-		Service: e.Service,
-		Port: ServiceInstancePort{
-			ServicePort: e.ServicePort,
-			TargetPort:  e.Endpoint.EndpointPort,
-		},
-	}
-}
-
-// DeepCopy creates a copy of ServiceInstance.
-func (instance *ServiceInstance) DeepCopy() *ServiceInstance {
-	return &ServiceInstance{
-		Service:  instance.Service.DeepCopy(),
-		Endpoint: instance.Endpoint.DeepCopy(),
-		ServicePort: &Port{
-			Name:     instance.ServicePort.Name,
-			Port:     instance.ServicePort.Port,
-			Protocol: instance.ServicePort.Protocol,
-		},
-	}
-}
-
 type workloadKind int
 
 const (
@@ -361,69 +483,6 @@ func (k workloadKind) String() string {
 	return ""
 }
 
-type WorkloadInstance struct {
-	Name      string `json:"name,omitempty"`
-	Namespace string `json:"namespace,omitempty"`
-	// Where the workloadInstance come from, valid values are`Pod` or `WorkloadEntry`
-	Kind     workloadKind      `json:"kind"`
-	Endpoint *IstioEndpoint    `json:"endpoint,omitempty"`
-	PortMap  map[string]uint32 `json:"portMap,omitempty"`
-	// Can only be selected by service entry of DNS type.
-	DNSServiceEntryOnly bool `json:"dnsServiceEntryOnly,omitempty"`
-}
-
-// DeepCopy creates a copy of WorkloadInstance.
-func (instance *WorkloadInstance) DeepCopy() *WorkloadInstance {
-	out := *instance
-	out.PortMap = maps.Clone(instance.PortMap)
-	out.Endpoint = instance.Endpoint.DeepCopy()
-	return &out
-}
-
-// WorkloadInstancesEqual is a custom comparison of workload instances based on the fields that we need.
-// Returns true if equal, false otherwise.
-func WorkloadInstancesEqual(first, second *WorkloadInstance) bool {
-	if first.Endpoint == nil || second.Endpoint == nil {
-		return first.Endpoint == second.Endpoint
-	}
-
-	if !slices.EqualUnordered(first.Endpoint.Addresses, second.Endpoint.Addresses) {
-		return false
-	}
-
-	if first.Endpoint.Network != second.Endpoint.Network {
-		return false
-	}
-	if first.Endpoint.TLSMode != second.Endpoint.TLSMode {
-		return false
-	}
-	if !first.Endpoint.Labels.Equals(second.Endpoint.Labels) {
-		return false
-	}
-	if first.Endpoint.ServiceAccount != second.Endpoint.ServiceAccount {
-		return false
-	}
-	if first.Endpoint.Locality != second.Endpoint.Locality {
-		return false
-	}
-	if first.Endpoint.GetLoadBalancingWeight() != second.Endpoint.GetLoadBalancingWeight() {
-		return false
-	}
-	if first.Namespace != second.Namespace {
-		return false
-	}
-	if first.Name != second.Name {
-		return false
-	}
-	if first.Kind != second.Kind {
-		return false
-	}
-	if !maps.Equal(first.PortMap, second.PortMap) {
-		return false
-	}
-	return true
-}
-
 // GetLocalityLabel returns the locality from the supplied label. Because Kubernetes
 // labels don't support `/`, we replace "." with "/" in the supplied label as a workaround.
 func GetLocalityLabel(label string) string {
@@ -439,182 +498,6 @@ type Locality struct {
 	ClusterID cluster.ID
 }
 
-// HealthStatus indicates the status of the Endpoint.
-type HealthStatus int32
-
-const (
-	// Healthy indicates an endpoint is ready to accept traffic
-	Healthy HealthStatus = 1
-	// UnHealthy indicates an endpoint is not ready to accept traffic
-	UnHealthy HealthStatus = 2
-	// Draining is a special case, which is used only when persistent sessions are enabled. This indicates an endpoint
-	// was previously healthy, but is now shutting down.
-	// Without persistent sessions, an endpoint that is shutting down will be marked as Terminating.
-	Draining HealthStatus = 3
-	// Terminating marks an endpoint as shutting down. Similar to "unhealthy", this means we should not send it traffic.
-	// But unlike "unhealthy", this means we do not consider it when calculating failover.
-	Terminating HealthStatus = 4
-)
-
-// IstioEndpoint defines a network address (IP:port) associated with an instance of the
-// service. A service has one or more instances each running in a
-// container/VM/pod. If a service has multiple ports, then the same
-// instance IP is expected to be listening on multiple ports (one per each
-// service port). Note that the port associated with an instance does not
-// have to be the same as the port associated with the service. Depending
-// on the network setup (NAT, overlays), this could vary.
-//
-// For e.g., if catalog.mystore.com is accessible through port 80 and 8080,
-// and it maps to an instance with IP 172.16.0.1, such that connections to
-// port 80 are forwarded to port 55446, and connections to port 8080 are
-// forwarded to port 33333,
-//
-// then internally, we have two endpoint structs for the
-// service catalog.mystore.com
-//
-//	--> 172.16.0.1:55446 (with ServicePort pointing to 80) and
-//	--> 172.16.0.1:33333 (with ServicePort pointing to 8080)
-type IstioEndpoint struct {
-	// Labels points to the workload or deployment labels.
-	Labels labels.Instance
-
-	// Addresses are the addresses of the endpoint, using envoy proto:
-	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/endpoint/v3/endpoint_components.proto#config-endpoint-v3-endpoint-additionaladdress
-	// This field can support multiple addresses for an Dual Stack endpoint, especially for an endpoint which contains both ipv4 or ipv6 addresses.
-	// There should be some constraints below:
-	// 1. Each address of the endpoint must have the same metadata.
-	// 2. The function Key() of IstioEndpoint returns the first IP address of this field in string format.
-	// 3. The IP address of field `address` in Envoy Endpoint is equal to the first address of this field.
-	// When the additional_addresses field is populated for EDS in Envoy configuration, Envoy will use an Happy Eyeballs algorithm.
-	// Therefore Envoy will first attempt connecting to the IP address in the `address` field of Envoy Endpoint.
-	// If the first attempt fails, then it will interleave IP addresses in the `additional_addresses` field based on IP version, as described in rfc8305,
-	// and attempt connections with them with a delay of 300ms each. The first connection to succeed will be used.
-	// Note: it uses Hash Based Load Balancing Policies for multiple addresses support Endpoint, and only the first address of the
-	// endpoint will be used as the hash key for the ring or maglev list, however, the upstream address that load balancer ends up
-	// connecting to will depend on the one that ends up "winning" using the Happy Eyeballs algorithm.
-	// Please refer to https://docs.google.com/document/d/1AjmTcMWwb7nia4rAgqE-iqIbSbfiXCI4h1vk-FONFdM/ for more details.
-	Addresses []string
-
-	// ServicePortName tracks the name of the port, this is used to select the IstioEndpoint by service port.
-	ServicePortName string
-	// LegacyClusterPortKey provides an alternative key from ServicePortName to support legacy quirks in the API.
-	// Basically, EDS merges by port name, but CDS historically ignored port name and matched on number.
-	// Note that for Kubernetes Service, this is identical - its only ServiceEntry where these checks can differ
-	LegacyClusterPortKey int
-
-	// ServiceAccount holds the associated service account.
-	ServiceAccount string
-
-	// Network holds the network where this endpoint is present
-	Network network.ID
-
-	// The locality where the endpoint is present.
-	Locality Locality
-
-	// EndpointPort is the port where the workload is listening, can be different
-	// from the service port.
-	EndpointPort uint32
-
-	// The load balancing weight associated with this endpoint.
-	LbWeight uint32
-
-	// TLSMode endpoint is injected with istio sidecar and ready to configure Istio mTLS
-	TLSMode string
-
-	// Namespace that this endpoint belongs to. This is for telemetry purpose.
-	Namespace string
-
-	// Name of the workload that this endpoint belongs to. This is for telemetry purpose.
-	WorkloadName string
-
-	// Specifies the hostname of the Pod, empty for vm workload.
-	HostName string
-
-	// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
-	SubDomain string
-
-	// Indicates the endpoint health status.
-	HealthStatus HealthStatus
-
-	// SendUnhealthyEndpoints indicates whether this endpoint should be sent when it is unhealthy
-	// Note: this is more appropriate at the Service level, but some codepaths require this in areas without the service
-	// object present.
-	SendUnhealthyEndpoints bool
-
-	// If in k8s, the node where the pod resides
-	NodeName string
-}
-
-func (ep *IstioEndpoint) SupportsTunnel(tunnelType string) bool {
-	return SupportsTunnel(ep.Labels, tunnelType)
-}
-
-// GetLoadBalancingWeight returns the weight for this endpoint, normalized to always be > 0.
-func (ep *IstioEndpoint) GetLoadBalancingWeight() uint32 {
-	if ep.LbWeight > 0 {
-		return ep.LbWeight
-	}
-	return 1
-}
-
-// MetadataClone returns the cloned endpoint metadata used for telemetry purposes.
-// This should be used when the endpoint labels should be updated.
-func (ep *IstioEndpoint) MetadataClone() *EndpointMetadata {
-	return &EndpointMetadata{
-		Network:      ep.Network,
-		TLSMode:      ep.TLSMode,
-		WorkloadName: ep.WorkloadName,
-		Namespace:    ep.Namespace,
-		Labels:       maps.Clone(ep.Labels),
-		ClusterID:    ep.Locality.ClusterID,
-	}
-}
-
-// Metadata returns the endpoint metadata used for telemetry purposes.
-func (ep *IstioEndpoint) Metadata() *EndpointMetadata {
-	return &EndpointMetadata{
-		Network:      ep.Network,
-		TLSMode:      ep.TLSMode,
-		WorkloadName: ep.WorkloadName,
-		Namespace:    ep.Namespace,
-		Labels:       ep.Labels,
-		ClusterID:    ep.Locality.ClusterID,
-	}
-}
-
-func (ep *IstioEndpoint) FirstAddressOrNil() string {
-	if ep == nil || len(ep.Addresses) == 0 {
-		return ""
-	}
-	return ep.Addresses[0]
-}
-
-// Key returns a function suitable for usage to distinguish this IstioEndpoint from another
-func (ep *IstioEndpoint) Key() string {
-	return ep.FirstAddressOrNil() + "/" + ep.WorkloadName + "/" + ep.ServicePortName
-}
-
-// EndpointMetadata represents metadata set on Envoy LbEndpoint used for telemetry purposes.
-type EndpointMetadata struct {
-	// Network holds the network where this endpoint is present
-	Network network.ID
-
-	// TLSMode endpoint is injected with istio sidecar and ready to configure Istio mTLS
-	TLSMode string
-
-	// Name of the workload that this endpoint belongs to. This is for telemetry purpose.
-	WorkloadName string
-
-	// Namespace that this endpoint belongs to. This is for telemetry purpose.
-	Namespace string
-
-	// Labels points to the workload or deployment labels.
-	Labels labels.Instance
-
-	// ClusterID where the endpoint is located
-	ClusterID cluster.ID
-}
-
 // ServiceAttributes represents a group of custom attributes of the service.
 type ServiceAttributes struct {
 	// ServiceRegistry indicates the backing service registry system where this service
@@ -927,27 +810,6 @@ func (l LabelSelector) GetLabelSelector() map[string]string {
 	return l.Labels
 }
 
-func ExtractWorkloadsFromAddresses(addrs []AddressInfo) []WorkloadInfo {
-	return slices.MapFilter(addrs, func(a AddressInfo) *WorkloadInfo {
-		switch addr := a.Type.(type) {
-		case *api.Address_Workload:
-			return &WorkloadInfo{Workload: addr.Workload}
-		default:
-			return nil
-		}
-	})
-}
-
-func SortWorkloadsByCreationTime(workloads []WorkloadInfo) []WorkloadInfo {
-	sort.SliceStable(workloads, func(i, j int) bool {
-		if workloads[i].CreationTime.Equal(workloads[j].CreationTime) {
-			return workloads[i].Workload.GetUid() < workloads[j].Workload.GetUid()
-		}
-		return workloads[i].CreationTime.Before(workloads[j].CreationTime)
-	})
-	return workloads
-}
-
 type NamespaceInfo struct {
 	Name               string
 	IngressUseWaypoint bool
@@ -1026,91 +888,6 @@ func (ports PortList) String() string {
 	return strings.Join(sp, ", ")
 }
 
-// BuildSubsetKey generates a unique string referencing service instances for a given service name, a subset and a port.
-// The proxy queries Pilot with this key to obtain the list of instances in a subset.
-func BuildSubsetKey(direction TrafficDirection, subsetName string, hostname host.Name, port int) string {
-	return string(direction) + "|" + strconv.Itoa(port) + "|" + subsetName + "|" + string(hostname)
-}
-
-// BuildInboundSubsetKey generates a unique string referencing service instances with port.
-func BuildInboundSubsetKey(port int) string {
-	return BuildSubsetKey(TrafficDirectionInbound, "", "", port)
-}
-
-// BuildDNSSrvSubsetKey generates a unique string referencing service instances for a given service name, a subset and a port.
-// The proxy queries Pilot with this key to obtain the list of instances in a subset.
-// This is used only for the SNI-DNAT router. Do not use for other purposes.
-// The DNS Srv format of the cluster is also used as the default SNI string for Istio mTLS connections
-func BuildDNSSrvSubsetKey(direction TrafficDirection, subsetName string, hostname host.Name, port int) string {
-	return string(direction) + "_." + strconv.Itoa(port) + "_." + subsetName + "_." + string(hostname)
-}
-
-// IsValidSubsetKey checks if a string is valid for subset key parsing.
-func IsValidSubsetKey(s string) bool {
-	return strings.Count(s, "|") == 3
-}
-
-// IsDNSSrvSubsetKey checks whether the given key is a DNSSrv key (built by BuildDNSSrvSubsetKey).
-func IsDNSSrvSubsetKey(s string) bool {
-	if strings.HasPrefix(s, trafficDirectionOutboundSrvPrefix) ||
-		strings.HasPrefix(s, trafficDirectionInboundSrvPrefix) {
-		return true
-	}
-	return false
-}
-
-// ParseSubsetKeyHostname is an optimized specialization of ParseSubsetKey that only returns the hostname.
-// This is created as this is used in some hot paths and is about 2x faster than ParseSubsetKey; for typical use ParseSubsetKey is sufficient (and zero-alloc).
-func ParseSubsetKeyHostname(s string) (hostname string) {
-	idx := strings.LastIndex(s, "|")
-	if idx == -1 {
-		// Could be DNS SRV format.
-		// Do not do LastIndex("_."), as those are valid characters in the hostname (unlike |)
-		// Fallback to the full parser.
-		_, _, hostname, _ := ParseSubsetKey(s)
-		return string(hostname)
-	}
-	return s[idx+1:]
-}
-
-// ParseSubsetKey is the inverse of the BuildSubsetKey method
-func ParseSubsetKey(s string) (direction TrafficDirection, subsetName string, hostname host.Name, port int) {
-	sep := "|"
-	// This could be the DNS srv form of the cluster that uses outbound_.port_.subset_.hostname
-	// Since we do not want every callsite to implement the logic to differentiate between the two forms
-	// we add an alternate parser here.
-	if strings.HasPrefix(s, trafficDirectionOutboundSrvPrefix) ||
-		strings.HasPrefix(s, trafficDirectionInboundSrvPrefix) {
-		sep = "_."
-	}
-
-	// Format: dir|port|subset|hostname
-	dir, s, ok := strings.Cut(s, sep)
-	if !ok {
-		return
-	}
-	direction = TrafficDirection(dir)
-
-	p, s, ok := strings.Cut(s, sep)
-	if !ok {
-		return
-	}
-	port, _ = strconv.Atoi(p)
-
-	ss, s, ok := strings.Cut(s, sep)
-	if !ok {
-		return
-	}
-	subsetName = ss
-
-	// last part. No | remains -- verify this
-	if strings.Contains(s, sep) {
-		return
-	}
-	hostname = host.Name(s)
-	return
-}
-
 // HasAddressOrAssigned returns whether the service has an IP address.
 // This includes auto-allocated IP addresses. Note that not all proxies support auto-allocated IP addresses;
 // typically GetAllAddressesForProxy should be used which automatically filters addresses to account for that.
@@ -1132,37 +909,6 @@ func (s *Service) HasAddressOrAssigned(id cluster.ID) bool {
 	return false
 }
 
-func filterAddresses(addresses []string, supportsV4, supportsV6 bool) []string {
-	var ipv4Addresses []string
-	var ipv6Addresses []string
-	for _, addr := range addresses {
-		// check if an address is a CIDR range
-		if strings.Contains(addr, "/") {
-			if prefix, err := netip.ParsePrefix(addr); err != nil {
-				logger.Warn("failed to parse prefix address", "addr", addr, "error", err)
-				continue
-			} else if supportsV4 && prefix.Addr().Is4() {
-				ipv4Addresses = append(ipv4Addresses, addr)
-			} else if supportsV6 && prefix.Addr().Is6() {
-				ipv6Addresses = append(ipv6Addresses, addr)
-			}
-		} else {
-			if ipAddr, err := netip.ParseAddr(addr); err != nil {
-				logger.Warn("failed to parse address", "addr", addr, "error", err)
-				continue
-			} else if supportsV4 && ipAddr.Is4() {
-				ipv4Addresses = append(ipv4Addresses, addr)
-			} else if supportsV6 && ipAddr.Is6() {
-				ipv6Addresses = append(ipv6Addresses, addr)
-			}
-		}
-	}
-	if len(ipv4Addresses) > 0 {
-		return ipv4Addresses
-	}
-	return ipv6Addresses
-}
-
 // GetTLSModeFromEndpointLabels returns the value of the label
 // security.istio.io/tlsMode if set. Do not return Enums or constants
 // from this function as users could provide values other than istio/disabled
@@ -1235,66 +981,6 @@ func (s *Service) Equals(other *Service) bool {
 		s.Resolution == other.Resolution
 }
 
-// DeepCopy creates a clone of IstioEndpoint.
-func (ep *IstioEndpoint) DeepCopy() *IstioEndpoint {
-	if ep == nil {
-		return nil
-	}
-
-	out := *ep
-	out.Labels = maps.Clone(ep.Labels)
-	out.Addresses = slices.Clone(ep.Addresses)
-
-	return &out
-}
-
-// ShallowCopy creates a shallow clone of IstioEndpoint.
-func (ep *IstioEndpoint) ShallowCopy() *IstioEndpoint {
-	// nolint: govet
-	cpy := *ep
-	return &cpy
-}
-
-// Equals checks whether the attributes are equal from the passed in service.
-func (ep *IstioEndpoint) Equals(other *IstioEndpoint) bool {
-	if ep == nil {
-		return other == nil
-	}
-	if other == nil {
-		return ep == nil
-	}
-
-	// Check things we can directly compare...
-	eq := ep.ServicePortName == other.ServicePortName &&
-		ep.LegacyClusterPortKey == other.LegacyClusterPortKey &&
-		ep.ServiceAccount == other.ServiceAccount &&
-		ep.Network == other.Network &&
-		ep.Locality == other.Locality &&
-		ep.EndpointPort == other.EndpointPort &&
-		ep.LbWeight == other.LbWeight &&
-		ep.TLSMode == other.TLSMode &&
-		ep.Namespace == other.Namespace &&
-		ep.WorkloadName == other.WorkloadName &&
-		ep.HostName == other.HostName &&
-		ep.SubDomain == other.SubDomain &&
-		ep.HealthStatus == other.HealthStatus &&
-		ep.SendUnhealthyEndpoints == other.SendUnhealthyEndpoints &&
-		ep.NodeName == other.NodeName
-	if !eq {
-		return false
-	}
-
-	// check everything else
-	if !slices.EqualUnordered(ep.Addresses, other.Addresses) {
-		return false
-	}
-	if !maps.Equal(ep.Labels, other.Labels) {
-		return false
-	}
-
-	return true
-}
-
 func equalUsingPremarshaled[T proto.Message](a T, am *anypb.Any, b T, bm *anypb.Any) bool {
 	// If they are both pre-marshaled, use the marshaled representation. This is orders of magnitude faster
 	if am != nil && bm != nil {
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 2724d1801..a4ea43190 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -12,12 +12,14 @@ import (
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/config/schema/gvr"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/kclient"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/kube/kubetypes"
 	corev1 "k8s.io/api/core/v1"
+	discoveryv1 "k8s.io/api/discovery/v1"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/sets"
 	"k8s.io/client-go/tools/cache"
@@ -41,7 +43,8 @@ var logger = logging.New("agentgateway/syncer")
 type AgentGwSyncer struct {
 	commonCols     *common.CommonCollections
 	controllerName string
-	xDS            krt.Collection[ADPCacheResource]
+	resourcexDS    krt.Collection[ADPCacheResource]
+	addressxDS     krt.Collection[ADPCacheAddress]
 	xdsCache       envoycache.SnapshotCache
 	client         kube.Client
 	domainSuffix   string
@@ -269,16 +272,98 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		routeInputs,
 		krtopts,
 	)
-	//httpRoutes := HTTPRouteCollection(
-	//	inputs.HTTPRoutes,
-	//	routeInputs,
-	//	krtopts,
-	//)
 
 	// TODO: inference pool
 
+	epSliceClient := kclient.NewFiltered[*discoveryv1.EndpointSlice](
+		s.commonCols.Client,
+		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
+	)
+	endpointSlices := krt.WrapClient(epSliceClient, s.commonCols.KrtOpts.ToOptions("EndpointSlices")...)
+
+	podsClient := kclient.NewFiltered[*corev1.Pod](
+		s.commonCols.Client,
+		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
+	)
+	pods := krt.WrapClient(podsClient, s.commonCols.KrtOpts.ToOptions("Pods")...)
+	nsClient := kclient.NewFiltered[*corev1.Namespace](
+		s.commonCols.Client,
+		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
+	)
+	namespaces := krt.WrapClient(nsClient, s.commonCols.KrtOpts.ToOptions("Namespaces")...)
+
+	seInformer := kclient.NewDelayedInformer[*networkingclient.ServiceEntry](
+		s.client, gvr.ServiceEntry,
+		kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.client.ObjectFilter()},
+	)
+	serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("ServiceEntries")...)
+
+	workloadIndex := index{
+		services: servicesCollection{},
+	}
+
+	// these are agw api-style services combined from kube services and service entries
+	WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, serviceEntries, namespaces, krtopts)
+	avcAddresses := krt.NewCollection(WorkloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
+		var cacheResources []envoytypes.Resource
+		addrMessage := obj.AsAddress.Address
+		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
+			Message: addrMessage,
+			Name:    obj.ResourceName(),
+			version: utils.HashProto(addrMessage),
+		})
+
+		// Create the resource wrappers
+		var resourceVersion uint64
+		for _, res := range cacheResources {
+			resourceVersion ^= res.(*envoyResourceWithCustomName).version
+		}
+
+		result := &ADPCacheAddress{
+			NamespacedName: types.NamespacedName{Name: obj.Service.GetName(), Namespace: obj.Service.GetNamespace()},
+			Address:        envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
+		}
+		logger.Debug("created XDS resources for svc address with ID", "addr", fmt.Sprintf("%s,%s", obj.Service.GetName(), obj.Service.GetNamespace()), "resourceid", result.ResourceName())
+		return result
+	})
+
+	Workloads := workloadIndex.WorkloadsCollection(
+		pods,
+		WorkloadServices,
+		serviceEntries,
+		endpointSlices,
+		namespaces,
+		krtopts,
+	)
+
+	proxyKey := "default~agent-gateway" // TODO: don't hard code, use s.perclientSnapCollection
+	workloadAddresses := krt.NewCollection(Workloads, func(ctx krt.HandlerContext, obj WorkloadInfo) *ADPCacheAddress {
+		var cacheResources []envoytypes.Resource
+		addrMessage := obj.AsAddress.Address
+		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
+			Message: addrMessage,
+			Name:    obj.ResourceName(),
+			version: utils.HashProto(addrMessage),
+		})
+
+		// Create the resource wrappers
+		var resourceVersion uint64
+		for _, res := range cacheResources {
+			resourceVersion ^= res.(*envoyResourceWithCustomName).version
+		}
+
+		result := &ADPCacheAddress{
+			NamespacedName: types.NamespacedName{Name: obj.Workload.GetName(), Namespace: obj.Workload.GetNamespace()},
+			Address:        envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
+			proxyKey:       proxyKey,
+		}
+		logger.Debug("created XDS resources for workload address with ID", "addr", fmt.Sprintf("%s,%s", obj.Workload.GetName(), obj.Workload.GetNamespace()), "resourceid", result.ResourceName())
+		return result
+	})
+	s.addressxDS = krt.JoinCollection([]krt.Collection[ADPCacheAddress]{avcAddresses, workloadAddresses}, krtopts.ToOptions("ADPAddresses")...)
+
 	resources := krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, ADPRoutes}, krtopts.ToOptions("ADPResources")...)
-	s.xDS = krt.NewCollection(resources, func(ctx krt.HandlerContext, obj ADPResource) *ADPCacheResource {
+	s.resourcexDS = krt.NewCollection(resources, func(ctx krt.HandlerContext, obj ADPResource) *ADPCacheResource {
 		var cacheResources []envoytypes.Resource
 		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
 			Message: obj.Resource,
@@ -302,10 +387,19 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
+		// resources
 		Binds.HasSynced,
 		Listeners.HasSynced,
 		ADPRoutes.HasSynced,
-		s.xDS.HasSynced,
+		s.resourcexDS.HasSynced,
+		// addresses
+		serviceEntries.HasSynced,
+		namespaces.HasSynced,
+		pods.HasSynced,
+		endpointSlices.HasSynced,
+		WorkloadServices.HasSynced,
+		Workloads.HasSynced,
+		s.addressxDS.HasSynced,
 	}
 }
 
@@ -318,7 +412,7 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		return fmt.Errorf("agentgateway syncer waiting for cache to sync failed")
 	}
 
-	s.xDS.RegisterBatch(func(events []krt.Event[ADPCacheResource], _ bool) {
+	s.resourcexDS.RegisterBatch(func(events []krt.Event[ADPCacheResource], _ bool) {
 		for _, e := range events {
 			r := e.Latest()
 			if e.Event == controllers.EventDelete {
@@ -327,7 +421,6 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 			}
 			snapshot := &agentGwSnapshot{
 				Resources: r.Resources,
-				Addresses: r.Addresses,
 			}
 			logger.Debug("setting xds snapshot", "resourcename", r.ResourceName())
 			err := s.xdsCache.SetSnapshot(ctx, r.ResourceName(), snapshot)
@@ -338,6 +431,26 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		}
 	}, true)
 
+	s.addressxDS.RegisterBatch(func(events []krt.Event[ADPCacheAddress], _ bool) {
+		for _, e := range events {
+			r := e.Latest()
+			if e.Event == controllers.EventDelete {
+				s.xdsCache.ClearSnapshot(r.ResourceName())
+				continue
+			}
+			snapshot := &agentGwSnapshot{
+				Addresses: r.Address,
+			}
+			logger.Debug("setting xds snapshot", "resourcename", r.ResourceName())
+			snapWrap := e.Latest()
+			err := s.xdsCache.SetSnapshot(ctx, snapWrap.proxyKey, snapshot)
+			if err != nil {
+				logger.Error("failed to set xds snapshot", "resourcename", r.ResourceName(), "error", err.Error())
+				continue
+			}
+		}
+	}, true)
+
 	return nil
 }
 
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
new file mode 100644
index 000000000..c779f98f1
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -0,0 +1,927 @@
+package agentgatewaysyncer
+
+import (
+	"fmt"
+	"net/netip"
+	"strings"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
+	"istio.io/api/annotation"
+	"istio.io/api/label"
+	apiv1 "istio.io/api/networking/v1"
+	networkingv1alpha3 "istio.io/api/networking/v1alpha3"
+	networkingv1beta1 "istio.io/api/networking/v1beta1"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pilot/pkg/serviceregistry/kube"
+	labelutil "istio.io/istio/pilot/pkg/serviceregistry/util/label"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
+	"istio.io/istio/pkg/config/host"
+	"istio.io/istio/pkg/config/schema/gvk"
+	"istio.io/istio/pkg/config/schema/kind"
+	"istio.io/istio/pkg/config/schema/kubetypes"
+	kubeutil "istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/controllers"
+	"istio.io/istio/pkg/kube/krt"
+	kubelabels "istio.io/istio/pkg/kube/labels"
+	"istio.io/istio/pkg/log"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
+	"istio.io/istio/pkg/util/sets"
+	corev1 "k8s.io/api/core/v1"
+	discovery "k8s.io/api/discovery/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+)
+
+// internal object used for indexing in ambientindex maps
+type networkAddress struct {
+	network string
+	ip      string
+}
+
+func (n networkAddress) String() string {
+	return n.network + "/" + n.ip
+}
+
+type NamespaceHostname struct {
+	Namespace string
+	Hostname  string
+}
+
+func (n NamespaceHostname) String() string {
+	return n.Namespace + "/" + n.Hostname
+}
+
+type workloadsCollection struct {
+	krt.Collection[WorkloadInfo]
+	ByAddress    krt.Index[networkAddress, WorkloadInfo]
+	ByServiceKey krt.Index[string, WorkloadInfo]
+}
+
+type servicesCollection struct {
+	krt.Collection[ServiceInfo]
+	ByAddress krt.Index[networkAddress, ServiceInfo]
+}
+
+// index maintains an index of ambient WorkloadInfo objects by various keys.
+// These are intentionally pre-computed based on events such that lookups are efficient.
+type index struct {
+	services   servicesCollection
+	workloads  workloadsCollection
+	namespaces krt.Collection[NamespaceInfo]
+
+	SystemNamespace string
+	DomainSuffix    string
+	ClusterID       string
+}
+
+// WorkloadsCollection builds out the core Workload object type used in ambient mode.
+// A Workload represents a single addressable unit of compute -- typically a Pod or a VM.
+// Workloads can come from a variety of sources; these are joined together to build one complete `Collection[WorkloadInfo]`.
+func (a *index) WorkloadsCollection(
+	pods krt.Collection[*corev1.Pod],
+	workloadServices krt.Collection[ServiceInfo],
+	serviceEntries krt.Collection[*networkingclient.ServiceEntry],
+	endpointSlices krt.Collection[*discovery.EndpointSlice],
+	namespaces krt.Collection[*corev1.Namespace],
+	krtopts krtutil.KrtOptions,
+) krt.Collection[WorkloadInfo] {
+	WorkloadServicesNamespaceIndex := krt.NewNamespaceIndex(workloadServices)
+	EndpointSlicesByIPIndex := endpointSliceAddressIndex(endpointSlices)
+	// Workloads coming from pods. There should be one workload for each (running) Pod.
+	PodWorkloads := krt.NewCollection(
+		pods,
+		a.podWorkloadBuilder(
+			workloadServices,
+			WorkloadServicesNamespaceIndex,
+			endpointSlices,
+			EndpointSlicesByIPIndex,
+		),
+		krtopts.ToOptions("PodWorkloads")...,
+	)
+	// TODO(npolshak): Add support for WE?
+	// Workloads coming from serviceEntries. These are inlined workloadEntries (under `spec.endpoints`); these serviceEntries will
+	// also be generating `api.Service` definitions in the `ServicesCollection` logic.
+	ServiceEntryWorkloads := krt.NewManyCollection(
+		serviceEntries,
+		a.serviceEntryWorkloadBuilder(),
+		krtopts.ToOptions("ServiceEntryWorkloads")...,
+	)
+	// Workloads coming from endpointSlices. These are for *manually added* endpoints. Typically, Kubernetes will insert each pod
+	// into the EndpointSlice. This is because Kubernetes has 3 APIs in its model: Service, Pod, and EndpointSlice.
+	// In our API, we only have two: Service and Workload.
+	// Pod provides much more information than EndpointSlice, so typically we just consume that directly; see method for more details
+	// on when we will build from an EndpointSlice.
+	EndpointSliceWorkloads := krt.NewManyCollection(
+		endpointSlices,
+		a.endpointSlicesBuilder(workloadServices),
+		krtopts.ToOptions("EndpointSliceWorkloads")...)
+
+	Workloads := krt.JoinCollection(
+		[]krt.Collection[WorkloadInfo]{
+			PodWorkloads,
+			ServiceEntryWorkloads,
+			EndpointSliceWorkloads,
+		},
+		// Each collection has its own unique UID as the key. This guarantees an object can exist in only a single collection
+		// This enables us to use the JoinUnchecked optimization.
+		append(krtopts.ToOptions("Workloads"), krt.WithJoinUnchecked())...)
+	return Workloads
+}
+
+// name format: <cluster>/<group>/<kind>/<namespace>/<name></section-name>
+func (a *index) generatePodUID(p *corev1.Pod) string {
+	return a.ClusterID + "//" + "Pod/" + p.Namespace + "/" + p.Name
+}
+
+func (a *index) podWorkloadBuilder(
+	workloadServices krt.Collection[ServiceInfo],
+	workloadServicesNamespaceIndex krt.Index[string, ServiceInfo],
+	endpointSlices krt.Collection[*discovery.EndpointSlice],
+	endpointSlicesAddressIndex krt.Index[TargetRef, *discovery.EndpointSlice],
+) krt.TransformationSingle[*corev1.Pod, WorkloadInfo] {
+	return func(ctx krt.HandlerContext, p *corev1.Pod) *WorkloadInfo {
+		// Pod Is Pending but have a pod IP should be a valid workload, we should build it ,
+		// Such as the pod have initContainer which is initialing.
+		// See https://github.com/istio/istio/issues/48854
+		if kubeutil.CheckPodTerminal(p) {
+			return nil
+		}
+		k8sPodIPs := getPodIPs(p)
+		if len(k8sPodIPs) == 0 {
+			return nil
+		}
+		podIPs, err := slices.MapErr(k8sPodIPs, func(e corev1.PodIP) ([]byte, error) {
+			n, err := netip.ParseAddr(e.IP)
+			if err != nil {
+				return nil, err
+			}
+			return n.AsSlice(), nil
+		})
+		if err != nil {
+			// Is this possible? Probably not in typical case, but anyone could put garbage there.
+			return nil
+		}
+
+		fo := []krt.FetchOption{krt.FilterIndex(workloadServicesNamespaceIndex, p.Namespace), krt.FilterSelectsNonEmpty(p.GetLabels())}
+		if !features.EnableServiceEntrySelectPods {
+			fo = append(fo, krt.FilterGeneric(func(a any) bool {
+				return a.(ServiceInfo).Source.Kind == kind.Service
+			}))
+		}
+		services := krt.Fetch(ctx, workloadServices, fo...)
+		services = append(services, a.matchingServicesWithoutSelectors(ctx, p, services, workloadServices, endpointSlices, endpointSlicesAddressIndex)...)
+		// Logic from https://github.com/kubernetes/kubernetes/blob/7c873327b679a70337288da62b96dd610858181d/staging/src/k8s.io/endpointslice/utils.go#L37
+		// Kubernetes has Ready, Serving, and Terminating. We only have a boolean, which is sufficient for our cases
+		status := api.WorkloadStatus_HEALTHY
+		if !IsPodReady(p) || p.DeletionTimestamp != nil {
+			status = api.WorkloadStatus_UNHEALTHY
+		}
+
+		w := &api.Workload{
+			Uid:       a.generatePodUID(p),
+			Name:      p.Name,
+			Namespace: p.Namespace,
+			//Network:               network,
+			//NetworkGateway:        a.getNetworkGatewayAddress(ctx, network),
+			ClusterId:      a.ClusterID,
+			Addresses:      podIPs,
+			ServiceAccount: p.Spec.ServiceAccountName,
+			Node:           p.Spec.NodeName,
+			Services:       constructServices(p, services),
+			Status:         status,
+			//Locality:              getPodLocality(ctx, nodes, p),
+		}
+
+		if p.Spec.HostNetwork {
+			w.NetworkMode = api.NetworkMode_HOST_NETWORK
+		}
+
+		w.WorkloadName = workloadName(p)
+		w.WorkloadType = api.WorkloadType_POD // backwards compatibility
+		w.CanonicalName, w.CanonicalRevision = kubelabels.CanonicalService(p.Labels, w.WorkloadName)
+
+		setTunnelProtocol(p.Labels, p.Annotations, w)
+		return precomputeWorkloadPtr(&WorkloadInfo{
+			Workload:     w,
+			Labels:       p.Labels,
+			Source:       kind.Pod,
+			CreationTime: p.CreationTimestamp.Time,
+		})
+	}
+}
+
+// IsPodReady is copied from kubernetes/pkg/api/v1/pod/utils.go
+func IsPodReady(pod *corev1.Pod) bool {
+	return IsPodReadyConditionTrue(pod.Status)
+}
+
+// IsPodReadyConditionTrue returns true if a pod is ready; false otherwise.
+func IsPodReadyConditionTrue(status corev1.PodStatus) bool {
+	condition := GetPodReadyCondition(status)
+	return condition != nil && condition.Status == corev1.ConditionTrue
+}
+
+func GetPodReadyCondition(status corev1.PodStatus) *corev1.PodCondition {
+	_, condition := GetPodCondition(&status, corev1.PodReady)
+	return condition
+}
+
+func GetPodCondition(status *corev1.PodStatus, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
+	if status == nil {
+		return -1, nil
+	}
+	return GetPodConditionFromList(status.Conditions, conditionType)
+}
+
+// GetPodConditionFromList extracts the provided condition from the given list of condition and
+// returns the index of the condition and the condition. Returns -1 and nil if the condition is not present.
+func GetPodConditionFromList(conditions []corev1.PodCondition, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
+	if conditions == nil {
+		return -1, nil
+	}
+	for i := range conditions {
+		if conditions[i].Type == conditionType {
+			return i, &conditions[i]
+		}
+	}
+	return -1, nil
+}
+
+func getPodIPs(p *corev1.Pod) []corev1.PodIP {
+	k8sPodIPs := p.Status.PodIPs
+	if len(k8sPodIPs) == 0 && p.Status.PodIP != "" {
+		k8sPodIPs = []corev1.PodIP{{IP: p.Status.PodIP}}
+	}
+	return k8sPodIPs
+}
+
+// matchingServicesWithoutSelectors finds all Services that match a given pod that do not use selectors.
+// See https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors for more info.
+// For selector service, we query by the selector elsewhere, so this only handles the services that are NOT already found
+// by a selector.
+// For EndpointSlices that happen to point to the same IP as the pod, but are not directly bound to the pod (via TargetRef),
+// we ignore them here. These will produce a Workload directly from the EndpointSlice, but with limited information;
+// we do not implicitly merge a Pod with an EndpointSlice just based on IP.
+func (a *index) matchingServicesWithoutSelectors(
+	ctx krt.HandlerContext,
+	p *corev1.Pod,
+	alreadyMatchingServices []ServiceInfo,
+	workloadServices krt.Collection[ServiceInfo],
+	endpointSlices krt.Collection[*discovery.EndpointSlice],
+	endpointSlicesAddressIndex krt.Index[TargetRef, *discovery.EndpointSlice],
+) []ServiceInfo {
+	var res []ServiceInfo
+	// Build out our set of already-matched services to avoid double-selecting a service
+	seen := sets.NewWithLength[string](len(alreadyMatchingServices))
+	for _, s := range alreadyMatchingServices {
+		seen.Insert(s.Service.Hostname)
+	}
+	tr := TargetRef{
+		Kind:      gvk.Pod.Kind,
+		Namespace: p.Namespace,
+		Name:      p.Name,
+		UID:       p.UID,
+	}
+	// For each IP, find any endpointSlices referencing it.
+	matchedSlices := krt.Fetch(ctx, endpointSlices, krt.FilterIndex(endpointSlicesAddressIndex, tr))
+	for _, es := range matchedSlices {
+		serviceName, f := es.Labels[discovery.LabelServiceName]
+		if !f {
+			// Not for a service; we don't care about it.
+			continue
+		}
+		hostname := string(kube.ServiceHostname(serviceName, es.Namespace, a.DomainSuffix))
+		if seen.Contains(hostname) {
+			// We already know about this service
+			continue
+		}
+		// This pod is included in the EndpointSlice. We need to fetch the Service object for it, by key.
+		serviceKey := es.Namespace + "/" + hostname
+		svcs := krt.Fetch(ctx, workloadServices, krt.FilterKey(serviceKey), krt.FilterGeneric(func(a any) bool {
+			// Only find Service, not Service Entry
+			return a.(ServiceInfo).Source.Kind == kind.Service
+		}))
+		if len(svcs) == 0 {
+			// no service found
+			continue
+		}
+		// There SHOULD only be one. This is only for `Service` which has unique hostnames.
+		svc := svcs[0]
+		res = append(res, svc)
+	}
+	return res
+}
+
+func (a *index) serviceEntriesInfo(ctx krt.HandlerContext, s *networkingclient.ServiceEntry) []ServiceInfo {
+	sel := NewSelector(s.Spec.GetWorkloadSelector().GetLabels())
+	portNames := map[int32]ServicePortName{}
+	for _, p := range s.Spec.Ports {
+		portNames[int32(p.Number)] = ServicePortName{
+			PortName: p.Name,
+		}
+	}
+	return slices.Map(a.constructServiceEntries(ctx, s), func(e *api.Service) ServiceInfo {
+		return precomputeService(ServiceInfo{
+			Service:       e,
+			PortNames:     portNames,
+			LabelSelector: sel,
+			Source:        MakeSource(s),
+		})
+	})
+}
+
+// MakeSource is a helper to turn an Object into a model.TypedObject.
+func MakeSource(o controllers.Object) TypedObject {
+	return TypedObject{
+		NamespacedName: config.NamespacedName(o),
+		Kind:           kind.MustFromGVK(kubetypes.GvkFromObject(o)),
+	}
+}
+
+func precomputeServicePtr(w *ServiceInfo) *ServiceInfo {
+	return ptr.Of(precomputeService(*w))
+}
+
+func precomputeService(w ServiceInfo) ServiceInfo {
+	addr := serviceToAddress(w.Service)
+	w.MarshaledAddress = protoconv.MessageToAny(addr)
+	w.AsAddress = AddressInfo{
+		Address:   addr,
+		Marshaled: w.MarshaledAddress,
+	}
+	return w
+}
+
+func serviceToAddress(s *api.Service) *api.Address {
+	return &api.Address{
+		Type: &api.Address_Service{
+			Service: s,
+		},
+	}
+}
+
+func toAppProtocolFromIstio(p *networkingv1alpha3.ServicePort) api.AppProtocol {
+	return toAppProtocolFromProtocol(p.Protocol)
+}
+
+func toAppProtocolFromProtocol(p string) api.AppProtocol {
+	switch p {
+	case "HTTP":
+		return api.AppProtocol_HTTP11
+	case "HTTP2":
+		return api.AppProtocol_HTTP2
+	case "GRPC":
+		return api.AppProtocol_GRPC
+	}
+	return api.AppProtocol_UNKNOWN
+}
+
+func GetHostAddressesFromServiceEntry(se *networkingclient.ServiceEntry) map[string][]netip.Addr {
+	if se == nil {
+		return map[string][]netip.Addr{}
+	}
+	return getHostAddressesFromServiceEntryStatus(&se.Status)
+}
+
+func getHostAddressesFromServiceEntryStatus(status *apiv1.ServiceEntryStatus) map[string][]netip.Addr {
+	results := map[string][]netip.Addr{}
+	for _, addr := range status.GetAddresses() {
+		parsed, err := netip.ParseAddr(addr.GetValue())
+		if err != nil {
+			// strange, we should have written these so it probaby should parse but for now unreadable is unusable and we move on
+			continue
+		}
+		host := addr.GetHost()
+		results[host] = append(results[host], parsed)
+	}
+	return results
+}
+
+func (a *index) constructServiceEntries(ctx krt.HandlerContext, svc *networkingclient.ServiceEntry) []*api.Service {
+	var autoassignedHostAddresses map[string][]netip.Addr
+	addresses, err := slices.MapErr(svc.Spec.Addresses, func(e string) (*api.NetworkAddress, error) {
+		return a.toNetworkAddressFromCidr(ctx, e)
+	})
+	if err != nil {
+		// TODO: perhaps we should support CIDR in the future?
+		return nil
+	}
+	// if this se has autoallocation we can se autoallocated IP, otherwise it will remain an empty slice
+	if ShouldV2AutoAllocateIP(svc) {
+		autoassignedHostAddresses = GetHostAddressesFromServiceEntry(svc)
+	}
+	ports := make([]*api.Port, 0, len(svc.Spec.Ports))
+	for _, p := range svc.Spec.Ports {
+		target := p.TargetPort
+		if target == 0 {
+			target = p.Number
+		}
+		ports = append(ports, &api.Port{
+			ServicePort: p.Number,
+			TargetPort:  target,
+			AppProtocol: toAppProtocolFromIstio(p),
+		})
+	}
+
+	// TODO this is only checking one controller - we may be missing service vips for instances in another cluster
+	res := make([]*api.Service, 0, len(svc.Spec.Hosts))
+	for _, h := range svc.Spec.Hosts {
+		// if we have no user-provided hostsAddresses and h is not wildcarded and we have hostsAddresses supported resolution
+		// we can try to use autoassigned hostsAddresses
+		hostsAddresses := addresses
+		if len(hostsAddresses) == 0 && !host.Name(h).IsWildCarded() && svc.Spec.Resolution != networkingv1beta1.ServiceEntry_NONE {
+			if hostsAddrs, ok := autoassignedHostAddresses[h]; ok {
+				hostsAddresses = slices.Map(hostsAddrs, func(e netip.Addr) *api.NetworkAddress {
+					return a.toNetworkAddressFromIP(ctx, e)
+				})
+			}
+		}
+		res = append(res, &api.Service{
+			Name:            svc.Name,
+			Namespace:       svc.Namespace,
+			Hostname:        h,
+			Addresses:       hostsAddresses,
+			Ports:           ports,
+			SubjectAltNames: svc.Spec.SubjectAltNames,
+			//LoadBalancing:   lb, // TODO: add lb support
+		})
+	}
+	return res
+}
+
+func ShouldV2AutoAllocateIP(se *networkingclient.ServiceEntry) bool {
+	if se == nil {
+		return false
+	}
+	return shouldV2AutoAllocateIPFromPieces(se.ObjectMeta, &se.Spec)
+}
+
+func shouldV2AutoAllocateIPFromPieces(meta metav1.ObjectMeta, spec *apiv1.ServiceEntry) bool {
+	// if the feature is off we should not assign/use addresses
+	if !features.EnableIPAutoallocate {
+		return false
+	}
+
+	// if resolution is none we cannot honor the assigned IP in the dataplane and should not assign
+	if spec.Resolution == apiv1.ServiceEntry_NONE {
+		return false
+	}
+
+	// check for opt-out by user
+	enabledValue, enabledFound := meta.Labels[label.NetworkingEnableAutoallocateIp.Name]
+	if enabledFound && strings.EqualFold(enabledValue, "false") {
+		return false
+	}
+
+	// if the user assigned their own we don't alloate or use autoassigned addresses
+	if len(spec.Addresses) > 0 {
+		return false
+	}
+
+	return true
+}
+
+// name format: <cluster>/<group>/<kind>/<namespace>/<name></section-name>
+// section name should be the WE address, which needs to be stable across SE updates (it is assumed WE addresses are unique)
+func (a *index) generateServiceEntryUID(svcEntryNamespace, svcEntryName, addr string) string {
+	return a.ClusterID + "/networking.istio.io/ServiceEntry/" + svcEntryNamespace + "/" + svcEntryName + "/" + addr
+}
+
+func (a *index) serviceEntryWorkloadBuilder() krt.TransformationMulti[*networkingclient.ServiceEntry, WorkloadInfo] {
+	return func(ctx krt.HandlerContext, se *networkingclient.ServiceEntry) []WorkloadInfo {
+		eps := se.Spec.Endpoints
+		// If we have a DNS service, endpoints are not required
+		implicitEndpoints := len(eps) == 0 &&
+			(se.Spec.Resolution == networkingv1alpha3.ServiceEntry_DNS || se.Spec.Resolution == networkingv1alpha3.ServiceEntry_DNS_ROUND_ROBIN) &&
+			se.Spec.WorkloadSelector == nil
+		if len(eps) == 0 && !implicitEndpoints {
+			return nil
+		}
+		// only going to use a subset of the info in `allServices` (since we are building workloads here, not services).
+		allServices := a.serviceEntriesInfo(ctx, se)
+		if implicitEndpoints {
+			eps = slices.Map(allServices, func(si ServiceInfo) *networkingv1alpha3.WorkloadEntry {
+				return &networkingv1alpha3.WorkloadEntry{Address: si.Service.Hostname}
+			})
+		}
+		if len(eps) == 0 {
+			return nil
+		}
+		res := make([]WorkloadInfo, 0, len(eps))
+
+		for i, wle := range eps {
+			services := allServices
+			if implicitEndpoints {
+				// For implicit endpoints, we generate each one from the hostname it was from.
+				// Otherwise, use all.
+				// [i] is safe here since we these are constructed to mirror each other
+				services = []ServiceInfo{allServices[i]}
+			}
+
+			w := &api.Workload{
+				Uid:       a.generateServiceEntryUID(se.Namespace, se.Name, wle.Address),
+				Name:      se.Name,
+				Namespace: se.Namespace,
+				//Network:               network,
+				ClusterId:      a.ClusterID,
+				ServiceAccount: wle.ServiceAccount,
+				Services:       constructServicesFromWorkloadEntry(wle, services),
+				Status:         api.WorkloadStatus_HEALTHY,
+				Locality:       getWorkloadEntryLocality(wle),
+			}
+			if wle.Weight > 0 {
+				w.Capacity = wrappers.UInt32(wle.Weight)
+			}
+
+			if addr, err := netip.ParseAddr(wle.Address); err == nil {
+				w.Addresses = [][]byte{addr.AsSlice()}
+			} else {
+				w.Hostname = wle.Address
+			}
+
+			w.WorkloadName, w.WorkloadType = se.Name, api.WorkloadType_POD // XXX(shashankram): HACK to impersonate pod
+			w.CanonicalName, w.CanonicalRevision = kubelabels.CanonicalService(se.Labels, w.WorkloadName)
+
+			setTunnelProtocol(se.Labels, se.Annotations, w)
+			res = append(res, precomputeWorkload(WorkloadInfo{
+				Workload:     w,
+				Labels:       se.Labels,
+				Source:       kind.WorkloadEntry,
+				CreationTime: se.CreationTimestamp.Time,
+			}))
+		}
+		return res
+	}
+}
+
+func (a *index) endpointSlicesBuilder(
+	workloadServices krt.Collection[ServiceInfo],
+) krt.TransformationMulti[*discovery.EndpointSlice, WorkloadInfo] {
+	return func(ctx krt.HandlerContext, es *discovery.EndpointSlice) []WorkloadInfo {
+		// EndpointSlices carry port information and a list of IPs.
+		// We only care about EndpointSlices that are for a Service.
+		// Otherwise, it is just an arbitrary bag of IP addresses for some user-specific purpose, which doesn't have a clear
+		// usage for us (if it had some additional info like service account, etc, then perhaps it would be useful).
+		serviceName, f := es.Labels[discovery.LabelServiceName]
+		if !f {
+			return nil
+		}
+		if es.AddressType == discovery.AddressTypeFQDN {
+			// Currently we do not support FQDN. In theory, we could, but its' support in Kubernetes entirely is questionable and
+			// may be removed in the near future.
+			return nil
+		}
+		var res []WorkloadInfo
+		seen := sets.New[string]()
+
+		// The slice must be for a single service, based on the label above.
+		serviceKey := es.Namespace + "/" + string(kube.ServiceHostname(serviceName, es.Namespace, a.DomainSuffix))
+		svcs := krt.Fetch(ctx, workloadServices, krt.FilterKey(serviceKey), krt.FilterGeneric(func(a any) bool {
+			// Only find Service, not Service Entry
+			return a.(ServiceInfo).Source.Kind == kind.Service
+		}))
+		if len(svcs) == 0 {
+			// no service found
+			return nil
+		}
+		// There SHOULD only be one. This is only Service which has unique hostnames.
+		svc := svcs[0]
+
+		// Translate slice ports to our port.
+		pl := &api.PortList{Ports: make([]*api.Port, 0, len(es.Ports))}
+		for _, p := range es.Ports {
+			// We must have name and port (Kubernetes should always set these)
+			if p.Name == nil {
+				continue
+			}
+			if p.Port == nil {
+				continue
+			}
+			// We only support TCP for now
+			if p.Protocol == nil || *p.Protocol != corev1.ProtocolTCP {
+				continue
+			}
+			// Endpoint slice port has name (service port name, not containerPort) and port (targetPort)
+			// We need to join with the Service port list to translate the port name to
+			for _, svcPort := range svc.Service.Ports {
+				portName := svc.PortNames[int32(svcPort.ServicePort)]
+				if portName.PortName != *p.Name {
+					continue
+				}
+				pl.Ports = append(pl.Ports, &api.Port{
+					ServicePort: svcPort.ServicePort,
+					TargetPort:  uint32(*p.Port),
+				})
+				break
+			}
+		}
+		services := map[string]*api.PortList{
+			serviceKey: pl,
+		}
+
+		// Each endpoint in the slice is going to create a Workload
+		for _, ep := range es.Endpoints {
+			if ep.TargetRef != nil && ep.TargetRef.Kind == gvk.Pod.Kind {
+				// Normal case; this is a slice for a pod. We already handle pods, with much more information, so we can skip them
+				continue
+			}
+			// This should not be possible
+			if len(ep.Addresses) == 0 {
+				continue
+			}
+			// We currently only support 1 address. Kubernetes will never set more (IPv4 and IPv6 will be two slices), so its mostly undefined.
+			key := ep.Addresses[0]
+			if seen.InsertContains(key) {
+				// Shouldn't happen. Make sure our UID is actually unique
+				log.Warnf("IP address %v seen twice in %v/%v", key, es.Namespace, es.Name)
+				continue
+			}
+			health := api.WorkloadStatus_UNHEALTHY
+			if ep.Conditions.Ready == nil || *ep.Conditions.Ready {
+				health = api.WorkloadStatus_HEALTHY
+			}
+			// Translate our addresses.
+			// Note: users may put arbitrary addresses here. It is recommended by Kubernetes to not
+			// give untrusted users EndpointSlice write access.
+			addresses, err := slices.MapErr(ep.Addresses, func(e string) ([]byte, error) {
+				n, err := netip.ParseAddr(e)
+				if err != nil {
+					log.Warnf("invalid address in endpointslice %v: %v", e, err)
+					return nil, err
+				}
+				return n.AsSlice(), nil
+			})
+			if err != nil {
+				// If any invalid, skip
+				continue
+			}
+			w := &api.Workload{
+				Uid:       a.ClusterID + "/discovery.k8s.io/EndpointSlice/" + es.Namespace + "/" + es.Name + "/" + key,
+				Name:      es.Name,
+				Namespace: es.Namespace,
+				Addresses: addresses,
+				Hostname:  "",
+				//Network:     a.Network(ctx).String(),
+				Services:  services,
+				Status:    health,
+				ClusterId: string(a.ClusterID),
+				// For opaque endpoints, we do not know anything about them. They could be overlapping with other IPs, so treat it
+				// as a shared address rather than a unique one.
+				NetworkMode:           api.NetworkMode_HOST_NETWORK,
+				AuthorizationPolicies: nil, // Not support. This can only be used for outbound, so not relevant
+				ServiceAccount:        "",  // Unknown.
+				Locality:              nil, // Not supported. We could maybe, there is a "zone", but it doesn't seem to be well supported
+			}
+			res = append(res, precomputeWorkload(WorkloadInfo{
+				Workload:     w,
+				Labels:       nil,
+				Source:       kind.EndpointSlice,
+				CreationTime: es.CreationTimestamp.Time,
+			}))
+		}
+
+		return res
+	}
+}
+
+func setTunnelProtocol(labels, annotations map[string]string, w *api.Workload) {
+	if annotations[annotation.AmbientRedirection.Name] == constants.AmbientRedirectionEnabled {
+		// Configured for override
+		w.TunnelProtocol = api.TunnelProtocol_HBONE
+	}
+	// Otherwise supports tunnel directly
+	if SupportsTunnel(labels, TunnelHTTP) {
+		w.TunnelProtocol = api.TunnelProtocol_HBONE
+		w.NativeTunnel = true
+	}
+	if w.TunnelProtocol == api.TunnelProtocol_NONE &&
+		GetTLSModeFromEndpointLabels(labels) == IstioMutualTLSModeLabel {
+		w.TunnelProtocol = api.TunnelProtocol_LEGACY_ISTIO_MTLS
+	}
+}
+
+func constructServicesFromWorkloadEntry(p *networkingv1alpha3.WorkloadEntry, services []ServiceInfo) map[string]*api.PortList {
+	res := map[string]*api.PortList{}
+	for _, svc := range services {
+		n := namespacedHostname(svc.Service.Namespace, svc.Service.Hostname)
+		pl := &api.PortList{}
+		res[n] = pl
+		for _, port := range svc.Service.Ports {
+			targetPort := port.TargetPort
+			// Named targetPort has different semantics from Service vs ServiceEntry
+			if svc.Source.Kind == kind.Service {
+				// Service has explicit named targetPorts.
+				if named, f := svc.PortNames[int32(port.ServicePort)]; f && named.TargetPortName != "" {
+					// This port is a named target port, look it up
+					tv, ok := p.Ports[named.TargetPortName]
+					if !ok {
+						// We needed an explicit port, but didn't find one - skip this port
+						continue
+					}
+					targetPort = tv
+				}
+			} else {
+				// ServiceEntry has no explicit named targetPorts; targetPort only allows a number
+				// Instead, there is name matching between the port names
+				if named, f := svc.PortNames[int32(port.ServicePort)]; f {
+					// get port name or target port
+					tv, ok := p.Ports[named.PortName]
+					if ok {
+						// if we match one, override it. Otherwise, use the service port
+						targetPort = tv
+					} else if targetPort == 0 {
+						targetPort = port.ServicePort
+					}
+				}
+			}
+			pl.Ports = append(pl.Ports, &api.Port{
+				ServicePort: port.ServicePort,
+				TargetPort:  targetPort,
+			})
+		}
+	}
+	return res
+}
+
+func workloadName(pod *corev1.Pod) string {
+	objMeta, _ := kubeutil.GetWorkloadMetaFromPod(pod)
+	return objMeta.Name
+}
+
+func constructServices(p *corev1.Pod, services []ServiceInfo) map[string]*api.PortList {
+	res := map[string]*api.PortList{}
+	for _, svc := range services {
+		n := namespacedHostname(svc.Service.Namespace, svc.Service.Hostname)
+		pl := &api.PortList{
+			Ports: make([]*api.Port, 0, len(svc.Service.Ports)),
+		}
+		res[n] = pl
+		for _, port := range svc.Service.Ports {
+			targetPort := port.TargetPort
+			// The svc.Ports represents the api.Service, which drops the port name info and just has numeric target Port.
+			// TargetPort can be 0 which indicates its a named port. Check if its a named port and replace with the real targetPort if so.
+			if named, f := svc.PortNames[int32(port.ServicePort)]; f && named.TargetPortName != "" {
+				// Pods only match on TargetPort names
+				tp, ok := FindPortName(p, named.TargetPortName)
+				if !ok {
+					// Port not present for this workload. Exclude the port entirely
+					continue
+				}
+				targetPort = uint32(tp)
+			}
+
+			pl.Ports = append(pl.Ports, &api.Port{
+				ServicePort: port.ServicePort,
+				TargetPort:  targetPort,
+			})
+		}
+	}
+	return res
+}
+
+func getWorkloadEntryLocality(p *networkingv1alpha3.WorkloadEntry) *api.Locality {
+	region, zone, subzone := labelutil.SplitLocalityLabel(p.GetLocality())
+	if region == "" && zone == "" && subzone == "" {
+		return nil
+	}
+	return &api.Locality{
+		Region:  region,
+		Zone:    zone,
+		Subzone: subzone,
+	}
+}
+
+// TargetRef is a subset of the Kubernetes ObjectReference which has some fields we don't care about
+type TargetRef struct {
+	Kind      string
+	Namespace string
+	Name      string
+	UID       types.UID
+}
+
+func (t TargetRef) String() string {
+	return t.Kind + "/" + t.Namespace + "/" + t.Name + "/" + string(t.UID)
+}
+
+// endpointSliceAddressIndex builds an index from IP Address
+func endpointSliceAddressIndex(EndpointSlices krt.Collection[*discovery.EndpointSlice]) krt.Index[TargetRef, *discovery.EndpointSlice] {
+	return krt.NewIndex(EndpointSlices, func(es *discovery.EndpointSlice) []TargetRef {
+		if es.AddressType == discovery.AddressTypeFQDN {
+			// Currently we do not support FQDN.
+			return nil
+		}
+		_, f := es.Labels[discovery.LabelServiceName]
+		if !f {
+			// Not for a service; we don't care about it.
+			return nil
+		}
+		res := make([]TargetRef, 0, len(es.Endpoints))
+		for _, ep := range es.Endpoints {
+			if ep.TargetRef == nil || ep.TargetRef.Kind != gvk.Pod.Kind {
+				// We only want pods here
+				continue
+			}
+			tr := TargetRef{
+				Kind:      ep.TargetRef.Kind,
+				Namespace: ep.TargetRef.Namespace,
+				Name:      ep.TargetRef.Name,
+				UID:       ep.TargetRef.UID,
+			}
+			res = append(res, tr)
+		}
+		return res
+	})
+}
+
+func precomputeWorkloadPtr(w *WorkloadInfo) *WorkloadInfo {
+	return ptr.Of(precomputeWorkload(*w))
+}
+
+func precomputeWorkload(w WorkloadInfo) WorkloadInfo {
+	addr := workloadToAddress(w.Workload)
+	w.MarshaledAddress = protoconv.MessageToAny(addr)
+	w.AsAddress = AddressInfo{
+		Address:   addr,
+		Marshaled: w.MarshaledAddress,
+	}
+	return w
+}
+
+func workloadToAddress(w *api.Workload) *api.Address {
+	return &api.Address{
+		Type: &api.Address_Workload{
+			Workload: w,
+		},
+	}
+}
+
+func mustByteIPToString(b []byte) string {
+	ip, _ := netip.AddrFromSlice(b) // Address only comes from objects we create, so it must be valid
+	return ip.String()
+}
+
+func (a *index) toNetworkAddress(ctx krt.HandlerContext, vip string) (*api.NetworkAddress, error) {
+	ip, err := netip.ParseAddr(vip)
+	if err != nil {
+		return nil, fmt.Errorf("parse %v: %v", vip, err)
+	}
+	return &api.NetworkAddress{
+		// TODO: calculate network
+		Address: ip.AsSlice(),
+	}, nil
+}
+
+func (a *index) toNetworkAddressFromIP(ctx krt.HandlerContext, ip netip.Addr) *api.NetworkAddress {
+	return &api.NetworkAddress{
+		// TODO: calculate network
+		Address: ip.AsSlice(),
+	}
+}
+
+func (a *index) toNetworkAddressFromCidr(ctx krt.HandlerContext, vip string) (*api.NetworkAddress, error) {
+	ip, err := parseCidrOrIP(vip)
+	if err != nil {
+		return nil, err
+	}
+	return &api.NetworkAddress{
+		// TODO: calculate network
+		Address: ip.AsSlice(),
+	}, nil
+}
+
+// parseCidrOrIP parses an IP or a CIDR of a exactly 1 IP (e.g. /32).
+// This is to support ServiceEntry which supports CIDRs, but we don't currently support more than 1 IP
+func parseCidrOrIP(ip string) (netip.Addr, error) {
+	if strings.Contains(ip, "/") {
+		prefix, err := netip.ParsePrefix(ip)
+		if err != nil {
+			return netip.Addr{}, err
+		}
+		if !prefix.IsSingleIP() {
+			return netip.Addr{}, fmt.Errorf("only single IP CIDR is allowed")
+		}
+		return prefix.Addr(), nil
+	}
+	return netip.ParseAddr(ip)
+}
+
+func FindPortName(pod *corev1.Pod, name string) (int32, bool) {
+	for _, container := range pod.Spec.Containers {
+		for _, port := range container.Ports {
+			if port.Name == name && port.Protocol == corev1.ProtocolTCP {
+				return port.ContainerPort, true
+			}
+		}
+	}
+	return 0, false
+}
+
+func namespacedHostname(namespace, hostname string) string {
+	return namespace + "/" + hostname
+}
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
new file mode 100644
index 000000000..893323e9c
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
@@ -0,0 +1,35 @@
+{
+  "addresses": null,
+  "resources": [
+    {
+      "Kind": {
+        "Route": {
+          "key": "gwtest.my-route2.0.0.http",
+          "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
+          "route_name": "gwtest/my-route2",
+          "hostnames": [
+            "www.example2.com"
+          ],
+          "matches": [
+            {
+              "path": {
+                "Kind": {
+                  "PathPrefix": "/"
+                }
+              }
+            }
+          ],
+          "backends": [
+            {
+              "Kind": {
+                "Service": "gwtest/reviews.gwtest.svc.cluster.local"
+              },
+              "weight": 1,
+              "port": 8080
+            }
+          ]
+        }
+      }
+    }
+  ]
+}
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 59715815ced727fde3d7b9856e555c5a2f2e1b4a Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 16:15:29 -0700
Subject: [PATCH 07/17] wip

---
 examples/httpbin.yaml                         |   8 -
 .../kgateway/agentgatewaysyncer/conversion.go | 332 +----------------
 .../agentgatewaysyncer/route_collections.go   | 342 +-----------------
 .../kgateway/agentgatewaysyncer/service.go    |  42 +--
 .../kgateway/agentgatewaysyncer/syncer.go     | 261 ++++++++++---
 .../agentgatewaysyncer/syncer_test.go         |  35 --
 .../kgateway/agentgatewaysyncer/workloads.go  |   2 +-
 .../kgateway/agentgatewaysyncer/xdswrapper.go | 192 ++++++++++
 internal/kgateway/controller/start.go         |   5 +-
 internal/kgateway/setup/agentgateway_test.go  |  69 ++++
 .../testdata/agentgateway/httproute-out.json  |  35 --
 .../testdata/agentgateway/httproute.yaml      |   7 +
 .../testdata/agentgateway-deploy.yaml         |   3 +
 13 files changed, 487 insertions(+), 846 deletions(-)
 delete mode 100644 internal/kgateway/agentgatewaysyncer/syncer_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/xdswrapper.go
 delete mode 100644 internal/kgateway/setup/testdata/agentgateway/httproute-out.json

diff --git a/examples/httpbin.yaml b/examples/httpbin.yaml
index a10d508ba..8a4451b1d 100644
--- a/examples/httpbin.yaml
+++ b/examples/httpbin.yaml
@@ -1,8 +1,3 @@
-apiVersion: v1
-kind: Namespace
-metadata:
-  name: httpbin
----
 ##################################################################################################
 # httpbin service
 ##################################################################################################
@@ -10,13 +5,11 @@ apiVersion: v1
 kind: ServiceAccount
 metadata:
   name: httpbin
-  namespace: httpbin
 ---
 apiVersion: v1
 kind: Service
 metadata:
   name: httpbin
-  namespace: httpbin
   labels:
     app: httpbin
     service: httpbin
@@ -34,7 +27,6 @@ apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: httpbin
-  namespace: httpbin
 spec:
   replicas: 1
   selector:
diff --git a/internal/kgateway/agentgatewaysyncer/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
index c169c7a29..4ec932dbc 100644
--- a/internal/kgateway/agentgatewaysyncer/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -1,7 +1,6 @@
 package agentgatewaysyncer
 
 import (
-	"cmp"
 	"crypto/tls"
 	"fmt"
 	"log"
@@ -24,7 +23,6 @@ import (
 
 	"github.com/agentgateway/agentgateway/go/api"
 	"istio.io/api/annotation"
-	"istio.io/api/label"
 	istio "istio.io/api/networking/v1alpha3"
 	kubecreds "istio.io/istio/pilot/pkg/credentials/kube"
 	"istio.io/istio/pilot/pkg/features"
@@ -48,18 +46,6 @@ const (
 	gatewayTLSTerminateModeKey = "gateway.agentgateway.io/tls-terminate-mode"
 )
 
-func sortRoutesByCreationTime(configs []RouteWithKey) {
-	sort.Slice(configs, func(i, j int) bool {
-		if r := configs[i].CreationTimestamp.Compare(configs[j].CreationTimestamp); r != 0 {
-			return r == -1 // -1 means i is less than j, so return true
-		}
-		if r := cmp.Compare(configs[i].Namespace, configs[j].Namespace); r != 0 {
-			return r == -1
-		}
-		return cmp.Compare(configs[i].Name, configs[j].Name) == -1
-	})
-}
-
 func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 	obj *k8sbeta.HTTPRoute, pos int, matchPos int,
 ) (*api.Route, *ConfigError) {
@@ -292,304 +278,6 @@ func buildADPDestination(
 	return rb, invalidBackendErr
 }
 
-func convertHTTPRoute(ctx RouteContext, r k8s.HTTPRouteRule,
-	obj *k8sbeta.HTTPRoute, pos int,
-) (*istio.HTTPRoute, *ConfigError) {
-	vs := &istio.HTTPRoute{}
-	if r.Name != nil {
-		vs.Name = string(*r.Name)
-	} else {
-		// Auto-name the route. If upstream defines an explicit name, will use it instead
-		// The position within the route is unique
-		vs.Name = obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) // format: %s.%s.%d
-	}
-
-	for _, match := range r.Matches {
-		uri, err := createURIMatch(match)
-		if err != nil {
-			return nil, err
-		}
-		headers, err := createHeadersMatch(match)
-		if err != nil {
-			return nil, err
-		}
-		qp, err := createQueryParamsMatch(match)
-		if err != nil {
-			return nil, err
-		}
-		method, err := createMethodMatch(match)
-		if err != nil {
-			return nil, err
-		}
-		vs.Match = append(vs.GetMatch(), &istio.HTTPMatchRequest{
-			Uri:         uri,
-			Headers:     headers,
-			QueryParams: qp,
-			Method:      method,
-		})
-	}
-	var mirrorBackendErr *ConfigError
-	for _, filter := range r.Filters {
-		switch filter.Type {
-		case k8s.HTTPRouteFilterRequestHeaderModifier:
-			h := createHeadersFilter(filter.RequestHeaderModifier)
-			if h == nil {
-				continue
-			}
-			if vs.GetHeaders() == nil {
-				vs.Headers = &istio.Headers{}
-			}
-			vs.GetHeaders().Request = h
-		case k8s.HTTPRouteFilterResponseHeaderModifier:
-			h := createHeadersFilter(filter.ResponseHeaderModifier)
-			if h == nil {
-				continue
-			}
-			if vs.GetHeaders() == nil {
-				vs.Headers = &istio.Headers{}
-			}
-			vs.GetHeaders().Response = h
-		case k8s.HTTPRouteFilterRequestRedirect:
-			vs.Redirect = createRedirectFilter(filter.RequestRedirect)
-		case k8s.HTTPRouteFilterRequestMirror:
-			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, wellknown.HTTPRouteGVK)
-			if err != nil {
-				mirrorBackendErr = err
-			} else {
-				vs.Mirrors = append(vs.GetMirrors(), mirror)
-			}
-		case k8s.HTTPRouteFilterURLRewrite:
-			vs.Rewrite = createRewriteFilter(filter.URLRewrite)
-		case k8s.HTTPRouteFilterCORS:
-			vs.CorsPolicy = createCorsFilter(filter.CORS)
-		default:
-			return nil, &ConfigError{
-				Reason:  InvalidFilter,
-				Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
-			}
-		}
-	}
-
-	if r.Retry != nil {
-		// "Implementations SHOULD retry on connection errors (disconnect, reset, timeout,
-		// TCP failure) if a retry stanza is configured."
-		retryOn := []string{"connect-failure", "refused-stream", "unavailable", "cancelled"}
-		for _, codes := range r.Retry.Codes {
-			retryOn = append(retryOn, strconv.Itoa(int(codes)))
-		}
-		vs.Retries = &istio.HTTPRetry{
-			// If unset, default is implementation specific.
-			// VirtualService.retry has no default when set -- users are expected to set it if they customize `retry`.
-			// However, the default retry if none are set is "2", so we use that as the default.
-			Attempts:      int32(ptr.OrDefault(r.Retry.Attempts, 2)),
-			PerTryTimeout: nil,
-			RetryOn:       strings.Join(retryOn, ","),
-		}
-		if vs.GetRetries().GetAttempts() == 0 {
-			// Invalid to set this when there are no attempts
-			vs.GetRetries().RetryOn = ""
-		}
-		//if r.Retry.Backoff != nil {
-		//	retrybackOff, _ := time.ParseDuration(string(*r.Retry.Backoff))
-		//	vs.Retries.Backoff = durationpb.New(retrybackOff)
-		//}
-	}
-
-	if r.Timeouts != nil {
-		if r.Timeouts.Request != nil {
-			request, _ := time.ParseDuration(string(*r.Timeouts.Request))
-			if request != 0 {
-				vs.Timeout = durationpb.New(request)
-			}
-		}
-		if r.Timeouts.BackendRequest != nil {
-			backendRequest, _ := time.ParseDuration(string(*r.Timeouts.BackendRequest))
-			if backendRequest != 0 {
-				timeout := durationpb.New(backendRequest)
-				if vs.GetRetries() != nil {
-					vs.GetRetries().PerTryTimeout = timeout
-				} else {
-					vs.Timeout = timeout
-				}
-			}
-		}
-	}
-	if weightSum(r.BackendRefs) == 0 && vs.GetRedirect() == nil {
-		// The spec requires us to return 500 when there are no >0 weight backends
-		vs.DirectResponse = &istio.HTTPDirectResponse{
-			Status: 500,
-		}
-	} else {
-		route, backendErr, err := buildHTTPDestination(ctx, r.BackendRefs, obj.Namespace)
-		if err != nil {
-			return nil, err
-		}
-		vs.Route = route
-		return vs, joinErrors(backendErr, mirrorBackendErr)
-	}
-
-	return vs, mirrorBackendErr
-}
-
-func joinErrors(a *ConfigError, b *ConfigError) *ConfigError {
-	if b == nil {
-		return a
-	}
-	if a == nil {
-		return b
-	}
-	a.Message += "; " + b.Message
-	return a
-}
-
-func convertGRPCRoute(ctx RouteContext, r k8s.GRPCRouteRule,
-	obj *k8s.GRPCRoute, pos int,
-) (*istio.HTTPRoute, *ConfigError) {
-	vs := &istio.HTTPRoute{}
-	if r.Name != nil {
-		vs.Name = string(*r.Name)
-	} else {
-		// Auto-name the route. If upstream defines an explicit name, will use it instead
-		// The position within the route is unique
-		vs.Name = obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) // format:%s.%s.%d
-	}
-
-	for _, match := range r.Matches {
-		uri, err := createGRPCURIMatch(match)
-		if err != nil {
-			return nil, err
-		}
-		headers, err := createGRPCHeadersMatch(match)
-		if err != nil {
-			return nil, err
-		}
-		vs.Match = append(vs.GetMatch(), &istio.HTTPMatchRequest{
-			Uri:     uri,
-			Headers: headers,
-		})
-	}
-	for _, filter := range r.Filters {
-		switch filter.Type {
-		case k8s.GRPCRouteFilterRequestHeaderModifier:
-			h := createHeadersFilter(filter.RequestHeaderModifier)
-			if h == nil {
-				continue
-			}
-			if vs.GetHeaders() == nil {
-				vs.Headers = &istio.Headers{}
-			}
-			vs.GetHeaders().Request = h
-		case k8s.GRPCRouteFilterResponseHeaderModifier:
-			h := createHeadersFilter(filter.ResponseHeaderModifier)
-			if h == nil {
-				continue
-			}
-			if vs.GetHeaders() == nil {
-				vs.Headers = &istio.Headers{}
-			}
-			vs.GetHeaders().Response = h
-		case k8s.GRPCRouteFilterRequestMirror:
-			mirror, err := createMirrorFilter(ctx, filter.RequestMirror, obj.Namespace, wellknown.GRPCRouteGVK)
-			if err != nil {
-				return nil, err
-			}
-			vs.Mirrors = append(vs.GetMirrors(), mirror)
-		default:
-			return nil, &ConfigError{
-				Reason:  InvalidFilter,
-				Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
-			}
-		}
-	}
-
-	if grpcWeightSum(r.BackendRefs) == 0 && vs.GetRedirect() == nil {
-		// The spec requires us to return 500 when there are no >0 weight backends
-		vs.DirectResponse = &istio.HTTPDirectResponse{
-			Status: 500,
-		}
-	} else {
-		route, backendErr, err := buildGRPCDestination(ctx, r.BackendRefs, obj.Namespace)
-		if err != nil {
-			return nil, err
-		}
-		vs.Route = route
-		return vs, backendErr
-	}
-
-	return vs, nil
-}
-
-func routeMeta(obj controllers.Object) map[string]string {
-	m := parentMeta(obj, nil)
-	m[constants.InternalRouteSemantics] = constants.RouteSemanticsGateway
-	return m
-}
-
-// sortHTTPRoutes sorts generated vs routes to meet gateway-api requirements
-// see https://gateway-api.sigs.k8s.io/v1alpha2/references/spec/#gateway.networking.k8s.io/v1alpha2.HTTPRouteRule
-func sortHTTPRoutes(routes []*istio.HTTPRoute) {
-	sort.SliceStable(routes, func(i, j int) bool {
-		if len(routes[i].GetMatch()) == 0 {
-			return false
-		} else if len(routes[j].GetMatch()) == 0 {
-			return true
-		}
-		// Only look at match[0], we always generate only one match
-		m1, m2 := routes[i].GetMatch()[0], routes[j].GetMatch()[0]
-		r1, r2 := getURIRank(m1), getURIRank(m2)
-		len1, len2 := getURILength(m1), getURILength(m2)
-		switch {
-		// 1: Exact/Prefix/Regex
-		case r1 != r2:
-			return r1 > r2
-		case len1 != len2:
-			return len1 > len2
-			// 2: method math
-		case (m1.GetMethod() == nil) != (m2.GetMethod() == nil):
-			return m1.GetMethod() != nil
-			// 3: number of header matches
-		case len(m1.GetHeaders()) != len(m2.GetHeaders()):
-			return len(m1.GetHeaders()) > len(m2.GetHeaders())
-			// 4: number of query matches
-		default:
-			return len(m1.GetQueryParams()) > len(m2.GetQueryParams())
-		}
-	})
-}
-
-// getURIRank ranks a URI match type. Exact > Prefix > Regex
-func getURIRank(match *istio.HTTPMatchRequest) int {
-	if match.GetUri() == nil {
-		return -1
-	}
-	switch match.GetUri().GetMatchType().(type) {
-	case *istio.StringMatch_Exact:
-		return 3
-	case *istio.StringMatch_Prefix:
-		return 2
-	case *istio.StringMatch_Regex:
-		return 1
-	}
-	// should not happen
-	return -1
-}
-
-func getURILength(match *istio.HTTPMatchRequest) int {
-	if match.GetUri() == nil {
-		return 0
-	}
-	switch match.GetUri().GetMatchType().(type) {
-	case *istio.StringMatch_Prefix:
-		return len(match.GetUri().GetPrefix())
-	case *istio.StringMatch_Exact:
-		return len(match.GetUri().GetExact())
-	case *istio.StringMatch_Regex:
-		return len(match.GetUri().GetRegex())
-	}
-	// should not happen
-	return -1
-}
-
 func parentMeta(obj controllers.Object, sectionName *k8s.SectionName) map[string]string {
 	name := fmt.Sprintf("%s/%s.%s", schematypes.GvkFromObject(obj).Kind, obj.GetName(), obj.GetNamespace())
 	if sectionName != nil {
@@ -600,16 +288,6 @@ func parentMeta(obj controllers.Object, sectionName *k8s.SectionName) map[string
 	}
 }
 
-func hostnameToStringList(h []k8s.Hostname) []string {
-	// In the Istio API, empty hostname is not allowed. In the Kubernetes API hosts means "any"
-	if len(h) == 0 {
-		return []string{"*"}
-	}
-	return slices.Map(h, func(e k8s.Hostname) string {
-		return string(e)
-	})
-}
-
 var allowedParentReferences = sets.New(
 	wellknown.GatewayGVK,
 	wellknown.ServiceGVK,
@@ -652,14 +330,6 @@ func toInternalParentReference(p k8s.ParentReference, localNamespace string) (pa
 	}, nil
 }
 
-// waypointConfigured returns true if a waypoint is configured via expected label's key-value pair.
-func waypointConfigured(labels map[string]string) bool {
-	if val, ok := labels[label.IoIstioUseWaypoint.Name]; ok && len(val) > 0 && !strings.EqualFold(val, "none") {
-		return true
-	}
-	return false
-}
-
 func referenceAllowed(
 	ctx RouteContext,
 	parent *parentInfo,
@@ -2020,5 +1690,5 @@ func routeGroupKindEqual(rgk1, rgk2 k8s.RouteGroupKind) bool {
 }
 
 func getGroup(rgk k8s.RouteGroupKind) k8s.Group {
-	return ptr.OrDefault(rgk.Group, k8s.Group(wellknown.GatewayGroup))
+	return ptr.OrDefault(rgk.Group, wellknown.GatewayGroup)
 }
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
index fa2d1e30a..f7eb7410b 100644
--- a/internal/kgateway/agentgatewaysyncer/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -1,112 +1,24 @@
 package agentgatewaysyncer
 
 import (
-	"fmt"
 	"iter"
 	"strings"
 
 	corev1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
-	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
-	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-
-	istio "istio.io/api/networking/v1alpha3"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/ptr"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/protomarshal"
 )
 
-func HTTPRouteCollection(
-	httpRoutes krt.Collection[*gateway.HTTPRoute],
-	inputs RouteContextInputs,
-	krtopts krtutil.KrtOptions,
-) RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, httpRoutes, wellknown.HTTPRouteGVK, krtopts)
-	baseVirtualServices := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []RouteWithKey {
-		ctx := inputs.WithCtx(krtctx)
-		route := obj.Spec
-		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gateway.HTTPRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
-			return func(yield func(*istio.HTTPRoute, *ConfigError) bool) {
-				for n, r := range route.Rules {
-					// split the rule to make sure each rule has up to one match
-					matches := slices.Reference(r.Matches)
-					if len(matches) == 0 {
-						matches = append(matches, nil)
-					}
-					for _, m := range matches {
-						if m != nil {
-							r.Matches = []gateway.HTTPRouteMatch{*m}
-						}
-						if !yield(convertHTTPRoute(ctx, r, obj, n)) {
-							return
-						}
-					}
-				}
-			}
-		})
-
-		count := 0
-		virtualServices := []RouteWithKey{}
-		for _, parent := range filteredReferences(parentRefs) {
-			// for gateway routes, build one VS per gateway+host
-			routeKey := parent.InternalName
-			vsHosts := hostnameToStringList(route.Hostnames)
-			routes := gwResult.routes
-			if len(routes) == 0 {
-				continue
-			}
-			// Create one VS per hostname with a single hostname.
-			// This ensures we can treat each hostname independently, as the spec requires
-			for _, h := range vsHosts {
-				if !parent.hostnameAllowedByIsolation(h) {
-					// TODO: standardize a status message for this upstream and report
-					continue
-				}
-				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, AgentgatewayName)
-				sortHTTPRoutes(routes)
-				cfg := &Config{
-					Meta: Meta{
-						CreationTimestamp: obj.CreationTimestamp.Time,
-						//GroupVersionKind:  gvk.VirtualService,
-						Name:        name,
-						Annotations: routeMeta(obj),
-						Namespace:   obj.Namespace,
-						Domain:      ctx.DomainSuffix,
-					},
-					Spec: &istio.VirtualService{
-						Hosts:    []string{h},
-						Gateways: []string{parent.InternalName},
-						Http:     routes,
-					},
-				}
-				virtualServices = append(virtualServices, RouteWithKey{
-					Config: cfg,
-					Key:    routeKey + "/" + h,
-				})
-				count++
-			}
-		}
-		return virtualServices
-	}, krtopts.ToOptions("HTTPRoute")...)
-
-	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, krtopts.ToOptions("HTTPRouteMerged")...)
-	return RouteResult[*gateway.HTTPRoute, gateway.HTTPRouteStatus]{
-		VirtualServices:  finalVirtualServices,
-		RouteAttachments: routeCount,
-	}
-}
-
+// TODO: support other route collections (TCP, TLS, etc.)
 func ADPRouteCollection(
 	httpRoutes krt.Collection[*gateway.HTTPRoute],
 	inputs RouteContextInputs,
@@ -173,196 +85,6 @@ func IsNil[O comparable](o O) bool {
 	return o == t
 }
 
-func GRPCRouteCollection(
-	grpcRoutes krt.Collection[*gatewayv1.GRPCRoute],
-	inputs RouteContextInputs,
-	krtopts krtutil.KrtOptions,
-) RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, grpcRoutes, wellknown.GRPCRouteGVK, krtopts)
-	baseVirtualServices := krt.NewManyCollection(grpcRoutes, func(krtctx krt.HandlerContext, obj *gatewayv1.GRPCRoute) []RouteWithKey {
-		ctx := inputs.WithCtx(krtctx)
-		route := obj.Spec
-		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gatewayv1.GRPCRoute) iter.Seq2[*istio.HTTPRoute, *ConfigError] {
-			return func(yield func(*istio.HTTPRoute, *ConfigError) bool) {
-				for n, r := range route.Rules {
-					// split the rule to make sure each rule has up to one match
-					matches := slices.Reference(r.Matches)
-					if len(matches) == 0 {
-						matches = append(matches, nil)
-					}
-					for _, m := range matches {
-						if m != nil {
-							r.Matches = []gatewayv1.GRPCRouteMatch{*m}
-						}
-						if !yield(convertGRPCRoute(ctx, r, obj, n)) {
-							return
-						}
-					}
-				}
-			}
-		})
-
-		count := 0
-		var virtualServices []RouteWithKey
-		for _, parent := range filteredReferences(parentRefs) {
-			// for gateway routes, build one VS per gateway+host
-			routeKey := parent.InternalName
-			vsHosts := hostnameToStringList(route.Hostnames)
-			routes := gwResult.routes
-			if len(routes) == 0 {
-				continue
-			}
-			// Create one VS per hostname with a single hostname.
-			// This ensures we can treat each hostname independently, as the spec requires
-			for _, h := range vsHosts {
-				if !parent.hostnameAllowedByIsolation(h) {
-					// TODO: standardize a status message for this upstream and report
-					continue
-				}
-				name := fmt.Sprintf("%s-%d-%s", obj.Name, count, AgentgatewayName)
-				sortHTTPRoutes(routes)
-				cfg := &Config{
-					Meta: Meta{
-						CreationTimestamp: obj.CreationTimestamp.Time,
-						//GroupVersionKind:  gvk.VirtualService,
-						Name:        name,
-						Annotations: routeMeta(obj),
-						Namespace:   obj.Namespace,
-						Domain:      ctx.DomainSuffix,
-					},
-					Spec: &istio.VirtualService{
-						Hosts:    []string{h},
-						Gateways: []string{parent.InternalName},
-						Http:     routes,
-					},
-				}
-				virtualServices = append(virtualServices, RouteWithKey{
-					Config: cfg,
-					Key:    routeKey + "/" + h,
-				})
-				count++
-			}
-		}
-		return virtualServices
-	}, krtopts.ToOptions("GRPCRoute")...)
-
-	finalVirtualServices := mergeHTTPRoutes(baseVirtualServices, krtopts.ToOptions("GRPCRouteMerged")...)
-	return RouteResult[*gatewayv1.GRPCRoute, gatewayv1.GRPCRouteStatus]{
-		VirtualServices:  finalVirtualServices,
-		RouteAttachments: routeCount,
-	}
-}
-
-func TCPRouteCollection(
-	tcpRoutes krt.Collection[*gatewayalpha.TCPRoute],
-	inputs RouteContextInputs,
-	krtopts krtutil.KrtOptions,
-) RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, tcpRoutes, wellknown.TCPRouteGVK, krtopts)
-	virtualServices := krt.NewManyCollection(tcpRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TCPRoute) []*Config {
-		ctx := inputs.WithCtx(krtctx)
-		route := obj.Spec
-		parentRefs, gwResult := computeRoute(ctx, obj,
-			func(obj *gatewayalpha.TCPRoute) iter.Seq2[*istio.TCPRoute, *ConfigError] {
-				return func(yield func(*istio.TCPRoute, *ConfigError) bool) {
-					for _, r := range route.Rules {
-						if !yield(convertTCPRoute(ctx, r, obj)) {
-							return
-						}
-					}
-				}
-			})
-
-		var vs []*Config
-		for _, parent := range filteredReferences(parentRefs) {
-			routes := gwResult.routes
-			vsHosts := []string{"*"}
-			for i, host := range vsHosts {
-				name := fmt.Sprintf("%s-tcp-%d-%s", obj.Name, i, AgentgatewayName)
-				// Create one VS per hostname with a single hostname.
-				// This ensures we can treat each hostname independently, as the spec requires
-				vs = append(vs, &Config{
-					Meta: Meta{
-						CreationTimestamp: obj.CreationTimestamp.Time,
-						//GroupVersionKind:  gvk.VirtualService,
-						Name:        name,
-						Annotations: routeMeta(obj),
-						Namespace:   obj.Namespace,
-						Domain:      ctx.DomainSuffix,
-					},
-					Spec: &istio.VirtualService{
-						// We can use wildcard here since each listener can have at most one route bound to it, so we have
-						// a single VS per Gateway.
-						Hosts:    []string{host},
-						Gateways: []string{parent.InternalName},
-						Tcp:      routes,
-					},
-				})
-			}
-		}
-		return vs
-	}, krtopts.ToOptions("TCPRoute")...)
-
-	return RouteResult[*gatewayalpha.TCPRoute, gatewayalpha.TCPRouteStatus]{
-		VirtualServices:  virtualServices,
-		RouteAttachments: routeCount,
-	}
-}
-
-func TLSRouteCollection(
-	tlsRoutes krt.Collection[*gatewayalpha.TLSRoute],
-	inputs RouteContextInputs,
-	krtopts krtutil.KrtOptions,
-) RouteResult[*gatewayalpha.TLSRoute, gatewayalpha.TLSRouteStatus] {
-	routeCount := gatewayRouteAttachmentCountCollection(inputs, tlsRoutes, wellknown.TLSRouteGVK, krtopts)
-	virtualServices := krt.NewManyCollection(tlsRoutes, func(krtctx krt.HandlerContext, obj *gatewayalpha.TLSRoute) []*Config {
-		ctx := inputs.WithCtx(krtctx)
-		route := obj.Spec
-		parentRefs, gwResult := computeRoute(ctx,
-			obj, func(obj *gatewayalpha.TLSRoute) iter.Seq2[*istio.TLSRoute, *ConfigError] {
-				return func(yield func(*istio.TLSRoute, *ConfigError) bool) {
-					for _, r := range route.Rules {
-						if !yield(convertTLSRoute(ctx, r, obj)) {
-							return
-						}
-					}
-				}
-			})
-
-		var vs []*Config
-		for _, parent := range filteredReferences(parentRefs) {
-			routes := gwResult.routes
-			vsHosts := hostnameToStringList(route.Hostnames)
-			for i, host := range vsHosts {
-				name := fmt.Sprintf("%s-tls-%d-%s", obj.Name, i, AgentgatewayName)
-				filteredRoutes := routes
-				// Create one VS per hostname with a single hostname.
-				// This ensures we can treat each hostname independently, as the spec requires
-				vs = append(vs, &Config{
-					Meta: Meta{
-						CreationTimestamp: obj.CreationTimestamp.Time,
-						//GroupVersionKind:  gvk.VirtualService,
-						Name:        name,
-						Annotations: routeMeta(obj),
-						Namespace:   obj.Namespace,
-						Domain:      ctx.DomainSuffix,
-					},
-					Spec: &istio.VirtualService{
-						Hosts:    []string{host},
-						Gateways: []string{parent.InternalName},
-						Tls:      filteredRoutes,
-					},
-				})
-			}
-		}
-		return vs
-	})
-	return RouteResult[*gatewayalpha.TLSRoute, gatewayalpha.TLSRouteStatus]{
-		VirtualServices:  virtualServices,
-		RouteAttachments: routeCount,
-	}
-}
-
 // computeRoute holds the common route building logic shared amongst all types
 func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, translator func(
 	obj T,
@@ -466,65 +188,3 @@ func (r *RouteAttachment) ResourceName() string {
 func (r *RouteAttachment) Equals(other RouteAttachment) bool {
 	return r.From == other.From && r.To == other.To && r.ListenerName == other.ListenerName
 }
-
-// gatewayRouteAttachmentCountCollection holds the generic logic to determine the parents a route is attached to, used for
-// computing the aggregated `attachedRoutes` status in Gateway.
-func gatewayRouteAttachmentCountCollection[T controllers.Object](
-	inputs RouteContextInputs,
-	col krt.Collection[T],
-	kind schema.GroupVersionKind,
-	krtopts krtutil.KrtOptions,
-) krt.Collection[*RouteAttachment] {
-	return krt.NewManyCollection(col, func(krtctx krt.HandlerContext, obj T) []*RouteAttachment {
-		ctx := inputs.WithCtx(krtctx)
-		from := TypedResource{
-			Kind: kind,
-			Name: config.NamespacedName(obj),
-		}
-
-		parentRefs := extractParentReferenceInfo(ctx, inputs.RouteParents, obj)
-		return slices.MapFilter(filteredReferences(parentRefs), func(e routeParentReference) **RouteAttachment {
-			if e.ParentKey.Kind != wellknown.GatewayGVK {
-				return nil
-			}
-			return ptr.Of(&RouteAttachment{
-				From: from,
-				To: types.NamespacedName{
-					Name:      e.ParentKey.Name,
-					Namespace: e.ParentKey.Namespace,
-				},
-				ListenerName: string(e.ParentSection),
-			})
-		})
-	}, krtopts.ToOptions(kind.Kind+"/count")...)
-}
-
-// mergeHTTPRoutes merges HTTProutes by key. Gateway API has semantics for the ordering of `match` rules, that merges across resource.
-// So we merge everything (by key) following that ordering logic, and sort into a linear list (how VirtualService semantics work).
-func mergeHTTPRoutes(baseVirtualServices krt.Collection[RouteWithKey], opts ...krt.CollectionOption) krt.Collection[*Config] {
-	groupedRoutes := krt.NewCollection(baseVirtualServices, func(ctx krt.HandlerContext, obj RouteWithKey) *IndexObject[string, RouteWithKey] {
-		return &IndexObject[string, RouteWithKey]{
-			Key:     obj.Key,
-			Objects: []RouteWithKey{obj},
-		}
-	}, opts...)
-	finalVirtualServices := krt.NewCollection(groupedRoutes, func(ctx krt.HandlerContext, object IndexObject[string, RouteWithKey]) **Config {
-		configs := object.Objects
-		if len(configs) == 1 {
-			return &configs[0].Config
-		}
-		sortRoutesByCreationTime(configs)
-		base := configs[0].DeepCopy()
-		baseVS := base.Spec.(*istio.VirtualService)
-		for _, config := range configs[1:] {
-			thisVS := config.Spec.(*istio.VirtualService)
-			baseVS.Http = append(baseVS.GetHttp(), thisVS.GetHttp()...)
-			// append parents
-			base.Annotations[constants.InternalParentNames] = fmt.Sprintf("%s,%s",
-				base.Annotations[constants.InternalParentNames], config.Annotations[constants.InternalParentNames])
-		}
-		sortHTTPRoutes(baseVS.GetHttp())
-		return ptr.Of(&base)
-	}, opts...)
-	return finalVirtualServices
-}
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
index 37386186a..2c87c5d26 100644
--- a/internal/kgateway/agentgatewaysyncer/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -31,7 +31,6 @@ import (
 	"istio.io/istio/pkg/config/visibility"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/maps"
-	pm "istio.io/istio/pkg/model"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/protomarshal"
 	"istio.io/istio/pkg/util/sets"
@@ -370,7 +369,7 @@ const (
 	//   negotiation for QUIC vs TCP.
 	// Users should appropriately parse the full list rather than doing a string literal check to
 	// ensure future-proofing against new protocols being added.
-	TunnelLabel = "networking.istio.io/tunnel"
+	TunnelLabel = "networking.agentgateway.io/tunnel"
 	// TunnelLabelShortName is a short name for TunnelLabel to be used in optimized scenarios.
 	TunnelLabelShortName = "tunnel"
 	// TunnelHTTP indicates tunneling over HTTP over TCP. HTTP/2 vs HTTP/1.1 may be supported by ALPN
@@ -380,14 +379,11 @@ const (
 )
 
 const (
-	// TLSModeLabelShortname name used for determining endpoint level tls transport socket configuration
-	TLSModeLabelShortname = "tlsMode"
-
 	// DisabledTLSModeLabel implies that this endpoint should receive traffic as is (mostly plaintext)
 	DisabledTLSModeLabel = "disabled"
 
-	// IstioMutualTLSModeLabel implies that the endpoint is ready to receive Istio mTLS connections.
-	IstioMutualTLSModeLabel = "istio"
+	// MutualTLSModeLabel implies that the endpoint is ready to receive agent mTLS connections.
+	MutualTLSModeLabel = "mtls"
 )
 
 func SupportsTunnel(labels map[string]string, tunnelType string) bool {
@@ -427,23 +423,6 @@ func (p Port) String() string {
 // PortList is a set of ports
 type PortList []*Port
 
-// TrafficDirection defines whether traffic exists a service instance or enters a service instance
-type TrafficDirection string
-
-const (
-	// TrafficDirectionInbound indicates inbound traffic
-	TrafficDirectionInbound TrafficDirection = "inbound"
-	// TrafficDirectionInboundVIP indicates inbound traffic for vip
-	TrafficDirectionInboundVIP TrafficDirection = "inbound-vip"
-	// TrafficDirectionOutbound indicates outbound traffic
-	TrafficDirectionOutbound TrafficDirection = "outbound"
-
-	// trafficDirectionOutboundSrvPrefix the prefix for a DNS SRV type subset key
-	trafficDirectionOutboundSrvPrefix = string(TrafficDirectionOutbound) + "_"
-	// trafficDirectionInboundSrvPrefix the prefix for a DNS SRV type subset key
-	trafficDirectionInboundSrvPrefix = string(TrafficDirectionInbound) + "_"
-)
-
 // ServiceTarget includes a Service object, along with a specific service port
 // and target port. This is basically a smaller version of ServiceInstance,
 // intended to avoid the need to have the full object when only port information
@@ -483,21 +462,6 @@ func (k workloadKind) String() string {
 	return ""
 }
 
-// GetLocalityLabel returns the locality from the supplied label. Because Kubernetes
-// labels don't support `/`, we replace "." with "/" in the supplied label as a workaround.
-func GetLocalityLabel(label string) string {
-	return pm.GetLocalityLabel(label)
-}
-
-// Locality information for an IstioEndpoint
-type Locality struct {
-	// Label for locality on the endpoint. This is a "/" separated string.
-	Label string
-
-	// ClusterID where the endpoint is located
-	ClusterID cluster.ID
-}
-
 // ServiceAttributes represents a group of custom attributes of the service.
 type ServiceAttributes struct {
 	// ServiceRegistry indicates the backing service registry system where this service
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index a4ea43190..96dccf64c 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -9,6 +9,7 @@ import (
 	"github.com/agentgateway/agentgateway/go/api"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
@@ -23,7 +24,6 @@ import (
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/sets"
 	"k8s.io/client-go/tools/cache"
-	"sigs.k8s.io/controller-runtime/pkg/manager"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
@@ -41,22 +41,22 @@ var logger = logging.New("agentgateway/syncer")
 // AgentGwSyncer synchronizes Kubernetes Gateway API resources with xDS for agentgateway proxies.
 // It watches Gateway resources with the agentgateway class and translates them to agentgateway configuration.
 type AgentGwSyncer struct {
-	commonCols     *common.CommonCollections
-	controllerName string
-	resourcexDS    krt.Collection[ADPCacheResource]
-	addressxDS     krt.Collection[ADPCacheAddress]
-	xdsCache       envoycache.SnapshotCache
-	client         kube.Client
-	domainSuffix   string
+	commonCols              *common.CommonCollections
+	controllerName          string
+	perclientSnapCollection krt.Collection[XdsSnapWrapper]
+	uniqueClients           krt.Collection[ir.UniqlyConnectedClient]
+	mostXdsSnapshots        krt.Collection[ADPCacheResource]
+	xdsCache                envoycache.SnapshotCache
+	client                  kube.Client
+	domainSuffix            string
 
 	waitForSync []cache.InformerSynced
 }
 
 func NewAgentGwSyncer(
-	ctx context.Context,
 	controllerName string,
-	mgr manager.Manager,
 	client kube.Client,
+	uniqueClients krt.Collection[ir.UniqlyConnectedClient],
 	commonCols *common.CommonCollections,
 	xdsCache envoycache.SnapshotCache,
 	domainSuffix string,
@@ -66,9 +66,9 @@ func NewAgentGwSyncer(
 		commonCols:     commonCols,
 		controllerName: controllerName,
 		xdsCache:       xdsCache,
-		// mgr:            mgr,
-		client:       client,
-		domainSuffix: domainSuffix,
+		client:         client,
+		uniqueClients:  uniqueClients,
+		domainSuffix:   domainSuffix,
 	}
 }
 
@@ -279,24 +279,26 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		s.commonCols.Client,
 		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
 	)
-	endpointSlices := krt.WrapClient(epSliceClient, s.commonCols.KrtOpts.ToOptions("EndpointSlices")...)
+	endpointSlices := krt.WrapClient(epSliceClient, s.commonCols.KrtOpts.ToOptions("informer/EndpointSlices")...)
 
+	// Create a separate Pods client for agentgateway syncer
 	podsClient := kclient.NewFiltered[*corev1.Pod](
-		s.commonCols.Client,
+		s.client,
 		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
 	)
-	pods := krt.WrapClient(podsClient, s.commonCols.KrtOpts.ToOptions("Pods")...)
+	pods := krt.WrapClient(podsClient)
+
 	nsClient := kclient.NewFiltered[*corev1.Namespace](
 		s.commonCols.Client,
 		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
 	)
-	namespaces := krt.WrapClient(nsClient, s.commonCols.KrtOpts.ToOptions("Namespaces")...)
+	namespaces := krt.WrapClient(nsClient, s.commonCols.KrtOpts.ToOptions("informer/Namespaces")...)
 
 	seInformer := kclient.NewDelayedInformer[*networkingclient.ServiceEntry](
 		s.client, gvr.ServiceEntry,
 		kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.client.ObjectFilter()},
 	)
-	serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("ServiceEntries")...)
+	serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("informer/ServiceEntries")...)
 
 	workloadIndex := index{
 		services: servicesCollection{},
@@ -360,10 +362,11 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		logger.Debug("created XDS resources for workload address with ID", "addr", fmt.Sprintf("%s,%s", obj.Workload.GetName(), obj.Workload.GetNamespace()), "resourceid", result.ResourceName())
 		return result
 	})
-	s.addressxDS = krt.JoinCollection([]krt.Collection[ADPCacheAddress]{avcAddresses, workloadAddresses}, krtopts.ToOptions("ADPAddresses")...)
+
+	addressxDS := krt.JoinCollection([]krt.Collection[ADPCacheAddress]{avcAddresses, workloadAddresses}, krtopts.ToOptions("ADPAddresses")...)
 
 	resources := krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, ADPRoutes}, krtopts.ToOptions("ADPResources")...)
-	s.resourcexDS = krt.NewCollection(resources, func(ctx krt.HandlerContext, obj ADPResource) *ADPCacheResource {
+	s.mostXdsSnapshots = krt.NewCollection(resources, func(ctx krt.HandlerContext, obj ADPResource) *ADPCacheResource {
 		var cacheResources []envoytypes.Resource
 		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
 			Message: obj.Resource,
@@ -385,13 +388,28 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		return result
 	})
 
+	// Create per-client addresses
+	addrPerClient := NewPerClientAddresses(
+		krtopts,
+		s.uniqueClients,
+		addressxDS,
+	)
+
+	// Initialize per-client snap collection
+	s.perclientSnapCollection = snapshotPerClient(
+		krtopts,
+		s.uniqueClients,
+		s.mostXdsSnapshots,
+		addrPerClient,
+	)
+
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
 		// resources
 		Binds.HasSynced,
 		Listeners.HasSynced,
 		ADPRoutes.HasSynced,
-		s.resourcexDS.HasSynced,
+		s.mostXdsSnapshots.HasSynced,
 		// addresses
 		serviceEntries.HasSynced,
 		namespaces.HasSynced,
@@ -399,7 +417,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		endpointSlices.HasSynced,
 		WorkloadServices.HasSynced,
 		Workloads.HasSynced,
-		s.addressxDS.HasSynced,
+		// per-client syncer
+		s.uniqueClients.HasSynced,
+		s.perclientSnapCollection.HasSynced,
 	}
 }
 
@@ -412,40 +432,18 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		return fmt.Errorf("agentgateway syncer waiting for cache to sync failed")
 	}
 
-	s.resourcexDS.RegisterBatch(func(events []krt.Event[ADPCacheResource], _ bool) {
+	// Register per-client snapshot handler
+	s.perclientSnapCollection.RegisterBatch(func(events []krt.Event[XdsSnapWrapper], _ bool) {
 		for _, e := range events {
-			r := e.Latest()
+			snap := e.Latest()
 			if e.Event == controllers.EventDelete {
-				s.xdsCache.ClearSnapshot(r.ResourceName())
+				s.xdsCache.ClearSnapshot(snap.proxyKey)
 				continue
 			}
-			snapshot := &agentGwSnapshot{
-				Resources: r.Resources,
-			}
-			logger.Debug("setting xds snapshot", "resourcename", r.ResourceName())
-			err := s.xdsCache.SetSnapshot(ctx, r.ResourceName(), snapshot)
+			logger.Debug("setting per-client xds snapshot", "proxy_key", snap.proxyKey)
+			err := s.xdsCache.SetSnapshot(ctx, snap.proxyKey, snap.snap)
 			if err != nil {
-				logger.Error("failed to set xds snapshot", "resourcename", r.ResourceName(), "error", err.Error())
-				continue
-			}
-		}
-	}, true)
-
-	s.addressxDS.RegisterBatch(func(events []krt.Event[ADPCacheAddress], _ bool) {
-		for _, e := range events {
-			r := e.Latest()
-			if e.Event == controllers.EventDelete {
-				s.xdsCache.ClearSnapshot(r.ResourceName())
-				continue
-			}
-			snapshot := &agentGwSnapshot{
-				Addresses: r.Address,
-			}
-			logger.Debug("setting xds snapshot", "resourcename", r.ResourceName())
-			snapWrap := e.Latest()
-			err := s.xdsCache.SetSnapshot(ctx, snapWrap.proxyKey, snapshot)
-			if err != nil {
-				logger.Error("failed to set xds snapshot", "resourcename", r.ResourceName(), "error", err.Error())
+				logger.Error("failed to set per-client xds snapshot", "proxy_key", snap.proxyKey, "error", err.Error())
 				continue
 			}
 		}
@@ -485,7 +483,7 @@ func (m *agentGwSnapshot) GetVersion(typeURL string) string {
 	case TargetTypeResourceUrl:
 		return m.Resources.Version
 	case TargetTypeAddressUrl:
-		return m.Resources.Version
+		return m.Addresses.Version
 	default:
 		return ""
 	}
@@ -528,3 +526,162 @@ func (m *agentGwSnapshot) GetVersionMap(typeURL string) map[string]string {
 }
 
 var _ envoycache.ResourceSnapshot = &agentGwSnapshot{}
+
+type clustersWithErrors struct {
+	clusters            envoycache.Resources
+	erroredClusters     []string
+	erroredClustersHash uint64
+	clustersHash        uint64
+	resourceName        string
+}
+
+type addressesWithUccName struct {
+	addresses    envoycache.Resources
+	resourceName string
+}
+
+func (c clustersWithErrors) ResourceName() string {
+	return c.resourceName
+}
+
+var _ krt.Equaler[clustersWithErrors] = new(clustersWithErrors)
+
+func (c clustersWithErrors) Equals(k clustersWithErrors) bool {
+	return c.clustersHash == k.clustersHash && c.erroredClustersHash == k.erroredClustersHash
+}
+
+func (c addressesWithUccName) ResourceName() string {
+	return c.resourceName
+}
+
+var _ krt.Equaler[addressesWithUccName] = new(addressesWithUccName)
+
+func (c addressesWithUccName) Equals(k addressesWithUccName) bool {
+	return c.addresses.Version == k.addresses.Version
+}
+
+type UccWithAddress struct {
+	Client  ir.UniqlyConnectedClient
+	Address ADPCacheAddress
+}
+
+func (c UccWithAddress) ResourceName() string {
+	return fmt.Sprintf("%s/%s", c.Client.ResourceName(), c.Address.ResourceName())
+}
+
+func (c UccWithAddress) Equals(in UccWithAddress) bool {
+	return c.Client.Equals(in.Client) && c.Address.Equals(in.Address)
+}
+
+type PerClientAddresses struct {
+	addresses krt.Collection[UccWithAddress]
+	index     krt.Index[string, UccWithAddress]
+}
+
+func (ie *PerClientAddresses) FetchEndpointsForClient(kctx krt.HandlerContext, ucc ir.UniqlyConnectedClient) []UccWithAddress {
+	return krt.Fetch(kctx, ie.addresses, krt.FilterIndex(ie.index, ucc.ResourceName()))
+}
+
+func NewPerClientAddresses(
+	krtopts krtutil.KrtOptions,
+	uccs krt.Collection[ir.UniqlyConnectedClient],
+	addresses krt.Collection[ADPCacheAddress],
+) PerClientAddresses {
+	perclientAddresses := krt.NewManyCollection(addresses, func(kctx krt.HandlerContext, addr ADPCacheAddress) []UccWithAddress {
+		uccs := krt.Fetch(kctx, uccs)
+		uccWithEndpointsRet := make([]UccWithAddress, 0, len(uccs))
+		for _, ucc := range uccs {
+			u := UccWithAddress{
+				Client:  ucc,
+				Address: addr,
+			}
+			uccWithEndpointsRet = append(uccWithEndpointsRet, u)
+		}
+		return uccWithEndpointsRet
+	}, krtopts.ToOptions("PerClientAddresses")...)
+	idx := krt.NewIndex(perclientAddresses, func(ucc UccWithAddress) []string {
+		return []string{ucc.Client.ResourceName()}
+	})
+
+	return PerClientAddresses{
+		addresses: perclientAddresses,
+		index:     idx,
+	}
+}
+
+func snapshotPerClient(
+	krtopts krtutil.KrtOptions,
+	uccCol krt.Collection[ir.UniqlyConnectedClient],
+	mostXdsSnapshots krt.Collection[ADPCacheResource],
+	addresses PerClientAddresses,
+) krt.Collection[XdsSnapWrapper] {
+	addrResources := krt.NewCollection(uccCol, func(kctx krt.HandlerContext, ucc ir.UniqlyConnectedClient) *addressesWithUccName {
+		endpointsForUcc := addresses.FetchEndpointsForClient(kctx, ucc)
+		endpointsProto := make([]envoytypes.ResourceWithTTL, 0, len(endpointsForUcc))
+		var endpointsHash uint64
+		for _, ep := range endpointsForUcc {
+			// Extract individual resources from the Address.Resources
+			for _, resourceWithTTL := range ep.Address.Address.Items {
+				endpointsProto = append(endpointsProto, resourceWithTTL)
+				// Use the resource hash for versioning
+				if resource, ok := resourceWithTTL.Resource.(*envoyResourceWithCustomName); ok {
+					endpointsHash ^= resource.version
+				}
+			}
+		}
+
+		endpointResources := envoycache.NewResourcesWithTTL(fmt.Sprintf("%d", endpointsHash), endpointsProto)
+		return &addressesWithUccName{
+			addresses:    endpointResources,
+			resourceName: ucc.ResourceName(),
+		}
+	}, krtopts.ToOptions("AddressResources")...)
+
+	xdsSnapshotsForUcc := krt.NewCollection(uccCol, func(kctx krt.HandlerContext, ucc ir.UniqlyConnectedClient) *XdsSnapWrapper {
+		listenerRouteSnapshot := krt.FetchOne(kctx, mostXdsSnapshots, krt.FilterKey(ucc.Role))
+		if listenerRouteSnapshot == nil {
+			logger.Debug("snapshot missing", "proxy_key", ucc.Role)
+			return nil
+		}
+		clientEndpointResources := krt.FetchOne(kctx, addrResources, krt.FilterKey(ucc.ResourceName()))
+
+		// HACK
+		// https://github.com/solo-io/gloo/pull/10611/files#diff-060acb7cdd3a287a3aef1dd864aae3e0193da17b6230c382b649ce9dc0eca80b
+		// Without this, we will send a "blip" where the DestinationRule
+		// or other per-client config is not applied to the clusters
+		// by sending the genericSnap clusters on the first pass, then
+		// the correct ones.
+		// This happens because the event for the new connected client
+		// triggers the per-client cluster transformation in parallel
+		// with this snapshotPerClient transformation. This Fetch is racing
+		// with that computation and will almost always lose.
+		// While we're looking for a way to make this ordering predictable
+		// to avoid hacks like this, it will do for now.
+		if clientEndpointResources == nil {
+			logger.Info("no perclient addresses; defer building snapshot", "client", ucc.ResourceName())
+			return nil
+		}
+
+		snap := XdsSnapWrapper{}
+		snap.proxyKey = ucc.ResourceName()
+		// Create agentGwSnapshot for XdsSnapWrapper
+		snapshot := &agentGwSnapshot{
+			Resources: listenerRouteSnapshot.Resources,
+			Addresses: clientEndpointResources.addresses,
+		}
+		snap.snap = snapshot
+		logger.Debug("snapshots", "proxy_key", snap.proxyKey,
+			"resources", resourcesStringer(listenerRouteSnapshot.Resources).String(),
+			"addresses", resourcesStringer(clientEndpointResources.addresses).String(),
+		)
+
+		return &snap
+	}, krtopts.ToOptions("PerClientXdsSnapshots")...)
+	return xdsSnapshotsForUcc
+}
+
+type resourcesStringer envoycache.Resources
+
+func (r resourcesStringer) String() string {
+	return fmt.Sprintf("len: %d, version %s", len(r.Items), r.Version)
+}
diff --git a/internal/kgateway/agentgatewaysyncer/syncer_test.go b/internal/kgateway/agentgatewaysyncer/syncer_test.go
deleted file mode 100644
index aeeeea27c..000000000
--- a/internal/kgateway/agentgatewaysyncer/syncer_test.go
+++ /dev/null
@@ -1,35 +0,0 @@
-package agentgatewaysyncer
-
-import (
-	"context"
-
-	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
-)
-
-// dumpXDSCacheState is a helper function that dump the current state of the XDS cache for the agentgateway cache
-func dumpXDSCacheState(ctx context.Context, cache envoycache.SnapshotCache) {
-	logger.Info("current XDS cache state:")
-
-	// Get all snapshot IDs from cache
-	for _, nodeID := range cache.GetStatusKeys() {
-		logger.Info("snapshot has node", "node_id", nodeID)
-
-		snapshot, err := cache.GetSnapshot(nodeID)
-		if err != nil {
-			logger.Info("error getting snapshot", "error", err.Error())
-			continue
-		}
-
-		logger.Info("Resource targets version", "snapshot", snapshot.GetVersion(TargetTypeResourceUrl))
-		resources := snapshot.GetResources(TargetTypeResourceUrl)
-		for name := range resources {
-			logger.Info("snapshot has resources", "name", name)
-		}
-
-		logger.Info("Address targets version", "snapshot", snapshot.GetVersion(TargetTypeAddressUrl))
-		resources = snapshot.GetResources(TargetTypeAddressUrl)
-		for name := range resources {
-			logger.Info("snapshot has resources", "name", name)
-		}
-	}
-}
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
index c779f98f1..722a0e4e4 100644
--- a/internal/kgateway/agentgatewaysyncer/workloads.go
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -701,7 +701,7 @@ func setTunnelProtocol(labels, annotations map[string]string, w *api.Workload) {
 		w.NativeTunnel = true
 	}
 	if w.TunnelProtocol == api.TunnelProtocol_NONE &&
-		GetTLSModeFromEndpointLabels(labels) == IstioMutualTLSModeLabel {
+		GetTLSModeFromEndpointLabels(labels) == MutualTLSModeLabel {
 		w.TunnelProtocol = api.TunnelProtocol_LEGACY_ISTIO_MTLS
 	}
 }
diff --git a/internal/kgateway/agentgatewaysyncer/xdswrapper.go b/internal/kgateway/agentgatewaysyncer/xdswrapper.go
new file mode 100644
index 000000000..bd5c61cda
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/xdswrapper.go
@@ -0,0 +1,192 @@
+package agentgatewaysyncer
+
+import (
+	"encoding/json"
+	"fmt"
+
+	udpaannontations "github.com/cncf/xds/go/udpa/annotations"
+	envoycachetypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
+	"google.golang.org/protobuf/encoding/protojson"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/reflect/protoreflect"
+	"google.golang.org/protobuf/types/descriptorpb"
+	"google.golang.org/protobuf/types/known/anypb"
+	"istio.io/istio/pkg/kube/krt"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
+	"github.com/kgateway-dev/kgateway/v2/pkg/utils/envutils"
+)
+
+var (
+	UseDetailedUnmarshalling = !envutils.IsEnvTruthy("DISABLE_DETAILED_SNAP_UNMARSHALLING")
+)
+
+type XdsSnapWrapper struct {
+	snap     *agentGwSnapshot
+	proxyKey string
+}
+
+func (p XdsSnapWrapper) WithSnapshot(snap *agentGwSnapshot) XdsSnapWrapper {
+	p.snap = snap
+	return p
+}
+
+var _ krt.ResourceNamer = XdsSnapWrapper{}
+
+func (p XdsSnapWrapper) Equals(in XdsSnapWrapper) bool {
+	// check that all the versions are the equal
+	if p.snap.Addresses.Version != in.snap.Addresses.Version {
+		return false
+	}
+	if p.snap.Resources.Version != in.snap.Resources.Version {
+		return false
+	}
+	return true
+}
+
+func (p XdsSnapWrapper) ResourceName() string {
+	return p.proxyKey
+}
+
+// note: this is feature gated, as i'm not confident the new logic can't panic, in all envoy configs
+// once 1.18 is out, we can remove the feature gate.
+func (p XdsSnapWrapper) MarshalJSON() (out []byte, err error) {
+	if !UseDetailedUnmarshalling {
+		// use a new struct to prevent infinite recursion
+		return json.Marshal(struct {
+			snap     *agentGwSnapshot
+			proxyKey string
+		}{
+			snap:     p.snap,
+			proxyKey: p.proxyKey,
+		})
+	}
+
+	snap := p.snap
+
+	defer func() {
+		if r := recover(); r != nil {
+			err = fmt.Errorf("panic handling snapshot: %v", r)
+		}
+	}()
+
+	// redact things
+	redact(snap)
+	snapJson := map[string]map[string]any{}
+	addToSnap(snapJson, "Address", snap.Addresses.Items)
+	addToSnap(snapJson, "Resources", snap.Resources.Items)
+
+	return json.Marshal(struct {
+		Snap     any
+		ProxyKey string
+	}{
+		Snap:     snapJson,
+		ProxyKey: p.proxyKey,
+	})
+}
+
+func addToSnap(snapJson map[string]map[string]any, k string, resources map[string]envoycachetypes.ResourceWithTTL) {
+	for rname, r := range resources {
+		rJson, _ := protojson.Marshal(r.Resource)
+		var rAny any
+		json.Unmarshal(rJson, &rAny)
+		if snapJson[k] == nil {
+			snapJson[k] = map[string]any{}
+		}
+		snapJson[k][rname] = rAny
+	}
+}
+
+func redact(snap *agentGwSnapshot) {
+	// clusters and listener might have secrets
+	for _, l := range snap.Resources.Items {
+		redactProto(l.Resource)
+	}
+	for _, l := range snap.Addresses.Items {
+		redactProto(l.Resource)
+	}
+}
+
+func redactProto(m proto.Message) {
+	var msg proto.Message = m.(proto.Message)
+	visitFields(msg.ProtoReflect(), false)
+}
+
+func isSensitive(fd protoreflect.FieldDescriptor) bool {
+	opts := fd.Options().(*descriptorpb.FieldOptions)
+	if !proto.HasExtension(opts, udpaannontations.E_Sensitive) {
+		return false
+	}
+
+	maybeExt := proto.GetExtension(opts, udpaannontations.E_Sensitive)
+	return maybeExt.(bool)
+}
+
+func visitFields(msg protoreflect.Message, ancestor_sensitive bool) {
+	msg.Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
+		sensitive := ancestor_sensitive || isSensitive(fd)
+
+		if fd.IsList() {
+			list := v.List()
+			for i := 0; i < list.Len(); i++ {
+				elem := list.Get(i)
+				if fd.Message() != nil {
+					visitMessage(msg, fd, elem, sensitive)
+				} else {
+					// Redact scalar fields if needed
+					if sensitive {
+						list.Set(i, redactValue(fd, elem))
+					}
+				}
+			}
+		} else if fd.IsMap() {
+			m := v.Map()
+			m.Range(func(k protoreflect.MapKey, v protoreflect.Value) bool {
+				if fd.MapValue().Message() != nil {
+					visitMessage(msg, fd.MapValue(), v, sensitive)
+				} else {
+					// Redact scalar fields if needed
+					if sensitive {
+						m.Set(k, redactValue(fd.MapValue(), v))
+					}
+				}
+				return true
+			})
+		} else {
+			if fd.Message() != nil {
+				visitMessage(msg, fd, v, sensitive)
+			} else {
+				// Redact scalar fields if needed
+				if sensitive {
+					msg.Set(fd, redactValue(fd, v))
+				}
+			}
+		}
+		return true
+	})
+}
+
+func visitMessage(msg protoreflect.Message, fd protoreflect.FieldDescriptor, v protoreflect.Value, sensitive bool) {
+	visitMsg := v.Message()
+	var anyMsg proto.Message
+	m := visitMsg.Interface()
+	if anymsg, ok := m.(*anypb.Any); ok {
+		anyMsg, _ = anypb.UnmarshalNew(anymsg, proto.UnmarshalOptions{})
+		visitMsg = anyMsg.ProtoReflect()
+	}
+	visitFields(visitMsg, sensitive)
+	if anyMsg != nil {
+		anymsg, _ := utils.MessageToAny(anyMsg)
+		msg.Set(fd, protoreflect.ValueOf(anymsg.ProtoReflect()))
+	}
+}
+
+func redactValue(fd protoreflect.FieldDescriptor, v protoreflect.Value) protoreflect.Value {
+	switch fd.Kind() {
+	case protoreflect.StringKind:
+		return protoreflect.ValueOfString("[REDACTED]")
+	case protoreflect.BytesKind:
+		return protoreflect.ValueOfBytes([]byte("[REDACTED]"))
+	}
+	return v
+}
diff --git a/internal/kgateway/controller/start.go b/internal/kgateway/controller/start.go
index 50d028874..bc0d0b162 100644
--- a/internal/kgateway/controller/start.go
+++ b/internal/kgateway/controller/start.go
@@ -32,7 +32,6 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/proxy_syncer"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned"
-	"github.com/kgateway-dev/kgateway/v2/pkg/deployer"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	sdk "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk"
 	common "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/collections"
@@ -213,11 +212,9 @@ func NewControllerBuilder(ctx context.Context, cfg StartConfig) (*ControllerBuil
 	if cfg.SetupOpts.GlobalSettings.EnableAgentGateway {
 		domainSuffix := "cluster.local" // TODO: don't hard code
 		agentGatewaySyncer := agentgatewaysyncer.NewAgentGwSyncer(
-			ctx,
 			cfg.ControllerName,
-			cfg.AgentGatewayClassName,
-			mgr,
 			cfg.Client,
+			cfg.UniqueClients,
 			commoncol,
 			cfg.SetupOpts.Cache,
 			domainSuffix,
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index ea1600fef..c9eb73004 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -183,6 +183,75 @@ func testAgentGatewayScenario(
 		}
 		t.Logf("Address counts - Workload: %d, Service: %d", worklodCount, serviceCount)
 
+		// --- BEGIN: Assert expected resources and addresses are present ---
+		// Expected resource keys (from example output)
+		expectedBinds := map[string]bool{"8080/gwtest/http-httproute": false}
+		expectedListeners := map[string]bool{"http-httproute-agentgateway-autogenerated-k8s-gateway-http": false}
+		expectedRoutes := map[string]bool{"gwtest.my-route.0.0.http": false, "gwtest.my-route2.0.0.http": false}
+
+		// Check resources
+		for _, r := range dump.Resources {
+			switch x := r.GetKind().(type) {
+			case *api.Resource_Bind:
+				if _, ok := expectedBinds[x.Bind.GetKey()]; ok {
+					expectedBinds[x.Bind.GetKey()] = true
+				}
+			case *api.Resource_Listener:
+				if _, ok := expectedListeners[x.Listener.GetKey()]; ok {
+					expectedListeners[x.Listener.GetKey()] = true
+				}
+			case *api.Resource_Route:
+				if _, ok := expectedRoutes[x.Route.GetKey()]; ok {
+					expectedRoutes[x.Route.GetKey()] = true
+				}
+			}
+		}
+		for k, v := range expectedBinds {
+			if !v {
+				t.Errorf("expected Bind resource with key %q not found", k)
+			}
+		}
+		for k, v := range expectedListeners {
+			if !v {
+				t.Errorf("expected Listener resource with key %q not found", k)
+			}
+		}
+		for k, v := range expectedRoutes {
+			if !v {
+				t.Errorf("expected Route resource with key %q not found", k)
+			}
+		}
+
+		// Expected address keys (from example output)
+		expectedWorkloads := map[string]bool{"reviews-1": false, "reviews-2": false, "reviews-3": false, "reviews-4": false}
+		expectedServices := map[string]bool{"http-httproute.gwtest.svc.": false, "reviews.gwtest.svc.": false, "kubernetes.default.svc.": false}
+
+		for _, addr := range dump.Addresses {
+			switch x := addr.GetType().(type) {
+			case *api.Address_Workload:
+				name := x.Workload.GetName()
+				if _, ok := expectedWorkloads[name]; ok {
+					expectedWorkloads[name] = true
+				}
+			case *api.Address_Service:
+				host := x.Service.GetHostname()
+				if _, ok := expectedServices[host]; ok {
+					expectedServices[host] = true
+				}
+			}
+		}
+		for k, v := range expectedWorkloads {
+			if !v {
+				t.Errorf("expected Workload address for %q not found", k)
+			}
+		}
+		for k, v := range expectedServices {
+			if !v {
+				t.Errorf("expected Service address for %q not found", k)
+			}
+		}
+		// --- END: Assert expected resources and addresses are present ---
+
 		return nil
 	}, retry.Converge(2), retry.BackoffDelay(2*time.Second), retry.Timeout(10*time.Second))
 
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
deleted file mode 100644
index 893323e9c..000000000
--- a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
+++ /dev/null
@@ -1,35 +0,0 @@
-{
-  "addresses": null,
-  "resources": [
-    {
-      "Kind": {
-        "Route": {
-          "key": "gwtest.my-route2.0.0.http",
-          "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
-          "route_name": "gwtest/my-route2",
-          "hostnames": [
-            "www.example2.com"
-          ],
-          "matches": [
-            {
-              "path": {
-                "Kind": {
-                  "PathPrefix": "/"
-                }
-              }
-            }
-          ],
-          "backends": [
-            {
-              "Kind": {
-                "Service": "gwtest/reviews.gwtest.svc.cluster.local"
-              },
-              "weight": 1,
-              "port": 8080
-            }
-          ]
-        }
-      }
-    }
-  ]
-}
\ No newline at end of file
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute.yaml b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
index 8c80a033a..edcd19181 100644
--- a/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
@@ -1,3 +1,10 @@
+kind: GatewayClass
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: agentgateway # TODO: fix in-memory class also works with env
+spec:
+  controllerName: kgateway.dev/kgateway
+---
 kind: Gateway
 apiVersion: gateway.networking.k8s.io/v1
 metadata:
diff --git a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
index ef5d3ed02..0b9d62098 100644
--- a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
+++ b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
@@ -6,6 +6,9 @@ spec:
   kube:
     agentGateway:
       enabled: true
+      logLevel: debug
+      image:
+        tag: fd98c99-dirty
 ---
 kind: GatewayClass
 apiVersion: gateway.networking.k8s.io/v1
-- 
2.39.5 (Apple Git-154)


From cd9be21d3c7f72625113b003af9b534ec94a238b Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 16:37:38 -0700
Subject: [PATCH 08/17] wip

---
 api/applyconfiguration/internal/internal.go   |   3 -
 go.mod                                        |   6 +-
 go.sum                                        |  64 +++-----
 hack/utils/oss_compliance/osa_provided.md     |  14 +-
 ...ay.kgateway.dev_backendconfigpolicies.yaml |  17 +--
 .../gateway.kgateway.dev_backends.yaml        |  56 +------
 .../gateway.kgateway.dev_directresponses.yaml |   2 +-
 ...ateway.kgateway.dev_gatewayextensions.yaml |   2 +-
 ...ateway.kgateway.dev_gatewayparameters.yaml |   8 +-
 ...way.kgateway.dev_httplistenerpolicies.yaml |   7 +-
 .../gateway.kgateway.dev_trafficpolicies.yaml |  22 +--
 .../agentgatewaysyncer/route_collections.go   |   3 +-
 .../kgateway/agentgatewaysyncer/service.go    |   3 +-
 .../kgateway/agentgatewaysyncer/syncer.go     |   3 +-
 .../kgateway/agentgatewaysyncer/workloads.go  |   3 +-
 .../versioned/fake/clientset_generated.go     |  13 +-
 .../typed/api/v1alpha1/api_client.go          |  12 +-
 pkg/generated/openapi/zz_generated.openapi.go | 141 ++++--------------
 18 files changed, 83 insertions(+), 296 deletions(-)

diff --git a/api/applyconfiguration/internal/internal.go b/api/applyconfiguration/internal/internal.go
index d0fff61fa..55aea752b 100644
--- a/api/applyconfiguration/internal/internal.go
+++ b/api/applyconfiguration/internal/internal.go
@@ -2255,9 +2255,6 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: preStop
       type:
         namedType: io.k8s.api.core.v1.LifecycleHandler
-    - name: stopSignal
-      type:
-        scalar: string
 - name: io.k8s.api.core.v1.LifecycleHandler
   map:
     fields:
diff --git a/go.mod b/go.mod
index 3a09babb9..b68a5c1c6 100644
--- a/go.mod
+++ b/go.mod
@@ -23,7 +23,6 @@ require (
 	github.com/onsi/ginkgo/v2 v2.23.3
 	github.com/onsi/gomega v1.36.3
 	github.com/pkg/errors v0.9.1
-	github.com/rotisserie/eris v0.5.4
 	github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966
 	github.com/solo-io/go-list-licenses v0.1.4
 	github.com/solo-io/go-utils v0.27.3
@@ -66,6 +65,7 @@ require (
 	github.com/jinzhu/copier v0.4.0 // indirect
 	github.com/manuelarte/funcorder v0.2.1 // indirect
 	github.com/mikefarah/yq/v4 v4.45.4 // indirect
+	github.com/rotisserie/eris v0.5.4 // indirect
 	github.com/yuin/gopher-lua v1.1.1 // indirect
 	go.augendre.info/fatcontext v0.8.0 // indirect
 	gopkg.in/op/go-logging.v1 v1.0.0-20160211212156-b2cb9fa56473 // indirect
@@ -464,8 +464,8 @@ require (
 	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
 	github.com/polydawn/refmt v0.89.1-0.20221221234430-40501e09de1f // indirect
 	github.com/polyfloyd/go-errorlint v1.8.0 // indirect
-	github.com/prometheus/client_golang v1.21.1 // indirect
-	github.com/prometheus/client_model v0.6.2 // indirect
+	github.com/prometheus/client_golang v1.21.1
+	github.com/prometheus/client_model v0.6.2
 	github.com/prometheus/common v0.62.0 // indirect
 	github.com/prometheus/procfs v0.15.1 // indirect
 	github.com/prometheus/statsd_exporter v0.25.0 // indirect
diff --git a/go.sum b/go.sum
index e20f4b337..a11c7cc53 100644
--- a/go.sum
+++ b/go.sum
@@ -783,9 +783,8 @@ github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69
 github.com/golang-jwt/jwt/v4 v4.0.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=
 github.com/golang-jwt/jwt/v4 v4.2.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=
 github.com/golang-jwt/jwt/v4 v4.5.0/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
+github.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=
 github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
-github.com/golang-jwt/jwt/v4 v4.5.2 h1:YtQM7lnr8iZ+j5q71MGKkNw9Mn7AjHM68uc9g5fXeUI=
-github.com/golang-jwt/jwt/v4 v4.5.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
 github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
 github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
 github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
@@ -859,9 +858,8 @@ github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Z
 github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
 github.com/google/btree v1.1.3 h1:CVpQJjYgC4VbzxeGVHfvZrv1ctoYCAI8vbl07Fcxlyg=
 github.com/google/btree v1.1.3/go.mod h1:qOPhT0dTNdNzV6Z/lhRX0YXUafgPLFUh+gZMl761Gm4=
+github.com/google/cel-go v0.22.1 h1:AfVXx3chM2qwoSbM7Da8g8hX8OVSkBFwX+rz2+PcK40=
 github.com/google/cel-go v0.22.1/go.mod h1:BuznPXXfQDpXKWQ9sPW3TzlAJN5zzFe+i9tIs0yC4s8=
-github.com/google/cel-go v0.23.2 h1:UdEe3CvQh3Nv+E/j9r1Y//WO0K0cSyD7/y0bzyLIMI4=
-github.com/google/cel-go v0.23.2/go.mod h1:52Pb6QsDbC5kvgxvZhiL9QX1oZEkcUF/ZqaPx1J5Wwo=
 github.com/google/gnostic-models v0.6.9 h1:MU/8wDLif2qCXZmzncUQ/BOfxWfthHi63KqpoNbWqVw=
 github.com/google/gnostic-models v0.6.9/go.mod h1:CiWsm0s6BSQd1hRn8/QmxqB6BesYcbSZxsz9b0KuDBw=
 github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
@@ -979,9 +977,8 @@ github.com/gorilla/sessions v1.2.1/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/z
 github.com/gorilla/websocket v0.0.0-20170926233335-4201258b820c/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
 github.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
 github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
+github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
 github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
-github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674 h1:JeSE6pjso5THxAzdVpqr6/geYxZytqFMBCOtn/ujyeo=
-github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674/go.mod h1:r4w70xmWCQKmi1ONH4KIaBptdivuRPyosB9RmPlGEwA=
 github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=
 github.com/gostaticanalysis/analysisutil v0.7.1/go.mod h1:v21E3hY37WKMGSnbsw2S/ojApNWb6C1//mXO48CXbVc=
 github.com/gostaticanalysis/comment v1.4.1/go.mod h1:ih6ZxzTHLdadaiSnF5WY3dxUoXfXAlTaRzuaNDlSado=
@@ -1179,9 +1176,8 @@ github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+o
 github.com/kkHAIKE/contextcheck v1.1.6 h1:7HIyRcnyzxL9Lz06NGhiKvenXq7Zw6Q0UQu/ttjfJCE=
 github.com/kkHAIKE/contextcheck v1.1.6/go.mod h1:3dDbMRNBFaq8HFXWC1JyvDSPm43CmE6IuHam8Wr0rkg=
 github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
+github.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=
 github.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
-github.com/klauspost/compress v1.18.0 h1:c/Cqfb0r+Yi+JtIEq73FWXVkRonBlf0CRNYc8Zttxdo=
-github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=
 github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=
 github.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=
 github.com/klauspost/pgzip v1.2.6 h1:8RXeL5crjEUFnR2/Sn6GJNWtSQ3Dk8pq4CL3jvdDyjU=
@@ -1414,9 +1410,8 @@ github.com/onsi/gomega v1.7.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1Cpa
 github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
 github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
 github.com/onsi/gomega v1.16.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=
+github.com/onsi/gomega v1.36.3 h1:hID7cr8t3Wp26+cYnfcjR6HpJ00fdogN6dqZ1t6IylU=
 github.com/onsi/gomega v1.36.3/go.mod h1:8D9+Txp43QWKhM24yyOBEdpkzN8FvJyAwecBgsU4KU0=
-github.com/onsi/gomega v1.37.0 h1:CdEG8g0S133B4OswTDC/5XPSzE1OeP29QOioj2PID2Y=
-github.com/onsi/gomega v1.37.0/go.mod h1:8D9+Txp43QWKhM24yyOBEdpkzN8FvJyAwecBgsU4KU0=
 github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
 github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
 github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
@@ -1490,9 +1485,8 @@ github.com/prometheus/client_golang v1.11.0/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqr
 github.com/prometheus/client_golang v1.12.1/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=
 github.com/prometheus/client_golang v1.12.2/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=
 github.com/prometheus/client_golang v1.13.0/go.mod h1:vTeo+zgvILHsnnj/39Ou/1fPN5nJFOEMgftOUOmlvYQ=
+github.com/prometheus/client_golang v1.21.1 h1:DOvXXTqVzvkIewV/CDPFdejpMCGeMcbGCQ8YOmu+Ibk=
 github.com/prometheus/client_golang v1.21.1/go.mod h1:U9NM32ykUErtVBxdvD3zfi+EuFkkaBvMb09mIfe0Zgg=
-github.com/prometheus/client_golang v1.22.0 h1:rb93p9lokFEsctTys46VnV1kLCDpVZ0a/Y92Vm0Zc6Q=
-github.com/prometheus/client_golang v1.22.0/go.mod h1:R7ljNsLXhuQXYZYtw6GAE9AZg8Y7vEW5scdCXrWRXC0=
 github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
 github.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
 github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
@@ -1584,6 +1578,7 @@ github.com/sagikazarmark/locafero v0.6.0 h1:ON7AQg37yzcRPU69mt7gwhFEBwxI6P9T4Qu3
 github.com/sagikazarmark/locafero v0.6.0/go.mod h1:77OmuIc6VTraTXKXIs/uvUxKGUXjE1GbemJYHqdNjX0=
 github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6gto+ugjYE=
 github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
+github.com/saiskee/gettercheck v0.0.0-20210820204958-38443d06ebe0 h1:04ip5n8Ct3tP0dpw9oO7vs4BFbaPhZ4Vs3xqqpYOtUs=
 github.com/saiskee/gettercheck v0.0.0-20210820204958-38443d06ebe0/go.mod h1:sa2CuStAMG5wPJQV6wdN8WFZ0A4Kj9on3oyoxGRbCAs=
 github.com/sanposhiho/wastedassign/v2 v2.1.0 h1:crurBF7fJKIORrV85u9UUpePDYGWnwvv3+A96WvwXT0=
 github.com/sanposhiho/wastedassign/v2 v2.1.0/go.mod h1:+oSmSC+9bQ+VUAxA66nBb0Z7N8CK7mscKTDYC6aIek4=
@@ -1608,8 +1603,6 @@ github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAm
 github.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
 github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 h1:n661drycOFuPLCN3Uc8sB6B/s6Z4t2xvBgU1htSHuq8=
 github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=
-github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132 h1:3CGPS0J9yy6qL+IcJ893z5gPnNRdNgjSRsm0EAPzl7E=
-github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132/go.mod h1:y7H2qZn9nI2dCNXzfLab/sk4wi6q2xJOcsvEspVK2VY=
 github.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=
 github.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=
 github.com/shurcooL/githubv4 v0.0.0-20191127044304-8f68eb5628d0/go.mod h1:hAF0iLZy4td2EX+/8Tw+4nodhlMrwN3HupfaXj3zkGo=
@@ -1962,9 +1955,8 @@ golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliY
 golang.org/x/crypto v0.14.0/go.mod h1:MVFd36DqK4CsrnJYDkBA3VC4m2GkXAM0PvzMCn4JQf4=
 golang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=
 golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
+golang.org/x/crypto v0.38.0 h1:jt+WWG8IZlBnVbomuhg2Mdq0+BBQaHbtqHEFEigjUV8=
 golang.org/x/crypto v0.38.0/go.mod h1:MvrbAqul58NNYPKnOra203SB9vpuZW0e+RRZV+Ggqjw=
-golang.org/x/crypto v0.39.0 h1:SHs+kF4LP+f+p14esP5jAoDpHU8Gu/v9lFRK6IT5imM=
-golang.org/x/crypto v0.39.0/go.mod h1:L+Xg3Wf6HoL4Bn4238Z6ft6KfEpN0tJGo53AAPC632U=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
@@ -2016,9 +2008,8 @@ golang.org/x/mod v0.9.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
 golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
 golang.org/x/mod v0.13.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
 golang.org/x/mod v0.14.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
+golang.org/x/mod v0.24.0 h1:ZfthKaKaT4NrhGVZHO1/WDTwGES4De8KtWO0SIbNJMU=
 golang.org/x/mod v0.24.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
-golang.org/x/mod v0.25.0 h1:n7a+ZbQKQA/Ysbyb0/6IbB1H/X41mKgbhfv7AfG/44w=
-golang.org/x/mod v0.25.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
@@ -2082,9 +2073,8 @@ golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
 golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=
 golang.org/x/net v0.16.0/go.mod h1:NxSsAGuq816PNPmqtQdLE42eU2Fs7NoRIZrHJAlaCOE=
 golang.org/x/net v0.20.0/go.mod h1:z8BVo6PvndSri0LbOE3hAn0apkU+1YvI6E70E9jsnvY=
+golang.org/x/net v0.40.0 h1:79Xs7wF06Gbdcg4kdCCIQArK11Z1hr5POQ6+fIYHNuY=
 golang.org/x/net v0.40.0/go.mod h1:y0hY0exeL2Pku80/zKK7tpntoX23cqL3Oa6njdgRtds=
-golang.org/x/net v0.41.0 h1:vBTly1HeNPEn3wtREYfy4GZ/NECgw2Cnl+nK6Nz3uvw=
-golang.org/x/net v0.41.0/go.mod h1:B/K4NNqkfmg07DQYrbwvSluqCJOOXwUjeb/5lOisjbA=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
 golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
 golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
@@ -2122,9 +2112,8 @@ golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.4.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
+golang.org/x/sync v0.14.0 h1:woo0S4Yywslg6hp4eUFjTVOyKt0RookbpAHG4c1HmhQ=
 golang.org/x/sync v0.14.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
-golang.org/x/sync v0.15.0 h1:KWH3jNZsfyT6xfAfKiz6MRNmd46ByHDYaZ7KSkCtdW8=
-golang.org/x/sync v0.15.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
 golang.org/x/sys v0.0.0-20180606202747-9527bec2660b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180823144017-11551d06cbcc/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
@@ -2250,9 +2239,8 @@ golang.org/x/text v0.8.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
 golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
 golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
 golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
+golang.org/x/text v0.25.0 h1:qVyWApTSYLk/drJRO5mDlNYskwQznZmkpV2c8q9zls4=
 golang.org/x/text v0.25.0/go.mod h1:WEdwpYrmk1qmdHvhkSTNPm3app7v4rsT8F2UD6+VHIA=
-golang.org/x/text v0.26.0 h1:P42AVeLghgTYr4+xUnTRKDMqpar+PtX7KWuNQL21L8M=
-golang.org/x/text v0.26.0/go.mod h1:QK15LZJUUQVJxhz7wXgxSy/CJaTFjd0G+YLonydOVQA=
 golang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
@@ -2342,9 +2330,8 @@ golang.org/x/tools v0.7.0/go.mod h1:4pg6aUX35JBAogB10C9AtvVL+qowtN4pT3CGSQex14s=
 golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
 golang.org/x/tools v0.14.0/go.mod h1:uYBEerGOWcJyEORxN+Ek8+TT266gXkNlHdJBwexUsBg=
 golang.org/x/tools v0.17.0/go.mod h1:xsh6VxdV005rRVaS6SSAf9oiAqljS7UZUacMZ8Bnsps=
+golang.org/x/tools v0.32.0 h1:Q7N1vhpkQv7ybVzLFtTjvQya2ewbwNDZzUgfXGqtMWU=
 golang.org/x/tools v0.32.0/go.mod h1:ZxrU41P/wAbZD8EDa6dDCa6XfpkhJ7HFMjHJXfBDu8s=
-golang.org/x/tools v0.34.0 h1:qIpSLOxeCYGg9TrcJokLBG4KFA6d795g0xkBkiESGlo=
-golang.org/x/tools v0.34.0/go.mod h1:pAP9OwEaY1CAW3HOmg3hLZC5Z0CCmzjAF2UQMSqNARg=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
@@ -2583,35 +2570,28 @@ istio.io/client-go v1.25.0-alpha.0.0.20250210220843-5a4065fded65/go.mod h1:40cl7
 istio.io/istio v0.0.0-20250212203644-c2ac935c5888 h1:4uIAapZvWqD/Vo8uLecH1hxC3EAE2aqUmq8rOzaXJws=
 istio.io/istio v0.0.0-20250212203644-c2ac935c5888/go.mod h1:k9mWJfHRkdIya53hz/BzKfKmVRk2/aiA2H1AF0KmDC0=
 k8s.io/api v0.21.4/go.mod h1:fTVGP+M4D8+00FN2cMnJqk/eb/GH53bvmNs2SVTmpFk=
+k8s.io/api v0.32.3 h1:Hw7KqxRusq+6QSplE3NYG4MBxZw1BZnq4aP4cJVINls=
 k8s.io/api v0.32.3/go.mod h1:2wEDTXADtm/HA7CCMD8D8bK4yuBUptzaRhYcYEEYA3k=
-k8s.io/api v0.33.2 h1:YgwIS5jKfA+BZg//OQhkJNIfie/kmRsO0BmNaVSimvY=
-k8s.io/api v0.33.2/go.mod h1:fhrbphQJSM2cXzCWgqU29xLDuks4mu7ti9vveEnpSXs=
 k8s.io/apiextensions-apiserver v0.21.4/go.mod h1:OoC8LhI9LnV+wKjZkXIBbLUwtnOGJiTRE33qctH5CIk=
+k8s.io/apiextensions-apiserver v0.32.3 h1:4D8vy+9GWerlErCwVIbcQjsWunF9SUGNu7O7hiQTyPY=
 k8s.io/apiextensions-apiserver v0.32.3/go.mod h1:8YwcvVRMVzw0r1Stc7XfGAzB/SIVLunqApySV5V7Dss=
-k8s.io/apiextensions-apiserver v0.33.2 h1:6gnkIbngnaUflR3XwE1mCefN3YS8yTD631JXQhsU6M8=
-k8s.io/apiextensions-apiserver v0.33.2/go.mod h1:IvVanieYsEHJImTKXGP6XCOjTwv2LUMos0YWc9O+QP8=
 k8s.io/apimachinery v0.21.4/go.mod h1:H/IM+5vH9kZRNJ4l3x/fXP/5bOPJaVP/guptnZPeCFI=
+k8s.io/apimachinery v0.32.3 h1:JmDuDarhDmA/Li7j3aPrwhpNBA94Nvk5zLeOge9HH1U=
 k8s.io/apimachinery v0.32.3/go.mod h1:GpHVgxoKlTxClKcteaeuF1Ul/lDVb74KpZcxcmLDElE=
-k8s.io/apimachinery v0.33.2 h1:IHFVhqg59mb8PJWTLi8m1mAoepkUNYmptHsV+Z1m5jY=
-k8s.io/apimachinery v0.33.2/go.mod h1:BHW0YOu7n22fFv/JkYOEfkUYNRN0fj0BlvMFWA7b+SM=
 k8s.io/apiserver v0.21.4/go.mod h1:SErUuFBBPZUcD2nsUU8hItxoYheqyYr2o/pCINEPW8g=
+k8s.io/apiserver v0.32.3 h1:kOw2KBuHOA+wetX1MkmrxgBr648ksz653j26ESuWNY8=
 k8s.io/apiserver v0.32.3/go.mod h1:q1x9B8E/WzShF49wh3ADOh6muSfpmFL0I2t+TG0Zdgc=
-k8s.io/apiserver v0.33.2 h1:KGTRbxn2wJagJowo29kKBp4TchpO1DRO3g+dB/KOJN4=
-k8s.io/apiserver v0.33.2/go.mod h1:9qday04wEAMLPWWo9AwqCZSiIn3OYSZacDyu/AcoM/M=
 k8s.io/cli-runtime v0.32.3 h1:khLF2ivU2T6Q77H97atx3REY9tXiA3OLOjWJxUrdvss=
 k8s.io/cli-runtime v0.32.3/go.mod h1:vZT6dZq7mZAca53rwUfdFSZjdtLyfF61mkf/8q+Xjak=
 k8s.io/client-go v0.21.4/go.mod h1:t0/eMKyUAq/DoQ7vW8NVVA00/nomlwC+eInsS8PxSew=
+k8s.io/client-go v0.32.3 h1:RKPVltzopkSgHS7aS98QdscAgtgah/+zmpAogooIqVU=
 k8s.io/client-go v0.32.3/go.mod h1:3v0+3k4IcT9bXTc4V2rt+d2ZPPG700Xy6Oi0Gdl2PaY=
-k8s.io/client-go v0.33.2 h1:z8CIcc0P581x/J1ZYf4CNzRKxRvQAwoAolYPbtQes+E=
-k8s.io/client-go v0.33.2/go.mod h1:9mCgT4wROvL948w6f6ArJNb7yQd7QsvqavDeZHvNmHo=
 k8s.io/code-generator v0.21.4/go.mod h1:K3y0Bv9Cz2cOW2vXUrNZlFbflhuPvuadW6JdnN6gGKo=
+k8s.io/code-generator v0.32.3 h1:31p2TVzC9+hVdSkAFruAk3JY+iSfzrJ83Qij1yZutyw=
 k8s.io/code-generator v0.32.3/go.mod h1:+mbiYID5NLsBuqxjQTygKM/DAdKpAjvBzrJd64NU1G8=
-k8s.io/code-generator v0.33.2 h1:PCJ0Y6viTCxxJHMOyGqYwWEteM4q6y1Hqo2rNpl6jF4=
-k8s.io/code-generator v0.33.2/go.mod h1:hBjCA9kPMpjLWwxcr75ReaQfFXY8u+9bEJJ7kRw3J8c=
 k8s.io/component-base v0.21.4/go.mod h1:ZKG0eHVX+tUDcaoIGpU3Vtk4TIjMddN9uhEWDmW6Nyg=
+k8s.io/component-base v0.32.3 h1:98WJvvMs3QZ2LYHBzvltFSeJjEx7t5+8s71P7M74u8k=
 k8s.io/component-base v0.32.3/go.mod h1:LWi9cR+yPAv7cu2X9rZanTiFKB2kHA+JjmhkKjCZRpI=
-k8s.io/component-base v0.33.2 h1:sCCsn9s/dG3ZrQTX/Us0/Sx2R0G5kwa0wbZFYoVp/+0=
-k8s.io/component-base v0.33.2/go.mod h1:/41uw9wKzuelhN+u+/C59ixxf4tYQKW7p32ddkYNe2k=
 k8s.io/gengo v0.0.0-20200413195148-3a45101e95ac/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
 k8s.io/gengo v0.0.0-20201214224949-b6c5ce23f027/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
 k8s.io/gengo v0.0.0-20211129171323-c02415ce4185/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
@@ -2645,13 +2625,13 @@ rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8
 rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
 rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.22/go.mod h1:LEScyzhFmoF5pso/YSeBstl57mOzx9xlU9n85RGrDQg=
+sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.1 h1:uOuSLOMBWkJH0TWa9X6l+mj5nZdm6Ay6Bli8HL8rNfk=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.1/go.mod h1:Ve9uj1L+deCXFrPOk1LpFXqTg7LCFzFso6PA48q/XZw=
-sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2 h1:jpcvIRr3GLoUoEKRkHKSmGjxb6lWwrBlJsXc+eUYQHM=
-sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2/go.mod h1:Ve9uj1L+deCXFrPOk1LpFXqTg7LCFzFso6PA48q/XZw=
 sigs.k8s.io/controller-runtime v0.20.4 h1:X3c+Odnxz+iPTRobG4tp092+CvBU9UK0t/bRf+n0DGU=
 sigs.k8s.io/controller-runtime v0.20.4/go.mod h1:xg2XB0K5ShQzAgsoujxuKN4LNXR2LfwwHsPj7Iaw+XY=
 sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235 h1:GRdpo0LC7QBPh9HefY30G1xmap2Q5U/KCBqeIZymDMo=
 sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235/go.mod h1:TF/lVLWS+JNNaVqJuDDictY2hZSXSsIHCx4FClMvqFg=
+sigs.k8s.io/controller-tools v0.17.3 h1:lwFPLicpBKLgIepah+c8ikRBubFW5kOQyT88r3EwfNw=
 sigs.k8s.io/controller-tools v0.17.3/go.mod h1:1ii+oXcYZkxcBXzwv3YZBlzjt1fvkrCGjVF73blosJI=
 sigs.k8s.io/gateway-api v1.3.0 h1:q6okN+/UKDATola4JY7zXzx40WO4VISk7i9DIfOvr9M=
 sigs.k8s.io/gateway-api v1.3.0/go.mod h1:d8NV8nJbaRbEKem+5IuxkL8gJGOZ+FJ+NvOIltV8gDk=
diff --git a/hack/utils/oss_compliance/osa_provided.md b/hack/utils/oss_compliance/osa_provided.md
index 4f0e4baee..1bca7873a 100644
--- a/hack/utils/oss_compliance/osa_provided.md
+++ b/hack/utils/oss_compliance/osa_provided.md
@@ -19,9 +19,9 @@ Name|Version|License
 [kelseyhightower/envconfig](https://github.com/kelseyhightower/envconfig)|v1.4.0|MIT License
 [mitchellh/hashstructure](https://github.com/mitchellh/hashstructure)|v1.0.0|MIT License
 [ginkgo/v2](https://github.com/onsi/ginkgo)|v2.23.3|MIT License
-[onsi/gomega](https://github.com/onsi/gomega)|v1.37.0|MIT License
+[onsi/gomega](https://github.com/onsi/gomega)|v1.36.3|MIT License
 [pkg/errors](https://github.com/pkg/errors)|v0.9.1|BSD 2-clause "Simplified" License
-[prometheus/client_golang](https://github.com/prometheus/client_golang)|v1.22.0|Apache License 2.0
+[prometheus/client_golang](https://github.com/prometheus/client_golang)|v1.21.1|Apache License 2.0
 [prometheus/client_model](https://github.com/prometheus/client_model)|v0.6.2|Apache License 2.0
 [spf13/afero](https://github.com/spf13/afero)|v1.14.0|Apache License 2.0
 [spf13/cobra](https://github.com/spf13/cobra)|v1.9.1|Apache License 2.0
@@ -29,17 +29,17 @@ Name|Version|License
 [go.opencensus.io](https://go.opencensus.io)|v0.24.0|Apache License 2.0
 [go.uber.org/zap](https://go.uber.org/zap)|v1.27.0|MIT License
 [x/exp](https://golang.org/x/exp)|v0.0.0-20241215155358-4a5509556b9e|BSD 3-clause "New" or "Revised" License
-[x/net](https://golang.org/x/net)|v0.41.0|BSD 3-clause "New" or "Revised" License
+[x/net](https://golang.org/x/net)|v0.40.0|BSD 3-clause "New" or "Revised" License
 [google.golang.org/grpc](https://google.golang.org/grpc)|v1.72.0|Apache License 2.0
 [google.golang.org/protobuf](https://google.golang.org/protobuf)|v1.36.6|BSD 3-clause "New" or "Revised" License
 [helm/v3](https://helm.sh/helm/v3)|v3.17.3|Apache License 2.0
 [istio.io/api](https://istio.io/api)|v1.25.0-alpha.0.0.20250210220544-0b64afd2de85|Apache License 2.0
 [istio.io/client-go](https://istio.io/client-go)|v1.25.0-alpha.0.0.20250210220843-5a4065fded65|Apache License 2.0
 [istio.io/istio](https://istio.io/istio)|v0.0.0-20250212203644-c2ac935c5888|Apache License 2.0
-[k8s.io/api](https://k8s.io/api)|v0.33.2|Apache License 2.0
-[k8s.io/apiextensions-apiserver](https://k8s.io/apiextensions-apiserver)|v0.33.2|Apache License 2.0
-[k8s.io/apimachinery](https://k8s.io/apimachinery)|v0.33.2|Apache License 2.0
-[k8s.io/client-go](https://k8s.io/client-go)|v0.33.2|Apache License 2.0
+[k8s.io/api](https://k8s.io/api)|v0.32.3|Apache License 2.0
+[k8s.io/apiextensions-apiserver](https://k8s.io/apiextensions-apiserver)|v0.32.3|Apache License 2.0
+[k8s.io/apimachinery](https://k8s.io/apimachinery)|v0.32.3|Apache License 2.0
+[k8s.io/client-go](https://k8s.io/client-go)|v0.32.3|Apache License 2.0
 [klog/v2](https://k8s.io/klog/v2)|v2.130.1|Apache License 2.0
 [k8s.io/kube-openapi](https://k8s.io/kube-openapi)|v0.0.0-20250318190949-c8a335a9a2ff|Apache License 2.0
 [k8s.io/utils](https://k8s.io/utils)|v0.0.0-20241210054802-24370beab758|Apache License 2.0
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
index f27b83901..612af49f5 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
+    controller-gen.kubebuilder.io/version: v0.17.3
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -227,11 +227,6 @@ spec:
                     default: false
                     type: boolean
                 type: object
-                x-kubernetes-validations:
-                - message: at most one of the fields in [leastRequest roundRobin ringHash
-                    maglev random] may be set
-                  rule: '[has(self.leastRequest),has(self.roundRobin),has(self.ringHash),has(self.maglev),has(self.random)].filter(x,x==true).size()
-                    <= 1'
               perConnectionBufferLimitBytes:
                 type: integer
               targetRefs:
@@ -363,17 +358,7 @@ spec:
                       type: string
                     type: array
                 type: object
-                x-kubernetes-validations:
-                - message: exactly one of the fields in [secretRef tlsFiles] must
-                    be set
-                  rule: '[has(self.secretRef),has(self.tlsFiles)].filter(x,x==true).size()
-                    == 1'
             type: object
-            x-kubernetes-validations:
-            - message: at most one of the fields in [http1ProtocolOptions http2ProtocolOptions]
-                may be set
-              rule: '[has(self.http1ProtocolOptions),has(self.http2ProtocolOptions)].filter(x,x==true).size()
-                <= 1'
           status:
             properties:
               ancestors:
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml
index 71fe49a08..fa9f8e5c9 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
+    controller-gen.kubebuilder.io/version: v0.17.3
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -105,11 +105,6 @@ spec:
                                 required:
                                 - kind
                                 type: object
-                                x-kubernetes-validations:
-                                - message: at most one of the fields in [inline secretRef]
-                                    may be set
-                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                    <= 1'
                               model:
                                 type: string
                             required:
@@ -140,11 +135,6 @@ spec:
                                 required:
                                 - kind
                                 type: object
-                                x-kubernetes-validations:
-                                - message: at most one of the fields in [inline secretRef]
-                                    may be set
-                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                    <= 1'
                               deploymentName:
                                 minLength: 1
                                 type: string
@@ -181,11 +171,6 @@ spec:
                                 required:
                                 - kind
                                 type: object
-                                x-kubernetes-validations:
-                                - message: at most one of the fields in [inline secretRef]
-                                    may be set
-                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                    <= 1'
                               model:
                                 type: string
                             required:
@@ -215,11 +200,6 @@ spec:
                                 required:
                                 - kind
                                 type: object
-                                x-kubernetes-validations:
-                                - message: at most one of the fields in [inline secretRef]
-                                    may be set
-                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                    <= 1'
                               model:
                                 type: string
                             required:
@@ -250,11 +230,6 @@ spec:
                                 required:
                                 - kind
                                 type: object
-                                x-kubernetes-validations:
-                                - message: at most one of the fields in [inline secretRef]
-                                    may be set
-                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                    <= 1'
                               location:
                                 minLength: 1
                                 type: string
@@ -349,11 +324,6 @@ spec:
                                             required:
                                             - kind
                                             type: object
-                                            x-kubernetes-validations:
-                                            - message: at most one of the fields in
-                                                [inline secretRef] may be set
-                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                                <= 1'
                                           model:
                                             type: string
                                         required:
@@ -384,11 +354,6 @@ spec:
                                             required:
                                             - kind
                                             type: object
-                                            x-kubernetes-validations:
-                                            - message: at most one of the fields in
-                                                [inline secretRef] may be set
-                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                                <= 1'
                                           deploymentName:
                                             minLength: 1
                                             type: string
@@ -425,11 +390,6 @@ spec:
                                             required:
                                             - kind
                                             type: object
-                                            x-kubernetes-validations:
-                                            - message: at most one of the fields in
-                                                [inline secretRef] may be set
-                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                                <= 1'
                                           model:
                                             type: string
                                         required:
@@ -459,11 +419,6 @@ spec:
                                             required:
                                             - kind
                                             type: object
-                                            x-kubernetes-validations:
-                                            - message: at most one of the fields in
-                                                [inline secretRef] may be set
-                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                                <= 1'
                                           model:
                                             type: string
                                         required:
@@ -494,11 +449,6 @@ spec:
                                             required:
                                             - kind
                                             type: object
-                                            x-kubernetes-validations:
-                                            - message: at most one of the fields in
-                                                [inline secretRef] may be set
-                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                                <= 1'
                                           location:
                                             minLength: 1
                                             type: string
@@ -664,10 +614,6 @@ spec:
                 'DynamicForwardProxy'
               rule: 'self.type == ''DynamicForwardProxy'' ? has(self.dynamicForwardProxy)
                 : true'
-            - message: exactly one of the fields in [ai aws static dynamicForwardProxy]
-                must be set
-              rule: '[has(self.ai),has(self.aws),has(self.static),has(self.dynamicForwardProxy)].filter(x,x==true).size()
-                == 1'
           status:
             properties:
               conditions:
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml
index c676b5717..17e2d9259 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
+    controller-gen.kubebuilder.io/version: v0.17.3
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml
index fdb4c3756..ffe9f3385 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
+    controller-gen.kubebuilder.io/version: v0.17.3
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
index 60cd8ef36..a60a79fec 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
+    controller-gen.kubebuilder.io/version: v0.17.3
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -897,8 +897,6 @@ spec:
                                       - port
                                       type: object
                                   type: object
-                                stopSignal:
-                                  type: string
                               type: object
                             livenessProbe:
                               properties:
@@ -2388,10 +2386,6 @@ spec:
                 type: object
                 x-kubernetes-preserve-unknown-fields: true
             type: object
-            x-kubernetes-validations:
-            - message: exactly one of the fields in [kube selfManaged] must be set
-              rule: '[has(self.kube),has(self.selfManaged)].filter(x,x==true).size()
-                == 1'
           status:
             type: object
         type: object
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
index 3f229f3da..78c24ef48 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
+    controller-gen.kubebuilder.io/version: v0.17.3
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -47,11 +47,6 @@ spec:
                       required:
                       - path
                       type: object
-                      x-kubernetes-validations:
-                      - message: exactly one of the fields in [stringFormat jsonFormat]
-                          must be set
-                        rule: '[has(self.stringFormat),has(self.jsonFormat)].filter(x,x==true).size()
-                          == 1'
                     filter:
                       allOf:
                       - maxProperties: 1
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
index 51e1ce2f0..68146e648 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
+    controller-gen.kubebuilder.io/version: v0.17.3
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -119,11 +119,6 @@ spec:
                                     required:
                                     - kind
                                     type: object
-                                    x-kubernetes-validations:
-                                    - message: at most one of the fields in [inline
-                                        secretRef] may be set
-                                      rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
-                                        <= 1'
                                   model:
                                     type: string
                                 required:
@@ -359,11 +354,6 @@ spec:
                       required:
                       - ignoreCase
                       type: object
-                      x-kubernetes-validations:
-                      - message: exactly one of the fields in [exact prefix suffix
-                          contains safeRegex] must be set
-                        rule: '[has(self.exact),has(self.prefix),has(self.suffix),has(self.contains),has(self.safeRegex)].filter(x,x==true).size()
-                          == 1'
                     maxItems: 16
                     type: array
                   percentageEnabled:
@@ -377,11 +367,6 @@ spec:
                     minimum: 0
                     type: integer
                 type: object
-                x-kubernetes-validations:
-                - message: at most one of the fields in [percentageEnabled percentageShadowed]
-                    may be set
-                  rule: '[has(self.percentageEnabled),has(self.percentageShadowed)].filter(x,x==true).size()
-                    <= 1'
               extAuth:
                 properties:
                   contextExtensions:
@@ -413,11 +398,6 @@ spec:
                     - maxRequestBytes
                     type: object
                 type: object
-                x-kubernetes-validations:
-                - message: exactly one of the fields in [extensionRef enablement]
-                    must be set
-                  rule: '[has(self.extensionRef),has(self.enablement)].filter(x,x==true).size()
-                    == 1'
               extProc:
                 properties:
                   extensionRef:
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
index f7eb7410b..054f2e5d9 100644
--- a/internal/kgateway/agentgatewaysyncer/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -9,13 +9,14 @@ import (
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/protomarshal"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 )
 
 // TODO: support other route collections (TCP, TLS, etc.)
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
index 2c87c5d26..ed8787ae5 100644
--- a/internal/kgateway/agentgatewaysyncer/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -11,7 +11,6 @@ import (
 	"github.com/agentgateway/agentgateway/go/api"
 	"github.com/google/go-cmp/cmp"
 	"github.com/google/go-cmp/cmp/cmpopts"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/anypb"
 	apiannotation "istio.io/api/annotation"
@@ -37,6 +36,8 @@ import (
 	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/types"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 )
 
 func (a *index) ServicesCollection(
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 96dccf64c..35bc715c0 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -9,7 +9,6 @@ import (
 	"github.com/agentgateway/agentgateway/go/api"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
@@ -29,6 +28,8 @@ import (
 	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
index 722a0e4e4..6fe10a817 100644
--- a/internal/kgateway/agentgatewaysyncer/workloads.go
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -6,7 +6,6 @@ import (
 	"strings"
 
 	"github.com/agentgateway/agentgateway/go/api"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 	"istio.io/api/annotation"
 	"istio.io/api/label"
@@ -36,6 +35,8 @@ import (
 	discovery "k8s.io/api/discovery/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 )
 
 // internal object used for indexing in ambientindex maps
diff --git a/pkg/client/clientset/versioned/fake/clientset_generated.go b/pkg/client/clientset/versioned/fake/clientset_generated.go
index 51e63cb63..287b7d538 100644
--- a/pkg/client/clientset/versioned/fake/clientset_generated.go
+++ b/pkg/client/clientset/versioned/fake/clientset_generated.go
@@ -3,7 +3,6 @@
 package fake
 
 import (
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/discovery"
@@ -36,13 +35,9 @@ func NewSimpleClientset(objects ...runtime.Object) *Clientset {
 	cs.discovery = &fakediscovery.FakeDiscovery{Fake: &cs.Fake}
 	cs.AddReactor("*", "*", testing.ObjectReaction(o))
 	cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) {
-		var opts metav1.ListOptions
-		if watchActcion, ok := action.(testing.WatchActionImpl); ok {
-			opts = watchActcion.ListOptions
-		}
 		gvr := action.GetResource()
 		ns := action.GetNamespace()
-		watch, err := o.Watch(gvr, ns, opts)
+		watch, err := o.Watch(gvr, ns)
 		if err != nil {
 			return false, nil, err
 		}
@@ -89,13 +84,9 @@ func NewClientset(objects ...runtime.Object) *Clientset {
 	cs.discovery = &fakediscovery.FakeDiscovery{Fake: &cs.Fake}
 	cs.AddReactor("*", "*", testing.ObjectReaction(o))
 	cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) {
-		var opts metav1.ListOptions
-		if watchActcion, ok := action.(testing.WatchActionImpl); ok {
-			opts = watchActcion.ListOptions
-		}
 		gvr := action.GetResource()
 		ns := action.GetNamespace()
-		watch, err := o.Watch(gvr, ns, opts)
+		watch, err := o.Watch(gvr, ns)
 		if err != nil {
 			return false, nil, err
 		}
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
index 5145d2df3..3e94e5065 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
@@ -60,7 +60,9 @@ func (c *GatewayV1alpha1Client) TrafficPolicies(namespace string) TrafficPolicyI
 // where httpClient was generated with rest.HTTPClientFor(c).
 func NewForConfig(c *rest.Config) (*GatewayV1alpha1Client, error) {
 	config := *c
-	setConfigDefaults(&config)
+	if err := setConfigDefaults(&config); err != nil {
+		return nil, err
+	}
 	httpClient, err := rest.HTTPClientFor(&config)
 	if err != nil {
 		return nil, err
@@ -72,7 +74,9 @@ func NewForConfig(c *rest.Config) (*GatewayV1alpha1Client, error) {
 // Note the http client provided takes precedence over the configured transport values.
 func NewForConfigAndClient(c *rest.Config, h *http.Client) (*GatewayV1alpha1Client, error) {
 	config := *c
-	setConfigDefaults(&config)
+	if err := setConfigDefaults(&config); err != nil {
+		return nil, err
+	}
 	client, err := rest.RESTClientForConfigAndClient(&config, h)
 	if err != nil {
 		return nil, err
@@ -95,7 +99,7 @@ func New(c rest.Interface) *GatewayV1alpha1Client {
 	return &GatewayV1alpha1Client{c}
 }
 
-func setConfigDefaults(config *rest.Config) {
+func setConfigDefaults(config *rest.Config) error {
 	gv := apiv1alpha1.SchemeGroupVersion
 	config.GroupVersion = &gv
 	config.APIPath = "/apis"
@@ -104,6 +108,8 @@ func setConfigDefaults(config *rest.Config) {
 	if config.UserAgent == "" {
 		config.UserAgent = rest.DefaultKubernetesUserAgent()
 	}
+
+	return nil
 }
 
 // RESTClient returns a RESTClient that is used to communicate
diff --git a/pkg/generated/openapi/zz_generated.openapi.go b/pkg/generated/openapi/zz_generated.openapi.go
index a59386eaa..2099598d2 100644
--- a/pkg/generated/openapi/zz_generated.openapi.go
+++ b/pkg/generated/openapi/zz_generated.openapi.go
@@ -262,7 +262,6 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"k8s.io/api/core/v1.NodeSelectorTerm":                                                        schema_k8sio_api_core_v1_NodeSelectorTerm(ref),
 		"k8s.io/api/core/v1.NodeSpec":                                                                schema_k8sio_api_core_v1_NodeSpec(ref),
 		"k8s.io/api/core/v1.NodeStatus":                                                              schema_k8sio_api_core_v1_NodeStatus(ref),
-		"k8s.io/api/core/v1.NodeSwapStatus":                                                          schema_k8sio_api_core_v1_NodeSwapStatus(ref),
 		"k8s.io/api/core/v1.NodeSystemInfo":                                                          schema_k8sio_api_core_v1_NodeSystemInfo(ref),
 		"k8s.io/api/core/v1.ObjectFieldSelector":                                                     schema_k8sio_api_core_v1_ObjectFieldSelector(ref),
 		"k8s.io/api/core/v1.ObjectReference":                                                         schema_k8sio_api_core_v1_ObjectReference(ref),
@@ -8136,14 +8135,6 @@ func schema_k8sio_api_core_v1_ContainerStatus(ref common.ReferenceCallback) comm
 							},
 						},
 					},
-					"stopSignal": {
-						SchemaProps: spec.SchemaProps{
-							Description: "StopSignal reports the effective stop signal for this container\n\nPossible enum values:\n - `\"SIGABRT\"`\n - `\"SIGALRM\"`\n - `\"SIGBUS\"`\n - `\"SIGCHLD\"`\n - `\"SIGCLD\"`\n - `\"SIGCONT\"`\n - `\"SIGFPE\"`\n - `\"SIGHUP\"`\n - `\"SIGILL\"`\n - `\"SIGINT\"`\n - `\"SIGIO\"`\n - `\"SIGIOT\"`\n - `\"SIGKILL\"`\n - `\"SIGPIPE\"`\n - `\"SIGPOLL\"`\n - `\"SIGPROF\"`\n - `\"SIGPWR\"`\n - `\"SIGQUIT\"`\n - `\"SIGRTMAX\"`\n - `\"SIGRTMAX-1\"`\n - `\"SIGRTMAX-10\"`\n - `\"SIGRTMAX-11\"`\n - `\"SIGRTMAX-12\"`\n - `\"SIGRTMAX-13\"`\n - `\"SIGRTMAX-14\"`\n - `\"SIGRTMAX-2\"`\n - `\"SIGRTMAX-3\"`\n - `\"SIGRTMAX-4\"`\n - `\"SIGRTMAX-5\"`\n - `\"SIGRTMAX-6\"`\n - `\"SIGRTMAX-7\"`\n - `\"SIGRTMAX-8\"`\n - `\"SIGRTMAX-9\"`\n - `\"SIGRTMIN\"`\n - `\"SIGRTMIN+1\"`\n - `\"SIGRTMIN+10\"`\n - `\"SIGRTMIN+11\"`\n - `\"SIGRTMIN+12\"`\n - `\"SIGRTMIN+13\"`\n - `\"SIGRTMIN+14\"`\n - `\"SIGRTMIN+15\"`\n - `\"SIGRTMIN+2\"`\n - `\"SIGRTMIN+3\"`\n - `\"SIGRTMIN+4\"`\n - `\"SIGRTMIN+5\"`\n - `\"SIGRTMIN+6\"`\n - `\"SIGRTMIN+7\"`\n - `\"SIGRTMIN+8\"`\n - `\"SIGRTMIN+9\"`\n - `\"SIGSEGV\"`\n - `\"SIGSTKFLT\"`\n - `\"SIGSTOP\"`\n - `\"SIGSYS\"`\n - `\"SIGTERM\"`\n - `\"SIGTRAP\"`\n - `\"SIGTSTP\"`\n - `\"SIGTTIN\"`\n - `\"SIGTTOU\"`\n - `\"SIGURG\"`\n - `\"SIGUSR1\"`\n - `\"SIGUSR2\"`\n - `\"SIGVTALRM\"`\n - `\"SIGWINCH\"`\n - `\"SIGXCPU\"`\n - `\"SIGXFSZ\"`",
-							Type:        []string{"string"},
-							Format:      "",
-							Enum:        []interface{}{"SIGABRT", "SIGALRM", "SIGBUS", "SIGCHLD", "SIGCLD", "SIGCONT", "SIGFPE", "SIGHUP", "SIGILL", "SIGINT", "SIGIO", "SIGIOT", "SIGKILL", "SIGPIPE", "SIGPOLL", "SIGPROF", "SIGPWR", "SIGQUIT", "SIGRTMAX", "SIGRTMAX-1", "SIGRTMAX-10", "SIGRTMAX-11", "SIGRTMAX-12", "SIGRTMAX-13", "SIGRTMAX-14", "SIGRTMAX-2", "SIGRTMAX-3", "SIGRTMAX-4", "SIGRTMAX-5", "SIGRTMAX-6", "SIGRTMAX-7", "SIGRTMAX-8", "SIGRTMAX-9", "SIGRTMIN", "SIGRTMIN+1", "SIGRTMIN+10", "SIGRTMIN+11", "SIGRTMIN+12", "SIGRTMIN+13", "SIGRTMIN+14", "SIGRTMIN+15", "SIGRTMIN+2", "SIGRTMIN+3", "SIGRTMIN+4", "SIGRTMIN+5", "SIGRTMIN+6", "SIGRTMIN+7", "SIGRTMIN+8", "SIGRTMIN+9", "SIGSEGV", "SIGSTKFLT", "SIGSTOP", "SIGSYS", "SIGTERM", "SIGTRAP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGURG", "SIGUSR1", "SIGUSR2", "SIGVTALRM", "SIGWINCH", "SIGXCPU", "SIGXFSZ"},
-						},
-					},
 				},
 				Required: []string{"name", "ready", "restartCount", "image", "imageID"},
 			},
@@ -8346,7 +8337,7 @@ func schema_k8sio_api_core_v1_EndpointAddress(ref common.ReferenceCallback) comm
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointAddress is a tuple that describes single IP address. Deprecated: This API is deprecated in v1.33+.",
+				Description: "EndpointAddress is a tuple that describes single IP address.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"ip": {
@@ -8395,7 +8386,7 @@ func schema_k8sio_api_core_v1_EndpointPort(ref common.ReferenceCallback) common.
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointPort is a tuple that describes a single port. Deprecated: This API is deprecated in v1.33+.",
+				Description: "EndpointPort is a tuple that describes a single port.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"name": {
@@ -8444,7 +8435,7 @@ func schema_k8sio_api_core_v1_EndpointSubset(ref common.ReferenceCallback) commo
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:\n\n\t{\n\t  Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t  Ports:     [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t}\n\nThe resulting set of endpoints can be viewed as:\n\n\ta: [ 10.10.1.1:8675, 10.10.2.2:8675 ],\n\tb: [ 10.10.1.1:309, 10.10.2.2:309 ]\n\nDeprecated: This API is deprecated in v1.33+.",
+				Description: "EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:\n\n\t{\n\t  Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t  Ports:     [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t}\n\nThe resulting set of endpoints can be viewed as:\n\n\ta: [ 10.10.1.1:8675, 10.10.2.2:8675 ],\n\tb: [ 10.10.1.1:309, 10.10.2.2:309 ]",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"addresses": {
@@ -8516,7 +8507,7 @@ func schema_k8sio_api_core_v1_Endpoints(ref common.ReferenceCallback) common.Ope
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]\n\nEndpoints is a legacy API and does not contain information about all Service features. Use discoveryv1.EndpointSlice for complete information about Service endpoints.\n\nDeprecated: This API is deprecated in v1.33+. Use discoveryv1.EndpointSlice.",
+				Description: "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"kind": {
@@ -8571,7 +8562,7 @@ func schema_k8sio_api_core_v1_EndpointsList(ref common.ReferenceCallback) common
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointsList is a list of endpoints. Deprecated: This API is deprecated in v1.33+.",
+				Description: "EndpointsList is a list of endpoints.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"kind": {
@@ -8622,12 +8613,12 @@ func schema_k8sio_api_core_v1_EnvFromSource(ref common.ReferenceCallback) common
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EnvFromSource represents the source of a set of ConfigMaps or Secrets",
+				Description: "EnvFromSource represents the source of a set of ConfigMaps",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"prefix": {
 						SchemaProps: spec.SchemaProps{
-							Description: "Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.",
+							Description: "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
 							Type:        []string{"string"},
 							Format:      "",
 						},
@@ -10529,14 +10520,6 @@ func schema_k8sio_api_core_v1_Lifecycle(ref common.ReferenceCallback) common.Ope
 							Ref:         ref("k8s.io/api/core/v1.LifecycleHandler"),
 						},
 					},
-					"stopSignal": {
-						SchemaProps: spec.SchemaProps{
-							Description: "StopSignal defines which signal will be sent to a container when it is being stopped. If not specified, the default is defined by the container runtime in use. StopSignal can only be set for Pods with a non-empty .spec.os.name\n\nPossible enum values:\n - `\"SIGABRT\"`\n - `\"SIGALRM\"`\n - `\"SIGBUS\"`\n - `\"SIGCHLD\"`\n - `\"SIGCLD\"`\n - `\"SIGCONT\"`\n - `\"SIGFPE\"`\n - `\"SIGHUP\"`\n - `\"SIGILL\"`\n - `\"SIGINT\"`\n - `\"SIGIO\"`\n - `\"SIGIOT\"`\n - `\"SIGKILL\"`\n - `\"SIGPIPE\"`\n - `\"SIGPOLL\"`\n - `\"SIGPROF\"`\n - `\"SIGPWR\"`\n - `\"SIGQUIT\"`\n - `\"SIGRTMAX\"`\n - `\"SIGRTMAX-1\"`\n - `\"SIGRTMAX-10\"`\n - `\"SIGRTMAX-11\"`\n - `\"SIGRTMAX-12\"`\n - `\"SIGRTMAX-13\"`\n - `\"SIGRTMAX-14\"`\n - `\"SIGRTMAX-2\"`\n - `\"SIGRTMAX-3\"`\n - `\"SIGRTMAX-4\"`\n - `\"SIGRTMAX-5\"`\n - `\"SIGRTMAX-6\"`\n - `\"SIGRTMAX-7\"`\n - `\"SIGRTMAX-8\"`\n - `\"SIGRTMAX-9\"`\n - `\"SIGRTMIN\"`\n - `\"SIGRTMIN+1\"`\n - `\"SIGRTMIN+10\"`\n - `\"SIGRTMIN+11\"`\n - `\"SIGRTMIN+12\"`\n - `\"SIGRTMIN+13\"`\n - `\"SIGRTMIN+14\"`\n - `\"SIGRTMIN+15\"`\n - `\"SIGRTMIN+2\"`\n - `\"SIGRTMIN+3\"`\n - `\"SIGRTMIN+4\"`\n - `\"SIGRTMIN+5\"`\n - `\"SIGRTMIN+6\"`\n - `\"SIGRTMIN+7\"`\n - `\"SIGRTMIN+8\"`\n - `\"SIGRTMIN+9\"`\n - `\"SIGSEGV\"`\n - `\"SIGSTKFLT\"`\n - `\"SIGSTOP\"`\n - `\"SIGSYS\"`\n - `\"SIGTERM\"`\n - `\"SIGTRAP\"`\n - `\"SIGTSTP\"`\n - `\"SIGTTIN\"`\n - `\"SIGTTOU\"`\n - `\"SIGURG\"`\n - `\"SIGUSR1\"`\n - `\"SIGUSR2\"`\n - `\"SIGVTALRM\"`\n - `\"SIGWINCH\"`\n - `\"SIGXCPU\"`\n - `\"SIGXFSZ\"`",
-							Type:        []string{"string"},
-							Format:      "",
-							Enum:        []interface{}{"SIGABRT", "SIGALRM", "SIGBUS", "SIGCHLD", "SIGCLD", "SIGCONT", "SIGFPE", "SIGHUP", "SIGILL", "SIGINT", "SIGIO", "SIGIOT", "SIGKILL", "SIGPIPE", "SIGPOLL", "SIGPROF", "SIGPWR", "SIGQUIT", "SIGRTMAX", "SIGRTMAX-1", "SIGRTMAX-10", "SIGRTMAX-11", "SIGRTMAX-12", "SIGRTMAX-13", "SIGRTMAX-14", "SIGRTMAX-2", "SIGRTMAX-3", "SIGRTMAX-4", "SIGRTMAX-5", "SIGRTMAX-6", "SIGRTMAX-7", "SIGRTMAX-8", "SIGRTMAX-9", "SIGRTMIN", "SIGRTMIN+1", "SIGRTMIN+10", "SIGRTMIN+11", "SIGRTMIN+12", "SIGRTMIN+13", "SIGRTMIN+14", "SIGRTMIN+15", "SIGRTMIN+2", "SIGRTMIN+3", "SIGRTMIN+4", "SIGRTMIN+5", "SIGRTMIN+6", "SIGRTMIN+7", "SIGRTMIN+8", "SIGRTMIN+9", "SIGSEGV", "SIGSTKFLT", "SIGSTOP", "SIGSYS", "SIGTERM", "SIGTRAP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGURG", "SIGUSR1", "SIGUSR2", "SIGVTALRM", "SIGWINCH", "SIGXCPU", "SIGXFSZ"},
-						},
-					},
 				},
 			},
 		},
@@ -12213,26 +12196,6 @@ func schema_k8sio_api_core_v1_NodeStatus(ref common.ReferenceCallback) common.Op
 	}
 }
 
-func schema_k8sio_api_core_v1_NodeSwapStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
-	return common.OpenAPIDefinition{
-		Schema: spec.Schema{
-			SchemaProps: spec.SchemaProps{
-				Description: "NodeSwapStatus represents swap memory information.",
-				Type:        []string{"object"},
-				Properties: map[string]spec.Schema{
-					"capacity": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Total amount of swap memory in bytes.",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
-				},
-			},
-		},
-	}
-}
-
 func schema_k8sio_api_core_v1_NodeSystemInfo(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -12320,18 +12283,10 @@ func schema_k8sio_api_core_v1_NodeSystemInfo(ref common.ReferenceCallback) commo
 							Format:      "",
 						},
 					},
-					"swap": {
-						SchemaProps: spec.SchemaProps{
-							Description: "Swap Info reported by the node.",
-							Ref:         ref("k8s.io/api/core/v1.NodeSwapStatus"),
-						},
-					},
 				},
 				Required: []string{"machineID", "systemUUID", "bootID", "kernelVersion", "osImage", "containerRuntimeVersion", "kubeletVersion", "kubeProxyVersion", "operatingSystem", "architecture"},
 			},
 		},
-		Dependencies: []string{
-			"k8s.io/api/core/v1.NodeSwapStatus"},
 	}
 }
 
@@ -13601,7 +13556,7 @@ func schema_k8sio_api_core_v1_PodAffinityTerm(ref common.ReferenceCallback) comm
 							},
 						},
 						SchemaProps: spec.SchemaProps{
-							Description: "MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set.",
+							Description: "MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
 							Type:        []string{"array"},
 							Items: &spec.SchemaOrArray{
 								Schema: &spec.Schema{
@@ -13621,7 +13576,7 @@ func schema_k8sio_api_core_v1_PodAffinityTerm(ref common.ReferenceCallback) comm
 							},
 						},
 						SchemaProps: spec.SchemaProps{
-							Description: "MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set.",
+							Description: "MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
 							Type:        []string{"array"},
 							Items: &spec.SchemaOrArray{
 								Schema: &spec.Schema{
@@ -13773,13 +13728,6 @@ func schema_k8sio_api_core_v1_PodCondition(ref common.ReferenceCallback) common.
 							Format:      "",
 						},
 					},
-					"observedGeneration": {
-						SchemaProps: spec.SchemaProps{
-							Description: "If set, this represents the .metadata.generation that the pod condition was set based upon. This is an alpha field. Enable PodObservedGenerationTracking to be able to use this field.",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
 					"status": {
 						SchemaProps: spec.SchemaProps{
 							Description: "Status is the status of the condition. Can be True, False, Unknown. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions",
@@ -14583,7 +14531,7 @@ func schema_k8sio_api_core_v1_PodSpec(ref common.ReferenceCallback) common.OpenA
 							},
 						},
 						SchemaProps: spec.SchemaProps{
-							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
+							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
 							Type:        []string{"array"},
 							Items: &spec.SchemaOrArray{
 								Schema: &spec.Schema{
@@ -15040,13 +14988,6 @@ func schema_k8sio_api_core_v1_PodStatus(ref common.ReferenceCallback) common.Ope
 				Description: "PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
-					"observedGeneration": {
-						SchemaProps: spec.SchemaProps{
-							Description: "If set, this represents the .metadata.generation that the pod status was set based upon. This is an alpha field. Enable PodObservedGenerationTracking to be able to use this field.",
-							Type:        []string{"integer"},
-							Format:      "int64",
-						},
-					},
 					"phase": {
 						SchemaProps: spec.SchemaProps{
 							Description: "The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The conditions array, the reason and message fields, and the individual container status arrays contain more detail about the pod's status. There are five possible phase values:\n\nPending: The pod has been accepted by the Kubernetes system, but one or more of the container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while. Running: The pod has been bound to a node, and all of the containers have been created. At least one container is still running, or is in the process of starting or restarting. Succeeded: All containers in the pod have terminated in success, and will not be restarted. Failed: All containers in the pod have terminated, and at least one container has terminated in failure. The container either exited with non-zero status or was terminated by the system. Unknown: For some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod.\n\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase\n\nPossible enum values:\n - `\"Failed\"` means that all containers in the pod have terminated, and at least one container has terminated in a failure (exited with a non-zero exit code or was stopped by the system).\n - `\"Pending\"` means the pod has been accepted by the system, but one or more of the containers has not been started. This includes time before being bound to a node, as well as time spent pulling images onto the host.\n - `\"Running\"` means the pod has been bound to a node and all of the containers have been started. At least one container is still running or is in the process of being restarted.\n - `\"Succeeded\"` means that all containers in the pod have voluntarily terminated with a container exit code of 0, and the system is not going to restart any of these containers.\n - `\"Unknown\"` means that for some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod. Deprecated: It isn't being set since 2015 (74da3b14b0c0f658b3bb8d2def5094686d0e9095)",
@@ -15232,7 +15173,7 @@ func schema_k8sio_api_core_v1_PodStatus(ref common.ReferenceCallback) common.Ope
 					},
 					"resize": {
 						SchemaProps: spec.SchemaProps{
-							Description: "Status of resources resize desired for pod's containers. It is empty if no resources resize is pending. Any changes to container resources will automatically set this to \"Proposed\" Deprecated: Resize status is moved to two pod conditions PodResizePending and PodResizeInProgress. PodResizePending will track states where the spec has been resized, but the Kubelet has not yet allocated the resources. PodResizeInProgress will track in-progress resizes, and should be present whenever allocated resources != acknowledged resources.",
+							Description: "Status of resources resize desired for pod's containers. It is empty if no resources resize is pending. Any changes to container resources will automatically set this to \"Proposed\"",
 							Type:        []string{"string"},
 							Format:      "",
 						},
@@ -16193,7 +16134,6 @@ func schema_k8sio_api_core_v1_ReplicationControllerSpec(ref common.ReferenceCall
 					"replicas": {
 						SchemaProps: spec.SchemaProps{
 							Description: "Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller",
-							Default:     1,
 							Type:        []string{"integer"},
 							Format:      "int32",
 						},
@@ -16201,7 +16141,6 @@ func schema_k8sio_api_core_v1_ReplicationControllerSpec(ref common.ReferenceCall
 					"minReadySeconds": {
 						SchemaProps: spec.SchemaProps{
 							Description: "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
-							Default:     0,
 							Type:        []string{"integer"},
 							Format:      "int32",
 						},
@@ -16554,7 +16493,7 @@ func schema_k8sio_api_core_v1_ResourceQuotaSpec(ref common.ReferenceCallback) co
 										Default: "",
 										Type:    []string{"string"},
 										Format:  "",
-										Enum:    []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating", "VolumeAttributesClass"},
+										Enum:    []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating"},
 									},
 								},
 							},
@@ -16995,11 +16934,11 @@ func schema_k8sio_api_core_v1_ScopedResourceSelectorRequirement(ref common.Refer
 				Properties: map[string]spec.Schema{
 					"scopeName": {
 						SchemaProps: spec.SchemaProps{
-							Description: "The name of the scope that the selector applies to.\n\nPossible enum values:\n - `\"BestEffort\"` Match all pod objects that have best effort quality of service\n - `\"CrossNamespacePodAffinity\"` Match all pod objects that have cross-namespace pod (anti)affinity mentioned.\n - `\"NotBestEffort\"` Match all pod objects that do not have best effort quality of service\n - `\"NotTerminating\"` Match all pod objects where spec.activeDeadlineSeconds is nil\n - `\"PriorityClass\"` Match all pod objects that have priority class mentioned\n - `\"Terminating\"` Match all pod objects where spec.activeDeadlineSeconds >=0\n - `\"VolumeAttributesClass\"` Match all pvc objects that have volume attributes class mentioned.",
+							Description: "The name of the scope that the selector applies to.\n\nPossible enum values:\n - `\"BestEffort\"` Match all pod objects that have best effort quality of service\n - `\"CrossNamespacePodAffinity\"` Match all pod objects that have cross-namespace pod (anti)affinity mentioned.\n - `\"NotBestEffort\"` Match all pod objects that do not have best effort quality of service\n - `\"NotTerminating\"` Match all pod objects where spec.activeDeadlineSeconds is nil\n - `\"PriorityClass\"` Match all pod objects that have priority class mentioned\n - `\"Terminating\"` Match all pod objects where spec.activeDeadlineSeconds >=0",
 							Default:     "",
 							Type:        []string{"string"},
 							Format:      "",
-							Enum:        []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating", "VolumeAttributesClass"},
+							Enum:        []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating"},
 						},
 					},
 					"operator": {
@@ -18148,7 +18087,7 @@ func schema_k8sio_api_core_v1_ServiceSpec(ref common.ReferenceCallback) common.O
 					},
 					"trafficDistribution": {
 						SchemaProps: spec.SchemaProps{
-							Description: "TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to \"PreferClose\", implementations should prioritize endpoints that are in the same zone.",
+							Description: "TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to \"PreferClose\", implementations should prioritize endpoints that are topologically close (e.g., same zone). This is a beta field and requires enabling ServiceTrafficDistribution feature.",
 							Type:        []string{"string"},
 							Format:      "",
 						},
@@ -18631,7 +18570,7 @@ func schema_k8sio_api_core_v1_TopologySpreadConstraint(ref common.ReferenceCallb
 					},
 					"nodeAffinityPolicy": {
 						SchemaProps: spec.SchemaProps{
-							Description: "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
+							Description: "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
 							Type:        []string{"string"},
 							Format:      "",
 							Enum:        []interface{}{"Honor", "Ignore"},
@@ -18639,7 +18578,7 @@ func schema_k8sio_api_core_v1_TopologySpreadConstraint(ref common.ReferenceCallb
 					},
 					"nodeTaintsPolicy": {
 						SchemaProps: spec.SchemaProps{
-							Description: "NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
+							Description: "NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
 							Type:        []string{"string"},
 							Format:      "",
 							Enum:        []interface{}{"Honor", "Ignore"},
@@ -18951,7 +18890,7 @@ func schema_k8sio_api_core_v1_Volume(ref common.ReferenceCallback) common.OpenAP
 					},
 					"image": {
 						SchemaProps: spec.SchemaProps{
-							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33. The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
+							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath). The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
 							Ref:         ref("k8s.io/api/core/v1.ImageVolumeSource"),
 						},
 					},
@@ -19396,7 +19335,7 @@ func schema_k8sio_api_core_v1_VolumeSource(ref common.ReferenceCallback) common.
 					},
 					"image": {
 						SchemaProps: spec.SchemaProps{
-							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33. The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
+							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath). The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
 							Ref:         ref("k8s.io/api/core/v1.ImageVolumeSource"),
 						},
 					},
@@ -22119,46 +22058,16 @@ func schema_k8sio_apimachinery_pkg_version_Info(ref common.ReferenceCallback) co
 				Properties: map[string]spec.Schema{
 					"major": {
 						SchemaProps: spec.SchemaProps{
-							Description: "Major is the major version of the binary version",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
+							Default: "",
+							Type:    []string{"string"},
+							Format:  "",
 						},
 					},
 					"minor": {
 						SchemaProps: spec.SchemaProps{
-							Description: "Minor is the minor version of the binary version",
-							Default:     "",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"emulationMajor": {
-						SchemaProps: spec.SchemaProps{
-							Description: "EmulationMajor is the major version of the emulation version",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"emulationMinor": {
-						SchemaProps: spec.SchemaProps{
-							Description: "EmulationMinor is the minor version of the emulation version",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"minCompatibilityMajor": {
-						SchemaProps: spec.SchemaProps{
-							Description: "MinCompatibilityMajor is the major version of the minimum compatibility version",
-							Type:        []string{"string"},
-							Format:      "",
-						},
-					},
-					"minCompatibilityMinor": {
-						SchemaProps: spec.SchemaProps{
-							Description: "MinCompatibilityMinor is the minor version of the minimum compatibility version",
-							Type:        []string{"string"},
-							Format:      "",
+							Default: "",
+							Type:    []string{"string"},
+							Format:  "",
 						},
 					},
 					"gitVersion": {
-- 
2.39.5 (Apple Git-154)


From def54ac78a618d1a5e652800b457ee8297d65578 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 30 Jun 2025 17:50:37 -0700
Subject: [PATCH 09/17] wip

---
 install/test/helm_test.go                     |   4 +-
 .../gatewayclass_collection.go                |   2 +-
 .../kgateway/agentgatewaysyncer/service.go    |   8 +-
 .../kgateway/agentgatewaysyncer/syncer.go     | 139 ++++++++++++++----
 .../kgateway/agentgatewaysyncer/workloads.go  |  14 +-
 internal/kgateway/controller/start.go         |   2 +-
 .../inferenceextension/endpointpicker/ir.go   |   4 +-
 .../extensions2/plugins/kubernetes/k8s.go     |   2 +-
 .../plugins/serviceentry/collections.go       |   6 +-
 .../gateway/agent-gateway-deployment.yaml     |  20 ++-
 internal/kgateway/krtcollections/pods.go      |   9 +-
 internal/kgateway/setup/agentgateway_test.go  |   4 +-
 internal/kgateway/setup/setup.go              |   9 +-
 internal/kgateway/setup/setup_test.go         |   4 +-
 pkg/pluginsdk/collections/collections.go      |  17 ++-
 test/envtestutil/util.go                      |   2 +-
 test/helpers/kube_dump.go                     |   2 +-
 .../kubernetes/e2e/features/waypoint/suite.go |   4 +-
 .../testutils/assertions/deployments.go       |   2 +-
 19 files changed, 177 insertions(+), 77 deletions(-)

diff --git a/install/test/helm_test.go b/install/test/helm_test.go
index 0ce18bce5..5618746ce 100644
--- a/install/test/helm_test.go
+++ b/install/test/helm_test.go
@@ -2102,7 +2102,7 @@ spec:
   behavior:
     scaleDown:
       policies:
-      - type: Pods
+      - type: LocalityPods
         value: 4
         periodSeconds: 60
       - type: Percent
@@ -2148,7 +2148,7 @@ spec:
       - type: Percent
         value: 100
         periodSeconds: 15
-      - type: Pods
+      - type: LocalityPods
         value: 4
         periodSeconds: 15
       selectPolicy: Max
diff --git a/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
index 77313b789..7a23ab2eb 100644
--- a/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
@@ -36,7 +36,7 @@ func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayCla
 	if class == nil {
 		return &GatewayClass{
 			Name:       string(gc),
-			Controller: wellknown.GatewayControllerName, // TODO: make this configurable
+			Controller: wellknown.DefaultGatewayControllerName, // TODO: make this configurable
 		}
 	}
 	return class
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
index ed8787ae5..e01444652 100644
--- a/internal/kgateway/agentgatewaysyncer/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -48,10 +48,12 @@ func (a *index) ServicesCollection(
 ) krt.Collection[ServiceInfo] {
 	ServicesInfo := krt.NewCollection(services, a.serviceServiceBuilder(namespaces),
 		krtopts.ToOptions("ServicesInfo")...)
-	ServiceEntriesInfo := krt.NewManyCollection(serviceEntries, a.serviceEntryServiceBuilder(namespaces),
-		krtopts.ToOptions("ServiceEntriesInfo")...)
+	//ServiceEntriesInfo := krt.NewManyCollection(serviceEntries, a.serviceEntryServiceBuilder(namespaces),
+	//	krtopts.ToOptions("ServiceEntriesInfo")...)
 	// TODO: add inference pool to svc collection
-	WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{ServicesInfo, ServiceEntriesInfo}, krtopts.ToOptions("WorkloadService")...)
+	//WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{ServicesInfo, ServiceEntriesInfo}, krtopts.ToOptions("WorkloadService")...)
+
+	WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{ServicesInfo}, krtopts.ToOptions("WorkloadService")...)
 	return WorkloadServices
 }
 
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 35bc715c0..598b0081d 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -5,6 +5,7 @@ import (
 	"fmt"
 	"maps"
 	"strconv"
+	"strings"
 
 	"github.com/agentgateway/agentgateway/go/api"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
@@ -12,7 +13,6 @@ import (
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
-	"istio.io/istio/pkg/config/schema/gvr"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/kclient"
@@ -29,12 +29,14 @@ import (
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
+	"github.com/kgateway-dev/kgateway/v2/pkg/metrics"
 )
 
 var logger = logging.New("agentgateway/syncer")
@@ -50,6 +52,7 @@ type AgentGwSyncer struct {
 	xdsCache                envoycache.SnapshotCache
 	client                  kube.Client
 	domainSuffix            string
+	xdsSnapshotsMetrics     krtcollections.CollectionMetricsRecorder
 
 	waitForSync []cache.InformerSynced
 }
@@ -64,12 +67,13 @@ func NewAgentGwSyncer(
 ) *AgentGwSyncer {
 	// TODO: register types (auth, policy, etc.) if necessary
 	return &AgentGwSyncer{
-		commonCols:     commonCols,
-		controllerName: controllerName,
-		xdsCache:       xdsCache,
-		client:         client,
-		uniqueClients:  uniqueClients,
-		domainSuffix:   domainSuffix,
+		commonCols:          commonCols,
+		controllerName:      controllerName,
+		xdsCache:            xdsCache,
+		client:              client,
+		uniqueClients:       uniqueClients,
+		domainSuffix:        domainSuffix,
+		xdsSnapshotsMetrics: krtcollections.NewCollectionMetricsRecorder("AgentGatewayXDSSnapshots"),
 	}
 }
 
@@ -159,7 +163,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		GRPCRoutes:     krt.WrapClient(kclient.New[*gatewayv1.GRPCRoute](s.client), krtopts.ToOptions("informer/GRPCRoutes")...),
 
 		ReferenceGrants: krt.WrapClient(kclient.New[*gateway.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
-		ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
+		//ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
 		//InferencePools:  krt.WrapClient(kclient.New[*inf.InferencePool](s.client), krtopts.ToOptions("informer/InferencePools")...),
 	}
 	if features.EnableAlphaGatewayAPI {
@@ -260,12 +264,12 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	routeParents := BuildRouteParents(Gateways)
 
 	routeInputs := RouteContextInputs{
-		Grants:         RefGrants,
-		RouteParents:   routeParents,
-		DomainSuffix:   s.domainSuffix,
-		Services:       inputs.Services,
-		Namespaces:     inputs.Namespaces,
-		ServiceEntries: inputs.ServiceEntries,
+		Grants:       RefGrants,
+		RouteParents: routeParents,
+		DomainSuffix: s.domainSuffix,
+		Services:     inputs.Services,
+		Namespaces:   inputs.Namespaces,
+		//ServiceEntries: inputs.ServiceEntries,
 		InferencePools: inputs.InferencePools,
 	}
 	ADPRoutes := ADPRouteCollection(
@@ -282,31 +286,25 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	)
 	endpointSlices := krt.WrapClient(epSliceClient, s.commonCols.KrtOpts.ToOptions("informer/EndpointSlices")...)
 
-	// Create a separate Pods client for agentgateway syncer
-	podsClient := kclient.NewFiltered[*corev1.Pod](
-		s.client,
-		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
-	)
-	pods := krt.WrapClient(podsClient)
-
 	nsClient := kclient.NewFiltered[*corev1.Namespace](
 		s.commonCols.Client,
 		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
 	)
 	namespaces := krt.WrapClient(nsClient, s.commonCols.KrtOpts.ToOptions("informer/Namespaces")...)
 
-	seInformer := kclient.NewDelayedInformer[*networkingclient.ServiceEntry](
-		s.client, gvr.ServiceEntry,
-		kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.client.ObjectFilter()},
-	)
-	serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("informer/ServiceEntries")...)
+	//seInformer := kclient.NewDelayedInformer[*networkingclient.ServiceEntry](
+	//	s.client, gvr.ServiceEntry,
+	//	kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.client.ObjectFilter()},
+	//)
+	//serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("informer/ServiceEntries")...)
 
 	workloadIndex := index{
 		services: servicesCollection{},
 	}
 
 	// these are agw api-style services combined from kube services and service entries
-	WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, serviceEntries, namespaces, krtopts)
+	//WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, serviceEntries, namespaces, krtopts)
+	WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, namespaces, krtopts)
 	avcAddresses := krt.NewCollection(WorkloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
 		var cacheResources []envoytypes.Resource
 		addrMessage := obj.AsAddress.Address
@@ -331,9 +329,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	})
 
 	Workloads := workloadIndex.WorkloadsCollection(
-		pods,
+		s.commonCols.Pods,
 		WorkloadServices,
-		serviceEntries,
+		nil, // serviceEntries,
 		endpointSlices,
 		namespaces,
 		krtopts,
@@ -402,6 +400,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		s.uniqueClients,
 		s.mostXdsSnapshots,
 		addrPerClient,
+		s.xdsSnapshotsMetrics,
 	)
 
 	s.waitForSync = []cache.InformerSynced{
@@ -412,9 +411,8 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		ADPRoutes.HasSynced,
 		s.mostXdsSnapshots.HasSynced,
 		// addresses
-		serviceEntries.HasSynced,
+		//serviceEntries.HasSynced,
 		namespaces.HasSynced,
-		pods.HasSynced,
 		endpointSlices.HasSynced,
 		WorkloadServices.HasSynced,
 		Workloads.HasSynced,
@@ -443,6 +441,10 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 			}
 			logger.Debug("setting per-client xds snapshot", "proxy_key", snap.proxyKey)
 			err := s.xdsCache.SetSnapshot(ctx, snap.proxyKey, snap.snap)
+
+			// todo: remove debug
+			dumpXDSCacheState(ctx, s.xdsCache)
+
 			if err != nil {
 				logger.Error("failed to set per-client xds snapshot", "proxy_key", snap.proxyKey, "error", err.Error())
 				continue
@@ -615,6 +617,7 @@ func snapshotPerClient(
 	uccCol krt.Collection[ir.UniqlyConnectedClient],
 	mostXdsSnapshots krt.Collection[ADPCacheResource],
 	addresses PerClientAddresses,
+	metricsRecorder krtcollections.CollectionMetricsRecorder,
 ) krt.Collection[XdsSnapWrapper] {
 	addrResources := krt.NewCollection(uccCol, func(kctx krt.HandlerContext, ucc ir.UniqlyConnectedClient) *addressesWithUccName {
 		endpointsForUcc := addresses.FetchEndpointsForClient(kctx, ucc)
@@ -678,6 +681,50 @@ func snapshotPerClient(
 
 		return &snap
 	}, krtopts.ToOptions("PerClientXdsSnapshots")...)
+
+	// Register metrics for the collection
+	metrics.RegisterEvents(xdsSnapshotsForUcc, func(o krt.Event[XdsSnapWrapper]) {
+		name := o.Latest().ResourceName()
+		namespace := "unknown"
+
+		pks := strings.SplitN(name, "~", 5)
+		if len(pks) > 1 {
+			namespace = pks[1]
+		}
+
+		if len(pks) > 2 {
+			name = pks[2]
+		}
+
+		switch o.Event {
+		case controllers.EventDelete:
+			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
+				Namespace: namespace,
+				Name:      name,
+				Resource:  "Resource",
+			}, 0)
+
+			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
+				Namespace: namespace,
+				Name:      name,
+				Resource:  "Address",
+			}, 0)
+		case controllers.EventAdd, controllers.EventUpdate:
+			snap := o.Latest().snap
+			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
+				Namespace: namespace,
+				Name:      name,
+				Resource:  "Resource",
+			}, len(snap.Resources.Items))
+
+			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
+				Namespace: namespace,
+				Name:      name,
+				Resource:  "Address",
+			}, len(snap.Addresses.Items))
+		}
+	})
+
 	return xdsSnapshotsForUcc
 }
 
@@ -686,3 +733,33 @@ type resourcesStringer envoycache.Resources
 func (r resourcesStringer) String() string {
 	return fmt.Sprintf("len: %d, version %s", len(r.Items), r.Version)
 }
+
+// dumpXDSCacheState is a helper function that dump the current state of the XDS cache for the agentgateway cache
+func dumpXDSCacheState(ctx context.Context, cache envoycache.SnapshotCache) {
+	logger.Info("current XDS cache state:")
+
+	// Get all snapshot IDs from cache
+	for _, nodeID := range cache.GetStatusKeys() {
+		logger.Info("snapshot has node", "node_id", nodeID)
+
+		snapshot, err := cache.GetSnapshot(nodeID)
+		if err != nil {
+			logger.Info("error getting snapshot", "error", err.Error())
+			continue
+		}
+
+		// Check for Resource targets
+		logger.Info("Resource targets version", "snapshot", snapshot.GetVersion(TargetTypeResourceUrl)) //nolint:sloglint // ignore msg-type
+		resources := snapshot.GetResources(TargetTypeResourceUrl)
+		for name := range resources {
+			logger.Info("snapshot has resources", "name", name)
+		}
+
+		// Check addresses
+		logger.Info("Address targets version", "snapshot", snapshot.GetVersion(TargetTypeAddressUrl)) //nolint:sloglint // ignore msg-type
+		addrs := snapshot.GetResources(TargetTypeAddressUrl)
+		for name := range addrs {
+			logger.Info("snapshot has addr", "name", name)
+		}
+	}
+}
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
index 6fe10a817..9f345d1e0 100644
--- a/internal/kgateway/agentgatewaysyncer/workloads.go
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -106,13 +106,15 @@ func (a *index) WorkloadsCollection(
 		krtopts.ToOptions("PodWorkloads")...,
 	)
 	// TODO(npolshak): Add support for WE?
+
 	// Workloads coming from serviceEntries. These are inlined workloadEntries (under `spec.endpoints`); these serviceEntries will
 	// also be generating `api.Service` definitions in the `ServicesCollection` logic.
-	ServiceEntryWorkloads := krt.NewManyCollection(
-		serviceEntries,
-		a.serviceEntryWorkloadBuilder(),
-		krtopts.ToOptions("ServiceEntryWorkloads")...,
-	)
+	//ServiceEntryWorkloads := krt.NewManyCollection(
+	//	serviceEntries,
+	//	a.serviceEntryWorkloadBuilder(),
+	//	krtopts.ToOptions("ServiceEntryWorkloads")...,
+	//)
+
 	// Workloads coming from endpointSlices. These are for *manually added* endpoints. Typically, Kubernetes will insert each pod
 	// into the EndpointSlice. This is because Kubernetes has 3 APIs in its model: Service, Pod, and EndpointSlice.
 	// In our API, we only have two: Service and Workload.
@@ -126,7 +128,7 @@ func (a *index) WorkloadsCollection(
 	Workloads := krt.JoinCollection(
 		[]krt.Collection[WorkloadInfo]{
 			PodWorkloads,
-			ServiceEntryWorkloads,
+			//ServiceEntryWorkloads,
 			EndpointSliceWorkloads,
 		},
 		// Each collection has its own unique UID as the key. This guarantees an object can exist in only a single collection
diff --git a/internal/kgateway/controller/start.go b/internal/kgateway/controller/start.go
index bc0d0b162..9a4375eec 100644
--- a/internal/kgateway/controller/start.go
+++ b/internal/kgateway/controller/start.go
@@ -22,7 +22,6 @@ import (
 	infextv1a2 "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/deployer"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/registry"
@@ -32,6 +31,7 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/proxy_syncer"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/pkg/client/clientset/versioned"
+	"github.com/kgateway-dev/kgateway/v2/pkg/deployer"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
 	sdk "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk"
 	common "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/collections"
diff --git a/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go b/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go
index 36b3f6ade..5e8a7b7c0 100644
--- a/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go
+++ b/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go
@@ -21,9 +21,9 @@ const (
 // inferencePool defines the internal representation of an inferencePool resource.
 type inferencePool struct {
 	objMeta metav1.ObjectMeta
-	// podSelector is a label selector to select Pods that are members of the InferencePool.
+	// podSelector is a label selector to select LocalityPods that are members of the InferencePool.
 	podSelector map[string]string
-	// targetPort is the port number that should be targeted for Pods selected by Selector.
+	// targetPort is the port number that should be targeted for LocalityPods selected by Selector.
 	targetPort int32
 	// configRef is a reference to the extension configuration. A configRef is typically implemented
 	// as a Kubernetes Service resource.
diff --git a/internal/kgateway/extensions2/plugins/kubernetes/k8s.go b/internal/kgateway/extensions2/plugins/kubernetes/k8s.go
index 0191434a8..d08a67101 100644
--- a/internal/kgateway/extensions2/plugins/kubernetes/k8s.go
+++ b/internal/kgateway/extensions2/plugins/kubernetes/k8s.go
@@ -32,7 +32,7 @@ func NewPlugin(ctx context.Context, commonCol *common.CommonCollections) extensi
 		kclient.Filter{ObjectFilter: commonCol.Client.ObjectFilter()},
 	)
 	endpointSlices := krt.WrapClient(epSliceClient, commonCol.KrtOpts.ToOptions("EndpointSlices")...)
-	return NewPluginFromCollections(ctx, commonCol.KrtOpts, commonCol.Pods, commonCol.Services, endpointSlices, commonCol.Settings)
+	return NewPluginFromCollections(ctx, commonCol.KrtOpts, commonCol.LocalityPods, commonCol.Services, endpointSlices, commonCol.Settings)
 }
 
 func NewPluginFromCollections(
diff --git a/internal/kgateway/extensions2/plugins/serviceentry/collections.go b/internal/kgateway/extensions2/plugins/serviceentry/collections.go
index 6a9d01c08..43dc1f1df 100644
--- a/internal/kgateway/extensions2/plugins/serviceentry/collections.go
+++ b/internal/kgateway/extensions2/plugins/serviceentry/collections.go
@@ -137,7 +137,7 @@ func initServiceEntryCollections(
 	SelectedWorkloads, selectedWorkloadsIndex := selectedWorkloads(
 		SelectingServiceEntries,
 		WorkloadEntries,
-		commonCols.Pods,
+		commonCols.LocalityPods,
 		opts.Aliaser,
 	)
 
@@ -221,7 +221,7 @@ func selectedWorkloads(
 		return &workload
 	}, krt.WithName("ServiceEntrySelectWorkloadEntry"))
 
-	// Pods: selection logic
+	// LocalityPods: selection logic
 	selectedPods := krt.NewCollection(Pods, func(ctx krt.HandlerContext, workload krtcollections.LocalityPod) *selectedWorkload {
 		serviceEntries := krt.Fetch(
 			ctx,
@@ -241,7 +241,7 @@ func selectedWorkloads(
 		}
 	}, krt.WithName("ServiceEntrySelectPod"))
 
-	// consolidate Pods and WorkloadEntries
+	// consolidate LocalityPods and WorkloadEntries
 	allWorkloads := krt.JoinCollection([]krt.Collection[selectedWorkload]{selectedPods, selectedWorkloadEntries}, krt.WithName("ServiceEntrySelectWorkloads"))
 	workloadsByServiceEntry := krt.NewIndex(allWorkloads, func(o selectedWorkload) []string {
 		return slices.Map(o.selectedBy, func(n krt.Named) string {
diff --git a/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml b/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
index 0b2ab2686..63fa3d3d2 100644
--- a/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
+++ b/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
@@ -40,7 +40,9 @@ spec:
             {{- toYaml $gateway.resources | nindent 12 }}
           {{- end }} {{/* if $gateway.resources */}}
           args:
-            - --file=/config/config.json
+            - gateway
+            - -f
+            - /config/config.json
           env:
             - name: NODE_NAME
               valueFrom:
@@ -60,6 +62,16 @@ spec:
               value: "1"
             - name: RUST_LOG
               value: {{ $gateway.agentGateway.logLevel }}
+            - name: XDS_ADDRESS
+              value: "http://{{ $gateway.xds.host }}:{{ $gateway.xds.port }}"
+            - name: NAMESPACE
+              valueFrom:
+                fieldRef:
+                  fieldPath: metadata.namespace
+            - name: GATEWAY
+              value: {{ include "kgateway.gateway.fullname" . }}
+{{/*            - name: LOCAL_XDS_PATH*/}}
+{{/*              value: /config/config.json*/}}
             {{- if $gateway.env }}
             {{- toYaml $gateway.env | nindent 12 }}
             {{- end }} {{/* if $gateway.env */}}
@@ -114,11 +126,7 @@ metadata:
 data:
   config.json: |
     {
-      "type": "xds",
-      "xds_address": "http://{{ $gateway.xds.host }}:{{ $gateway.xds.port }}",
-      "metadata": {},
-      "alt_xds_hostname": "{{ $gateway.gatewayName | default (include "kgateway.gateway.fullname" .) }}.{{ $gateway.gatewayNamespace }}.svc.cluster.local",
-      "listeners": []
+      "config": {}
     }
 
 {{- end }} {{/* if $gateway.agentGateway.enabled */}}
diff --git a/internal/kgateway/krtcollections/pods.go b/internal/kgateway/krtcollections/pods.go
index 65204294e..2d7953c3b 100644
--- a/internal/kgateway/krtcollections/pods.go
+++ b/internal/kgateway/krtcollections/pods.go
@@ -74,12 +74,7 @@ func NewNodeMetadataCollection(nodes krt.Collection[*corev1.Node]) krt.Collectio
 	})
 }
 
-func NewPodsCollection(istioClient kube.Client, krtOptions krtutil.KrtOptions) krt.Collection[LocalityPod] {
-	podClient := kclient.NewFiltered[*corev1.Pod](istioClient, kclient.Filter{
-		ObjectTransform: kube.StripPodUnusedFields,
-		ObjectFilter:    istioClient.ObjectFilter(),
-	})
-	pods := krt.WrapClient(podClient, krtOptions.ToOptions("Pods")...)
+func NewPodsCollection(istioClient kube.Client, pods krt.Collection[*corev1.Pod], krtOptions krtutil.KrtOptions) krt.Collection[LocalityPod] {
 	nodes := newNodeCollection(istioClient, krtOptions)
 	return NewLocalityPodsCollection(nodes, pods, krtOptions)
 }
@@ -152,7 +147,7 @@ func AugmentLabels(locality ir.PodLocality, labels map[string]string) {
 
 // technically the plural PodIPs isn't a required field.
 // we don't use it yet, but it will be useful to support ipv6
-// "Pods may be allocated at most 1 value for each of IPv4 and IPv6."
+// "LocalityPods may be allocated at most 1 value for each of IPv4 and IPv6."
 //   - k8s docs
 func extractPodIPs(pod *corev1.Pod) []string {
 	if len(pod.Status.PodIPs) > 0 {
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index c9eb73004..d8d61644c 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -22,8 +22,7 @@ import (
 	"istio.io/istio/pkg/test/util/retry"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
-
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/settings"
+	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 )
 
 func TestAgentGatewayScenarioDump(t *testing.T) {
@@ -40,6 +39,7 @@ func TestAgentGatewayScenarioDump(t *testing.T) {
 
 func runAgentGatewayScenario(t *testing.T, scenarioDir string, globalSettings *settings.Settings) {
 	setupEnvTestAndRun(t, globalSettings, func(t *testing.T, ctx context.Context, kdbg *krt.DebugHandler, client istiokube.CLIClient, xdsPort int) {
+
 		// list all yamls in test data
 		files, err := os.ReadDir(scenarioDir)
 		if err != nil {
diff --git a/internal/kgateway/setup/setup.go b/internal/kgateway/setup/setup.go
index 858a5c5dc..511972f1a 100644
--- a/internal/kgateway/setup/setup.go
+++ b/internal/kgateway/setup/setup.go
@@ -9,7 +9,9 @@ import (
 	xdsserver "github.com/envoyproxy/go-control-plane/pkg/server/v3"
 	"github.com/go-logr/logr"
 	istiokube "istio.io/istio/pkg/kube"
+	"istio.io/istio/pkg/kube/kclient"
 	"istio.io/istio/pkg/kube/krt"
+	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/client-go/rest"
 	"k8s.io/klog/v2"
@@ -214,7 +216,12 @@ func StartKgatewayWithConfig(
 	slog.Info("creating krt collections")
 	krtOpts := krtutil.NewKrtOptions(ctx.Done(), setupOpts.KrtDebugger)
 
-	augmentedPods := krtcollections.NewPodsCollection(kubeClient, krtOpts)
+	podClient := kclient.NewFiltered[*corev1.Pod](kubeClient, kclient.Filter{
+		ObjectTransform: istiokube.StripPodUnusedFields,
+		ObjectFilter:    kubeClient.ObjectFilter(),
+	})
+	pods := krt.WrapClient(podClient, krtOpts.ToOptions("Pods")...)
+	augmentedPods := krtcollections.NewPodsCollection(kubeClient, pods, krtOpts)
 	augmentedPodsForUcc := augmentedPods
 	if envutils.IsEnvTruthy("DISABLE_POD_LOCALITY_XDS") {
 		augmentedPodsForUcc = nil
diff --git a/internal/kgateway/setup/setup_test.go b/internal/kgateway/setup/setup_test.go
index d56746317..17433812a 100644
--- a/internal/kgateway/setup/setup_test.go
+++ b/internal/kgateway/setup/setup_test.go
@@ -45,8 +45,8 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/log"
 	"sigs.k8s.io/yaml"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/settings"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/proxy_syncer"
+	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 	"github.com/kgateway-dev/kgateway/v2/test/envtestutil"
 )
 
@@ -169,7 +169,7 @@ func TestWithAutoDns(t *testing.T) {
 	if err != nil {
 		t.Fatalf("can't get settings %v", err)
 	}
-	st.DnsLookupFamily = "AUTO"
+	st.DnsLookupFamily = settings.DnsLookupFamilyAuto
 
 	runScenario(t, "testdata/autodns", st)
 }
diff --git a/pkg/pluginsdk/collections/collections.go b/pkg/pluginsdk/collections/collections.go
index c4cf9f639..478bbe96e 100644
--- a/pkg/pluginsdk/collections/collections.go
+++ b/pkg/pluginsdk/collections/collections.go
@@ -41,9 +41,10 @@ type CommonCollections struct {
 	Services          krt.Collection[*corev1.Service]
 	ServiceEntries    krt.Collection[*networkingclient.ServiceEntry]
 
-	Pods       krt.Collection[krtcollections.LocalityPod]
-	RefGrants  *krtcollections.RefGrantIndex
-	ConfigMaps krt.Collection[*corev1.ConfigMap]
+	Pods         krt.Collection[*corev1.Pod] // TODO: refactor to ir that can work with agentgateway
+	LocalityPods krt.Collection[krtcollections.LocalityPod]
+	RefGrants    *krtcollections.RefGrantIndex
+	ConfigMaps   krt.Collection[*corev1.ConfigMap]
 
 	// static set of global Settings, non-krt based for dev speed
 	// TODO: this should be refactored to a more correct location,
@@ -59,6 +60,7 @@ func (c *CommonCollections) HasSynced() bool {
 		c.BackendIndex != nil && c.BackendIndex.HasSynced() &&
 		c.Routes != nil && c.Routes.HasSynced() &&
 		c.Pods != nil && c.Pods.HasSynced() &&
+		c.LocalityPods != nil && c.LocalityPods.HasSynced() &&
 		c.RefGrants != nil && c.RefGrants.HasSynced() &&
 		c.ConfigMaps != nil && c.ConfigMaps.HasSynced() &&
 		c.GatewayExtensions != nil && c.GatewayExtensions.HasSynced() &&
@@ -139,13 +141,20 @@ func NewCommonCollections(
 
 	gwExts := krtcollections.NewGatewayExtensionsCollection(ctx, client, ourClient, krtOptions)
 
+	podClient := kclient.NewFiltered[*corev1.Pod](client, kclient.Filter{
+		ObjectTransform: kube.StripPodUnusedFields,
+		ObjectFilter:    client.ObjectFilter(),
+	})
+	pods := krt.WrapClient(podClient, krtOptions.ToOptions("Pods")...)
+
 	return &CommonCollections{
 		OurClient:         ourClient,
 		Client:            client,
 		CrudClient:        cl,
 		KrtOpts:           krtOptions,
 		Secrets:           krtcollections.NewSecretIndex(secrets, refgrants),
-		Pods:              krtcollections.NewPodsCollection(client, krtOptions),
+		LocalityPods:      krtcollections.NewPodsCollection(client, pods, krtOptions),
+		Pods:              pods,
 		RefGrants:         refgrants,
 		Settings:          settings,
 		Namespaces:        namespaces,
diff --git a/test/envtestutil/util.go b/test/envtestutil/util.go
index e203bcf9f..1b883c783 100644
--- a/test/envtestutil/util.go
+++ b/test/envtestutil/util.go
@@ -190,7 +190,7 @@ func addApiServerLogs(t *testing.T, testEnv *envtest.Environment) {
 }
 
 // applyPodStatusFromFile reads a YAML file, looks for Pod resources with a Status set,
-// and patches their status into the cluster. Skips any Pods not found or lacking a status.
+// and patches their status into the cluster. Skips any LocalityPods not found or lacking a status.
 // This is needed because the other places that apply yaml will only apply spec.
 // We now have tests (ServiceEntry) that rely on IPs from Pod status instead of EndpointSlice.
 func applyPodStatusFromFile(ctx context.Context, c istiokube.CLIClient, defaultNs, filePath string) error {
diff --git a/test/helpers/kube_dump.go b/test/helpers/kube_dump.go
index 16b12159c..739502431 100644
--- a/test/helpers/kube_dump.go
+++ b/test/helpers/kube_dump.go
@@ -144,7 +144,7 @@ func recordKubeState(ctx context.Context, kubectlCli *kubectl.Cli, f *os.File) {
 		return
 	}
 
-	// Describe everything to identify the reason for issues such as Pods, LoadBalancers stuck in pending state
+	// Describe everything to identify the reason for issues such as LocalityPods, LoadBalancers stuck in pending state
 	// (insufficient resources, unable to acquire an IP), etc.
 	// Ie: More context around the output of the previous command `kubectl get all -A`
 	kubeDescribe, err := kubectlCli.RunCommandWithOutput(ctx, "describe", "all", "-A")
diff --git a/test/kubernetes/e2e/features/waypoint/suite.go b/test/kubernetes/e2e/features/waypoint/suite.go
index 6635fe880..801408bdb 100644
--- a/test/kubernetes/e2e/features/waypoint/suite.go
+++ b/test/kubernetes/e2e/features/waypoint/suite.go
@@ -60,8 +60,8 @@ func NewIngressTestingSuite(ctx context.Context, testInst *e2e.TestInstallation)
 // SetupSuite provides common objects used by all tests:
 // * Create an ambient captured Namespace - `testNamespace`
 // * Deploy a kgateway-waypoint using a Gateway resource - `gwName`
-// * Deploy server (Services, Pods) - `svc-a`, `svc-b`
-// * Deploy client (Pods) - `client-a`
+// * Deploy server (Services, LocalityPods) - `svc-a`, `svc-b`
+// * Deploy client (LocalityPods) - `client-a`
 func (s *testingSuite) SetupSuite() {
 	// must apply the ns first
 	err := s.testInstallation.ClusterContext.Cli.ApplyFilePath(s.ctx, nsYAML)
diff --git a/test/kubernetes/testutils/assertions/deployments.go b/test/kubernetes/testutils/assertions/deployments.go
index c6b4a88dc..36de52d2c 100644
--- a/test/kubernetes/testutils/assertions/deployments.go
+++ b/test/kubernetes/testutils/assertions/deployments.go
@@ -15,7 +15,7 @@ import (
 // are in the ready state and able to receive traffic.
 func (p *Provider) EventuallyReadyReplicas(ctx context.Context, deploymentMeta metav1.ObjectMeta, replicaMatcher types.GomegaMatcher) {
 	p.Gomega.Eventually(func(innerG Gomega) {
-		// We intentionally rely only on Pods that have marked themselves as ready as a way of defining more explicit assertions
+		// We intentionally rely only on LocalityPods that have marked themselves as ready as a way of defining more explicit assertions
 		pods, err := kubeutils.GetReadyPodsForDeployment(ctx, p.clusterContext.Clientset, deploymentMeta)
 		innerG.Expect(err).NotTo(HaveOccurred(), "can get pods for deployment")
 		innerG.Expect(len(pods)).To(replicaMatcher, "running pods matches expected count")
-- 
2.39.5 (Apple Git-154)


From 92670fd54ba4f0ccb05dffd7c8c168319846fc46 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Tue, 1 Jul 2025 11:35:39 -0700
Subject: [PATCH 10/17] working version

---
 .../agentgatewaysyncer/gateway_collection.go  |   8 +-
 .../kgateway/agentgatewaysyncer/service.go    |  13 -
 .../kgateway/agentgatewaysyncer/syncer.go     | 236 ++++++++++++------
 .../kgateway/agentgatewaysyncer/workloads.go  |  88 ++-----
 internal/kgateway/controller/start.go         |   3 +
 internal/kgateway/krtcollections/pods.go      | 173 ++++++++++++-
 internal/kgateway/setup/agentgateway_test.go  |   2 +-
 internal/kgateway/setup/setup.go              |  11 +-
 .../testdata/agentgateway/httproute-out.json  | 139 +++++++++++
 .../testdata/agentgateway/httproute.yaml      |   6 -
 pkg/pluginsdk/collections/collections.go      |  14 +-
 .../testdata/agentgateway-deploy.yaml         |  27 +-
 12 files changed, 529 insertions(+), 191 deletions(-)
 create mode 100644 internal/kgateway/setup/testdata/agentgateway/httproute-out.json

diff --git a/internal/kgateway/agentgatewaysyncer/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
index b76b2b840..9e3308e5e 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
@@ -110,6 +110,7 @@ func (g Gateway) Equals(other Gateway) bool {
 }
 
 func GatewayCollection(
+	agentGatewayClassName string,
 	gateways krt.Collection[*gateway.Gateway],
 	gatewayClasses krt.Collection[GatewayClass],
 	namespaces krt.Collection[*corev1.Namespace],
@@ -119,6 +120,10 @@ func GatewayCollection(
 	krtopts krtutil.KrtOptions,
 ) krt.Collection[Gateway] {
 	gw := krt.NewManyCollection(gateways, func(ctx krt.HandlerContext, obj *gateway.Gateway) []Gateway {
+		if string(obj.Spec.GatewayClassName) != agentGatewayClassName {
+			return nil // ignore non agentgateway gws
+		}
+
 		var result []Gateway
 		kgw := obj.Spec
 		status := obj.Status.DeepCopy()
@@ -142,7 +147,7 @@ func GatewayCollection(
 
 			servers = append(servers, server)
 			meta := parentMeta(obj, &l.Name)
-			// Each listener generates an Istio Gateway with a single Server. This allows binding to a specific listener.
+			// Each listener generates a Gateway with a single Server. This allows binding to a specific listener.
 			gatewayConfig := Config{
 				Meta: Meta{
 					CreationTimestamp: obj.CreationTimestamp.Time,
@@ -152,6 +157,7 @@ func GatewayCollection(
 					Namespace:         obj.Namespace,
 					Domain:            domainSuffix,
 				},
+				// TODO: move away from istio gateway ir
 				Spec: &istio.Gateway{
 					Servers: []*istio.Server{server},
 				},
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
index e01444652..08476a401 100644
--- a/internal/kgateway/agentgatewaysyncer/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -777,19 +777,6 @@ func (l LabelSelector) GetLabelSelector() map[string]string {
 	return l.Labels
 }
 
-type NamespaceInfo struct {
-	Name               string
-	IngressUseWaypoint bool
-}
-
-func (i NamespaceInfo) ResourceName() string {
-	return i.Name
-}
-
-func (i NamespaceInfo) Equals(other NamespaceInfo) bool {
-	return i == other
-}
-
 // MCSServiceInfo combines the name of a service with a particular Kubernetes cluster. This
 // is used for debug information regarding the state of Kubernetes Multi-Cluster Services (MCS).
 type MCSServiceInfo struct {
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 598b0081d..f2540d736 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -44,35 +44,70 @@ var logger = logging.New("agentgateway/syncer")
 // AgentGwSyncer synchronizes Kubernetes Gateway API resources with xDS for agentgateway proxies.
 // It watches Gateway resources with the agentgateway class and translates them to agentgateway configuration.
 type AgentGwSyncer struct {
-	commonCols              *common.CommonCollections
-	controllerName          string
-	perclientSnapCollection krt.Collection[XdsSnapWrapper]
-	uniqueClients           krt.Collection[ir.UniqlyConnectedClient]
-	mostXdsSnapshots        krt.Collection[ADPCacheResource]
-	xdsCache                envoycache.SnapshotCache
-	client                  kube.Client
-	domainSuffix            string
-	xdsSnapshotsMetrics     krtcollections.CollectionMetricsRecorder
+	commonCols            *common.CommonCollections
+	controllerName        string
+	agentGatewayClassName string
+
+	// TODO: do per client snpshot
+	//perclientSnapCollection krt.Collection[XdsSnapWrapper]
+	//uniqueClients           krt.Collection[ir.UniqlyConnectedClient]
+	//mostXdsSnapshots        krt.Collection[ADPCacheResource]
+
+	xDS                 krt.Collection[agentGwXdsResources]
+	xdsCache            envoycache.SnapshotCache
+	client              kube.Client
+	domainSuffix        string
+	systemNamespace     string
+	clusterID           string
+	xdsSnapshotsMetrics krtcollections.CollectionMetricsRecorder
 
 	waitForSync []cache.InformerSynced
 }
 
+type agentGwXdsResources struct {
+	types.NamespacedName
+
+	reports reports.ReportMap
+	// Resources config for gw (Bind, Listener. Route)
+	ResourceConfig envoycache.Resources
+	// Address config (Services, Workloads)
+	AddressConfig envoycache.Resources
+}
+
+// Needs to match agentgateway role configured in client.rs (https://github.com/agentgateway/agentgateway/blob/main/crates/agentgateway/src/xds/client.rs)
+func (r agentGwXdsResources) ResourceName() string {
+	return fmt.Sprintf("%s~%s", r.Namespace, r.Name)
+}
+
+func (r agentGwXdsResources) Equals(in agentGwXdsResources) bool {
+	return r.NamespacedName == in.NamespacedName &&
+		report{r.reports}.Equals(report{in.reports}) &&
+		r.ResourceConfig.Version == in.ResourceConfig.Version &&
+		r.AddressConfig.Version == in.AddressConfig.Version
+}
+
 func NewAgentGwSyncer(
 	controllerName string,
+	agentGatewayClassName string,
 	client kube.Client,
 	uniqueClients krt.Collection[ir.UniqlyConnectedClient],
 	commonCols *common.CommonCollections,
 	xdsCache envoycache.SnapshotCache,
 	domainSuffix string,
+	systemNamespace string,
+	clusterID string,
 ) *AgentGwSyncer {
 	// TODO: register types (auth, policy, etc.) if necessary
 	return &AgentGwSyncer{
-		commonCols:          commonCols,
-		controllerName:      controllerName,
-		xdsCache:            xdsCache,
-		client:              client,
-		uniqueClients:       uniqueClients,
+		commonCols:            commonCols,
+		controllerName:        controllerName,
+		agentGatewayClassName: agentGatewayClassName,
+		xdsCache:              xdsCache,
+		client:                client,
+		//uniqueClients:         uniqueClients,
 		domainSuffix:        domainSuffix,
+		systemNamespace:     systemNamespace,
+		clusterID:           clusterID,
 		xdsSnapshotsMetrics: krtcollections.NewCollectionMetricsRecorder("AgentGatewayXDSSnapshots"),
 	}
 }
@@ -181,7 +216,8 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 	// Note: not fully complete until its join with route attachments to report attachedRoutes.
 	// Do not register yet.
-	Gateways := GatewayCollection(
+	gateways := GatewayCollection(
+		s.agentGatewayClassName,
 		inputs.Gateways,
 		GatewayClasses,
 		inputs.Namespaces,
@@ -190,7 +226,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		s.domainSuffix,
 		krtopts,
 	)
-	ports := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
+	ports := krt.NewCollection(gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
 		port := fmt.Sprint(obj.parentInfo.Port)
 		return &IndexObject[string, Gateway]{
 			Key:     port,
@@ -198,7 +234,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		}
 	}, krtopts.ToOptions("ports")...)
 
-	Binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object IndexObject[string, Gateway]) []ADPResource {
+	binds := krt.NewManyCollection(ports, func(ctx krt.HandlerContext, object IndexObject[string, Gateway]) []ADPResource {
 		port, _ := strconv.Atoi(object.Key)
 		uniq := sets.New[types.NamespacedName]()
 		for _, gw := range object.Objects {
@@ -220,7 +256,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		return binds
 	}, krtopts.ToOptions("Binds")...)
 
-	Listeners := krt.NewCollection(Gateways, func(ctx krt.HandlerContext, obj Gateway) *ADPResource {
+	listeners := krt.NewCollection(gateways, func(ctx krt.HandlerContext, obj Gateway) *ADPResource {
 		l := &api.Listener{
 			Key:         obj.ResourceName(),
 			Name:        string(obj.parentInfo.SectionName),
@@ -261,7 +297,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		}, ADPListener{l})
 	}, krtopts.ToOptions("Listeners")...)
 
-	routeParents := BuildRouteParents(Gateways)
+	routeParents := BuildRouteParents(gateways)
 
 	routeInputs := RouteContextInputs{
 		Grants:       RefGrants,
@@ -272,7 +308,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		//ServiceEntries: inputs.ServiceEntries,
 		InferencePools: inputs.InferencePools,
 	}
-	ADPRoutes := ADPRouteCollection(
+	adpRoutes := ADPRouteCollection(
 		inputs.HTTPRoutes,
 		routeInputs,
 		krtopts,
@@ -299,13 +335,18 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	//serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("informer/ServiceEntries")...)
 
 	workloadIndex := index{
-		services: servicesCollection{},
+		services:        servicesCollection{},
+		workloads:       workloadsCollection{},
+		namespaces:      s.commonCols.Namespaces,
+		SystemNamespace: s.systemNamespace,
+		ClusterID:       s.clusterID,
+		DomainSuffix:    s.domainSuffix,
 	}
 
 	// these are agw api-style services combined from kube services and service entries
 	//WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, serviceEntries, namespaces, krtopts)
-	WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, namespaces, krtopts)
-	avcAddresses := krt.NewCollection(WorkloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
+	workloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, namespaces, krtopts)
+	svcAddresses := krt.NewCollection(workloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
 		var cacheResources []envoytypes.Resource
 		addrMessage := obj.AsAddress.Address
 		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
@@ -328,9 +369,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		return result
 	})
 
-	Workloads := workloadIndex.WorkloadsCollection(
-		s.commonCols.Pods,
-		WorkloadServices,
+	workloads := workloadIndex.WorkloadsCollection(
+		s.commonCols.WrappedPods,
+		workloadServices,
 		nil, // serviceEntries,
 		endpointSlices,
 		namespaces,
@@ -338,7 +379,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	)
 
 	proxyKey := "default~agent-gateway" // TODO: don't hard code, use s.perclientSnapCollection
-	workloadAddresses := krt.NewCollection(Workloads, func(ctx krt.HandlerContext, obj WorkloadInfo) *ADPCacheAddress {
+	workloadAddresses := krt.NewCollection(workloads, func(ctx krt.HandlerContext, obj WorkloadInfo) *ADPCacheAddress {
 		var cacheResources []envoytypes.Resource
 		addrMessage := obj.AsAddress.Address
 		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
@@ -362,63 +403,91 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		return result
 	})
 
-	addressxDS := krt.JoinCollection([]krt.Collection[ADPCacheAddress]{avcAddresses, workloadAddresses}, krtopts.ToOptions("ADPAddresses")...)
-
-	resources := krt.JoinCollection([]krt.Collection[ADPResource]{Binds, Listeners, ADPRoutes}, krtopts.ToOptions("ADPResources")...)
-	s.mostXdsSnapshots = krt.NewCollection(resources, func(ctx krt.HandlerContext, obj ADPResource) *ADPCacheResource {
+	adpAddresses := krt.JoinCollection([]krt.Collection[ADPCacheAddress]{svcAddresses, workloadAddresses}, krtopts.ToOptions("ADPAddresses")...)
+
+	// TODO: if you make a collection from adpResources -> only last value gets added to agentGwXdsResources (same gw key)
+	adpResources := krt.JoinCollection([]krt.Collection[ADPResource]{binds, listeners, adpRoutes}, krtopts.ToOptions("ADPResources")...)
+	s.xDS = krt.NewCollection(adpResources, func(kctx krt.HandlerContext, obj ADPResource) *agentGwXdsResources {
+		//gwNamespacedName := types.NamespacedName{Name: obj.Name, Namespace: obj.Namespace}
+		gwNamespacedName := obj.Gateway
+
+		// TODO: sync addr separately
+		var cacheAddresses []envoytypes.Resource
+		addrList := krt.Fetch(kctx, adpAddresses)
+		for _, addr := range addrList {
+			// Extract resources from the Address.Resources
+			for _, resourceWithTTL := range addr.Address.Items {
+				cacheAddresses = append(cacheAddresses, resourceWithTTL.Resource)
+			}
+		}
 		var cacheResources []envoytypes.Resource
-		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
-			Message: obj.Resource,
-			Name:    obj.ResourceName(),
-			version: utils.HashProto(obj.Resource),
-		})
+		resourceList := krt.Fetch(kctx, adpResources) // TODO: gw collection doesn't seem to work?
+		for _, resource := range resourceList {
+			// TODO: filter at collection? (add index per gw?)
+			// TODO: empty gw??
+			//if resource.Gateway.Name == gwNamespacedName.Name && resource.Gateway.Namespace == gwNamespacedName.Namespace {
+			cacheResources = append(cacheResources, &envoyResourceWithCustomName{
+				Message: resource.Resource,
+				Name:    resource.ResourceName(),
+				version: utils.HashProto(resource.Resource),
+			})
+			//}
+		}
 
 		// Create the resource wrappers
 		var resourceVersion uint64
 		for _, res := range cacheResources {
 			resourceVersion ^= res.(*envoyResourceWithCustomName).version
 		}
+		// Calculate address version
+		var addrVersion uint64
+		for _, res := range cacheAddresses {
+			if resource, ok := res.(*envoyResourceWithCustomName); ok {
+				addrVersion ^= resource.version
+			}
+		}
 
-		result := &ADPCacheResource{
-			Gateway:   obj.Gateway,
-			Resources: envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
+		result := &agentGwXdsResources{
+			NamespacedName: gwNamespacedName,
+			ResourceConfig: envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
+			AddressConfig:  envoycache.NewResources(fmt.Sprintf("%d", addrVersion), cacheAddresses),
 		}
-		logger.Debug("created XDS resources for gateway with ID", "gwname", fmt.Sprintf("%s,%s", obj.Gateway.Name, obj.Gateway.Namespace), "resourceid", result.ResourceName())
+		logger.Debug("created XDS resources for gateway with ID", "gwname", fmt.Sprintf("%s,%s", gwNamespacedName.Name, gwNamespacedName.Namespace), "resourceid", result.ResourceName())
 		return result
 	})
 
 	// Create per-client addresses
-	addrPerClient := NewPerClientAddresses(
-		krtopts,
-		s.uniqueClients,
-		addressxDS,
-	)
-
-	// Initialize per-client snap collection
-	s.perclientSnapCollection = snapshotPerClient(
-		krtopts,
-		s.uniqueClients,
-		s.mostXdsSnapshots,
-		addrPerClient,
-		s.xdsSnapshotsMetrics,
-	)
+	//addrPerClient := NewPerClientAddresses(
+	//	krtopts,
+	//	s.uniqueClients,
+	//	addressxDS,
+	//)
+	//// Initialize per-client snap collection
+	//s.perclientSnapCollection = snapshotPerClient(
+	//	krtopts,
+	//	s.uniqueClients,
+	//	s.mostXdsSnapshots,
+	//	addrPerClient,
+	//	s.xdsSnapshotsMetrics,
+	//)
 
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
+		gateways.HasSynced, // wait separately?
 		// resources
-		Binds.HasSynced,
-		Listeners.HasSynced,
-		ADPRoutes.HasSynced,
-		s.mostXdsSnapshots.HasSynced,
+		binds.HasSynced,
+		listeners.HasSynced,
+		adpRoutes.HasSynced,
+		s.xDS.HasSynced,
 		// addresses
 		//serviceEntries.HasSynced,
 		namespaces.HasSynced,
 		endpointSlices.HasSynced,
-		WorkloadServices.HasSynced,
-		Workloads.HasSynced,
-		// per-client syncer
-		s.uniqueClients.HasSynced,
-		s.perclientSnapCollection.HasSynced,
+		workloadServices.HasSynced,
+		workloads.HasSynced,
+		////per-client syncer
+		//s.uniqueClients.HasSynced,
+		//s.perclientSnapCollection.HasSynced,
 	}
 }
 
@@ -431,27 +500,48 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		return fmt.Errorf("agentgateway syncer waiting for cache to sync failed")
 	}
 
-	// Register per-client snapshot handler
-	s.perclientSnapCollection.RegisterBatch(func(events []krt.Event[XdsSnapWrapper], _ bool) {
+	s.xDS.RegisterBatch(func(events []krt.Event[agentGwXdsResources], _ bool) {
 		for _, e := range events {
 			snap := e.Latest()
 			if e.Event == controllers.EventDelete {
-				s.xdsCache.ClearSnapshot(snap.proxyKey)
+				s.xdsCache.ClearSnapshot(snap.ResourceName())
 				continue
 			}
-			logger.Debug("setting per-client xds snapshot", "proxy_key", snap.proxyKey)
-			err := s.xdsCache.SetSnapshot(ctx, snap.proxyKey, snap.snap)
-
-			// todo: remove debug
-			dumpXDSCacheState(ctx, s.xdsCache)
-
+			snapshot := &agentGwSnapshot{
+				Resources: snap.ResourceConfig,
+				Addresses: snap.AddressConfig,
+			}
+			logger.Debug("setting xds snapshot", "resourceName", snap.ResourceName())
+			logger.Debug("snapshot config", "resourceSnapshot", snapshot.Resources, "workloadSnapshot", snapshot.Addresses)
+			err := s.xdsCache.SetSnapshot(ctx, snap.ResourceName(), snapshot)
 			if err != nil {
-				logger.Error("failed to set per-client xds snapshot", "proxy_key", snap.proxyKey, "error", err.Error())
+				logger.Error("failed to set xds snapshot", "resourcename", snap.ResourceName(), "error", err.Error())
 				continue
 			}
 		}
 	}, true)
 
+	//// Register per-client snapshot handler
+	//s.perclientSnapCollection.RegisterBatch(func(events []krt.Event[XdsSnapWrapper], _ bool) {
+	//	for _, e := range events {
+	//		snap := e.Latest()
+	//		if e.Event == controllers.EventDelete {
+	//			s.xdsCache.ClearSnapshot(snap.proxyKey)
+	//			continue
+	//		}
+	//		logger.Debug("setting per-client xds snapshot", "proxy_key", snap.proxyKey)
+	//		err := s.xdsCache.SetSnapshot(ctx, snap.proxyKey, snap.snap)
+	//
+	//		// todo: remove debug
+	//		dumpXDSCacheState(ctx, s.xdsCache)
+	//
+	//		if err != nil {
+	//			logger.Error("failed to set per-client xds snapshot", "proxy_key", snap.proxyKey, "error", err.Error())
+	//			continue
+	//		}
+	//	}
+	//}, true)
+
 	return nil
 }
 
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
index 9f345d1e0..2adbc36ef 100644
--- a/internal/kgateway/agentgatewaysyncer/workloads.go
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -6,6 +6,7 @@ import (
 	"strings"
 
 	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 	"istio.io/api/annotation"
 	"istio.io/api/label"
@@ -23,7 +24,6 @@ import (
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/schema/kind"
 	"istio.io/istio/pkg/config/schema/kubetypes"
-	kubeutil "istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
 	kubelabels "istio.io/istio/pkg/kube/labels"
@@ -74,7 +74,7 @@ type servicesCollection struct {
 type index struct {
 	services   servicesCollection
 	workloads  workloadsCollection
-	namespaces krt.Collection[NamespaceInfo]
+	namespaces krt.Collection[krtcollections.NamespaceMetadata]
 
 	SystemNamespace string
 	DomainSuffix    string
@@ -85,7 +85,7 @@ type index struct {
 // A Workload represents a single addressable unit of compute -- typically a Pod or a VM.
 // Workloads can come from a variety of sources; these are joined together to build one complete `Collection[WorkloadInfo]`.
 func (a *index) WorkloadsCollection(
-	pods krt.Collection[*corev1.Pod],
+	pods krt.Collection[krtcollections.WrappedPod],
 	workloadServices krt.Collection[ServiceInfo],
 	serviceEntries krt.Collection[*networkingclient.ServiceEntry],
 	endpointSlices krt.Collection[*discovery.EndpointSlice],
@@ -138,7 +138,7 @@ func (a *index) WorkloadsCollection(
 }
 
 // name format: <cluster>/<group>/<kind>/<namespace>/<name></section-name>
-func (a *index) generatePodUID(p *corev1.Pod) string {
+func (a *index) generatePodUID(p krtcollections.WrappedPod) string {
 	return a.ClusterID + "//" + "Pod/" + p.Namespace + "/" + p.Name
 }
 
@@ -147,15 +147,15 @@ func (a *index) podWorkloadBuilder(
 	workloadServicesNamespaceIndex krt.Index[string, ServiceInfo],
 	endpointSlices krt.Collection[*discovery.EndpointSlice],
 	endpointSlicesAddressIndex krt.Index[TargetRef, *discovery.EndpointSlice],
-) krt.TransformationSingle[*corev1.Pod, WorkloadInfo] {
-	return func(ctx krt.HandlerContext, p *corev1.Pod) *WorkloadInfo {
+) krt.TransformationSingle[krtcollections.WrappedPod, WorkloadInfo] {
+	return func(ctx krt.HandlerContext, p krtcollections.WrappedPod) *WorkloadInfo {
 		// Pod Is Pending but have a pod IP should be a valid workload, we should build it ,
 		// Such as the pod have initContainer which is initialing.
 		// See https://github.com/istio/istio/issues/48854
-		if kubeutil.CheckPodTerminal(p) {
+		if p.Terminal {
 			return nil
 		}
-		k8sPodIPs := getPodIPs(p)
+		k8sPodIPs := p.PodIPs
 		if len(k8sPodIPs) == 0 {
 			return nil
 		}
@@ -171,7 +171,7 @@ func (a *index) podWorkloadBuilder(
 			return nil
 		}
 
-		fo := []krt.FetchOption{krt.FilterIndex(workloadServicesNamespaceIndex, p.Namespace), krt.FilterSelectsNonEmpty(p.GetLabels())}
+		fo := []krt.FetchOption{krt.FilterIndex(workloadServicesNamespaceIndex, p.Namespace), krt.FilterSelectsNonEmpty(p.Labels)}
 		if !features.EnableServiceEntrySelectPods {
 			fo = append(fo, krt.FilterGeneric(func(a any) bool {
 				return a.(ServiceInfo).Source.Kind == kind.Service
@@ -182,7 +182,7 @@ func (a *index) podWorkloadBuilder(
 		// Logic from https://github.com/kubernetes/kubernetes/blob/7c873327b679a70337288da62b96dd610858181d/staging/src/k8s.io/endpointslice/utils.go#L37
 		// Kubernetes has Ready, Serving, and Terminating. We only have a boolean, which is sufficient for our cases
 		status := api.WorkloadStatus_HEALTHY
-		if !IsPodReady(p) || p.DeletionTimestamp != nil {
+		if !p.Ready || p.DeletionTimestamp != nil {
 			status = api.WorkloadStatus_UNHEALTHY
 		}
 
@@ -194,18 +194,18 @@ func (a *index) podWorkloadBuilder(
 			//NetworkGateway:        a.getNetworkGatewayAddress(ctx, network),
 			ClusterId:      a.ClusterID,
 			Addresses:      podIPs,
-			ServiceAccount: p.Spec.ServiceAccountName,
-			Node:           p.Spec.NodeName,
+			ServiceAccount: p.ServiceAccountName,
+			Node:           p.NodeName,
 			Services:       constructServices(p, services),
 			Status:         status,
 			//Locality:              getPodLocality(ctx, nodes, p),
 		}
 
-		if p.Spec.HostNetwork {
+		if p.HostNetwork {
 			w.NetworkMode = api.NetworkMode_HOST_NETWORK
 		}
 
-		w.WorkloadName = workloadName(p)
+		w.WorkloadName = p.WorkloadNameForPod
 		w.WorkloadType = api.WorkloadType_POD // backwards compatibility
 		w.CanonicalName, w.CanonicalRevision = kubelabels.CanonicalService(p.Labels, w.WorkloadName)
 
@@ -219,51 +219,6 @@ func (a *index) podWorkloadBuilder(
 	}
 }
 
-// IsPodReady is copied from kubernetes/pkg/api/v1/pod/utils.go
-func IsPodReady(pod *corev1.Pod) bool {
-	return IsPodReadyConditionTrue(pod.Status)
-}
-
-// IsPodReadyConditionTrue returns true if a pod is ready; false otherwise.
-func IsPodReadyConditionTrue(status corev1.PodStatus) bool {
-	condition := GetPodReadyCondition(status)
-	return condition != nil && condition.Status == corev1.ConditionTrue
-}
-
-func GetPodReadyCondition(status corev1.PodStatus) *corev1.PodCondition {
-	_, condition := GetPodCondition(&status, corev1.PodReady)
-	return condition
-}
-
-func GetPodCondition(status *corev1.PodStatus, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
-	if status == nil {
-		return -1, nil
-	}
-	return GetPodConditionFromList(status.Conditions, conditionType)
-}
-
-// GetPodConditionFromList extracts the provided condition from the given list of condition and
-// returns the index of the condition and the condition. Returns -1 and nil if the condition is not present.
-func GetPodConditionFromList(conditions []corev1.PodCondition, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
-	if conditions == nil {
-		return -1, nil
-	}
-	for i := range conditions {
-		if conditions[i].Type == conditionType {
-			return i, &conditions[i]
-		}
-	}
-	return -1, nil
-}
-
-func getPodIPs(p *corev1.Pod) []corev1.PodIP {
-	k8sPodIPs := p.Status.PodIPs
-	if len(k8sPodIPs) == 0 && p.Status.PodIP != "" {
-		k8sPodIPs = []corev1.PodIP{{IP: p.Status.PodIP}}
-	}
-	return k8sPodIPs
-}
-
 // matchingServicesWithoutSelectors finds all Services that match a given pod that do not use selectors.
 // See https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors for more info.
 // For selector service, we query by the selector elsewhere, so this only handles the services that are NOT already found
@@ -273,7 +228,7 @@ func getPodIPs(p *corev1.Pod) []corev1.PodIP {
 // we do not implicitly merge a Pod with an EndpointSlice just based on IP.
 func (a *index) matchingServicesWithoutSelectors(
 	ctx krt.HandlerContext,
-	p *corev1.Pod,
+	p krtcollections.WrappedPod,
 	alreadyMatchingServices []ServiceInfo,
 	workloadServices krt.Collection[ServiceInfo],
 	endpointSlices krt.Collection[*discovery.EndpointSlice],
@@ -752,12 +707,7 @@ func constructServicesFromWorkloadEntry(p *networkingv1alpha3.WorkloadEntry, ser
 	return res
 }
 
-func workloadName(pod *corev1.Pod) string {
-	objMeta, _ := kubeutil.GetWorkloadMetaFromPod(pod)
-	return objMeta.Name
-}
-
-func constructServices(p *corev1.Pod, services []ServiceInfo) map[string]*api.PortList {
+func constructServices(p krtcollections.WrappedPod, services []ServiceInfo) map[string]*api.PortList {
 	res := map[string]*api.PortList{}
 	for _, svc := range services {
 		n := namespacedHostname(svc.Service.Namespace, svc.Service.Hostname)
@@ -914,9 +864,9 @@ func parseCidrOrIP(ip string) (netip.Addr, error) {
 	return netip.ParseAddr(ip)
 }
 
-func FindPortName(pod *corev1.Pod, name string) (int32, bool) {
-	for _, container := range pod.Spec.Containers {
-		for _, port := range container.Ports {
+func FindPortName(pod krtcollections.WrappedPod, name string) (int32, bool) {
+	for _, ports := range pod.ContainerPorts {
+		for _, port := range ports {
 			if port.Name == name && port.Protocol == corev1.ProtocolTCP {
 				return port.ContainerPort, true
 			}
diff --git a/internal/kgateway/controller/start.go b/internal/kgateway/controller/start.go
index 9a4375eec..95cc9047b 100644
--- a/internal/kgateway/controller/start.go
+++ b/internal/kgateway/controller/start.go
@@ -213,11 +213,14 @@ func NewControllerBuilder(ctx context.Context, cfg StartConfig) (*ControllerBuil
 		domainSuffix := "cluster.local" // TODO: don't hard code
 		agentGatewaySyncer := agentgatewaysyncer.NewAgentGwSyncer(
 			cfg.ControllerName,
+			cfg.AgentGatewayClassName,
 			cfg.Client,
 			cfg.UniqueClients,
 			commoncol,
 			cfg.SetupOpts.Cache,
 			domainSuffix,
+			namespaces.GetPodNamespace(),
+			cfg.Client.ClusterID().String(),
 		)
 		agentGatewaySyncer.Init(cfg.KrtOptions)
 
diff --git a/internal/kgateway/krtcollections/pods.go b/internal/kgateway/krtcollections/pods.go
index 2d7953c3b..01fcfaf26 100644
--- a/internal/kgateway/krtcollections/pods.go
+++ b/internal/kgateway/krtcollections/pods.go
@@ -10,6 +10,7 @@ import (
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/slices"
 	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
@@ -34,6 +35,91 @@ var (
 	_ krt.Equaler[NodeMetadata] = NodeMetadata{}
 )
 
+// WrappedPod is used by agentgateway as a stripped down representation of the pod
+type WrappedPod struct {
+	krt.Named
+	HostNetwork        bool
+	ServiceAccountName string
+	NodeName           string
+	CreationTimestamp  metav1.Time
+	DeletionTimestamp  *metav1.Time
+	Labels             map[string]string
+	ContainerPorts     map[string][]corev1.ContainerPort
+	WorkloadNameForPod string
+	UID                types.UID
+	Annotations        map[string]string
+	// status fields
+	Ready    bool
+	PodIPs   []corev1.PodIP
+	Terminal bool
+}
+
+func (c WrappedPod) Equals(in WrappedPod) bool {
+	return c.Named == in.Named &&
+		c.Ready == in.Ready &&
+		c.Terminal == in.Terminal &&
+		c.podIPsEquals(c.PodIPs, in.PodIPs) &&
+		c.HostNetwork == in.HostNetwork &&
+		c.NodeName == in.NodeName &&
+		c.ServiceAccountName == in.ServiceAccountName &&
+		c.CreationTimestamp.Equal(&in.CreationTimestamp) &&
+		(c.DeletionTimestamp == nil && in.DeletionTimestamp == nil ||
+			c.DeletionTimestamp != nil && in.DeletionTimestamp != nil &&
+				c.DeletionTimestamp.Equal(in.DeletionTimestamp)) &&
+		c.mapStringEquals(c.Labels, in.Labels) &&
+		c.containerPortsEquals(c.ContainerPorts, in.ContainerPorts) &&
+		c.WorkloadNameForPod == in.WorkloadNameForPod &&
+		c.UID == in.UID &&
+		c.mapStringEquals(c.Annotations, in.Annotations)
+}
+
+func (c WrappedPod) podIPsEquals(ips1, ips2 []corev1.PodIP) bool {
+	if len(ips1) != len(ips2) {
+		return false
+	}
+	for i, ip1 := range ips1 {
+		if ip1.IP != ips2[i].IP {
+			return false
+		}
+	}
+	return true
+}
+
+func (c WrappedPod) mapStringEquals(m1, m2 map[string]string) bool {
+	if len(m1) != len(m2) {
+		return false
+	}
+	for k, v := range m1 {
+		if v2, exists := m2[k]; !exists || v != v2 {
+			return false
+		}
+	}
+	return true
+}
+
+func (c WrappedPod) containerPortsEquals(cp1, cp2 map[string][]corev1.ContainerPort) bool {
+	if len(cp1) != len(cp2) {
+		return false
+	}
+	for k, ports1 := range cp1 {
+		ports2, exists := cp2[k]
+		if !exists || len(ports1) != len(ports2) {
+			return false
+		}
+		for i, port1 := range ports1 {
+			port2 := ports2[i]
+			if port1.Name != port2.Name ||
+				port1.HostPort != port2.HostPort ||
+				port1.ContainerPort != port2.ContainerPort ||
+				port1.Protocol != port2.Protocol ||
+				port1.HostIP != port2.HostIP {
+				return false
+			}
+		}
+	}
+	return true
+}
+
 type LocalityPod struct {
 	krt.Named
 	Locality        ir.PodLocality
@@ -74,15 +160,98 @@ func NewNodeMetadataCollection(nodes krt.Collection[*corev1.Node]) krt.Collectio
 	})
 }
 
-func NewPodsCollection(istioClient kube.Client, pods krt.Collection[*corev1.Pod], krtOptions krtutil.KrtOptions) krt.Collection[LocalityPod] {
+func NewPodsCollection(istioClient kube.Client, krtOptions krtutil.KrtOptions) (krt.Collection[LocalityPod], krt.Collection[WrappedPod]) {
+	podClient := kclient.NewFiltered[*corev1.Pod](istioClient, kclient.Filter{
+		ObjectTransform: kube.StripPodUnusedFields,
+		ObjectFilter:    istioClient.ObjectFilter(),
+	})
+	pods := krt.WrapClient(podClient, krtOptions.ToOptions("Pods")...)
 	nodes := newNodeCollection(istioClient, krtOptions)
-	return NewLocalityPodsCollection(nodes, pods, krtOptions)
+	return NewLocalityPodsCollection(nodes, pods, krtOptions), NewPodWrapperCollection(pods, krtOptions)
 }
 
 func NewLocalityPodsCollection(nodes krt.Collection[NodeMetadata], pods krt.Collection[*corev1.Pod], krtOptions krtutil.KrtOptions) krt.Collection[LocalityPod] {
 	return krt.NewCollection(pods, augmentPodLabels(nodes), krtOptions.ToOptions("AugmentPod")...)
 }
 
+func NewPodWrapperCollection(pods krt.Collection[*corev1.Pod], krtOptions krtutil.KrtOptions) krt.Collection[WrappedPod] {
+	return krt.NewCollection(pods, func(ctx krt.HandlerContext, obj *corev1.Pod) *WrappedPod {
+		objMeta, _ := kube.GetWorkloadMetaFromPod(obj)
+		containerPorts := map[string][]corev1.ContainerPort{}
+		for _, container := range obj.Spec.Containers {
+			containerPorts[container.Name] = []corev1.ContainerPort{}
+			for _, port := range container.Ports {
+				containerPorts[container.Name] = append(containerPorts[container.Name], port)
+			}
+		}
+
+		return &WrappedPod{
+			Named: krt.Named{
+				Name:      obj.Name,
+				Namespace: obj.Namespace,
+			},
+			HostNetwork:        obj.Spec.HostNetwork,
+			NodeName:           obj.Spec.NodeName,
+			ServiceAccountName: obj.Spec.ServiceAccountName,
+			DeletionTimestamp:  obj.GetDeletionTimestamp(),
+			CreationTimestamp:  obj.GetCreationTimestamp(),
+			Labels:             obj.GetLabels(),
+			Annotations:        obj.GetAnnotations(),
+			WorkloadNameForPod: objMeta.Name,
+			ContainerPorts:     containerPorts,
+			UID:                obj.UID,
+			// status
+			Terminal: checkPodTerminal(obj),
+			Ready:    isPodReadyConditionTrue(obj.Status),
+			PodIPs:   getPodIPs(obj),
+		}
+	}, krtOptions.ToOptions("WrappedPod")...)
+}
+
+// isPodReadyConditionTrue returns true if a pod is ready; false otherwise.
+func isPodReadyConditionTrue(status corev1.PodStatus) bool {
+	condition := GetPodReadyCondition(status)
+	return condition != nil && condition.Status == corev1.ConditionTrue
+}
+
+func GetPodReadyCondition(status corev1.PodStatus) *corev1.PodCondition {
+	_, condition := GetPodCondition(&status, corev1.PodReady)
+	return condition
+}
+
+func GetPodCondition(status *corev1.PodStatus, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
+	if status == nil {
+		return -1, nil
+	}
+	return GetPodConditionFromList(status.Conditions, conditionType)
+}
+
+func checkPodTerminal(pod *corev1.Pod) bool {
+	return pod.Status.Phase == corev1.PodFailed || pod.Status.Phase == corev1.PodSucceeded
+}
+
+// GetPodConditionFromList extracts the provided condition from the given list of condition and
+// returns the index of the condition and the condition. Returns -1 and nil if the condition is not present.
+func GetPodConditionFromList(conditions []corev1.PodCondition, conditionType corev1.PodConditionType) (int, *corev1.PodCondition) {
+	if conditions == nil {
+		return -1, nil
+	}
+	for i := range conditions {
+		if conditions[i].Type == conditionType {
+			return i, &conditions[i]
+		}
+	}
+	return -1, nil
+}
+
+func getPodIPs(p *corev1.Pod) []corev1.PodIP {
+	k8sPodIPs := p.Status.PodIPs
+	if len(k8sPodIPs) == 0 && p.Status.PodIP != "" {
+		k8sPodIPs = []corev1.PodIP{{IP: p.Status.PodIP}}
+	}
+	return k8sPodIPs
+}
+
 func augmentPodLabels(nodes krt.Collection[NodeMetadata]) func(kctx krt.HandlerContext, pod *corev1.Pod) *LocalityPod {
 	return func(kctx krt.HandlerContext, pod *corev1.Pod) *LocalityPod {
 		labels := maps.Clone(pod.Labels)
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index d8d61644c..142753844 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -79,7 +79,7 @@ func testAgentGatewayScenario(
 
 	// read the out file
 	fout := fpre + "-out" + fext
-	write := false
+	write := true
 	_, err := os.ReadFile(fout)
 	// if not exist
 	if os.IsNotExist(err) {
diff --git a/internal/kgateway/setup/setup.go b/internal/kgateway/setup/setup.go
index 511972f1a..707f5fa63 100644
--- a/internal/kgateway/setup/setup.go
+++ b/internal/kgateway/setup/setup.go
@@ -9,9 +9,7 @@ import (
 	xdsserver "github.com/envoyproxy/go-control-plane/pkg/server/v3"
 	"github.com/go-logr/logr"
 	istiokube "istio.io/istio/pkg/kube"
-	"istio.io/istio/pkg/kube/kclient"
 	"istio.io/istio/pkg/kube/krt"
-	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/client-go/rest"
 	"k8s.io/klog/v2"
@@ -215,13 +213,8 @@ func StartKgatewayWithConfig(
 
 	slog.Info("creating krt collections")
 	krtOpts := krtutil.NewKrtOptions(ctx.Done(), setupOpts.KrtDebugger)
-
-	podClient := kclient.NewFiltered[*corev1.Pod](kubeClient, kclient.Filter{
-		ObjectTransform: istiokube.StripPodUnusedFields,
-		ObjectFilter:    kubeClient.ObjectFilter(),
-	})
-	pods := krt.WrapClient(podClient, krtOpts.ToOptions("Pods")...)
-	augmentedPods := krtcollections.NewPodsCollection(kubeClient, pods, krtOpts)
+	
+	augmentedPods, _ := krtcollections.NewPodsCollection(kubeClient, krtOpts)
 	augmentedPodsForUcc := augmentedPods
 	if envutils.IsEnvTruthy("DISABLE_POD_LOCALITY_XDS") {
 		augmentedPodsForUcc = nil
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
new file mode 100644
index 000000000..50b05d5c4
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
@@ -0,0 +1,139 @@
+{
+  "addresses": [
+    {
+      "Type": {
+        "Service": {
+          "name": "http-httproute",
+          "namespace": "gwtest",
+          "hostname": "http-httproute.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAIg=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-2",
+          "name": "reviews-2",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQCDg=="
+          ],
+          "service_account": "default",
+          "node": "worker2",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-2",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
+    }
+  ],
+  "resources": [
+    {
+      "Kind": {
+        "Bind": {
+          "key": "8080/gwtest/http-httproute",
+          "port": 8080
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Listener": {
+          "key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
+          "name": "http",
+          "bind_key": "8080/gwtest/http-httproute",
+          "gateway_name": "gwtest/http-httproute",
+          "protocol": 1
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Route": {
+          "key": "gwtest.my-route.0.0.http",
+          "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
+          "route_name": "gwtest/my-route",
+          "hostnames": [
+            "www.example.com"
+          ],
+          "matches": [
+            {
+              "path": {
+                "Kind": {
+                  "PathPrefix": "/myapp"
+                }
+              }
+            }
+          ],
+          "backends": [
+            {
+              "Kind": {
+                "Service": "gwtest/reviews.gwtest.svc.cluster.local"
+              },
+              "weight": 1,
+              "port": 8080
+            }
+          ]
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Route": {
+          "key": "gwtest.my-route2.0.0.http",
+          "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
+          "route_name": "gwtest/my-route2",
+          "hostnames": [
+            "www.example2.com"
+          ],
+          "matches": [
+            {
+              "path": {
+                "Kind": {
+                  "PathPrefix": "/"
+                }
+              }
+            }
+          ],
+          "backends": [
+            {
+              "Kind": {
+                "Service": "gwtest/reviews.gwtest.svc.cluster.local"
+              },
+              "weight": 1,
+              "port": 8080
+            }
+          ]
+        }
+      }
+    }
+  ]
+}
\ No newline at end of file
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute.yaml b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
index edcd19181..d0c005d8c 100644
--- a/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute.yaml
@@ -1,9 +1,3 @@
-kind: GatewayClass
-apiVersion: gateway.networking.k8s.io/v1
-metadata:
-  name: agentgateway # TODO: fix in-memory class also works with env
-spec:
-  controllerName: kgateway.dev/kgateway
 ---
 kind: Gateway
 apiVersion: gateway.networking.k8s.io/v1
diff --git a/pkg/pluginsdk/collections/collections.go b/pkg/pluginsdk/collections/collections.go
index 478bbe96e..d92e9a596 100644
--- a/pkg/pluginsdk/collections/collections.go
+++ b/pkg/pluginsdk/collections/collections.go
@@ -41,7 +41,7 @@ type CommonCollections struct {
 	Services          krt.Collection[*corev1.Service]
 	ServiceEntries    krt.Collection[*networkingclient.ServiceEntry]
 
-	Pods         krt.Collection[*corev1.Pod] // TODO: refactor to ir that can work with agentgateway
+	WrappedPods  krt.Collection[krtcollections.WrappedPod]
 	LocalityPods krt.Collection[krtcollections.LocalityPod]
 	RefGrants    *krtcollections.RefGrantIndex
 	ConfigMaps   krt.Collection[*corev1.ConfigMap]
@@ -59,7 +59,7 @@ func (c *CommonCollections) HasSynced() bool {
 	return c.Secrets != nil && c.Secrets.HasSynced() &&
 		c.BackendIndex != nil && c.BackendIndex.HasSynced() &&
 		c.Routes != nil && c.Routes.HasSynced() &&
-		c.Pods != nil && c.Pods.HasSynced() &&
+		c.WrappedPods != nil && c.WrappedPods.HasSynced() &&
 		c.LocalityPods != nil && c.LocalityPods.HasSynced() &&
 		c.RefGrants != nil && c.RefGrants.HasSynced() &&
 		c.ConfigMaps != nil && c.ConfigMaps.HasSynced() &&
@@ -141,11 +141,7 @@ func NewCommonCollections(
 
 	gwExts := krtcollections.NewGatewayExtensionsCollection(ctx, client, ourClient, krtOptions)
 
-	podClient := kclient.NewFiltered[*corev1.Pod](client, kclient.Filter{
-		ObjectTransform: kube.StripPodUnusedFields,
-		ObjectFilter:    client.ObjectFilter(),
-	})
-	pods := krt.WrapClient(podClient, krtOptions.ToOptions("Pods")...)
+	localityPods, wrappedPods := krtcollections.NewPodsCollection(client, krtOptions)
 
 	return &CommonCollections{
 		OurClient:         ourClient,
@@ -153,8 +149,8 @@ func NewCommonCollections(
 		CrudClient:        cl,
 		KrtOpts:           krtOptions,
 		Secrets:           krtcollections.NewSecretIndex(secrets, refgrants),
-		LocalityPods:      krtcollections.NewPodsCollection(client, pods, krtOptions),
-		Pods:              pods,
+		LocalityPods:      localityPods,
+		WrappedPods:       wrappedPods,
 		RefGrants:         refgrants,
 		Settings:          settings,
 		Namespaces:        namespaces,
diff --git a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
index 0b9d62098..4cc108066 100644
--- a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
+++ b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
@@ -29,15 +29,26 @@ metadata:
 spec:
   gatewayClassName: agentgateway
   listeners:
-    - protocol: kgateway.dev/mcp
+    - protocol: HTTP
       port: 8080
-      name: mcp
+      name: http
       allowedRoutes:
         namespaces:
           from: All
-    - protocol: kgateway.dev/a2a
-      port: 9090
-      name: a2a
-      allowedRoutes:
-        namespaces:
-          from: All
\ No newline at end of file
+---
+apiVersion: gateway.networking.k8s.io/v1
+kind: HTTPRoute
+metadata:
+  name: httpbin
+  labels:
+    example: httpbin-route
+spec:
+  parentRefs:
+    - name: agent-gateway
+      namespace: default
+  hostnames:
+    - "www.example.com"
+  rules:
+    - backendRefs:
+        - name: httpbin
+          port: 8000
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)


From 0df6932fcd39cfecc95569c503410ab31ea2e3ad Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Tue, 1 Jul 2025 14:29:23 -0700
Subject: [PATCH 11/17] add inf pool

---
 .../kgateway/agentgatewaysyncer/README.md     | 11 ++-
 .../kgateway/agentgatewaysyncer/conversion.go | 32 +++----
 .../kgateway/agentgatewaysyncer/service.go    | 18 ++--
 .../kgateway/agentgatewaysyncer/syncer.go     | 32 ++++++-
 .../kgateway/agentgatewaysyncer/workloads.go  | 36 ++------
 internal/kgateway/setup/setup.go              |  2 +-
 .../testdata/agentgateway/httproute-out.json  | 18 ++--
 .../agentgateway/inferencepool-out.json       | 90 +++++++++++++++++++
 .../testdata/agentgateway/inferencepool.yaml  | 65 ++++++++++++++
 9 files changed, 237 insertions(+), 67 deletions(-)
 create mode 100644 internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
 create mode 100644 internal/kgateway/setup/testdata/agentgateway/inferencepool.yaml

diff --git a/internal/kgateway/agentgatewaysyncer/README.md b/internal/kgateway/agentgatewaysyncer/README.md
index 34de8ac44..97441e8bb 100644
--- a/internal/kgateway/agentgatewaysyncer/README.md
+++ b/internal/kgateway/agentgatewaysyncer/README.md
@@ -6,6 +6,11 @@ This syncer configures xds updates for the [agentgateway](https://agentgateway.d
 
 The syncer uses the following APIs:
 
-- [a2a](https://github.com/agentgateway/agentgateway/tree/main/go/api/a2a/a2a)
-- [mcp](https://github.com/agentgateway/agentgateway/tree/main/go/api/mcp/mcp)
-- [listener](https://github.com/agentgateway/agentgateway/tree/main/go/api/listener)
+- [workload](https://github.com/agentgateway/agentgateway/tree/main/go/api/workload.pb.go)
+- [resource](https://github.com/agentgateway/agentgateway/tree/main/go/api/resource.pb.go)
+
+### Conformance tests
+
+```
+make run HELM_ADDITIONAL_VALUES=test/kubernetes/e2e/tests/manifests/agent-gateway-integration.yaml; CONFORMANCE_GATEWAY_CLASS=agentgateway make conformance 
+```
\ No newline at end of file
diff --git a/internal/kgateway/agentgatewaysyncer/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
index 4ec932dbc..0a391271a 100644
--- a/internal/kgateway/agentgatewaysyncer/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -234,22 +234,22 @@ func buildADPDestination(
 	}
 	var port *k8s.PortNumber
 	ref := normalizeReference(to.Group, to.Kind, wellknown.ServiceGVK)
-	switch ref {
-	//case wellknown.InferencePoolGVK:
-	//	if strings.Contains(string(to.Name), ".") {
-	//		return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
-	//	}
-	//	hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
-	//	key := namespace + "/" + string(to.Name)
-	//	svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
-	//	log.Errorf("howardjohn: got pool %v for %v", svc, key)
-	//	if svc == nil {
-	//		invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
-	//	} else {
-	//		port = ptr.Of(k8s.PortNumber(svc.Spec.TargetPortNumber))
-	//	}
-	//	rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
-	case wellknown.ServiceGVK:
+	switch ref.GroupKind() {
+	case wellknown.InferencePoolGVK.GroupKind():
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+		logger.Debug("Found pull pool for service", "svc", svc, "key", key)
+		if svc == nil {
+			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		} else {
+			port = ptr.Of(k8s.PortNumber(svc.Spec.TargetPortNumber))
+		}
+		rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
+	case wellknown.ServiceGVK.GroupKind():
 		port = to.Port
 		if strings.Contains(string(to.Name), ".") {
 			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
index 08476a401..efcb3a363 100644
--- a/internal/kgateway/agentgatewaysyncer/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -43,17 +43,19 @@ import (
 func (a *index) ServicesCollection(
 	services krt.Collection[*v1.Service],
 	serviceEntries krt.Collection[*networkingclient.ServiceEntry],
+	inferencePools krt.Collection[*inf.InferencePool],
 	namespaces krt.Collection[*v1.Namespace],
 	krtopts krtutil.KrtOptions,
 ) krt.Collection[ServiceInfo] {
-	ServicesInfo := krt.NewCollection(services, a.serviceServiceBuilder(namespaces),
+	servicesInfo := krt.NewCollection(services, a.serviceServiceBuilder(namespaces),
 		krtopts.ToOptions("ServicesInfo")...)
 	//ServiceEntriesInfo := krt.NewManyCollection(serviceEntries, a.serviceEntryServiceBuilder(namespaces),
 	//	krtopts.ToOptions("ServiceEntriesInfo")...)
-	// TODO: add inference pool to svc collection
+	inferencePoolsInfo := krt.NewCollection(inferencePools, a.inferencePoolBuilder(namespaces),
+		krtopts.ToOptions("InferencePools")...)
 	//WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{ServicesInfo, ServiceEntriesInfo}, krtopts.ToOptions("WorkloadService")...)
 
-	WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{ServicesInfo}, krtopts.ToOptions("WorkloadService")...)
+	WorkloadServices := krt.JoinCollection([]krt.Collection[ServiceInfo]{servicesInfo, inferencePoolsInfo}, krtopts.ToOptions("WorkloadService")...)
 	return WorkloadServices
 }
 
@@ -119,7 +121,13 @@ func (a *index) inferencePoolBuilder(
 			Service:       svc,
 			PortNames:     portNames,
 			LabelSelector: NewSelector(selector),
-			Source:        MakeSource(s),
+			Source: TypedObject{
+				NamespacedName: types.NamespacedName{
+					Namespace: s.Namespace,
+					Name:      s.Name,
+				},
+				Kind: "InferencePool", // TODO: get wellknown kind
+			},
 		})
 	}
 }
@@ -665,7 +673,7 @@ func (i AddressInfo) ResourceName() string {
 
 type TypedObject struct {
 	types.NamespacedName
-	Kind kind.Kind
+	Kind string
 }
 
 type ServicePortName struct {
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index f2540d736..6d5e07658 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -13,6 +13,7 @@ import (
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
+	"istio.io/istio/pkg/config/schema/kubeclient"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/kclient"
@@ -20,14 +21,20 @@ import (
 	"istio.io/istio/pkg/kube/kubetypes"
 	corev1 "k8s.io/api/core/v1"
 	discoveryv1 "k8s.io/api/discovery/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/sets"
+	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/tools/cache"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	"sigs.k8s.io/gateway-api-inference-extension/client-go/clientset/versioned"
 	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
 
@@ -180,6 +187,25 @@ type Inputs struct {
 func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	logger.Debug("init agentgateway Syncer", "controllername", s.controllerName)
 
+	// TODO: move this
+	// Create the inference extension clientset.
+	inferencePoolGVR := wellknown.InferencePoolGVK.GroupVersion().WithResource("inferencepools")
+	infCli, err := versioned.NewForConfig(s.commonCols.Client.RESTConfig())
+	if err != nil {
+		logger.Error("failed to create inference extension client", "error", err)
+	} else {
+		kubeclient.Register[*inf.InferencePool](
+			inferencePoolGVR,
+			wellknown.InferencePoolGVK,
+			func(c kubeclient.ClientGetter, namespace string, o metav1.ListOptions) (runtime.Object, error) {
+				return infCli.InferenceV1alpha2().InferencePools(namespace).List(context.Background(), o)
+			},
+			func(c kubeclient.ClientGetter, namespace string, o metav1.ListOptions) (watch.Interface, error) {
+				return infCli.InferenceV1alpha2().InferencePools(namespace).Watch(context.Background(), o)
+			},
+		)
+	}
+
 	inputs := Inputs{
 		Namespaces: krt.NewInformer[*corev1.Namespace](s.client),
 		Secrets: krt.WrapClient[*corev1.Secret](
@@ -199,7 +225,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 		ReferenceGrants: krt.WrapClient(kclient.New[*gateway.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
 		//ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
-		//InferencePools:  krt.WrapClient(kclient.New[*inf.InferencePool](s.client), krtopts.ToOptions("informer/InferencePools")...),
+		InferencePools: krt.WrapClient(kclient.NewDelayedInformer[*inf.InferencePool](s.client, inferencePoolGVR, kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()}), krtopts.ToOptions("informer/InferencePools")...),
 	}
 	if features.EnableAlphaGatewayAPI {
 		inputs.TCPRoutes = krt.WrapClient(kclient.New[*gatewayalpha.TCPRoute](s.client), krtopts.ToOptions("informer/TCPRoutes")...)
@@ -335,8 +361,6 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	//serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("informer/ServiceEntries")...)
 
 	workloadIndex := index{
-		services:        servicesCollection{},
-		workloads:       workloadsCollection{},
 		namespaces:      s.commonCols.Namespaces,
 		SystemNamespace: s.systemNamespace,
 		ClusterID:       s.clusterID,
@@ -345,7 +369,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 	// these are agw api-style services combined from kube services and service entries
 	//WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, serviceEntries, namespaces, krtopts)
-	workloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, namespaces, krtopts)
+	workloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, inputs.InferencePools, namespaces, krtopts)
 	svcAddresses := krt.NewCollection(workloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
 		var cacheResources []envoytypes.Resource
 		addrMessage := obj.AsAddress.Address
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
index 2adbc36ef..5b7457aba 100644
--- a/internal/kgateway/agentgatewaysyncer/workloads.go
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -6,7 +6,6 @@ import (
 	"strings"
 
 	"github.com/agentgateway/agentgateway/go/api"
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
 	"istio.io/api/annotation"
 	"istio.io/api/label"
@@ -36,19 +35,11 @@ import (
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 )
 
-// internal object used for indexing in ambientindex maps
-type networkAddress struct {
-	network string
-	ip      string
-}
-
-func (n networkAddress) String() string {
-	return n.network + "/" + n.ip
-}
-
 type NamespaceHostname struct {
 	Namespace string
 	Hostname  string
@@ -58,22 +49,9 @@ func (n NamespaceHostname) String() string {
 	return n.Namespace + "/" + n.Hostname
 }
 
-type workloadsCollection struct {
-	krt.Collection[WorkloadInfo]
-	ByAddress    krt.Index[networkAddress, WorkloadInfo]
-	ByServiceKey krt.Index[string, WorkloadInfo]
-}
-
-type servicesCollection struct {
-	krt.Collection[ServiceInfo]
-	ByAddress krt.Index[networkAddress, ServiceInfo]
-}
-
 // index maintains an index of ambient WorkloadInfo objects by various keys.
 // These are intentionally pre-computed based on events such that lookups are efficient.
 type index struct {
-	services   servicesCollection
-	workloads  workloadsCollection
 	namespaces krt.Collection[krtcollections.NamespaceMetadata]
 
 	SystemNamespace string
@@ -174,7 +152,7 @@ func (a *index) podWorkloadBuilder(
 		fo := []krt.FetchOption{krt.FilterIndex(workloadServicesNamespaceIndex, p.Namespace), krt.FilterSelectsNonEmpty(p.Labels)}
 		if !features.EnableServiceEntrySelectPods {
 			fo = append(fo, krt.FilterGeneric(func(a any) bool {
-				return a.(ServiceInfo).Source.Kind == kind.Service
+				return a.(ServiceInfo).Source.Kind == kind.Service.String()
 			}))
 		}
 		services := krt.Fetch(ctx, workloadServices, fo...)
@@ -263,7 +241,7 @@ func (a *index) matchingServicesWithoutSelectors(
 		serviceKey := es.Namespace + "/" + hostname
 		svcs := krt.Fetch(ctx, workloadServices, krt.FilterKey(serviceKey), krt.FilterGeneric(func(a any) bool {
 			// Only find Service, not Service Entry
-			return a.(ServiceInfo).Source.Kind == kind.Service
+			return a.(ServiceInfo).Source.Kind == kind.Service.String()
 		}))
 		if len(svcs) == 0 {
 			// no service found
@@ -298,7 +276,7 @@ func (a *index) serviceEntriesInfo(ctx krt.HandlerContext, s *networkingclient.S
 func MakeSource(o controllers.Object) TypedObject {
 	return TypedObject{
 		NamespacedName: config.NamespacedName(o),
-		Kind:           kind.MustFromGVK(kubetypes.GvkFromObject(o)),
+		Kind:           kubetypes.GvkFromObject(o).Kind,
 	}
 }
 
@@ -542,7 +520,7 @@ func (a *index) endpointSlicesBuilder(
 		serviceKey := es.Namespace + "/" + string(kube.ServiceHostname(serviceName, es.Namespace, a.DomainSuffix))
 		svcs := krt.Fetch(ctx, workloadServices, krt.FilterKey(serviceKey), krt.FilterGeneric(func(a any) bool {
 			// Only find Service, not Service Entry
-			return a.(ServiceInfo).Source.Kind == kind.Service
+			return a.(ServiceInfo).Source.Kind == kind.Service.String()
 		}))
 		if len(svcs) == 0 {
 			// no service found
@@ -673,7 +651,7 @@ func constructServicesFromWorkloadEntry(p *networkingv1alpha3.WorkloadEntry, ser
 		for _, port := range svc.Service.Ports {
 			targetPort := port.TargetPort
 			// Named targetPort has different semantics from Service vs ServiceEntry
-			if svc.Source.Kind == kind.Service {
+			if svc.Source.Kind == kind.Service.String() {
 				// Service has explicit named targetPorts.
 				if named, f := svc.PortNames[int32(port.ServicePort)]; f && named.TargetPortName != "" {
 					// This port is a named target port, look it up
diff --git a/internal/kgateway/setup/setup.go b/internal/kgateway/setup/setup.go
index 707f5fa63..696ca8e11 100644
--- a/internal/kgateway/setup/setup.go
+++ b/internal/kgateway/setup/setup.go
@@ -213,7 +213,7 @@ func StartKgatewayWithConfig(
 
 	slog.Info("creating krt collections")
 	krtOpts := krtutil.NewKrtOptions(ctx.Done(), setupOpts.KrtDebugger)
-	
+
 	augmentedPods, _ := krtcollections.NewPodsCollection(kubeClient, krtOpts)
 	augmentedPodsForUcc := augmentedPods
 	if envutils.IsEnvTruthy("DISABLE_POD_LOCALITY_XDS") {
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
index 50b05d5c4..ffe45fe88 100644
--- a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
@@ -8,7 +8,7 @@
           "hostname": "http-httproute.gwtest.svc.cluster.local",
           "addresses": [
             {
-              "address": "CgAAIg=="
+              "address": "CgAAhA=="
             }
           ],
           "ports": [
@@ -78,17 +78,17 @@
     {
       "Kind": {
         "Route": {
-          "key": "gwtest.my-route.0.0.http",
+          "key": "gwtest.my-route2.0.0.http",
           "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
-          "route_name": "gwtest/my-route",
+          "route_name": "gwtest/my-route2",
           "hostnames": [
-            "www.example.com"
+            "www.example2.com"
           ],
           "matches": [
             {
               "path": {
                 "Kind": {
-                  "PathPrefix": "/myapp"
+                  "PathPrefix": "/"
                 }
               }
             }
@@ -108,17 +108,17 @@
     {
       "Kind": {
         "Route": {
-          "key": "gwtest.my-route2.0.0.http",
+          "key": "gwtest.my-route.0.0.http",
           "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
-          "route_name": "gwtest/my-route2",
+          "route_name": "gwtest/my-route",
           "hostnames": [
-            "www.example2.com"
+            "www.example.com"
           ],
           "matches": [
             {
               "path": {
                 "Kind": {
-                  "PathPrefix": "/"
+                  "PathPrefix": "/myapp"
                 }
               }
             }
diff --git a/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
new file mode 100644
index 000000000..bb4023240
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
@@ -0,0 +1,90 @@
+{
+  "addresses": [
+    {
+      "Type": {
+        "Service": {
+          "name": "gateway-pool",
+          "namespace": "gwtest",
+          "hostname": "gateway-pool.gwtest.inference.cluster.local",
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080,
+              "app_protocol": 1
+            }
+          ]
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-2",
+          "name": "reviews-2",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQCDg=="
+          ],
+          "service_account": "default",
+          "node": "worker2",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-2",
+          "status": 1
+        }
+      }
+    }
+  ],
+  "resources": [
+    {
+      "Kind": {
+        "Route": {
+          "key": "gwtest.gateway-route.0.0.http",
+          "listener_key": "http-inferencepool-agentgateway-autogenerated-k8s-gateway-http",
+          "route_name": "gwtest/gateway-route",
+          "hostnames": [
+            "www.example.com"
+          ],
+          "matches": [
+            {
+              "path": {
+                "Kind": {
+                  "PathPrefix": "/"
+                }
+              }
+            }
+          ],
+          "backends": [
+            {
+              "Kind": {
+                "Service": "gwtest/gateway-pool.gwtest.inference.cluster.local"
+              },
+              "weight": 1,
+              "port": 8080
+            }
+          ]
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Bind": {
+          "key": "8080/gwtest/http-inferencepool",
+          "port": 8080
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Listener": {
+          "key": "http-inferencepool-agentgateway-autogenerated-k8s-gateway-http",
+          "name": "http",
+          "bind_key": "8080/gwtest/http-inferencepool",
+          "gateway_name": "gwtest/http-inferencepool",
+          "protocol": 1
+        }
+      }
+    }
+  ]
+}
\ No newline at end of file
diff --git a/internal/kgateway/setup/testdata/agentgateway/inferencepool.yaml b/internal/kgateway/setup/testdata/agentgateway/inferencepool.yaml
new file mode 100644
index 000000000..7782b7a4c
--- /dev/null
+++ b/internal/kgateway/setup/testdata/agentgateway/inferencepool.yaml
@@ -0,0 +1,65 @@
+# One Gateway with one HTTPRoute referencing one InferencePool
+---
+kind: Gateway
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: http-gw-for-test
+  namespace: gwtest
+spec:
+  gatewayClassName: agentgateway
+  listeners:
+    - protocol: HTTP
+      port: 8080
+      name: http
+      allowedRoutes:
+        namespaces:
+          from: All
+---
+apiVersion: gateway.networking.k8s.io/v1beta1
+kind: HTTPRoute
+metadata:
+  name: gateway-route
+  namespace: gwtest
+spec:
+  parentRefs:
+    - name: http-gw-for-test
+  hostnames:
+    - "www.example.com"
+  rules:
+    - backendRefs:
+        - name: gateway-pool
+          kind: InferencePool
+          group: inference.networking.x-k8s.io
+          weight: 1
+---
+# This service is auto created by the inference extension deployer but it's created
+# here for clean-up purposes (avoid test pollution). Repeat for additional endpoint
+# picker tests or until test cases are run in parallel.
+apiVersion: v1
+kind: Service
+metadata:
+  name: gateway-pool-endpoint-picker
+  namespace: gwtest
+spec:
+  ports:
+    - name: grpc
+      port: 9002
+      targetPort: 9002
+  selector:
+    app: gateway
+---
+apiVersion: inference.networking.x-k8s.io/v1alpha2
+kind: InferencePool
+metadata:
+  name: gateway-pool
+  namespace: gwtest
+spec:
+  extensionRef:
+    failureMode: FailClose
+    group: ""
+    kind: Service
+    name: gateway-pool-endpoint-picker
+    portNumber: 9002
+  selector:
+    app: gateway
+  targetPortNumber: 8080
-- 
2.39.5 (Apple Git-154)


From 83506bf5a993fc9690ea64af598316706003f46b Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Wed, 2 Jul 2025 11:59:03 -0700
Subject: [PATCH 12/17] use gwv1

---
 api/applyconfiguration/internal/internal.go   |   3 +
 go.mod                                        |  48 +--
 go.sum                                        |  86 +++--
 hack/utils/oss_compliance/osa_provided.md     |  14 +-
 ...ay.kgateway.dev_backendconfigpolicies.yaml |  17 +-
 .../gateway.kgateway.dev_backends.yaml        |  56 +++-
 .../gateway.kgateway.dev_directresponses.yaml |   2 +-
 ...ateway.kgateway.dev_gatewayextensions.yaml |   2 +-
 ...ateway.kgateway.dev_gatewayparameters.yaml |   8 +-
 ...way.kgateway.dev_httplistenerpolicies.yaml |   7 +-
 .../gateway.kgateway.dev_trafficpolicies.yaml |  22 +-
 internal/kgateway/agentgatewaysyncer/adp.go   |  56 ++--
 .../kgateway/agentgatewaysyncer/conditions.go |  62 ++--
 .../kgateway/agentgatewaysyncer/conversion.go | 295 +++++++++---------
 .../agentgatewaysyncer/gateway_collection.go  |  42 ++-
 .../gatewayclass_collection.go                |  14 +-
 .../references_collection.go                  |  20 +-
 .../agentgatewaysyncer/route_collections.go   |  39 ++-
 .../kgateway/agentgatewaysyncer/syncer.go     |  62 ++--
 .../kgateway/agentgatewaysyncer/workloads.go  |   4 +-
 internal/kgateway/setup/agentgateway_test.go  |   2 +-
 .../testdata/agentgateway/httproute-out.json  |  28 +-
 .../agentgateway/inferencepool-out.json       |  48 +--
 .../versioned/fake/clientset_generated.go     |  13 +-
 .../typed/api/v1alpha1/api_client.go          |  12 +-
 pkg/generated/openapi/zz_generated.openapi.go | 141 +++++++--
 26 files changed, 662 insertions(+), 441 deletions(-)

diff --git a/api/applyconfiguration/internal/internal.go b/api/applyconfiguration/internal/internal.go
index 55aea752b..d0fff61fa 100644
--- a/api/applyconfiguration/internal/internal.go
+++ b/api/applyconfiguration/internal/internal.go
@@ -2255,6 +2255,9 @@ var schemaYAML = typed.YAMLObject(`types:
     - name: preStop
       type:
         namedType: io.k8s.api.core.v1.LifecycleHandler
+    - name: stopSignal
+      type:
+        scalar: string
 - name: io.k8s.api.core.v1.LifecycleHandler
   map:
     fields:
diff --git a/go.mod b/go.mod
index b68a5c1c6..ad0627a85 100644
--- a/go.mod
+++ b/go.mod
@@ -21,7 +21,7 @@ require (
 	github.com/kelseyhightower/envconfig v1.4.0
 	github.com/mitchellh/hashstructure v1.0.0
 	github.com/onsi/ginkgo/v2 v2.23.3
-	github.com/onsi/gomega v1.36.3
+	github.com/onsi/gomega v1.37.0
 	github.com/pkg/errors v0.9.1
 	github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966
 	github.com/solo-io/go-list-licenses v0.1.4
@@ -32,17 +32,17 @@ require (
 	go.opencensus.io v0.24.0
 	go.uber.org/zap v1.27.0
 	golang.org/x/exp v0.0.0-20241215155358-4a5509556b9e
-	golang.org/x/net v0.40.0
+	golang.org/x/net v0.41.0
 	google.golang.org/grpc v1.72.0
 	google.golang.org/protobuf v1.36.6
 	helm.sh/helm/v3 v3.17.3
 	istio.io/api v1.25.0-alpha.0.0.20250210220544-0b64afd2de85
 	istio.io/client-go v1.25.0-alpha.0.0.20250210220843-5a4065fded65
 	istio.io/istio v0.0.0-20250212203644-c2ac935c5888
-	k8s.io/api v0.32.3
-	k8s.io/apiextensions-apiserver v0.32.3
-	k8s.io/apimachinery v0.32.3
-	k8s.io/client-go v0.32.3
+	k8s.io/api v0.33.2
+	k8s.io/apiextensions-apiserver v0.33.2
+	k8s.io/apimachinery v0.33.2
+	k8s.io/client-go v0.33.2
 	k8s.io/klog/v2 v2.130.1
 	k8s.io/kube-openapi v0.0.0-20250318190949-c8a335a9a2ff
 	k8s.io/utils v0.0.0-20241210054802-24370beab758
@@ -295,7 +295,7 @@ require (
 	github.com/goccy/go-json v0.10.5 // indirect
 	github.com/gofrs/flock v0.12.1 // indirect
 	github.com/gogo/protobuf v1.3.2
-	github.com/golang-jwt/jwt/v4 v4.5.1 // indirect
+	github.com/golang-jwt/jwt/v4 v4.5.2 // indirect
 	github.com/golang-jwt/jwt/v5 v5.2.1 // indirect
 	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
 	github.com/golang/protobuf v1.5.4 // indirect
@@ -309,12 +309,11 @@ require (
 	github.com/golangci/revgrep v0.8.0 // indirect
 	github.com/golangci/unconvert v0.0.0-20250410112200-a129a6e6413e // indirect
 	github.com/google/btree v1.1.3 // indirect
-	github.com/google/cel-go v0.22.1 // indirect
+	github.com/google/cel-go v0.23.2 // indirect
 	github.com/google/gnostic-models v0.6.9 // indirect
 	github.com/google/go-containerregistry v0.20.3 // indirect
 	github.com/google/go-github/v68 v68.0.0 // indirect
 	github.com/google/go-querystring v1.1.0 // indirect
-	github.com/google/gofuzz v1.2.0 // indirect
 	github.com/google/ko v0.17.1 // indirect
 	github.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad // indirect
 	github.com/google/rpmpack v0.6.1-0.20240329070804-c2247cbb881a // indirect
@@ -331,7 +330,7 @@ require (
 	github.com/goreleaser/goreleaser/v2 v2.5.1 // indirect
 	github.com/goreleaser/nfpm/v2 v2.41.1 // indirect
 	github.com/gorilla/mux v1.8.1 // indirect
-	github.com/gorilla/websocket v1.5.3 // indirect
+	github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674 // indirect
 	github.com/gostaticanalysis/analysisutil v0.7.1 // indirect
 	github.com/gostaticanalysis/comment v1.5.0 // indirect
 	github.com/gostaticanalysis/forcetypeassert v0.2.0 // indirect
@@ -379,7 +378,7 @@ require (
 	github.com/kevinburke/ssh_config v1.2.0 // indirect
 	github.com/kisielk/errcheck v1.9.0 // indirect
 	github.com/kkHAIKE/contextcheck v1.1.6 // indirect
-	github.com/klauspost/compress v1.17.11 // indirect
+	github.com/klauspost/compress v1.18.0 // indirect
 	github.com/klauspost/cpuid/v2 v2.2.7 // indirect
 	github.com/klauspost/pgzip v1.2.6 // indirect
 	github.com/kulti/thelper v0.6.3 // indirect
@@ -464,7 +463,7 @@ require (
 	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
 	github.com/polydawn/refmt v0.89.1-0.20221221234430-40501e09de1f // indirect
 	github.com/polyfloyd/go-errorlint v1.8.0 // indirect
-	github.com/prometheus/client_golang v1.21.1
+	github.com/prometheus/client_golang v1.22.0
 	github.com/prometheus/client_model v0.6.2
 	github.com/prometheus/common v0.62.0 // indirect
 	github.com/prometheus/procfs v0.15.1 // indirect
@@ -485,7 +484,6 @@ require (
 	github.com/ryanrolds/sqlclosecheck v0.5.1 // indirect
 	github.com/sagikazarmark/locafero v0.6.0 // indirect
 	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
-	github.com/saiskee/gettercheck v0.0.0-20210820204958-38443d06ebe0 // indirect
 	github.com/sanposhiho/wastedassign/v2 v2.1.0 // indirect
 	github.com/santhosh-tekuri/jsonschema/v6 v6.0.1 // indirect
 	github.com/sashamelentyev/interfacebloat v1.1.0 // indirect
@@ -569,16 +567,16 @@ require (
 	go.uber.org/automaxprocs v1.6.0 // indirect
 	go.uber.org/multierr v1.11.0 // indirect
 	gocloud.dev v0.40.0 // indirect
-	golang.org/x/crypto v0.38.0 // indirect
+	golang.org/x/crypto v0.39.0 // indirect
 	golang.org/x/exp/typeparams v0.0.0-20250210185358-939b2ce775ac // indirect
-	golang.org/x/mod v0.24.0 // indirect
+	golang.org/x/mod v0.25.0 // indirect
 	golang.org/x/oauth2 v0.28.0 // indirect
-	golang.org/x/sync v0.14.0 // indirect
+	golang.org/x/sync v0.15.0 // indirect
 	golang.org/x/sys v0.33.0 // indirect
 	golang.org/x/term v0.32.0 // indirect
-	golang.org/x/text v0.25.0 // indirect
+	golang.org/x/text v0.26.0 // indirect
 	golang.org/x/time v0.11.0 // indirect
-	golang.org/x/tools v0.32.0 // indirect
+	golang.org/x/tools v0.34.0 // indirect
 	golang.org/x/xerrors v0.0.0-20240716161551-93cc26a95ae9 // indirect
 	gomodules.xyz/jsonpatch/v2 v2.4.0 // indirect
 	google.golang.org/api v0.228.0 // indirect
@@ -594,18 +592,18 @@ require (
 	gopkg.in/yaml.v2 v2.4.0 // indirect
 	gopkg.in/yaml.v3 v3.0.1 // indirect
 	honnef.co/go/tools v0.6.1 // indirect
-	k8s.io/apiserver v0.32.3 // indirect
+	k8s.io/apiserver v0.33.2 // indirect
 	k8s.io/cli-runtime v0.32.3 // indirect
-	k8s.io/code-generator v0.32.3 // indirect
-	k8s.io/component-base v0.32.3 // indirect
-	k8s.io/gengo/v2 v2.0.0-20240911193312-2b36238f13e9 // indirect
+	k8s.io/code-generator v0.33.2 // indirect
+	k8s.io/component-base v0.33.2 // indirect
+	k8s.io/gengo/v2 v2.0.0-20250207200755-1244d31929d7 // indirect
 	k8s.io/kubectl v0.32.3 // indirect
 	lukechampine.com/blake3 v1.2.1 // indirect
 	mvdan.cc/gofumpt v0.8.0 // indirect
 	mvdan.cc/unparam v0.0.0-20250301125049-0df0534333a4 // indirect
 	oras.land/oras-go v1.2.5 // indirect
 	sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235 // indirect
-	sigs.k8s.io/controller-tools v0.17.3 // indirect
+	sigs.k8s.io/controller-tools v0.18.1-0.20250625175829-8d11ce77f347 // indirect
 	sigs.k8s.io/json v0.0.0-20241014173422-cfa47c3a1cc8 // indirect
 	sigs.k8s.io/kind v0.27.0 // indirect
 	sigs.k8s.io/kustomize/api v0.18.0 // indirect
@@ -615,6 +613,9 @@ require (
 	software.sslmate.com/src/go-pkcs12 v0.5.0 // indirect
 )
 
+// Remove once https://github.com/kubernetes-sigs/controller-tools/pull/1224 merges
+replace sigs.k8s.io/controller-tools => github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132
+
 replace (
 	github.com/agentgateway/agentgateway => github.com/solo-io/agentgateway-enterprise v0.0.0-20250626235044-bb6ced925fc3
 	github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
@@ -630,7 +631,6 @@ tool (
 	github.com/goreleaser/goreleaser/v2
 	github.com/mikefarah/yq/v4
 	github.com/onsi/ginkgo/v2/ginkgo
-	github.com/saiskee/gettercheck
 	golang.org/x/tools/cmd/goimports
 	helm.sh/helm/v3/cmd/helm
 	k8s.io/code-generator/cmd/applyconfiguration-gen
diff --git a/go.sum b/go.sum
index a11c7cc53..6bc3d7835 100644
--- a/go.sum
+++ b/go.sum
@@ -783,8 +783,8 @@ github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69
 github.com/golang-jwt/jwt/v4 v4.0.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=
 github.com/golang-jwt/jwt/v4 v4.2.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=
 github.com/golang-jwt/jwt/v4 v4.5.0/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
-github.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=
-github.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
+github.com/golang-jwt/jwt/v4 v4.5.2 h1:YtQM7lnr8iZ+j5q71MGKkNw9Mn7AjHM68uc9g5fXeUI=
+github.com/golang-jwt/jwt/v4 v4.5.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
 github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
 github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
 github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
@@ -858,8 +858,8 @@ github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Z
 github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
 github.com/google/btree v1.1.3 h1:CVpQJjYgC4VbzxeGVHfvZrv1ctoYCAI8vbl07Fcxlyg=
 github.com/google/btree v1.1.3/go.mod h1:qOPhT0dTNdNzV6Z/lhRX0YXUafgPLFUh+gZMl761Gm4=
-github.com/google/cel-go v0.22.1 h1:AfVXx3chM2qwoSbM7Da8g8hX8OVSkBFwX+rz2+PcK40=
-github.com/google/cel-go v0.22.1/go.mod h1:BuznPXXfQDpXKWQ9sPW3TzlAJN5zzFe+i9tIs0yC4s8=
+github.com/google/cel-go v0.23.2 h1:UdEe3CvQh3Nv+E/j9r1Y//WO0K0cSyD7/y0bzyLIMI4=
+github.com/google/cel-go v0.23.2/go.mod h1:52Pb6QsDbC5kvgxvZhiL9QX1oZEkcUF/ZqaPx1J5Wwo=
 github.com/google/gnostic-models v0.6.9 h1:MU/8wDLif2qCXZmzncUQ/BOfxWfthHi63KqpoNbWqVw=
 github.com/google/gnostic-models v0.6.9/go.mod h1:CiWsm0s6BSQd1hRn8/QmxqB6BesYcbSZxsz9b0KuDBw=
 github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
@@ -977,8 +977,8 @@ github.com/gorilla/sessions v1.2.1/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/z
 github.com/gorilla/websocket v0.0.0-20170926233335-4201258b820c/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
 github.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
 github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
-github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
-github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
+github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674 h1:JeSE6pjso5THxAzdVpqr6/geYxZytqFMBCOtn/ujyeo=
+github.com/gorilla/websocket v1.5.4-0.20250319132907-e064f32e3674/go.mod h1:r4w70xmWCQKmi1ONH4KIaBptdivuRPyosB9RmPlGEwA=
 github.com/gostaticanalysis/analysisutil v0.7.1 h1:ZMCjoue3DtDWQ5WyU16YbjbQEQ3VuzwxALrpYd+HeKk=
 github.com/gostaticanalysis/analysisutil v0.7.1/go.mod h1:v21E3hY37WKMGSnbsw2S/ojApNWb6C1//mXO48CXbVc=
 github.com/gostaticanalysis/comment v1.4.1/go.mod h1:ih6ZxzTHLdadaiSnF5WY3dxUoXfXAlTaRzuaNDlSado=
@@ -1176,8 +1176,8 @@ github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+o
 github.com/kkHAIKE/contextcheck v1.1.6 h1:7HIyRcnyzxL9Lz06NGhiKvenXq7Zw6Q0UQu/ttjfJCE=
 github.com/kkHAIKE/contextcheck v1.1.6/go.mod h1:3dDbMRNBFaq8HFXWC1JyvDSPm43CmE6IuHam8Wr0rkg=
 github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
-github.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=
-github.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=
+github.com/klauspost/compress v1.18.0 h1:c/Cqfb0r+Yi+JtIEq73FWXVkRonBlf0CRNYc8Zttxdo=
+github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=
 github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=
 github.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=
 github.com/klauspost/pgzip v1.2.6 h1:8RXeL5crjEUFnR2/Sn6GJNWtSQ3Dk8pq4CL3jvdDyjU=
@@ -1410,8 +1410,8 @@ github.com/onsi/gomega v1.7.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1Cpa
 github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
 github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
 github.com/onsi/gomega v1.16.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=
-github.com/onsi/gomega v1.36.3 h1:hID7cr8t3Wp26+cYnfcjR6HpJ00fdogN6dqZ1t6IylU=
-github.com/onsi/gomega v1.36.3/go.mod h1:8D9+Txp43QWKhM24yyOBEdpkzN8FvJyAwecBgsU4KU0=
+github.com/onsi/gomega v1.37.0 h1:CdEG8g0S133B4OswTDC/5XPSzE1OeP29QOioj2PID2Y=
+github.com/onsi/gomega v1.37.0/go.mod h1:8D9+Txp43QWKhM24yyOBEdpkzN8FvJyAwecBgsU4KU0=
 github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
 github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
 github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
@@ -1485,8 +1485,8 @@ github.com/prometheus/client_golang v1.11.0/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqr
 github.com/prometheus/client_golang v1.12.1/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=
 github.com/prometheus/client_golang v1.12.2/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=
 github.com/prometheus/client_golang v1.13.0/go.mod h1:vTeo+zgvILHsnnj/39Ou/1fPN5nJFOEMgftOUOmlvYQ=
-github.com/prometheus/client_golang v1.21.1 h1:DOvXXTqVzvkIewV/CDPFdejpMCGeMcbGCQ8YOmu+Ibk=
-github.com/prometheus/client_golang v1.21.1/go.mod h1:U9NM32ykUErtVBxdvD3zfi+EuFkkaBvMb09mIfe0Zgg=
+github.com/prometheus/client_golang v1.22.0 h1:rb93p9lokFEsctTys46VnV1kLCDpVZ0a/Y92Vm0Zc6Q=
+github.com/prometheus/client_golang v1.22.0/go.mod h1:R7ljNsLXhuQXYZYtw6GAE9AZg8Y7vEW5scdCXrWRXC0=
 github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
 github.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
 github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
@@ -1578,8 +1578,6 @@ github.com/sagikazarmark/locafero v0.6.0 h1:ON7AQg37yzcRPU69mt7gwhFEBwxI6P9T4Qu3
 github.com/sagikazarmark/locafero v0.6.0/go.mod h1:77OmuIc6VTraTXKXIs/uvUxKGUXjE1GbemJYHqdNjX0=
 github.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6gto+ugjYE=
 github.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=
-github.com/saiskee/gettercheck v0.0.0-20210820204958-38443d06ebe0 h1:04ip5n8Ct3tP0dpw9oO7vs4BFbaPhZ4Vs3xqqpYOtUs=
-github.com/saiskee/gettercheck v0.0.0-20210820204958-38443d06ebe0/go.mod h1:sa2CuStAMG5wPJQV6wdN8WFZ0A4Kj9on3oyoxGRbCAs=
 github.com/sanposhiho/wastedassign/v2 v2.1.0 h1:crurBF7fJKIORrV85u9UUpePDYGWnwvv3+A96WvwXT0=
 github.com/sanposhiho/wastedassign/v2 v2.1.0/go.mod h1:+oSmSC+9bQ+VUAxA66nBb0Z7N8CK7mscKTDYC6aIek4=
 github.com/santhosh-tekuri/jsonschema/v6 v6.0.1 h1:PKK9DyHxif4LZo+uQSgXNqs0jj5+xZwwfKHgph2lxBw=
@@ -1603,6 +1601,8 @@ github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAm
 github.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
 github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 h1:n661drycOFuPLCN3Uc8sB6B/s6Z4t2xvBgU1htSHuq8=
 github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=
+github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132 h1:3CGPS0J9yy6qL+IcJ893z5gPnNRdNgjSRsm0EAPzl7E=
+github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132/go.mod h1:y7H2qZn9nI2dCNXzfLab/sk4wi6q2xJOcsvEspVK2VY=
 github.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=
 github.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=
 github.com/shurcooL/githubv4 v0.0.0-20191127044304-8f68eb5628d0/go.mod h1:hAF0iLZy4td2EX+/8Tw+4nodhlMrwN3HupfaXj3zkGo=
@@ -1955,8 +1955,8 @@ golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliY
 golang.org/x/crypto v0.14.0/go.mod h1:MVFd36DqK4CsrnJYDkBA3VC4m2GkXAM0PvzMCn4JQf4=
 golang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=
 golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
-golang.org/x/crypto v0.38.0 h1:jt+WWG8IZlBnVbomuhg2Mdq0+BBQaHbtqHEFEigjUV8=
-golang.org/x/crypto v0.38.0/go.mod h1:MvrbAqul58NNYPKnOra203SB9vpuZW0e+RRZV+Ggqjw=
+golang.org/x/crypto v0.39.0 h1:SHs+kF4LP+f+p14esP5jAoDpHU8Gu/v9lFRK6IT5imM=
+golang.org/x/crypto v0.39.0/go.mod h1:L+Xg3Wf6HoL4Bn4238Z6ft6KfEpN0tJGo53AAPC632U=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
@@ -2008,8 +2008,8 @@ golang.org/x/mod v0.9.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
 golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
 golang.org/x/mod v0.13.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
 golang.org/x/mod v0.14.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
-golang.org/x/mod v0.24.0 h1:ZfthKaKaT4NrhGVZHO1/WDTwGES4De8KtWO0SIbNJMU=
-golang.org/x/mod v0.24.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
+golang.org/x/mod v0.25.0 h1:n7a+ZbQKQA/Ysbyb0/6IbB1H/X41mKgbhfv7AfG/44w=
+golang.org/x/mod v0.25.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
@@ -2073,8 +2073,8 @@ golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
 golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=
 golang.org/x/net v0.16.0/go.mod h1:NxSsAGuq816PNPmqtQdLE42eU2Fs7NoRIZrHJAlaCOE=
 golang.org/x/net v0.20.0/go.mod h1:z8BVo6PvndSri0LbOE3hAn0apkU+1YvI6E70E9jsnvY=
-golang.org/x/net v0.40.0 h1:79Xs7wF06Gbdcg4kdCCIQArK11Z1hr5POQ6+fIYHNuY=
-golang.org/x/net v0.40.0/go.mod h1:y0hY0exeL2Pku80/zKK7tpntoX23cqL3Oa6njdgRtds=
+golang.org/x/net v0.41.0 h1:vBTly1HeNPEn3wtREYfy4GZ/NECgw2Cnl+nK6Nz3uvw=
+golang.org/x/net v0.41.0/go.mod h1:B/K4NNqkfmg07DQYrbwvSluqCJOOXwUjeb/5lOisjbA=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
 golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
 golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
@@ -2112,8 +2112,8 @@ golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.4.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=
 golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
-golang.org/x/sync v0.14.0 h1:woo0S4Yywslg6hp4eUFjTVOyKt0RookbpAHG4c1HmhQ=
-golang.org/x/sync v0.14.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
+golang.org/x/sync v0.15.0 h1:KWH3jNZsfyT6xfAfKiz6MRNmd46ByHDYaZ7KSkCtdW8=
+golang.org/x/sync v0.15.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
 golang.org/x/sys v0.0.0-20180606202747-9527bec2660b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180823144017-11551d06cbcc/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
@@ -2239,8 +2239,8 @@ golang.org/x/text v0.8.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
 golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
 golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=
 golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
-golang.org/x/text v0.25.0 h1:qVyWApTSYLk/drJRO5mDlNYskwQznZmkpV2c8q9zls4=
-golang.org/x/text v0.25.0/go.mod h1:WEdwpYrmk1qmdHvhkSTNPm3app7v4rsT8F2UD6+VHIA=
+golang.org/x/text v0.26.0 h1:P42AVeLghgTYr4+xUnTRKDMqpar+PtX7KWuNQL21L8M=
+golang.org/x/text v0.26.0/go.mod h1:QK15LZJUUQVJxhz7wXgxSy/CJaTFjd0G+YLonydOVQA=
 golang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
@@ -2330,8 +2330,8 @@ golang.org/x/tools v0.7.0/go.mod h1:4pg6aUX35JBAogB10C9AtvVL+qowtN4pT3CGSQex14s=
 golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
 golang.org/x/tools v0.14.0/go.mod h1:uYBEerGOWcJyEORxN+Ek8+TT266gXkNlHdJBwexUsBg=
 golang.org/x/tools v0.17.0/go.mod h1:xsh6VxdV005rRVaS6SSAf9oiAqljS7UZUacMZ8Bnsps=
-golang.org/x/tools v0.32.0 h1:Q7N1vhpkQv7ybVzLFtTjvQya2ewbwNDZzUgfXGqtMWU=
-golang.org/x/tools v0.32.0/go.mod h1:ZxrU41P/wAbZD8EDa6dDCa6XfpkhJ7HFMjHJXfBDu8s=
+golang.org/x/tools v0.34.0 h1:qIpSLOxeCYGg9TrcJokLBG4KFA6d795g0xkBkiESGlo=
+golang.org/x/tools v0.34.0/go.mod h1:pAP9OwEaY1CAW3HOmg3hLZC5Z0CCmzjAF2UQMSqNARg=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
@@ -2570,28 +2570,28 @@ istio.io/client-go v1.25.0-alpha.0.0.20250210220843-5a4065fded65/go.mod h1:40cl7
 istio.io/istio v0.0.0-20250212203644-c2ac935c5888 h1:4uIAapZvWqD/Vo8uLecH1hxC3EAE2aqUmq8rOzaXJws=
 istio.io/istio v0.0.0-20250212203644-c2ac935c5888/go.mod h1:k9mWJfHRkdIya53hz/BzKfKmVRk2/aiA2H1AF0KmDC0=
 k8s.io/api v0.21.4/go.mod h1:fTVGP+M4D8+00FN2cMnJqk/eb/GH53bvmNs2SVTmpFk=
-k8s.io/api v0.32.3 h1:Hw7KqxRusq+6QSplE3NYG4MBxZw1BZnq4aP4cJVINls=
-k8s.io/api v0.32.3/go.mod h1:2wEDTXADtm/HA7CCMD8D8bK4yuBUptzaRhYcYEEYA3k=
+k8s.io/api v0.33.2 h1:YgwIS5jKfA+BZg//OQhkJNIfie/kmRsO0BmNaVSimvY=
+k8s.io/api v0.33.2/go.mod h1:fhrbphQJSM2cXzCWgqU29xLDuks4mu7ti9vveEnpSXs=
 k8s.io/apiextensions-apiserver v0.21.4/go.mod h1:OoC8LhI9LnV+wKjZkXIBbLUwtnOGJiTRE33qctH5CIk=
-k8s.io/apiextensions-apiserver v0.32.3 h1:4D8vy+9GWerlErCwVIbcQjsWunF9SUGNu7O7hiQTyPY=
-k8s.io/apiextensions-apiserver v0.32.3/go.mod h1:8YwcvVRMVzw0r1Stc7XfGAzB/SIVLunqApySV5V7Dss=
+k8s.io/apiextensions-apiserver v0.33.2 h1:6gnkIbngnaUflR3XwE1mCefN3YS8yTD631JXQhsU6M8=
+k8s.io/apiextensions-apiserver v0.33.2/go.mod h1:IvVanieYsEHJImTKXGP6XCOjTwv2LUMos0YWc9O+QP8=
 k8s.io/apimachinery v0.21.4/go.mod h1:H/IM+5vH9kZRNJ4l3x/fXP/5bOPJaVP/guptnZPeCFI=
-k8s.io/apimachinery v0.32.3 h1:JmDuDarhDmA/Li7j3aPrwhpNBA94Nvk5zLeOge9HH1U=
-k8s.io/apimachinery v0.32.3/go.mod h1:GpHVgxoKlTxClKcteaeuF1Ul/lDVb74KpZcxcmLDElE=
+k8s.io/apimachinery v0.33.2 h1:IHFVhqg59mb8PJWTLi8m1mAoepkUNYmptHsV+Z1m5jY=
+k8s.io/apimachinery v0.33.2/go.mod h1:BHW0YOu7n22fFv/JkYOEfkUYNRN0fj0BlvMFWA7b+SM=
 k8s.io/apiserver v0.21.4/go.mod h1:SErUuFBBPZUcD2nsUU8hItxoYheqyYr2o/pCINEPW8g=
-k8s.io/apiserver v0.32.3 h1:kOw2KBuHOA+wetX1MkmrxgBr648ksz653j26ESuWNY8=
-k8s.io/apiserver v0.32.3/go.mod h1:q1x9B8E/WzShF49wh3ADOh6muSfpmFL0I2t+TG0Zdgc=
+k8s.io/apiserver v0.33.2 h1:KGTRbxn2wJagJowo29kKBp4TchpO1DRO3g+dB/KOJN4=
+k8s.io/apiserver v0.33.2/go.mod h1:9qday04wEAMLPWWo9AwqCZSiIn3OYSZacDyu/AcoM/M=
 k8s.io/cli-runtime v0.32.3 h1:khLF2ivU2T6Q77H97atx3REY9tXiA3OLOjWJxUrdvss=
 k8s.io/cli-runtime v0.32.3/go.mod h1:vZT6dZq7mZAca53rwUfdFSZjdtLyfF61mkf/8q+Xjak=
 k8s.io/client-go v0.21.4/go.mod h1:t0/eMKyUAq/DoQ7vW8NVVA00/nomlwC+eInsS8PxSew=
-k8s.io/client-go v0.32.3 h1:RKPVltzopkSgHS7aS98QdscAgtgah/+zmpAogooIqVU=
-k8s.io/client-go v0.32.3/go.mod h1:3v0+3k4IcT9bXTc4V2rt+d2ZPPG700Xy6Oi0Gdl2PaY=
+k8s.io/client-go v0.33.2 h1:z8CIcc0P581x/J1ZYf4CNzRKxRvQAwoAolYPbtQes+E=
+k8s.io/client-go v0.33.2/go.mod h1:9mCgT4wROvL948w6f6ArJNb7yQd7QsvqavDeZHvNmHo=
 k8s.io/code-generator v0.21.4/go.mod h1:K3y0Bv9Cz2cOW2vXUrNZlFbflhuPvuadW6JdnN6gGKo=
-k8s.io/code-generator v0.32.3 h1:31p2TVzC9+hVdSkAFruAk3JY+iSfzrJ83Qij1yZutyw=
-k8s.io/code-generator v0.32.3/go.mod h1:+mbiYID5NLsBuqxjQTygKM/DAdKpAjvBzrJd64NU1G8=
+k8s.io/code-generator v0.33.2 h1:PCJ0Y6viTCxxJHMOyGqYwWEteM4q6y1Hqo2rNpl6jF4=
+k8s.io/code-generator v0.33.2/go.mod h1:hBjCA9kPMpjLWwxcr75ReaQfFXY8u+9bEJJ7kRw3J8c=
 k8s.io/component-base v0.21.4/go.mod h1:ZKG0eHVX+tUDcaoIGpU3Vtk4TIjMddN9uhEWDmW6Nyg=
-k8s.io/component-base v0.32.3 h1:98WJvvMs3QZ2LYHBzvltFSeJjEx7t5+8s71P7M74u8k=
-k8s.io/component-base v0.32.3/go.mod h1:LWi9cR+yPAv7cu2X9rZanTiFKB2kHA+JjmhkKjCZRpI=
+k8s.io/component-base v0.33.2 h1:sCCsn9s/dG3ZrQTX/Us0/Sx2R0G5kwa0wbZFYoVp/+0=
+k8s.io/component-base v0.33.2/go.mod h1:/41uw9wKzuelhN+u+/C59ixxf4tYQKW7p32ddkYNe2k=
 k8s.io/gengo v0.0.0-20200413195148-3a45101e95ac/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=
 k8s.io/gengo v0.0.0-20201214224949-b6c5ce23f027/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
 k8s.io/gengo v0.0.0-20211129171323-c02415ce4185/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=
@@ -2625,14 +2625,12 @@ rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8
 rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
 rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.22/go.mod h1:LEScyzhFmoF5pso/YSeBstl57mOzx9xlU9n85RGrDQg=
-sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.1 h1:uOuSLOMBWkJH0TWa9X6l+mj5nZdm6Ay6Bli8HL8rNfk=
-sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.1/go.mod h1:Ve9uj1L+deCXFrPOk1LpFXqTg7LCFzFso6PA48q/XZw=
+sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2 h1:jpcvIRr3GLoUoEKRkHKSmGjxb6lWwrBlJsXc+eUYQHM=
+sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2/go.mod h1:Ve9uj1L+deCXFrPOk1LpFXqTg7LCFzFso6PA48q/XZw=
 sigs.k8s.io/controller-runtime v0.20.4 h1:X3c+Odnxz+iPTRobG4tp092+CvBU9UK0t/bRf+n0DGU=
 sigs.k8s.io/controller-runtime v0.20.4/go.mod h1:xg2XB0K5ShQzAgsoujxuKN4LNXR2LfwwHsPj7Iaw+XY=
 sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235 h1:GRdpo0LC7QBPh9HefY30G1xmap2Q5U/KCBqeIZymDMo=
 sigs.k8s.io/controller-runtime/tools/setup-envtest v0.0.0-20231019135941-15d792835235/go.mod h1:TF/lVLWS+JNNaVqJuDDictY2hZSXSsIHCx4FClMvqFg=
-sigs.k8s.io/controller-tools v0.17.3 h1:lwFPLicpBKLgIepah+c8ikRBubFW5kOQyT88r3EwfNw=
-sigs.k8s.io/controller-tools v0.17.3/go.mod h1:1ii+oXcYZkxcBXzwv3YZBlzjt1fvkrCGjVF73blosJI=
 sigs.k8s.io/gateway-api v1.3.0 h1:q6okN+/UKDATola4JY7zXzx40WO4VISk7i9DIfOvr9M=
 sigs.k8s.io/gateway-api v1.3.0/go.mod h1:d8NV8nJbaRbEKem+5IuxkL8gJGOZ+FJ+NvOIltV8gDk=
 sigs.k8s.io/gateway-api-inference-extension v0.2.0 h1:AqENYqi2OHjAhBhTKARNcM7G5L/gsRIxZGS4P8CNqAI=
diff --git a/hack/utils/oss_compliance/osa_provided.md b/hack/utils/oss_compliance/osa_provided.md
index 1bca7873a..4f0e4baee 100644
--- a/hack/utils/oss_compliance/osa_provided.md
+++ b/hack/utils/oss_compliance/osa_provided.md
@@ -19,9 +19,9 @@ Name|Version|License
 [kelseyhightower/envconfig](https://github.com/kelseyhightower/envconfig)|v1.4.0|MIT License
 [mitchellh/hashstructure](https://github.com/mitchellh/hashstructure)|v1.0.0|MIT License
 [ginkgo/v2](https://github.com/onsi/ginkgo)|v2.23.3|MIT License
-[onsi/gomega](https://github.com/onsi/gomega)|v1.36.3|MIT License
+[onsi/gomega](https://github.com/onsi/gomega)|v1.37.0|MIT License
 [pkg/errors](https://github.com/pkg/errors)|v0.9.1|BSD 2-clause "Simplified" License
-[prometheus/client_golang](https://github.com/prometheus/client_golang)|v1.21.1|Apache License 2.0
+[prometheus/client_golang](https://github.com/prometheus/client_golang)|v1.22.0|Apache License 2.0
 [prometheus/client_model](https://github.com/prometheus/client_model)|v0.6.2|Apache License 2.0
 [spf13/afero](https://github.com/spf13/afero)|v1.14.0|Apache License 2.0
 [spf13/cobra](https://github.com/spf13/cobra)|v1.9.1|Apache License 2.0
@@ -29,17 +29,17 @@ Name|Version|License
 [go.opencensus.io](https://go.opencensus.io)|v0.24.0|Apache License 2.0
 [go.uber.org/zap](https://go.uber.org/zap)|v1.27.0|MIT License
 [x/exp](https://golang.org/x/exp)|v0.0.0-20241215155358-4a5509556b9e|BSD 3-clause "New" or "Revised" License
-[x/net](https://golang.org/x/net)|v0.40.0|BSD 3-clause "New" or "Revised" License
+[x/net](https://golang.org/x/net)|v0.41.0|BSD 3-clause "New" or "Revised" License
 [google.golang.org/grpc](https://google.golang.org/grpc)|v1.72.0|Apache License 2.0
 [google.golang.org/protobuf](https://google.golang.org/protobuf)|v1.36.6|BSD 3-clause "New" or "Revised" License
 [helm/v3](https://helm.sh/helm/v3)|v3.17.3|Apache License 2.0
 [istio.io/api](https://istio.io/api)|v1.25.0-alpha.0.0.20250210220544-0b64afd2de85|Apache License 2.0
 [istio.io/client-go](https://istio.io/client-go)|v1.25.0-alpha.0.0.20250210220843-5a4065fded65|Apache License 2.0
 [istio.io/istio](https://istio.io/istio)|v0.0.0-20250212203644-c2ac935c5888|Apache License 2.0
-[k8s.io/api](https://k8s.io/api)|v0.32.3|Apache License 2.0
-[k8s.io/apiextensions-apiserver](https://k8s.io/apiextensions-apiserver)|v0.32.3|Apache License 2.0
-[k8s.io/apimachinery](https://k8s.io/apimachinery)|v0.32.3|Apache License 2.0
-[k8s.io/client-go](https://k8s.io/client-go)|v0.32.3|Apache License 2.0
+[k8s.io/api](https://k8s.io/api)|v0.33.2|Apache License 2.0
+[k8s.io/apiextensions-apiserver](https://k8s.io/apiextensions-apiserver)|v0.33.2|Apache License 2.0
+[k8s.io/apimachinery](https://k8s.io/apimachinery)|v0.33.2|Apache License 2.0
+[k8s.io/client-go](https://k8s.io/client-go)|v0.33.2|Apache License 2.0
 [klog/v2](https://k8s.io/klog/v2)|v2.130.1|Apache License 2.0
 [k8s.io/kube-openapi](https://k8s.io/kube-openapi)|v0.0.0-20250318190949-c8a335a9a2ff|Apache License 2.0
 [k8s.io/utils](https://k8s.io/utils)|v0.0.0-20241210054802-24370beab758|Apache License 2.0
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
index 612af49f5..f27b83901 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backendconfigpolicies.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.17.3
+    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -227,6 +227,11 @@ spec:
                     default: false
                     type: boolean
                 type: object
+                x-kubernetes-validations:
+                - message: at most one of the fields in [leastRequest roundRobin ringHash
+                    maglev random] may be set
+                  rule: '[has(self.leastRequest),has(self.roundRobin),has(self.ringHash),has(self.maglev),has(self.random)].filter(x,x==true).size()
+                    <= 1'
               perConnectionBufferLimitBytes:
                 type: integer
               targetRefs:
@@ -358,7 +363,17 @@ spec:
                       type: string
                     type: array
                 type: object
+                x-kubernetes-validations:
+                - message: exactly one of the fields in [secretRef tlsFiles] must
+                    be set
+                  rule: '[has(self.secretRef),has(self.tlsFiles)].filter(x,x==true).size()
+                    == 1'
             type: object
+            x-kubernetes-validations:
+            - message: at most one of the fields in [http1ProtocolOptions http2ProtocolOptions]
+                may be set
+              rule: '[has(self.http1ProtocolOptions),has(self.http2ProtocolOptions)].filter(x,x==true).size()
+                <= 1'
           status:
             properties:
               ancestors:
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml
index fa9f8e5c9..71fe49a08 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_backends.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.17.3
+    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -105,6 +105,11 @@ spec:
                                 required:
                                 - kind
                                 type: object
+                                x-kubernetes-validations:
+                                - message: at most one of the fields in [inline secretRef]
+                                    may be set
+                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                    <= 1'
                               model:
                                 type: string
                             required:
@@ -135,6 +140,11 @@ spec:
                                 required:
                                 - kind
                                 type: object
+                                x-kubernetes-validations:
+                                - message: at most one of the fields in [inline secretRef]
+                                    may be set
+                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                    <= 1'
                               deploymentName:
                                 minLength: 1
                                 type: string
@@ -171,6 +181,11 @@ spec:
                                 required:
                                 - kind
                                 type: object
+                                x-kubernetes-validations:
+                                - message: at most one of the fields in [inline secretRef]
+                                    may be set
+                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                    <= 1'
                               model:
                                 type: string
                             required:
@@ -200,6 +215,11 @@ spec:
                                 required:
                                 - kind
                                 type: object
+                                x-kubernetes-validations:
+                                - message: at most one of the fields in [inline secretRef]
+                                    may be set
+                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                    <= 1'
                               model:
                                 type: string
                             required:
@@ -230,6 +250,11 @@ spec:
                                 required:
                                 - kind
                                 type: object
+                                x-kubernetes-validations:
+                                - message: at most one of the fields in [inline secretRef]
+                                    may be set
+                                  rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                    <= 1'
                               location:
                                 minLength: 1
                                 type: string
@@ -324,6 +349,11 @@ spec:
                                             required:
                                             - kind
                                             type: object
+                                            x-kubernetes-validations:
+                                            - message: at most one of the fields in
+                                                [inline secretRef] may be set
+                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                                <= 1'
                                           model:
                                             type: string
                                         required:
@@ -354,6 +384,11 @@ spec:
                                             required:
                                             - kind
                                             type: object
+                                            x-kubernetes-validations:
+                                            - message: at most one of the fields in
+                                                [inline secretRef] may be set
+                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                                <= 1'
                                           deploymentName:
                                             minLength: 1
                                             type: string
@@ -390,6 +425,11 @@ spec:
                                             required:
                                             - kind
                                             type: object
+                                            x-kubernetes-validations:
+                                            - message: at most one of the fields in
+                                                [inline secretRef] may be set
+                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                                <= 1'
                                           model:
                                             type: string
                                         required:
@@ -419,6 +459,11 @@ spec:
                                             required:
                                             - kind
                                             type: object
+                                            x-kubernetes-validations:
+                                            - message: at most one of the fields in
+                                                [inline secretRef] may be set
+                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                                <= 1'
                                           model:
                                             type: string
                                         required:
@@ -449,6 +494,11 @@ spec:
                                             required:
                                             - kind
                                             type: object
+                                            x-kubernetes-validations:
+                                            - message: at most one of the fields in
+                                                [inline secretRef] may be set
+                                              rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                                <= 1'
                                           location:
                                             minLength: 1
                                             type: string
@@ -614,6 +664,10 @@ spec:
                 'DynamicForwardProxy'
               rule: 'self.type == ''DynamicForwardProxy'' ? has(self.dynamicForwardProxy)
                 : true'
+            - message: exactly one of the fields in [ai aws static dynamicForwardProxy]
+                must be set
+              rule: '[has(self.ai),has(self.aws),has(self.static),has(self.dynamicForwardProxy)].filter(x,x==true).size()
+                == 1'
           status:
             properties:
               conditions:
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml
index 17e2d9259..c676b5717 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_directresponses.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.17.3
+    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml
index ffe9f3385..fdb4c3756 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayextensions.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.17.3
+    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
index a60a79fec..60cd8ef36 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_gatewayparameters.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.17.3
+    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -897,6 +897,8 @@ spec:
                                       - port
                                       type: object
                                   type: object
+                                stopSignal:
+                                  type: string
                               type: object
                             livenessProbe:
                               properties:
@@ -2386,6 +2388,10 @@ spec:
                 type: object
                 x-kubernetes-preserve-unknown-fields: true
             type: object
+            x-kubernetes-validations:
+            - message: exactly one of the fields in [kube selfManaged] must be set
+              rule: '[has(self.kube),has(self.selfManaged)].filter(x,x==true).size()
+                == 1'
           status:
             type: object
         type: object
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
index 78c24ef48..3f229f3da 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_httplistenerpolicies.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.17.3
+    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -47,6 +47,11 @@ spec:
                       required:
                       - path
                       type: object
+                      x-kubernetes-validations:
+                      - message: exactly one of the fields in [stringFormat jsonFormat]
+                          must be set
+                        rule: '[has(self.stringFormat),has(self.jsonFormat)].filter(x,x==true).size()
+                          == 1'
                     filter:
                       allOf:
                       - maxProperties: 1
diff --git a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
index 68146e648..51e1ce2f0 100644
--- a/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
+++ b/install/helm/kgateway-crds/templates/gateway.kgateway.dev_trafficpolicies.yaml
@@ -3,7 +3,7 @@ apiVersion: apiextensions.k8s.io/v1
 kind: CustomResourceDefinition
 metadata:
   annotations:
-    controller-gen.kubebuilder.io/version: v0.17.3
+    controller-gen.kubebuilder.io/version: v0.18.1-0.20250625175829-8d11ce77f347
   labels:
     app: kgateway
     app.kubernetes.io/name: kgateway
@@ -119,6 +119,11 @@ spec:
                                     required:
                                     - kind
                                     type: object
+                                    x-kubernetes-validations:
+                                    - message: at most one of the fields in [inline
+                                        secretRef] may be set
+                                      rule: '[has(self.inline),has(self.secretRef)].filter(x,x==true).size()
+                                        <= 1'
                                   model:
                                     type: string
                                 required:
@@ -354,6 +359,11 @@ spec:
                       required:
                       - ignoreCase
                       type: object
+                      x-kubernetes-validations:
+                      - message: exactly one of the fields in [exact prefix suffix
+                          contains safeRegex] must be set
+                        rule: '[has(self.exact),has(self.prefix),has(self.suffix),has(self.contains),has(self.safeRegex)].filter(x,x==true).size()
+                          == 1'
                     maxItems: 16
                     type: array
                   percentageEnabled:
@@ -367,6 +377,11 @@ spec:
                     minimum: 0
                     type: integer
                 type: object
+                x-kubernetes-validations:
+                - message: at most one of the fields in [percentageEnabled percentageShadowed]
+                    may be set
+                  rule: '[has(self.percentageEnabled),has(self.percentageShadowed)].filter(x,x==true).size()
+                    <= 1'
               extAuth:
                 properties:
                   contextExtensions:
@@ -398,6 +413,11 @@ spec:
                     - maxRequestBytes
                     type: object
                 type: object
+                x-kubernetes-validations:
+                - message: exactly one of the fields in [extensionRef enablement]
+                    must be set
+                  rule: '[has(self.extensionRef),has(self.enablement)].filter(x,x==true).size()
+                    == 1'
               extProc:
                 properties:
                   extensionRef:
diff --git a/internal/kgateway/agentgatewaysyncer/adp.go b/internal/kgateway/agentgatewaysyncer/adp.go
index 912e49aae..b8e15d390 100644
--- a/internal/kgateway/agentgatewaysyncer/adp.go
+++ b/internal/kgateway/agentgatewaysyncer/adp.go
@@ -7,10 +7,10 @@ import (
 	"github.com/agentgateway/agentgateway/go/api"
 	"istio.io/istio/pkg/slices"
 	"k8s.io/apimachinery/pkg/runtime/schema"
-	k8s "sigs.k8s.io/gateway-api/apis/v1"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 )
 
-func createADPMethodMatch(match k8s.HTTPRouteMatch) (*api.MethodMatch, *ConfigError) {
+func createADPMethodMatch(match gwv1.HTTPRouteMatch) (*api.MethodMatch, *ConfigError) {
 	if match.Method == nil {
 		return nil, nil
 	}
@@ -19,20 +19,20 @@ func createADPMethodMatch(match k8s.HTTPRouteMatch) (*api.MethodMatch, *ConfigEr
 	}, nil
 }
 
-func createADPQueryMatch(match k8s.HTTPRouteMatch) ([]*api.QueryMatch, *ConfigError) {
+func createADPQueryMatch(match gwv1.HTTPRouteMatch) ([]*api.QueryMatch, *ConfigError) {
 	res := []*api.QueryMatch{}
 	for _, header := range match.QueryParams {
-		tp := k8s.QueryParamMatchExact
+		tp := gwv1.QueryParamMatchExact
 		if header.Type != nil {
 			tp = *header.Type
 		}
 		switch tp {
-		case k8s.QueryParamMatchExact:
+		case gwv1.QueryParamMatchExact:
 			res = append(res, &api.QueryMatch{
 				Name:  string(header.Name),
 				Value: &api.QueryMatch_Exact{Exact: header.Value},
 			})
-		case k8s.QueryParamMatchRegularExpression:
+		case gwv1.QueryParamMatchRegularExpression:
 			res = append(res, &api.QueryMatch{
 				Name:  string(header.Name),
 				Value: &api.QueryMatch_Regex{Regex: header.Value},
@@ -48,8 +48,8 @@ func createADPQueryMatch(match k8s.HTTPRouteMatch) ([]*api.QueryMatch, *ConfigEr
 	return res, nil
 }
 
-func createADPPathMatch(match k8s.HTTPRouteMatch) (*api.PathMatch, *ConfigError) {
-	tp := k8s.PathMatchPathPrefix
+func createADPPathMatch(match gwv1.HTTPRouteMatch) (*api.PathMatch, *ConfigError) {
+	tp := gwv1.PathMatchPathPrefix
 	if match.Path.Type != nil {
 		tp = *match.Path.Type
 	}
@@ -58,7 +58,7 @@ func createADPPathMatch(match k8s.HTTPRouteMatch) (*api.PathMatch, *ConfigError)
 		dest = *match.Path.Value
 	}
 	switch tp {
-	case k8s.PathMatchPathPrefix:
+	case gwv1.PathMatchPathPrefix:
 		// "When specified, a trailing `/` is ignored."
 		if dest != "/" {
 			dest = strings.TrimSuffix(dest, "/")
@@ -66,11 +66,11 @@ func createADPPathMatch(match k8s.HTTPRouteMatch) (*api.PathMatch, *ConfigError)
 		return &api.PathMatch{Kind: &api.PathMatch_PathPrefix{
 			PathPrefix: dest,
 		}}, nil
-	case k8s.PathMatchExact:
+	case gwv1.PathMatchExact:
 		return &api.PathMatch{Kind: &api.PathMatch_Exact{
 			Exact: dest,
 		}}, nil
-	case k8s.PathMatchRegularExpression:
+	case gwv1.PathMatchRegularExpression:
 		return &api.PathMatch{Kind: &api.PathMatch_Regex{
 			Regex: dest,
 		}}, nil
@@ -80,20 +80,20 @@ func createADPPathMatch(match k8s.HTTPRouteMatch) (*api.PathMatch, *ConfigError)
 	}
 }
 
-func createADPHeadersMatch(match k8s.HTTPRouteMatch) ([]*api.HeaderMatch, *ConfigError) {
+func createADPHeadersMatch(match gwv1.HTTPRouteMatch) ([]*api.HeaderMatch, *ConfigError) {
 	res := []*api.HeaderMatch{}
 	for _, header := range match.Headers {
-		tp := k8s.HeaderMatchExact
+		tp := gwv1.HeaderMatchExact
 		if header.Type != nil {
 			tp = *header.Type
 		}
 		switch tp {
-		case k8s.HeaderMatchExact:
+		case gwv1.HeaderMatchExact:
 			res = append(res, &api.HeaderMatch{
 				Name:  string(header.Name),
 				Value: &api.HeaderMatch_Exact{Exact: header.Value},
 			})
-		case k8s.HeaderMatchRegularExpression:
+		case gwv1.HeaderMatchRegularExpression:
 			res = append(res, &api.HeaderMatch{
 				Name:  string(header.Name),
 				Value: &api.HeaderMatch_Regex{Regex: header.Value},
@@ -110,7 +110,7 @@ func createADPHeadersMatch(match k8s.HTTPRouteMatch) ([]*api.HeaderMatch, *Confi
 	return res, nil
 }
 
-func createADPHeadersFilter(filter *k8s.HTTPHeaderFilter) *api.RouteFilter {
+func createADPHeadersFilter(filter *gwv1.HTTPHeaderFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
@@ -125,7 +125,7 @@ func createADPHeadersFilter(filter *k8s.HTTPHeaderFilter) *api.RouteFilter {
 	}
 }
 
-func createADPResponseHeadersFilter(filter *k8s.HTTPHeaderFilter) *api.RouteFilter {
+func createADPResponseHeadersFilter(filter *gwv1.HTTPHeaderFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
@@ -140,7 +140,7 @@ func createADPResponseHeadersFilter(filter *k8s.HTTPHeaderFilter) *api.RouteFilt
 	}
 }
 
-func createADPRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *api.RouteFilter {
+func createADPRewriteFilter(filter *gwv1.HTTPURLRewriteFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
@@ -154,9 +154,9 @@ func createADPRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *api.RouteFilter {
 	}
 	if filter.Path != nil {
 		switch filter.Path.Type {
-		case k8s.PrefixMatchHTTPPathModifier:
+		case gwv1.PrefixMatchHTTPPathModifier:
 			ff.Path = &api.UrlRewrite_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
-		case k8s.FullPathHTTPPathModifier:
+		case gwv1.FullPathHTTPPathModifier:
 			ff.Path = &api.UrlRewrite_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
 		}
 	}
@@ -169,7 +169,7 @@ func createADPRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *api.RouteFilter {
 
 func createADPMirrorFilter(
 	ctx RouteContext,
-	filter *k8s.HTTPRequestMirrorFilter,
+	filter *gwv1.HTTPRequestMirrorFilter,
 	ns string,
 	k schema.GroupVersionKind,
 ) (*api.RouteFilter, *ConfigError) {
@@ -177,8 +177,8 @@ func createADPMirrorFilter(
 		return nil, nil
 	}
 	var weightOne int32 = 1
-	dst, err := buildADPDestination(ctx, k8s.HTTPBackendRef{
-		BackendRef: k8s.BackendRef{
+	dst, err := buildADPDestination(ctx, gwv1.HTTPBackendRef{
+		BackendRef: gwv1.BackendRef{
 			BackendObjectReference: filter.BackendRef,
 			Weight:                 &weightOne,
 		},
@@ -215,7 +215,7 @@ func createADPMirrorFilter(
 	return &api.RouteFilter{Kind: &api.RouteFilter_RequestMirror{RequestMirror: rm}}, nil
 }
 
-func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *api.RouteFilter {
+func createADPRedirectFilter(filter *gwv1.HTTPRequestRedirectFilter) *api.RouteFilter {
 	if filter == nil {
 		return nil
 	}
@@ -242,9 +242,9 @@ func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *api.RouteFi
 	}
 	if filter.Path != nil {
 		switch filter.Path.Type {
-		case k8s.PrefixMatchHTTPPathModifier:
+		case gwv1.PrefixMatchHTTPPathModifier:
 			ff.Path = &api.RequestRedirect_Prefix{Prefix: strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")}
-		case k8s.FullPathHTTPPathModifier:
+		case gwv1.FullPathHTTPPathModifier:
 			ff.Path = &api.RequestRedirect_Full{Full: strings.TrimSuffix(*filter.Path.ReplaceFullPath, "/")}
 		}
 	}
@@ -255,8 +255,8 @@ func createADPRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *api.RouteFi
 	}
 }
 
-func headerListToADP(hl []k8s.HTTPHeader) []*api.Header {
-	return slices.Map(hl, func(hl k8s.HTTPHeader) *api.Header {
+func headerListToADP(hl []gwv1.HTTPHeader) []*api.Header {
+	return slices.Map(hl, func(hl gwv1.HTTPHeader) *api.Header {
 		return &api.Header{
 			Name:  string(hl.Name),
 			Value: hl.Value,
diff --git a/internal/kgateway/agentgatewaysyncer/conditions.go b/internal/kgateway/agentgatewaysyncer/conditions.go
index ed85a2e6c..828e03e21 100644
--- a/internal/kgateway/agentgatewaysyncer/conditions.go
+++ b/internal/kgateway/agentgatewaysyncer/conditions.go
@@ -1,23 +1,21 @@
 package agentgatewaysyncer
 
 import (
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	k8s "sigs.k8s.io/gateway-api/apis/v1"
-	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-
 	"istio.io/istio/pilot/pkg/model/kstatus"
 	"istio.io/istio/pkg/maps"
 	"istio.io/istio/pkg/slices"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 )
 
 type ParentErrorReason string
 
 const (
-	ParentErrorNotAccepted       = ParentErrorReason(k8s.RouteReasonNoMatchingParent)
-	ParentErrorNotAllowed        = ParentErrorReason(k8s.RouteReasonNotAllowedByListeners)
-	ParentErrorNoHostname        = ParentErrorReason(k8s.RouteReasonNoMatchingListenerHostname)
+	ParentErrorNotAccepted       = ParentErrorReason(gwv1.RouteReasonNoMatchingParent)
+	ParentErrorNotAllowed        = ParentErrorReason(gwv1.RouteReasonNotAllowedByListeners)
+	ParentErrorNoHostname        = ParentErrorReason(gwv1.RouteReasonNoMatchingListenerHostname)
 	ParentErrorParentRefConflict = ParentErrorReason("ParentRefConflict")
 	ParentNoError                = ParentErrorReason("")
 )
@@ -27,19 +25,19 @@ type ConfigErrorReason = string
 const (
 	// InvalidDestination indicates an issue with the destination
 	InvalidDestination ConfigErrorReason = "InvalidDestination"
-	InvalidAddress     ConfigErrorReason = ConfigErrorReason(k8s.GatewayReasonUnsupportedAddress)
+	InvalidAddress     ConfigErrorReason = ConfigErrorReason(gwv1.GatewayReasonUnsupportedAddress)
 	// InvalidDestinationPermit indicates a destination was not permitted
-	InvalidDestinationPermit ConfigErrorReason = ConfigErrorReason(k8s.RouteReasonRefNotPermitted)
+	InvalidDestinationPermit ConfigErrorReason = ConfigErrorReason(gwv1.RouteReasonRefNotPermitted)
 	// InvalidDestinationKind indicates an issue with the destination kind
-	InvalidDestinationKind ConfigErrorReason = ConfigErrorReason(k8s.RouteReasonInvalidKind)
+	InvalidDestinationKind ConfigErrorReason = ConfigErrorReason(gwv1.RouteReasonInvalidKind)
 	// InvalidDestinationNotFound indicates a destination does not exist
-	InvalidDestinationNotFound ConfigErrorReason = ConfigErrorReason(k8s.RouteReasonBackendNotFound)
+	InvalidDestinationNotFound ConfigErrorReason = ConfigErrorReason(gwv1.RouteReasonBackendNotFound)
 	// InvalidFilter indicates an issue with the filters
 	InvalidFilter ConfigErrorReason = "InvalidFilter"
 	// InvalidTLS indicates an issue with TLS settings
-	InvalidTLS ConfigErrorReason = ConfigErrorReason(k8s.ListenerReasonInvalidCertificateRef)
+	InvalidTLS ConfigErrorReason = ConfigErrorReason(gwv1.ListenerReasonInvalidCertificateRef)
 	// InvalidListenerRefNotPermitted indicates a listener reference was not permitted
-	InvalidListenerRefNotPermitted ConfigErrorReason = ConfigErrorReason(k8s.ListenerReasonRefNotPermitted)
+	InvalidListenerRefNotPermitted ConfigErrorReason = ConfigErrorReason(gwv1.ListenerReasonRefNotPermitted)
 	// InvalidConfiguration indicates a generic error for all other invalid configurations
 	InvalidConfiguration ConfigErrorReason = "InvalidConfiguration"
 	DeprecateFieldUsage  ConfigErrorReason = "DeprecatedField"
@@ -117,22 +115,22 @@ func setConditions(generation int64, existingConditions []metav1.Condition, cond
 	return existingConditions
 }
 
-func reportListenerCondition(index int, l k8s.Listener, obj *k8sbeta.Gateway,
-	gs *k8sbeta.GatewayStatus, conditions map[string]*condition,
+func reportListenerCondition(index int, l gwv1.Listener, obj *gwv1.Gateway,
+	gs *gwv1.GatewayStatus, conditions map[string]*condition,
 ) {
 	for index >= len(gs.Listeners) {
-		gs.Listeners = append(gs.Listeners, k8s.ListenerStatus{})
+		gs.Listeners = append(gs.Listeners, gwv1.ListenerStatus{})
 	}
 	cond := gs.Listeners[index].Conditions
 	supported, valid := generateSupportedKinds(l)
 	if !valid {
-		conditions[string(k8s.ListenerConditionResolvedRefs)] = &condition{
-			reason:  string(k8s.ListenerReasonInvalidRouteKinds),
+		conditions[string(gwv1.ListenerConditionResolvedRefs)] = &condition{
+			reason:  string(gwv1.ListenerReasonInvalidRouteKinds),
 			status:  metav1.ConditionFalse,
 			message: "Invalid route kinds",
 		}
 	}
-	gs.Listeners[index] = k8s.ListenerStatus{
+	gs.Listeners[index] = gwv1.ListenerStatus{
 		Name:           l.Name,
 		AttachedRoutes: 0, // this will be reported later
 		SupportedKinds: supported,
@@ -140,28 +138,28 @@ func reportListenerCondition(index int, l k8s.Listener, obj *k8sbeta.Gateway,
 	}
 }
 
-func generateSupportedKinds(l k8s.Listener) ([]k8s.RouteGroupKind, bool) {
-	var supported []k8s.RouteGroupKind
+func generateSupportedKinds(l gwv1.Listener) ([]gwv1.RouteGroupKind, bool) {
+	var supported []gwv1.RouteGroupKind
 	switch l.Protocol {
-	case k8s.HTTPProtocolType, k8s.HTTPSProtocolType:
+	case gwv1.HTTPProtocolType, gwv1.HTTPSProtocolType:
 		// Only terminate allowed, so its always HTTP
-		supported = []k8s.RouteGroupKind{
+		supported = []gwv1.RouteGroupKind{
 			toRouteKind(wellknown.HTTPRouteGVK),
 			toRouteKind(wellknown.GRPCRouteGVK),
 		}
-	case k8s.TCPProtocolType:
-		supported = []k8s.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
-	case k8s.TLSProtocolType:
-		if l.TLS != nil && l.TLS.Mode != nil && *l.TLS.Mode == k8s.TLSModePassthrough {
-			supported = []k8s.RouteGroupKind{toRouteKind(wellknown.TLSRouteGVK)}
+	case gwv1.TCPProtocolType:
+		supported = []gwv1.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
+	case gwv1.TLSProtocolType:
+		if l.TLS != nil && l.TLS.Mode != nil && *l.TLS.Mode == gwv1.TLSModePassthrough {
+			supported = []gwv1.RouteGroupKind{toRouteKind(wellknown.TLSRouteGVK)}
 		} else {
-			supported = []k8s.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
+			supported = []gwv1.RouteGroupKind{toRouteKind(wellknown.TCPRouteGVK)}
 		}
 		// UDP route not support
 	}
 	if l.AllowedRoutes != nil && len(l.AllowedRoutes.Kinds) > 0 {
 		// We need to filter down to only ones we actually support
-		var intersection []k8s.RouteGroupKind
+		var intersection []gwv1.RouteGroupKind
 		for _, s := range supported {
 			for _, kind := range l.AllowedRoutes.Kinds {
 				if routeGroupKindEqual(s, kind) {
diff --git a/internal/kgateway/agentgatewaysyncer/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
index 0a391271a..7bfaeb27d 100644
--- a/internal/kgateway/agentgatewaysyncer/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -9,19 +9,9 @@ import (
 	"strings"
 	"time"
 
+	"github.com/agentgateway/agentgateway/go/api"
 	"google.golang.org/protobuf/types/known/durationpb"
 	wrappers "google.golang.org/protobuf/types/known/wrapperspb"
-	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
-	klabels "k8s.io/apimachinery/pkg/labels"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	k8s "sigs.k8s.io/gateway-api/apis/v1"
-	k8salpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
-	k8sbeta "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-
-	"github.com/agentgateway/agentgateway/go/api"
 	"istio.io/api/annotation"
 	istio "istio.io/api/networking/v1alpha3"
 	kubecreds "istio.io/istio/pilot/pkg/credentials/kube"
@@ -34,20 +24,28 @@ import (
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
 	"istio.io/istio/pkg/config/schema/kind"
-	schematypes "istio.io/istio/pkg/config/schema/kubetypes"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/ptr"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/sets"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	klabels "k8s.io/apimachinery/pkg/labels"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gwv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 )
 
 const (
 	gatewayTLSTerminateModeKey = "gateway.agentgateway.io/tls-terminate-mode"
 )
 
-func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
-	obj *k8sbeta.HTTPRoute, pos int, matchPos int,
+func convertHTTPRouteToADP(ctx RouteContext, r gwv1.HTTPRouteRule,
+	obj *gwv1.HTTPRoute, pos int, matchPos int,
 ) (*api.Route, *ConfigError) {
 	res := &api.Route{
 		Key:         obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) + "." + strconv.Itoa(matchPos),
@@ -108,7 +106,7 @@ func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 		return nil, err
 	}
 	res.Backends = route
-	res.Hostnames = slices.Map(obj.Spec.Hostnames, func(e k8s.Hostname) string {
+	res.Hostnames = slices.Map(obj.Spec.Hostnames, func(e gwv1.Hostname) string {
 		return string(e)
 	})
 	return res, backendErr
@@ -117,44 +115,44 @@ func convertHTTPRouteToADP(ctx RouteContext, r k8s.HTTPRouteRule,
 func buildADPFilters(
 	ctx RouteContext,
 	ns string,
-	inputFilters []k8s.HTTPRouteFilter,
+	inputFilters []gwv1.HTTPRouteFilter,
 ) ([]*api.RouteFilter, *ConfigError) {
 	var filters []*api.RouteFilter
 	var mirrorBackendErr *ConfigError
 	for _, filter := range inputFilters {
 		switch filter.Type {
-		case k8s.HTTPRouteFilterRequestHeaderModifier:
+		case gwv1.HTTPRouteFilterRequestHeaderModifier:
 			h := createADPHeadersFilter(filter.RequestHeaderModifier)
 			if h == nil {
 				continue
 			}
 			filters = append(filters, h)
-		case k8s.HTTPRouteFilterResponseHeaderModifier:
+		case gwv1.HTTPRouteFilterResponseHeaderModifier:
 			h := createADPResponseHeadersFilter(filter.ResponseHeaderModifier)
 			if h == nil {
 				continue
 			}
 			filters = append(filters, h)
-		case k8s.HTTPRouteFilterRequestRedirect:
+		case gwv1.HTTPRouteFilterRequestRedirect:
 			h := createADPRedirectFilter(filter.RequestRedirect)
 			if h == nil {
 				continue
 			}
 			filters = append(filters, h)
-		case k8s.HTTPRouteFilterRequestMirror:
+		case gwv1.HTTPRouteFilterRequestMirror:
 			h, err := createADPMirrorFilter(ctx, filter.RequestMirror, ns, wellknown.HTTPRouteGVK)
 			if err != nil {
 				mirrorBackendErr = err
 			} else {
 				filters = append(filters, h)
 			}
-		case k8s.HTTPRouteFilterURLRewrite:
+		case gwv1.HTTPRouteFilterURLRewrite:
 			h := createADPRewriteFilter(filter.URLRewrite)
 			if h == nil {
 				continue
 			}
 			filters = append(filters, h)
-		case k8s.HTTPRouteFilterCORS:
+		case gwv1.HTTPRouteFilterCORS:
 			//return nil, &ConfigError{
 			//	Reason:  InvalidFilter,
 			//	Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
@@ -171,7 +169,7 @@ func buildADPFilters(
 
 func buildADPHTTPDestination(
 	ctx RouteContext,
-	forwardTo []k8s.HTTPBackendRef,
+	forwardTo []gwv1.HTTPBackendRef,
 	ns string,
 ) ([]*api.RouteBackend, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
@@ -205,7 +203,7 @@ func buildADPHTTPDestination(
 
 func buildADPDestination(
 	ctx RouteContext,
-	to k8s.HTTPBackendRef,
+	to gwv1.HTTPBackendRef,
 	ns string,
 	k schema.GroupVersionKind,
 ) (*api.RouteBackend, *ConfigError) {
@@ -232,7 +230,7 @@ func buildADPDestination(
 	rb := &api.RouteBackend{
 		Weight: weight,
 	}
-	var port *k8s.PortNumber
+	var port *gwv1.PortNumber
 	ref := normalizeReference(to.Group, to.Kind, wellknown.ServiceGVK)
 	switch ref.GroupKind() {
 	case wellknown.InferencePoolGVK.GroupKind():
@@ -246,7 +244,7 @@ func buildADPDestination(
 		if svc == nil {
 			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
 		} else {
-			port = ptr.Of(k8s.PortNumber(svc.Spec.TargetPortNumber))
+			port = ptr.Of(gwv1.PortNumber(svc.Spec.TargetPortNumber))
 		}
 		rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
 	case wellknown.ServiceGVK.GroupKind():
@@ -278,10 +276,11 @@ func buildADPDestination(
 	return rb, invalidBackendErr
 }
 
-func parentMeta(obj controllers.Object, sectionName *k8s.SectionName) map[string]string {
-	name := fmt.Sprintf("%s/%s.%s", schematypes.GvkFromObject(obj).Kind, obj.GetName(), obj.GetNamespace())
+func parentMeta(obj controllers.Object, sectionName *gwv1.SectionName) map[string]string {
+	kind := obj.GetObjectKind().GroupVersionKind().Kind
+	name := fmt.Sprintf("%s/%s.%s", kind, obj.GetName(), obj.GetNamespace())
 	if sectionName != nil {
-		name = fmt.Sprintf("%s/%s/%s.%s", schematypes.GvkFromObject(obj).Kind, obj.GetName(), *sectionName, obj.GetNamespace())
+		name = fmt.Sprintf("%s/%s/%s.%s", kind, obj.GetName(), *sectionName, obj.GetNamespace())
 	}
 	return map[string]string{
 		constants.InternalParentNames: name,
@@ -297,7 +296,7 @@ var allowedParentReferences = sets.New(
 // normalizeReference normalizes group and kind references to a standard GVK format.
 // If group or kind are nil/empty, it uses the default GVK's group/kind.
 // Empty group is treated as "core" API group.
-func normalizeReference(group *k8s.Group, kind *k8s.Kind, defaultGVK schema.GroupVersionKind) schema.GroupVersionKind {
+func normalizeReference(group *gwv1.Group, kind *gwv1.Kind, defaultGVK schema.GroupVersionKind) schema.GroupVersionKind {
 	result := defaultGVK
 
 	if kind != nil && *kind != "" {
@@ -317,7 +316,7 @@ func normalizeReference(group *k8s.Group, kind *k8s.Kind, defaultGVK schema.Grou
 	return result
 }
 
-func toInternalParentReference(p k8s.ParentReference, localNamespace string) (parentKey, error) {
+func toInternalParentReference(p gwv1.ParentReference, localNamespace string) (parentKey, error) {
 	ref := normalizeReference(p.Group, p.Kind, wellknown.GatewayGVK)
 	if !allowedParentReferences.Contains(wellknown.GatewayGVK) {
 		return parentKey{}, fmt.Errorf("unsupported parent: %v/%v", p.Group, p.Kind)
@@ -335,7 +334,7 @@ func referenceAllowed(
 	parent *parentInfo,
 	routeKind schema.GroupVersionKind,
 	parentRef parentReference,
-	hostnames []k8s.Hostname,
+	hostnames []gwv1.Hostname,
 	localNamespace string,
 ) *ParentError {
 	if parentRef.Kind == wellknown.ServiceGVK {
@@ -380,7 +379,7 @@ func referenceAllowed(
 		// If either is empty its treated as a wildcard which always matches
 
 		if len(hostnames) == 0 {
-			hostnames = []k8s.Hostname{"*"}
+			hostnames = []gwv1.Hostname{"*"}
 		}
 		if len(parent.Hostnames) > 0 {
 			// TODO: the spec actually has a label match, not a string match. That is, *.com does not match *.apple.com
@@ -496,7 +495,7 @@ func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj cont
 	return parentRefs
 }
 
-func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TCPRoute) (*istio.TCPRoute, *ConfigError) {
+func convertTCPRoute(ctx RouteContext, r gwv1alpha2.TCPRouteRule, obj *gwv1alpha2.TCPRoute) (*istio.TCPRoute, *ConfigError) {
 	if tcpWeightSum(r.BackendRefs) == 0 {
 		// The spec requires us to reject connections when there are no >0 weight backends
 		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
@@ -520,7 +519,7 @@ func convertTCPRoute(ctx RouteContext, r k8salpha.TCPRouteRule, obj *k8salpha.TC
 	}, backendErr
 }
 
-func convertTLSRoute(ctx RouteContext, r k8salpha.TLSRouteRule, obj *k8salpha.TLSRoute) (*istio.TLSRoute, *ConfigError) {
+func convertTLSRoute(ctx RouteContext, r gwv1alpha2.TLSRouteRule, obj *gwv1alpha2.TLSRoute) (*istio.TLSRoute, *ConfigError) {
 	if tcpWeightSum(r.BackendRefs) == 0 {
 		// The spec requires us to reject connections when there are no >0 weight backends
 		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
@@ -547,7 +546,7 @@ func convertTLSRoute(ctx RouteContext, r k8salpha.TLSRouteRule, obj *k8salpha.TL
 
 func buildTCPDestination(
 	ctx RouteContext,
-	forwardTo []k8s.BackendRef,
+	forwardTo []gwv1.BackendRef,
 	ns string,
 	k schema.GroupVersionKind,
 ) ([]*istio.RouteDestination, *ConfigError, *ConfigError) {
@@ -556,7 +555,7 @@ func buildTCPDestination(
 	}
 
 	weights := []int{}
-	action := []k8s.BackendRef{}
+	var action []gwv1.BackendRef
 	for _, w := range forwardTo {
 		wt := int(ptr.OrDefault(w.Weight, 1))
 		if wt == 0 {
@@ -589,14 +588,14 @@ func buildTCPDestination(
 	return res, invalidBackendErr, nil
 }
 
-func buildTLSMatch(hostnames []k8s.Hostname) []*istio.TLSMatchAttributes {
+func buildTLSMatch(hostnames []gwv1.Hostname) []*istio.TLSMatchAttributes {
 	// Currently, the spec only supports extensions beyond hostname, which are not currently implemented by Istio.
 	return []*istio.TLSMatchAttributes{{
 		SniHosts: hostnamesToStringListWithWildcard(hostnames),
 	}}
 }
 
-func hostnamesToStringListWithWildcard(h []k8s.Hostname) []string {
+func hostnamesToStringListWithWildcard(h []gwv1.Hostname) []string {
 	if len(h) == 0 {
 		return []string{"*"}
 	}
@@ -607,7 +606,7 @@ func hostnamesToStringListWithWildcard(h []k8s.Hostname) []string {
 	return res
 }
 
-func weightSum(forwardTo []k8s.HTTPBackendRef) int {
+func weightSum(forwardTo []gwv1.HTTPBackendRef) int {
 	sum := int32(0)
 	for _, w := range forwardTo {
 		sum += ptr.OrDefault(w.Weight, 1)
@@ -615,7 +614,7 @@ func weightSum(forwardTo []k8s.HTTPBackendRef) int {
 	return int(sum)
 }
 
-func grpcWeightSum(forwardTo []k8s.GRPCBackendRef) int {
+func grpcWeightSum(forwardTo []gwv1.GRPCBackendRef) int {
 	sum := int32(0)
 	for _, w := range forwardTo {
 		sum += ptr.OrDefault(w.Weight, 1)
@@ -623,7 +622,7 @@ func grpcWeightSum(forwardTo []k8s.GRPCBackendRef) int {
 	return int(sum)
 }
 
-func tcpWeightSum(forwardTo []k8s.BackendRef) int {
+func tcpWeightSum(forwardTo []gwv1.BackendRef) int {
 	sum := int32(0)
 	for _, w := range forwardTo {
 		sum += ptr.OrDefault(w.Weight, 1)
@@ -633,14 +632,14 @@ func tcpWeightSum(forwardTo []k8s.BackendRef) int {
 
 func buildHTTPDestination(
 	ctx RouteContext,
-	forwardTo []k8s.HTTPBackendRef,
+	forwardTo []gwv1.HTTPBackendRef,
 	ns string,
 ) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
 		return nil, nil, nil
 	}
 	weights := []int{}
-	action := []k8s.HTTPBackendRef{}
+	action := []gwv1.HTTPBackendRef{}
 	for _, w := range forwardTo {
 		wt := int(ptr.OrDefault(w.Weight, 1))
 		if wt == 0 {
@@ -671,7 +670,7 @@ func buildHTTPDestination(
 		}
 		for _, filter := range fwd.Filters {
 			switch filter.Type {
-			case k8s.HTTPRouteFilterRequestHeaderModifier:
+			case gwv1.HTTPRouteFilterRequestHeaderModifier:
 				h := createHeadersFilter(filter.RequestHeaderModifier)
 				if h == nil {
 					continue
@@ -680,7 +679,7 @@ func buildHTTPDestination(
 					rd.Headers = &istio.Headers{}
 				}
 				rd.GetHeaders().Request = h
-			case k8s.HTTPRouteFilterResponseHeaderModifier:
+			case gwv1.HTTPRouteFilterResponseHeaderModifier:
 				h := createHeadersFilter(filter.ResponseHeaderModifier)
 				if h == nil {
 					continue
@@ -700,14 +699,14 @@ func buildHTTPDestination(
 
 func buildGRPCDestination(
 	ctx RouteContext,
-	forwardTo []k8s.GRPCBackendRef,
+	forwardTo []gwv1.GRPCBackendRef,
 	ns string,
 ) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
 	if forwardTo == nil {
 		return nil, nil, nil
 	}
 	weights := []int{}
-	action := []k8s.GRPCBackendRef{}
+	action := []gwv1.GRPCBackendRef{}
 	for _, w := range forwardTo {
 		wt := int(ptr.OrDefault(w.Weight, 1))
 		if wt == 0 {
@@ -738,7 +737,7 @@ func buildGRPCDestination(
 		}
 		for _, filter := range fwd.Filters {
 			switch filter.Type {
-			case k8s.GRPCRouteFilterRequestHeaderModifier:
+			case gwv1.GRPCRouteFilterRequestHeaderModifier:
 				h := createHeadersFilter(filter.RequestHeaderModifier)
 				if h == nil {
 					continue
@@ -747,7 +746,7 @@ func buildGRPCDestination(
 					rd.Headers = &istio.Headers{}
 				}
 				rd.GetHeaders().Request = h
-			case k8s.GRPCRouteFilterResponseHeaderModifier:
+			case gwv1.GRPCRouteFilterResponseHeaderModifier:
 				h := createHeadersFilter(filter.ResponseHeaderModifier)
 				if h == nil {
 					continue
@@ -765,7 +764,7 @@ func buildGRPCDestination(
 	return res, invalidBackendErr, nil
 }
 
-func buildDestination(ctx RouteContext, to k8s.BackendRef, ns string, k schema.GroupVersionKind) (*istio.Destination, *ConfigError) {
+func buildDestination(ctx RouteContext, to gwv1.BackendRef, ns string, k schema.GroupVersionKind) (*istio.Destination, *ConfigError) {
 	// check if the reference is allowed
 	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
 		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
@@ -845,7 +844,7 @@ func isInvalidBackend(err *ConfigError) bool {
 		err.Reason == InvalidDestinationKind
 }
 
-func headerListToMap(hl []k8s.HTTPHeader) map[string]string {
+func headerListToMap(hl []gwv1.HTTPHeader) map[string]string {
 	if len(hl) == 0 {
 		return nil
 	}
@@ -861,14 +860,14 @@ func headerListToMap(hl []k8s.HTTPHeader) map[string]string {
 	return res
 }
 
-func createMirrorFilter(ctx RouteContext, filter *k8s.HTTPRequestMirrorFilter, ns string,
+func createMirrorFilter(ctx RouteContext, filter *gwv1.HTTPRequestMirrorFilter, ns string,
 	k schema.GroupVersionKind,
 ) (*istio.HTTPMirrorPolicy, *ConfigError) {
 	if filter == nil {
 		return nil, nil
 	}
 	var weightOne int32 = 1
-	dst, err := buildDestination(ctx, k8s.BackendRef{
+	dst, err := buildDestination(ctx, gwv1.BackendRef{
 		BackendObjectReference: filter.BackendRef,
 		Weight:                 &weightOne,
 	}, ns, k)
@@ -884,20 +883,20 @@ func createMirrorFilter(ctx RouteContext, filter *k8s.HTTPRequestMirrorFilter, n
 	return &istio.HTTPMirrorPolicy{Destination: dst, Percentage: percent}, nil
 }
 
-func createRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *istio.HTTPRewrite {
+func createRewriteFilter(filter *gwv1.HTTPURLRewriteFilter) *istio.HTTPRewrite {
 	if filter == nil {
 		return nil
 	}
 	rewrite := &istio.HTTPRewrite{}
 	if filter.Path != nil {
 		switch filter.Path.Type {
-		case k8s.PrefixMatchHTTPPathModifier:
+		case gwv1.PrefixMatchHTTPPathModifier:
 			rewrite.Uri = strings.TrimSuffix(*filter.Path.ReplacePrefixMatch, "/")
 			if rewrite.GetUri() == "" {
 				// `/` means removing the prefix
 				rewrite.Uri = "/"
 			}
-		case k8s.FullPathHTTPPathModifier:
+		case gwv1.FullPathHTTPPathModifier:
 			rewrite.UriRegexRewrite = &istio.RegexRewrite{
 				Match:   "/.*",
 				Rewrite: *filter.Path.ReplaceFullPath,
@@ -914,7 +913,7 @@ func createRewriteFilter(filter *k8s.HTTPURLRewriteFilter) *istio.HTTPRewrite {
 	return rewrite
 }
 
-func createCorsFilter(filter *k8s.HTTPCORSFilter) *istio.CorsPolicy {
+func createCorsFilter(filter *gwv1.HTTPCORSFilter) *istio.CorsPolicy {
 	if filter == nil {
 		return nil
 	}
@@ -949,7 +948,7 @@ func createCorsFilter(filter *k8s.HTTPCORSFilter) *istio.CorsPolicy {
 	return res
 }
 
-func createRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *istio.HTTPRedirect {
+func createRedirectFilter(filter *gwv1.HTTPRequestRedirectFilter) *istio.HTTPRedirect {
 	if filter == nil {
 		return nil
 	}
@@ -979,16 +978,16 @@ func createRedirectFilter(filter *k8s.HTTPRequestRedirectFilter) *istio.HTTPRedi
 	}
 	if filter.Path != nil {
 		switch filter.Path.Type {
-		case k8s.FullPathHTTPPathModifier:
+		case gwv1.FullPathHTTPPathModifier:
 			resp.Uri = *filter.Path.ReplaceFullPath
-		case k8s.PrefixMatchHTTPPathModifier:
+		case gwv1.PrefixMatchHTTPPathModifier:
 			resp.Uri = fmt.Sprintf("%%PREFIX()%%%s", *filter.Path.ReplacePrefixMatch)
 		}
 	}
 	return resp
 }
 
-func createHeadersFilter(filter *k8s.HTTPHeaderFilter) *istio.Headers_HeaderOperations {
+func createHeadersFilter(filter *gwv1.HTTPHeaderFilter) *istio.Headers_HeaderOperations {
 	if filter == nil {
 		return nil
 	}
@@ -1000,7 +999,7 @@ func createHeadersFilter(filter *k8s.HTTPHeaderFilter) *istio.Headers_HeaderOper
 }
 
 // nolint: unparam
-func createMethodMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
+func createMethodMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
 	if match.Method == nil {
 		return nil, nil
 	}
@@ -1009,19 +1008,19 @@ func createMethodMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigErr
 	}, nil
 }
 
-func createQueryParamsMatch(match k8s.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+func createQueryParamsMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
 	res := map[string]*istio.StringMatch{}
 	for _, qp := range match.QueryParams {
-		tp := k8s.QueryParamMatchExact
+		tp := gwv1.QueryParamMatchExact
 		if qp.Type != nil {
 			tp = *qp.Type
 		}
 		switch tp {
-		case k8s.QueryParamMatchExact:
+		case gwv1.QueryParamMatchExact:
 			res[string(qp.Name)] = &istio.StringMatch{
 				MatchType: &istio.StringMatch_Exact{Exact: qp.Value},
 			}
-		case k8s.QueryParamMatchRegularExpression:
+		case gwv1.QueryParamMatchRegularExpression:
 			res[string(qp.Name)] = &istio.StringMatch{
 				MatchType: &istio.StringMatch_Regex{Regex: qp.Value},
 			}
@@ -1037,19 +1036,19 @@ func createQueryParamsMatch(match k8s.HTTPRouteMatch) (map[string]*istio.StringM
 	return res, nil
 }
 
-func createHeadersMatch(match k8s.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+func createHeadersMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
 	res := map[string]*istio.StringMatch{}
 	for _, header := range match.Headers {
-		tp := k8s.HeaderMatchExact
+		tp := gwv1.HeaderMatchExact
 		if header.Type != nil {
 			tp = *header.Type
 		}
 		switch tp {
-		case k8s.HeaderMatchExact:
+		case gwv1.HeaderMatchExact:
 			res[string(header.Name)] = &istio.StringMatch{
 				MatchType: &istio.StringMatch_Exact{Exact: header.Value},
 			}
-		case k8s.HeaderMatchRegularExpression:
+		case gwv1.HeaderMatchRegularExpression:
 			res[string(header.Name)] = &istio.StringMatch{
 				MatchType: &istio.StringMatch_Regex{Regex: header.Value},
 			}
@@ -1065,19 +1064,19 @@ func createHeadersMatch(match k8s.HTTPRouteMatch) (map[string]*istio.StringMatch
 	return res, nil
 }
 
-func createGRPCHeadersMatch(match k8s.GRPCRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+func createGRPCHeadersMatch(match gwv1.GRPCRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
 	res := map[string]*istio.StringMatch{}
 	for _, header := range match.Headers {
-		tp := k8s.GRPCHeaderMatchExact
+		tp := gwv1.GRPCHeaderMatchExact
 		if header.Type != nil {
 			tp = *header.Type
 		}
 		switch tp {
-		case k8s.GRPCHeaderMatchExact:
+		case gwv1.GRPCHeaderMatchExact:
 			res[string(header.Name)] = &istio.StringMatch{
 				MatchType: &istio.StringMatch_Exact{Exact: header.Value},
 			}
-		case k8s.GRPCHeaderMatchRegularExpression:
+		case gwv1.GRPCHeaderMatchRegularExpression:
 			res[string(header.Name)] = &istio.StringMatch{
 				MatchType: &istio.StringMatch_Regex{Regex: header.Value},
 			}
@@ -1093,8 +1092,8 @@ func createGRPCHeadersMatch(match k8s.GRPCRouteMatch) (map[string]*istio.StringM
 	return res, nil
 }
 
-func createURIMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
-	tp := k8s.PathMatchPathPrefix
+func createURIMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
+	tp := gwv1.PathMatchPathPrefix
 	if match.Path.Type != nil {
 		tp = *match.Path.Type
 	}
@@ -1103,7 +1102,7 @@ func createURIMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigError)
 		dest = *match.Path.Value
 	}
 	switch tp {
-	case k8s.PathMatchPathPrefix:
+	case gwv1.PathMatchPathPrefix:
 		// "When specified, a trailing `/` is ignored."
 		if dest != "/" {
 			dest = strings.TrimSuffix(dest, "/")
@@ -1111,11 +1110,11 @@ func createURIMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigError)
 		return &istio.StringMatch{
 			MatchType: &istio.StringMatch_Prefix{Prefix: dest},
 		}, nil
-	case k8s.PathMatchExact:
+	case gwv1.PathMatchExact:
 		return &istio.StringMatch{
 			MatchType: &istio.StringMatch_Exact{Exact: dest},
 		}, nil
-	case k8s.PathMatchRegularExpression:
+	case gwv1.PathMatchRegularExpression:
 		return &istio.StringMatch{
 			MatchType: &istio.StringMatch_Regex{Regex: dest},
 		}, nil
@@ -1125,12 +1124,12 @@ func createURIMatch(match k8s.HTTPRouteMatch) (*istio.StringMatch, *ConfigError)
 	}
 }
 
-func createGRPCURIMatch(match k8s.GRPCRouteMatch) (*istio.StringMatch, *ConfigError) {
+func createGRPCURIMatch(match gwv1.GRPCRouteMatch) (*istio.StringMatch, *ConfigError) {
 	m := match.Method
 	if m == nil {
 		return nil, nil
 	}
-	tp := k8s.GRPCMethodMatchExact
+	tp := gwv1.GRPCMethodMatchExact
 	if m.Type != nil {
 		tp = *m.Type
 	}
@@ -1140,7 +1139,7 @@ func createGRPCURIMatch(match k8s.GRPCRouteMatch) (*istio.StringMatch, *ConfigEr
 	}
 	// gRPC format is /<Service>/<Method>. Since we don't natively understand this, convert to various string matches
 	switch tp {
-	case k8s.GRPCMethodMatchExact:
+	case gwv1.GRPCMethodMatchExact:
 		if m.Method == nil {
 			return &istio.StringMatch{
 				MatchType: &istio.StringMatch_Prefix{Prefix: fmt.Sprintf("/%s/", *m.Service)},
@@ -1154,7 +1153,7 @@ func createGRPCURIMatch(match k8s.GRPCRouteMatch) (*istio.StringMatch, *ConfigEr
 		return &istio.StringMatch{
 			MatchType: &istio.StringMatch_Exact{Exact: fmt.Sprintf("/%s/%s", *m.Service, *m.Method)},
 		}, nil
-	case k8s.GRPCMethodMatchRegularExpression:
+	case gwv1.GRPCMethodMatchRegularExpression:
 		if m.Method == nil {
 			return &istio.StringMatch{
 				MatchType: &istio.StringMatch_Regex{Regex: fmt.Sprintf("/%s/.+", *m.Service)},
@@ -1175,7 +1174,7 @@ func createGRPCURIMatch(match k8s.GRPCRouteMatch) (*istio.StringMatch, *ConfigEr
 }
 
 // parentKey holds info about a parentRef (eg route binding to a Gateway). This is a mirror of
-// k8s.ParentReference in a form that can be stored in a map
+// gwv1.ParentReference in a form that can be stored in a map
 type parentKey struct {
 	Kind schema.GroupVersionKind
 	// Name is the original name of the resource (eg Kubernetes Gateway name)
@@ -1191,8 +1190,8 @@ func (p parentKey) String() string {
 type parentReference struct {
 	parentKey
 
-	SectionName k8s.SectionName
-	Port        k8s.PortNumber
+	SectionName gwv1.SectionName
+	Port        gwv1.PortNumber
 }
 
 func (p parentReference) String() string {
@@ -1205,16 +1204,16 @@ type parentInfo struct {
 	// InternalName refers to the internal name we can reference it by. For example "my-ns/my-gateway"
 	InternalName string
 	// AllowedKinds indicates which kinds can be admitted by this parent
-	AllowedKinds []k8s.RouteGroupKind
+	AllowedKinds []gwv1.RouteGroupKind
 	// Hostnames is the hostnames that must be match to reference to the parent. For gateway this is listener hostname
 	// Format is ns/hostname
 	Hostnames []string
 	// OriginalHostname is the unprocessed form of Hostnames; how it appeared in users' config
 	OriginalHostname string
 
-	SectionName k8s.SectionName
-	Port        k8s.PortNumber
-	Protocol    k8s.ProtocolType
+	SectionName gwv1.SectionName
+	Port        gwv1.PortNumber
+	Protocol    gwv1.ProtocolType
 }
 
 // routeParentReference holds information about a route's parent reference
@@ -1226,12 +1225,12 @@ type routeParentReference struct {
 	// DeniedReason, if present, indicates why the reference was not valid
 	DeniedReason *ParentError
 	// OriginalReference contains the original reference
-	OriginalReference k8s.ParentReference
+	OriginalReference gwv1.ParentReference
 	// Hostname is the hostname match of the parent, if any
 	Hostname        string
 	BannedHostnames sets.Set[string]
 	ParentKey       parentKey
-	ParentSection   k8s.SectionName
+	ParentSection   gwv1.SectionName
 }
 
 func (r routeParentReference) hostnameAllowedByIsolation(rawRouteHost string) bool {
@@ -1280,7 +1279,7 @@ func filteredReferences(parents []routeParentReference) []routeParentReference {
 	return ret
 }
 
-func getDefaultName(name string, kgw *k8s.GatewaySpec) string {
+func getDefaultName(name string, kgw *gwv1.GatewaySpec) string {
 	return fmt.Sprintf("%v-%v", name, kgw.GatewayClassName)
 }
 
@@ -1305,7 +1304,7 @@ func getDefaultName(name string, kgw *k8s.GatewaySpec) string {
 //	which users can add to the Gateway.
 //
 // If manual deployments are disabled, IsManaged() always returns true.
-func IsManaged(gw *k8s.GatewaySpec) bool {
+func IsManaged(gw *gwv1.GatewaySpec) bool {
 	//if !features.EnableGatewayAPIManualDeployment {
 	//	return true
 	//}
@@ -1315,13 +1314,13 @@ func IsManaged(gw *k8s.GatewaySpec) bool {
 	if len(gw.Addresses) > 1 {
 		return false
 	}
-	if t := gw.Addresses[0].Type; t == nil || *t == k8s.IPAddressType {
+	if t := gw.Addresses[0].Type; t == nil || *t == gwv1.IPAddressType {
 		return true
 	}
 	return false
 }
 
-func extractGatewayServices(domainSuffix string, kgw *k8sbeta.Gateway) ([]string, *ConfigError) {
+func extractGatewayServices(domainSuffix string, kgw *gwv1.Gateway) ([]string, *ConfigError) {
 	if IsManaged(&kgw.Spec) {
 		name := model.GetOrDefault(kgw.Annotations[annotation.GatewayNameOverride.Name], getDefaultName(kgw.Name, &kgw.Spec))
 		return []string{fmt.Sprintf("%s.%s.svc.%v", name, kgw.Namespace, domainSuffix)}, nil
@@ -1329,7 +1328,7 @@ func extractGatewayServices(domainSuffix string, kgw *k8sbeta.Gateway) ([]string
 	gatewayServices := []string{}
 	skippedAddresses := []string{}
 	for _, addr := range kgw.Spec.Addresses {
-		if addr.Type != nil && *addr.Type != k8s.HostnameAddressType {
+		if addr.Type != nil && *addr.Type != gwv1.HostnameAddressType {
 			// We only support HostnameAddressType. Keep track of invalid ones so we can report in status.
 			skippedAddresses = append(skippedAddresses, addr.Value)
 			continue
@@ -1367,28 +1366,28 @@ func buildListener(
 	secrets krt.Collection[*corev1.Secret],
 	grants ReferenceGrants,
 	namespaces krt.Collection[*corev1.Namespace],
-	obj *k8sbeta.Gateway,
-	status *k8sbeta.GatewayStatus,
-	l k8s.Listener,
+	obj *gwv1.Gateway,
+	status *gwv1.GatewayStatus,
+	l gwv1.Listener,
 	listenerIndex int,
-	controllerName k8s.GatewayController,
+	controllerName gwv1.GatewayController,
 ) (*istio.Server, *TLSInfo, bool) {
 	listenerConditions := map[string]*condition{
-		string(k8s.ListenerConditionAccepted): {
-			reason:  string(k8s.ListenerReasonAccepted),
+		string(gwv1.ListenerConditionAccepted): {
+			reason:  string(gwv1.ListenerReasonAccepted),
 			message: "No errors found",
 		},
-		string(k8s.ListenerConditionProgrammed): {
-			reason:  string(k8s.ListenerReasonProgrammed),
+		string(gwv1.ListenerConditionProgrammed): {
+			reason:  string(gwv1.ListenerReasonProgrammed),
 			message: "No errors found",
 		},
-		string(k8s.ListenerConditionConflicted): {
-			reason:  string(k8s.ListenerReasonNoConflicts),
+		string(gwv1.ListenerConditionConflicted): {
+			reason:  string(gwv1.ListenerReasonNoConflicts),
 			message: "No errors found",
 			status:  kstatus.StatusFalse,
 		},
-		string(k8s.ListenerConditionResolvedRefs): {
-			reason:  string(k8s.ListenerReasonResolvedRefs),
+		string(gwv1.ListenerConditionResolvedRefs): {
+			reason:  string(gwv1.ListenerReasonResolvedRefs),
 			message: "No errors found",
 		},
 	}
@@ -1396,9 +1395,9 @@ func buildListener(
 	ok := true
 	tls, tlsInfo, err := buildTLS(ctx, secrets, grants, l.TLS, obj, kube.IsAutoPassthrough(obj.Labels, l))
 	if err != nil {
-		listenerConditions[string(k8s.ListenerConditionResolvedRefs)].error = err
-		listenerConditions[string(k8s.GatewayConditionProgrammed)].error = &ConfigError{
-			Reason:  string(k8s.GatewayReasonInvalid),
+		listenerConditions[string(gwv1.ListenerConditionResolvedRefs)].error = err
+		listenerConditions[string(gwv1.GatewayConditionProgrammed)].error = &ConfigError{
+			Reason:  string(gwv1.GatewayReasonInvalid),
 			Message: "Bad TLS configuration",
 		}
 		ok = false
@@ -1407,8 +1406,8 @@ func buildListener(
 	hostnames := buildHostnameMatch(ctx, obj.Namespace, namespaces, l)
 	protocol, perr := listenerProtocolToAgentgateway(controllerName, l.Protocol)
 	if perr != nil {
-		listenerConditions[string(k8s.ListenerConditionAccepted)].error = &ConfigError{
-			Reason:  string(k8s.ListenerReasonUnsupportedProtocol),
+		listenerConditions[string(gwv1.ListenerConditionAccepted)].error = &ConfigError{
+			Reason:  string(gwv1.ListenerReasonUnsupportedProtocol),
 			Message: perr.Error(),
 		}
 		ok = false
@@ -1429,26 +1428,26 @@ func buildListener(
 }
 
 var supportedProtocols = sets.New(
-	k8s.HTTPProtocolType,
-	k8s.HTTPSProtocolType,
-	k8s.TLSProtocolType,
-	k8s.TCPProtocolType,
-	k8s.ProtocolType(protocol.HBONE))
+	gwv1.HTTPProtocolType,
+	gwv1.HTTPSProtocolType,
+	gwv1.TLSProtocolType,
+	gwv1.TCPProtocolType,
+	gwv1.ProtocolType(protocol.HBONE))
 
-func listenerProtocolToAgentgateway(name k8s.GatewayController, p k8s.ProtocolType) (string, error) {
+func listenerProtocolToAgentgateway(name gwv1.GatewayController, p gwv1.ProtocolType) (string, error) {
 	switch p {
 	// Standard protocol types
-	case k8s.HTTPProtocolType:
+	case gwv1.HTTPProtocolType:
 		return string(p), nil
-	case k8s.HTTPSProtocolType:
+	case gwv1.HTTPSProtocolType:
 		return string(p), nil
-	case k8s.TLSProtocolType, k8s.TCPProtocolType:
+	case gwv1.TLSProtocolType, gwv1.TCPProtocolType:
 		if !features.EnableAlphaGatewayAPI {
 			return "", fmt.Errorf("protocol %q is supported, but only when %v=true is configured", p, features.EnableAlphaGatewayAPIName)
 		}
 		return string(p), nil
 	}
-	up := k8s.ProtocolType(strings.ToUpper(string(p)))
+	up := gwv1.ProtocolType(strings.ToUpper(string(p)))
 	if supportedProtocols.Contains(up) {
 		return "", fmt.Errorf("protocol %q is unsupported. hint: %q (uppercase) may be supported", p, up)
 	}
@@ -1460,8 +1459,8 @@ func buildTLS(
 	ctx krt.HandlerContext,
 	secrets krt.Collection[*corev1.Secret],
 	grants ReferenceGrants,
-	tls *k8s.GatewayTLSConfig,
-	gw *k8sbeta.Gateway,
+	tls *gwv1.GatewayTLSConfig,
+	gw *gwv1.Gateway,
 	isAutoPassthrough bool,
 ) (*istio.ServerTLSSettings, *TLSInfo, *ConfigError) {
 	if tls == nil {
@@ -1472,13 +1471,13 @@ func buildTLS(
 	out := &istio.ServerTLSSettings{
 		HttpsRedirect: false,
 	}
-	mode := k8s.TLSModeTerminate
+	mode := gwv1.TLSModeTerminate
 	if tls.Mode != nil {
 		mode = *tls.Mode
 	}
 	namespace := gw.Namespace
 	switch mode {
-	case k8s.TLSModeTerminate:
+	case gwv1.TLSModeTerminate:
 		out.Mode = istio.ServerTLSSettings_SIMPLE
 		if tls.Options != nil {
 			switch tls.Options[gatewayTLSTerminateModeKey] {
@@ -1510,7 +1509,7 @@ func buildTLS(
 		}
 		out.CredentialName = cred
 		return out, &tlsInfo, nil
-	case k8s.TLSModePassthrough:
+	case gwv1.TLSModePassthrough:
 		out.Mode = istio.ServerTLSSettings_PASSTHROUGH
 		if isAutoPassthrough {
 			out.Mode = istio.ServerTLSSettings_AUTO_PASSTHROUGH
@@ -1521,8 +1520,8 @@ func buildTLS(
 
 func buildSecretReference(
 	ctx krt.HandlerContext,
-	ref k8s.SecretObjectReference,
-	gw *k8sbeta.Gateway,
+	ref gwv1.SecretObjectReference,
+	gw *gwv1.Gateway,
 	secrets krt.Collection[*corev1.Secret],
 ) (string, TLSInfo, *ConfigError) {
 	if normalizeReference(ref.Group, ref.Kind, wellknown.SecretGVK) != wellknown.SecretGVK {
@@ -1562,7 +1561,7 @@ func buildSecretReference(
 	}, nil
 }
 
-func objectReferenceString(ref k8s.SecretObjectReference) string {
+func objectReferenceString(ref gwv1.SecretObjectReference) string {
 	return fmt.Sprintf("%s/%s/%s.%s",
 		ptr.OrEmpty(ref.Group),
 		ptr.OrEmpty(ref.Kind),
@@ -1570,7 +1569,7 @@ func objectReferenceString(ref k8s.SecretObjectReference) string {
 		ptr.OrEmpty(ref.Namespace))
 }
 
-func parentRefString(ref k8s.ParentReference) string {
+func parentRefString(ref gwv1.ParentReference) string {
 	return fmt.Sprintf("%s/%s/%s/%s/%d.%s",
 		ptr.OrEmpty(ref.Group),
 		ptr.OrEmpty(ref.Kind),
@@ -1581,7 +1580,7 @@ func parentRefString(ref k8s.ParentReference) string {
 }
 
 // buildHostnameMatch generates a Gateway.spec.servers.hosts section from a listener
-func buildHostnameMatch(ctx krt.HandlerContext, localNamespace string, namespaces krt.Collection[*corev1.Namespace], l k8s.Listener) []string {
+func buildHostnameMatch(ctx krt.HandlerContext, localNamespace string, namespaces krt.Collection[*corev1.Namespace], l gwv1.Listener) []string {
 	// We may allow all hostnames or a specific one
 	hostname := "*"
 	if l.Hostname != nil {
@@ -1606,12 +1605,12 @@ func buildHostnameMatch(ctx krt.HandlerContext, localNamespace string, namespace
 }
 
 // namespacesFromSelector determines a list of allowed namespaces for a given AllowedRoutes
-func namespacesFromSelector(ctx krt.HandlerContext, localNamespace string, namespaceCol krt.Collection[*corev1.Namespace], lr *k8s.AllowedRoutes) []string {
+func namespacesFromSelector(ctx krt.HandlerContext, localNamespace string, namespaceCol krt.Collection[*corev1.Namespace], lr *gwv1.AllowedRoutes) []string {
 	// Default is to allow only the same namespace
-	if lr == nil || lr.Namespaces == nil || lr.Namespaces.From == nil || *lr.Namespaces.From == k8s.NamespacesFromSame {
+	if lr == nil || lr.Namespaces == nil || lr.Namespaces.From == nil || *lr.Namespaces.From == gwv1.NamespacesFromSame {
 		return []string{localNamespace}
 	}
-	if *lr.Namespaces.From == k8s.NamespacesFromAll {
+	if *lr.Namespaces.From == gwv1.NamespacesFromAll {
 		return []string{"*"}
 	}
 
@@ -1658,15 +1657,17 @@ func toNamespaceSet(name string, labels map[string]string) klabels.Set {
 	return ret
 }
 
-func GetCommonRouteInfo(spec any) ([]k8s.ParentReference, []k8s.Hostname, schema.GroupVersionKind) {
+func GetCommonRouteInfo(spec any) ([]gwv1.ParentReference, []gwv1.Hostname, schema.GroupVersionKind) {
 	switch t := spec.(type) {
-	case *k8salpha.TCPRoute:
+	case *gwv1alpha2.TCPRoute:
 		return t.Spec.ParentRefs, nil, wellknown.TCPRouteGVK
-	case *k8salpha.TLSRoute:
+	case *gwv1alpha2.TLSRoute:
 		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.TLSRouteGVK
-	case *k8sbeta.HTTPRoute:
+	case *gwv1.HTTPRoute:
+		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.HTTPRouteGVK
+	case *gwv1beta1.HTTPRoute: // TODO: support both v1 and v1beta1?
 		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.HTTPRouteGVK
-	case *k8s.GRPCRoute:
+	case *gwv1.GRPCRoute:
 		return t.Spec.ParentRefs, t.Spec.Hostnames, wellknown.GRPCRouteGVK
 	default:
 		log.Fatalf("unknown type %T", t)
@@ -1681,14 +1682,14 @@ func defaultString[T ~string](s *T, def string) string {
 	return string(*s)
 }
 
-func toRouteKind(g schema.GroupVersionKind) k8s.RouteGroupKind {
-	return k8s.RouteGroupKind{Group: (*k8s.Group)(&g.Group), Kind: k8s.Kind(g.Kind)}
+func toRouteKind(g schema.GroupVersionKind) gwv1.RouteGroupKind {
+	return gwv1.RouteGroupKind{Group: (*gwv1.Group)(&g.Group), Kind: gwv1.Kind(g.Kind)}
 }
 
-func routeGroupKindEqual(rgk1, rgk2 k8s.RouteGroupKind) bool {
+func routeGroupKindEqual(rgk1, rgk2 gwv1.RouteGroupKind) bool {
 	return rgk1.Kind == rgk2.Kind && getGroup(rgk1) == getGroup(rgk2)
 }
 
-func getGroup(rgk k8s.RouteGroupKind) k8s.Group {
+func getGroup(rgk gwv1.RouteGroupKind) gwv1.Group {
 	return ptr.OrDefault(rgk.Group, wellknown.GatewayGroup)
 }
diff --git a/internal/kgateway/agentgatewaysyncer/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
index 9e3308e5e..97d7a59c8 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
@@ -4,19 +4,21 @@ import (
 	"fmt"
 
 	"github.com/agentgateway/agentgateway/go/api"
+	istio "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/util/protoconv"
+	"istio.io/istio/pkg/kube/krt"
+	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/slices"
 	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-
-	istio "istio.io/api/networking/v1alpha3"
-	"istio.io/istio/pilot/pkg/util/protoconv"
-	"istio.io/istio/pkg/kube/krt"
-	"istio.io/istio/pkg/ptr"
-	"istio.io/istio/pkg/slices"
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 )
 
 func toResourcep(gw types.NamespacedName, t any) *ADPResource {
@@ -111,7 +113,7 @@ func (g Gateway) Equals(other Gateway) bool {
 
 func GatewayCollection(
 	agentGatewayClassName string,
-	gateways krt.Collection[*gateway.Gateway],
+	gateways krt.Collection[*gwv1.Gateway],
 	gatewayClasses krt.Collection[GatewayClass],
 	namespaces krt.Collection[*corev1.Namespace],
 	grants ReferenceGrants,
@@ -119,7 +121,11 @@ func GatewayCollection(
 	domainSuffix string,
 	krtopts krtutil.KrtOptions,
 ) krt.Collection[Gateway] {
-	gw := krt.NewManyCollection(gateways, func(ctx krt.HandlerContext, obj *gateway.Gateway) []Gateway {
+	gw := krt.NewManyCollection(gateways, func(ctx krt.HandlerContext, obj *gwv1.Gateway) []Gateway {
+		rm := reports.NewReportMap()
+		r := reports.NewReporter(&rm)
+		logger.Debug("translating Gateway", "gw_name", obj.GetName(), "resource_version", obj.GetResourceVersion())
+
 		if string(obj.Spec.GatewayClassName) != agentGatewayClassName {
 			return nil // ignore non agentgateway gws
 		}
@@ -134,11 +140,17 @@ func GatewayCollection(
 		controllerName := class.Controller
 		var servers []*istio.Server
 
-		// Extract the addresses. A gateway will bind to a specific Service
+		// Extract the addresses. A gwv1 will bind to a specific Service
 		gatewayServices, err := extractGatewayServices(domainSuffix, obj)
 		if len(gatewayServices) == 0 && err != nil {
 			// Short circuit if its a hard failure
-			// TODO: log
+			logger.Error("failed to translate gwv1", "name", obj.GetName(), "namespace", obj.GetNamespace(), "err", err.Message)
+			r.Gateway(obj).SetCondition(reporter.GatewayCondition{
+				Type:    gwv1.GatewayConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.GatewayReasonInvalid, // TODO: check reason
+				Message: err.Message,
+			})
 			return nil
 		}
 
@@ -157,7 +169,7 @@ func GatewayCollection(
 					Namespace:         obj.Namespace,
 					Domain:            domainSuffix,
 				},
-				// TODO: move away from istio gateway ir
+				// TODO: clean up and move away from istio gwv1 ir
 				Spec: &istio.Gateway{
 					Servers: []*istio.Server{server},
 				},
@@ -189,6 +201,10 @@ func GatewayCollection(
 			result = append(result, res)
 		}
 
+		r.Gateway(obj).SetCondition(reporter.GatewayCondition{
+			Type:   gwv1.GatewayConditionAccepted,
+			Status: metav1.ConditionTrue,
+		})
 		return result
 	}, krtopts.ToOptions("KubernetesGateway")...)
 
@@ -220,7 +236,7 @@ func BuildRouteParents(
 }
 
 // InternalGatewayName returns the name of the internal Istio Gateway corresponding to the
-// specified gateway-api gateway and listener.
+// specified gwv1-api gwv1 and listener.
 func InternalGatewayName(gwName, lName string) string {
 	return fmt.Sprintf("%s-%s-%s", gwName, AgentgatewayName, lName)
 }
diff --git a/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
index 7a23ab2eb..2570a2e84 100644
--- a/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gatewayclass_collection.go
@@ -2,17 +2,15 @@ package agentgatewaysyncer
 
 import (
 	"istio.io/istio/pkg/kube/krt"
-	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
-
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 )
 
 type GatewayClass struct {
 	Name       string
-	Controller gateway.GatewayController
+	Controller gwv1.GatewayController
 }
 
 func (g GatewayClass) ResourceName() string {
@@ -20,10 +18,10 @@ func (g GatewayClass) ResourceName() string {
 }
 
 func GatewayClassesCollection(
-	gatewayClasses krt.Collection[*gateway.GatewayClass],
+	gatewayClasses krt.Collection[*gwv1.GatewayClass],
 	krtopts krtutil.KrtOptions,
 ) krt.Collection[GatewayClass] {
-	return krt.NewCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gateway.GatewayClass) *GatewayClass {
+	return krt.NewCollection(gatewayClasses, func(ctx krt.HandlerContext, obj *gwv1.GatewayClass) *GatewayClass {
 		return &GatewayClass{
 			Name:       obj.Name,
 			Controller: obj.Spec.ControllerName,
@@ -31,7 +29,7 @@ func GatewayClassesCollection(
 	}, krtopts.ToOptions("GatewayClasses")...)
 }
 
-func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayClass], gc gatewayv1.ObjectName) *GatewayClass {
+func fetchClass(ctx krt.HandlerContext, gatewayClasses krt.Collection[GatewayClass], gc gwv1.ObjectName) *GatewayClass {
 	class := krt.FetchOne(ctx, gatewayClasses, krt.FilterKey(string(gc)))
 	if class == nil {
 		return &GatewayClass{
diff --git a/internal/kgateway/agentgatewaysyncer/references_collection.go b/internal/kgateway/agentgatewaysyncer/references_collection.go
index b4a93f233..50cf00277 100644
--- a/internal/kgateway/agentgatewaysyncer/references_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/references_collection.go
@@ -5,7 +5,7 @@ import (
 
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
@@ -18,7 +18,7 @@ import (
 // Reference stores a reference to a namespaced GVK, as used by ReferencePolicy
 type Reference struct {
 	Kind      schema.GroupVersionKind
-	Namespace gateway.Namespace
+	Namespace gwv1beta1.Namespace
 }
 
 func (refs Reference) String() string {
@@ -38,8 +38,8 @@ type ReferenceGrants struct {
 	index      krt.Index[ReferencePair, ReferenceGrant]
 }
 
-func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.ReferenceGrant], krtopts krtutil.KrtOptions) krt.Collection[ReferenceGrant] {
-	return krt.NewManyCollection(referenceGrants, func(ctx krt.HandlerContext, obj *gateway.ReferenceGrant) []ReferenceGrant {
+func ReferenceGrantsCollection(referenceGrants krt.Collection[*gwv1beta1.ReferenceGrant], krtopts krtutil.KrtOptions) krt.Collection[ReferenceGrant] {
+	return krt.NewManyCollection(referenceGrants, func(ctx krt.HandlerContext, obj *gwv1beta1.ReferenceGrant) []ReferenceGrant {
 		rp := obj.Spec
 		results := make([]ReferenceGrant, 0, len(rp.From)*len(rp.To))
 		for _, from := range rp.From {
@@ -62,7 +62,7 @@ func ReferenceGrantsCollection(referenceGrants krt.Collection[*gateway.Reference
 			}
 			for _, to := range rp.To {
 				toKey := Reference{
-					Namespace: gateway.Namespace(obj.Namespace),
+					Namespace: gwv1beta1.Namespace(obj.Namespace),
 				}
 				if to.Group == "" && string(to.Kind) == wellknown.SecretGVK.Kind {
 					toKey.Kind = wellknown.SecretGVK
@@ -122,8 +122,8 @@ func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName s
 		logger.Warn("failed to parse resource name", "resourceName", resourceName, "error", err)
 		return false
 	}
-	from := Reference{Kind: wellknown.GatewayGVK, Namespace: gateway.Namespace(namespace)}
-	to := Reference{Kind: wellknown.SecretGVK, Namespace: gateway.Namespace(p.Namespace)}
+	from := Reference{Kind: wellknown.GatewayGVK, Namespace: gwv1beta1.Namespace(namespace)}
+	to := Reference{Kind: wellknown.SecretGVK, Namespace: gwv1beta1.Namespace(p.Namespace)}
 	pair := ReferencePair{From: from, To: to}
 	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
 	for _, g := range grants {
@@ -136,11 +136,11 @@ func (refs ReferenceGrants) SecretAllowed(ctx krt.HandlerContext, resourceName s
 
 func (refs ReferenceGrants) BackendAllowed(ctx krt.HandlerContext,
 	k schema.GroupVersionKind,
-	backendName gateway.ObjectName,
-	backendNamespace gateway.Namespace,
+	backendName gwv1beta1.ObjectName,
+	backendNamespace gwv1beta1.Namespace,
 	routeNamespace string,
 ) bool {
-	from := Reference{Kind: k, Namespace: gateway.Namespace(routeNamespace)}
+	from := Reference{Kind: k, Namespace: gwv1beta1.Namespace(routeNamespace)}
 	to := Reference{Kind: wellknown.SecretGVK, Namespace: backendNamespace}
 	pair := ReferencePair{From: from, To: to}
 	grants := krt.Fetch(ctx, refs.collection, krt.FilterIndex(refs.index, pair))
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
index 054f2e5d9..48cea3cf2 100644
--- a/internal/kgateway/agentgatewaysyncer/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -4,31 +4,38 @@ import (
 	"iter"
 	"strings"
 
-	corev1 "k8s.io/api/core/v1"
-	"k8s.io/apimachinery/pkg/types"
-	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
-
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pkg/config"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/protomarshal"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 )
 
 // TODO: support other route collections (TCP, TLS, etc.)
 func ADPRouteCollection(
-	httpRoutes krt.Collection[*gateway.HTTPRoute],
+	httpRoutes krt.Collection[*gwv1.HTTPRoute],
 	inputs RouteContextInputs,
 	krtopts krtutil.KrtOptions,
 ) krt.Collection[ADPResource] {
-	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gateway.HTTPRoute) []ADPResource {
+	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gwv1.HTTPRoute) []ADPResource {
+		rm := reports.NewReportMap()
+		rep := reports.NewReporter(&rm)
+		logger.Debug("translating HTTPRoute", "route_name", obj.GetName(), "resource_version", obj.GetResourceVersion())
+
 		ctx := inputs.WithCtx(krtctx)
 		route := obj.Spec
-		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gateway.HTTPRoute) iter.Seq2[ADPRoute, *ConfigError] {
+		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gwv1.HTTPRoute) iter.Seq2[ADPRoute, *ConfigError] {
 			return func(yield func(ADPRoute, *ConfigError) bool) {
 				for n, r := range route.Rules {
 					// split the rule to make sure each rule has up to one match
@@ -38,10 +45,9 @@ func ADPRouteCollection(
 					}
 					for idx, m := range matches {
 						if m != nil {
-							r.Matches = []gateway.HTTPRouteMatch{*m}
+							r.Matches = []gwv1.HTTPRouteMatch{*m}
 						}
 						res, err := convertHTTPRouteToADP(ctx, r, obj, n, idx)
-
 						if !yield(ADPRoute{Route: res}, err) {
 							return
 						}
@@ -52,11 +58,20 @@ func ADPRouteCollection(
 
 		var res []ADPResource
 		for _, parent := range filteredReferences(parentRefs) {
-			// for gateway routes, build one VS per gateway+host
+			// for gwv1beta1 routes, build one VS per gwv1beta1+host
 			routes := gwResult.routes
 			if len(routes) == 0 {
 				continue
 			}
+			if gwResult.error != nil {
+				rep.Route(obj).ParentRef(&parent.OriginalReference).SetCondition(reporter.RouteCondition{
+					Type:    gwv1beta1.RouteConditionResolvedRefs, // TODO: check type
+					Status:  metav1.ConditionFalse,
+					Reason:  gwv1beta1.RouteConditionReason(gwResult.error.Reason),
+					Message: gwResult.error.Message,
+				})
+			}
+
 			gw := types.NamespacedName{
 				Namespace: parent.ParentKey.Namespace,
 				Name:      parent.ParentKey.Name,
@@ -152,7 +167,7 @@ func (r RouteWithKey) Equals(o RouteWithKey) bool {
 	return r.Config.Equals(o.Config)
 }
 
-// buildGatewayRoutes contains common logic to build a set of routes with gateway semantics
+// buildGatewayRoutes contains common logic to build a set of routes with gwv1beta1 semantics
 func buildGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func() T) T {
 	return convertRules()
 }
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 6d5e07658..78234e8df 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -29,9 +29,9 @@ import (
 	"k8s.io/client-go/tools/cache"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	"sigs.k8s.io/gateway-api-inference-extension/client-go/clientset/versioned"
-	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
-	gatewayalpha "sigs.k8s.io/gateway-api/apis/v1alpha2"
-	gateway "sigs.k8s.io/gateway-api/apis/v1beta1"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+	gwv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
+	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 
@@ -173,13 +173,13 @@ type Inputs struct {
 	Services krt.Collection[*corev1.Service]
 	Secrets  krt.Collection[*corev1.Secret]
 
-	GatewayClasses  krt.Collection[*gateway.GatewayClass]
-	Gateways        krt.Collection[*gateway.Gateway]
-	HTTPRoutes      krt.Collection[*gateway.HTTPRoute]
-	GRPCRoutes      krt.Collection[*gatewayv1.GRPCRoute]
-	TCPRoutes       krt.Collection[*gatewayalpha.TCPRoute]
-	TLSRoutes       krt.Collection[*gatewayalpha.TLSRoute]
-	ReferenceGrants krt.Collection[*gateway.ReferenceGrant]
+	GatewayClasses  krt.Collection[*gwv1.GatewayClass]
+	Gateways        krt.Collection[*gwv1.Gateway]
+	HTTPRoutes      krt.Collection[*gwv1.HTTPRoute]
+	GRPCRoutes      krt.Collection[*gwv1.GRPCRoute]
+	TCPRoutes       krt.Collection[*gwv1alpha2.TCPRoute]
+	TLSRoutes       krt.Collection[*gwv1alpha2.TLSRoute]
+	ReferenceGrants krt.Collection[*gwv1beta1.ReferenceGrant]
 	ServiceEntries  krt.Collection[*networkingclient.ServiceEntry]
 	InferencePools  krt.Collection[*inf.InferencePool]
 }
@@ -218,22 +218,22 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 			kclient.NewFiltered[*corev1.Service](s.client, kubetypes.Filter{ObjectFilter: s.client.ObjectFilter()}),
 			krtopts.ToOptions("informer/Services")...),
 
-		GatewayClasses: krt.WrapClient(kclient.New[*gateway.GatewayClass](s.client), krtopts.ToOptions("informer/GatewayClasses")...),
-		Gateways:       krt.WrapClient(kclient.New[*gateway.Gateway](s.client), krtopts.ToOptions("informer/Gateways")...),
-		HTTPRoutes:     krt.WrapClient(kclient.New[*gateway.HTTPRoute](s.client), krtopts.ToOptions("informer/HTTPRoutes")...),
-		GRPCRoutes:     krt.WrapClient(kclient.New[*gatewayv1.GRPCRoute](s.client), krtopts.ToOptions("informer/GRPCRoutes")...),
+		GatewayClasses: krt.WrapClient(kclient.New[*gwv1.GatewayClass](s.client), krtopts.ToOptions("informer/GatewayClasses")...),
+		Gateways:       krt.WrapClient(kclient.New[*gwv1.Gateway](s.client), krtopts.ToOptions("informer/Gateways")...),
+		HTTPRoutes:     krt.WrapClient(kclient.New[*gwv1.HTTPRoute](s.client), krtopts.ToOptions("informer/HTTPRoutes")...),
+		GRPCRoutes:     krt.WrapClient(kclient.New[*gwv1.GRPCRoute](s.client), krtopts.ToOptions("informer/GRPCRoutes")...),
 
-		ReferenceGrants: krt.WrapClient(kclient.New[*gateway.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
+		ReferenceGrants: krt.WrapClient(kclient.New[*gwv1beta1.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
 		//ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
 		InferencePools: krt.WrapClient(kclient.NewDelayedInformer[*inf.InferencePool](s.client, inferencePoolGVR, kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()}), krtopts.ToOptions("informer/InferencePools")...),
 	}
 	if features.EnableAlphaGatewayAPI {
-		inputs.TCPRoutes = krt.WrapClient(kclient.New[*gatewayalpha.TCPRoute](s.client), krtopts.ToOptions("informer/TCPRoutes")...)
-		inputs.TLSRoutes = krt.WrapClient(kclient.New[*gatewayalpha.TLSRoute](s.client), krtopts.ToOptions("informer/TLSRoutes")...)
+		inputs.TCPRoutes = krt.WrapClient(kclient.New[*gwv1alpha2.TCPRoute](s.client), krtopts.ToOptions("informer/TCPRoutes")...)
+		inputs.TLSRoutes = krt.WrapClient(kclient.New[*gwv1alpha2.TLSRoute](s.client), krtopts.ToOptions("informer/TLSRoutes")...)
 	} else {
 		// If disabled, still build a collection but make it always empty
-		inputs.TCPRoutes = krt.NewStaticCollection[*gatewayalpha.TCPRoute](nil, krtopts.ToOptions("disable/TCPRoutes")...)
-		inputs.TLSRoutes = krt.NewStaticCollection[*gatewayalpha.TLSRoute](nil, krtopts.ToOptions("disable/TLSRoutes")...)
+		inputs.TCPRoutes = krt.NewStaticCollection[*gwv1alpha2.TCPRoute](nil, krtopts.ToOptions("disable/TCPRoutes")...)
+		inputs.TLSRoutes = krt.NewStaticCollection[*gwv1alpha2.TLSRoute](nil, krtopts.ToOptions("disable/TLSRoutes")...)
 	}
 
 	GatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, krtopts)
@@ -292,9 +292,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		}
 
 		switch obj.parentInfo.Protocol {
-		case gatewayv1.HTTPProtocolType:
+		case gwv1.HTTPProtocolType:
 			l.Protocol = api.Protocol_HTTP
-		case gatewayv1.HTTPSProtocolType:
+		case gwv1.HTTPSProtocolType:
 			l.Protocol = api.Protocol_HTTPS
 			if obj.TLSInfo == nil {
 				return nil
@@ -303,7 +303,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 				Cert:       obj.TLSInfo.Cert,
 				PrivateKey: obj.TLSInfo.Key,
 			}
-		case gatewayv1.TLSProtocolType:
+		case gwv1.TLSProtocolType:
 			l.Protocol = api.Protocol_TLS
 			if obj.TLSInfo == nil {
 				return nil
@@ -312,7 +312,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 				Cert:       obj.TLSInfo.Cert,
 				PrivateKey: obj.TLSInfo.Key,
 			}
-		case gatewayv1.TCPProtocolType:
+		case gwv1.TCPProtocolType:
 			l.Protocol = api.Protocol_TCP
 		default:
 			return nil
@@ -340,8 +340,6 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		krtopts,
 	)
 
-	// TODO: inference pool
-
 	epSliceClient := kclient.NewFiltered[*discoveryv1.EndpointSlice](
 		s.commonCols.Client,
 		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
@@ -449,13 +447,13 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		for _, resource := range resourceList {
 			// TODO: filter at collection? (add index per gw?)
 			// TODO: empty gw??
-			//if resource.Gateway.Name == gwNamespacedName.Name && resource.Gateway.Namespace == gwNamespacedName.Namespace {
-			cacheResources = append(cacheResources, &envoyResourceWithCustomName{
-				Message: resource.Resource,
-				Name:    resource.ResourceName(),
-				version: utils.HashProto(resource.Resource),
-			})
-			//}
+			if resource.Gateway.Name == gwNamespacedName.Name && resource.Gateway.Namespace == gwNamespacedName.Namespace {
+				cacheResources = append(cacheResources, &envoyResourceWithCustomName{
+					Message: resource.Resource,
+					Name:    resource.ResourceName(),
+					version: utils.HashProto(resource.Resource),
+				})
+			}
 		}
 
 		// Create the resource wrappers
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
index 5b7457aba..0ddbbd16b 100644
--- a/internal/kgateway/agentgatewaysyncer/workloads.go
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -22,7 +22,6 @@ import (
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/schema/kind"
-	"istio.io/istio/pkg/config/schema/kubetypes"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
 	kubelabels "istio.io/istio/pkg/kube/labels"
@@ -274,9 +273,10 @@ func (a *index) serviceEntriesInfo(ctx krt.HandlerContext, s *networkingclient.S
 
 // MakeSource is a helper to turn an Object into a model.TypedObject.
 func MakeSource(o controllers.Object) TypedObject {
+	kind := o.GetObjectKind().GroupVersionKind().Kind
 	return TypedObject{
 		NamespacedName: config.NamespacedName(o),
-		Kind:           kubetypes.GvkFromObject(o).Kind,
+		Kind:           kind,
 	}
 }
 
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index 142753844..d8d61644c 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -79,7 +79,7 @@ func testAgentGatewayScenario(
 
 	// read the out file
 	fout := fpre + "-out" + fext
-	write := true
+	write := false
 	_, err := os.ReadFile(fout)
 	// if not exist
 	if os.IsNotExist(err) {
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
index ffe45fe88..42c0ab793 100644
--- a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
@@ -8,7 +8,7 @@
           "hostname": "http-httproute.gwtest.svc.cluster.local",
           "addresses": [
             {
-              "address": "CgAAhA=="
+              "address": "CgAApw=="
             }
           ],
           "ports": [
@@ -24,18 +24,18 @@
     {
       "Type": {
         "Workload": {
-          "uid": "//Pod/gwtest/reviews-2",
-          "name": "reviews-2",
+          "uid": "//Pod/gwtest/reviews-1",
+          "name": "reviews-1",
           "namespace": "gwtest",
           "addresses": [
-            "CvQCDg=="
+            "CvQBCw=="
           ],
           "service_account": "default",
-          "node": "worker2",
+          "node": "worker",
           "canonical_name": "reviews",
           "canonical_revision": "latest",
           "workload_type": 2,
-          "workload_name": "reviews-2",
+          "workload_name": "reviews-1",
           "services": {
             "gwtest/reviews.gwtest.svc.cluster.local": {
               "ports": [
@@ -78,17 +78,17 @@
     {
       "Kind": {
         "Route": {
-          "key": "gwtest.my-route2.0.0.http",
+          "key": "gwtest.my-route.0.0.http",
           "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
-          "route_name": "gwtest/my-route2",
+          "route_name": "gwtest/my-route",
           "hostnames": [
-            "www.example2.com"
+            "www.example.com"
           ],
           "matches": [
             {
               "path": {
                 "Kind": {
-                  "PathPrefix": "/"
+                  "PathPrefix": "/myapp"
                 }
               }
             }
@@ -108,17 +108,17 @@
     {
       "Kind": {
         "Route": {
-          "key": "gwtest.my-route.0.0.http",
+          "key": "gwtest.my-route2.0.0.http",
           "listener_key": "http-httproute-agentgateway-autogenerated-k8s-gateway-http",
-          "route_name": "gwtest/my-route",
+          "route_name": "gwtest/my-route2",
           "hostnames": [
-            "www.example.com"
+            "www.example2.com"
           ],
           "matches": [
             {
               "path": {
                 "Kind": {
-                  "PathPrefix": "/myapp"
+                  "PathPrefix": "/"
                 }
               }
             }
diff --git a/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
index bb4023240..717094c9e 100644
--- a/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
+++ b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
@@ -19,24 +19,43 @@
     {
       "Type": {
         "Workload": {
-          "uid": "//Pod/gwtest/reviews-2",
-          "name": "reviews-2",
+          "uid": "//Pod/gwtest/reviews-3",
+          "name": "reviews-3",
           "namespace": "gwtest",
           "addresses": [
-            "CvQCDg=="
+            "CvQDAw=="
           ],
           "service_account": "default",
-          "node": "worker2",
+          "node": "worker3",
           "canonical_name": "reviews",
           "canonical_revision": "latest",
           "workload_type": 2,
-          "workload_name": "reviews-2",
+          "workload_name": "reviews-3",
           "status": 1
         }
       }
     }
   ],
   "resources": [
+    {
+      "Kind": {
+        "Bind": {
+          "key": "8080/gwtest/http-inferencepool",
+          "port": 8080
+        }
+      }
+    },
+    {
+      "Kind": {
+        "Listener": {
+          "key": "http-inferencepool-agentgateway-autogenerated-k8s-gateway-http",
+          "name": "http",
+          "bind_key": "8080/gwtest/http-inferencepool",
+          "gateway_name": "gwtest/http-inferencepool",
+          "protocol": 1
+        }
+      }
+    },
     {
       "Kind": {
         "Route": {
@@ -66,25 +85,6 @@
           ]
         }
       }
-    },
-    {
-      "Kind": {
-        "Bind": {
-          "key": "8080/gwtest/http-inferencepool",
-          "port": 8080
-        }
-      }
-    },
-    {
-      "Kind": {
-        "Listener": {
-          "key": "http-inferencepool-agentgateway-autogenerated-k8s-gateway-http",
-          "name": "http",
-          "bind_key": "8080/gwtest/http-inferencepool",
-          "gateway_name": "gwtest/http-inferencepool",
-          "protocol": 1
-        }
-      }
     }
   ]
 }
\ No newline at end of file
diff --git a/pkg/client/clientset/versioned/fake/clientset_generated.go b/pkg/client/clientset/versioned/fake/clientset_generated.go
index 287b7d538..51e63cb63 100644
--- a/pkg/client/clientset/versioned/fake/clientset_generated.go
+++ b/pkg/client/clientset/versioned/fake/clientset_generated.go
@@ -3,6 +3,7 @@
 package fake
 
 import (
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/discovery"
@@ -35,9 +36,13 @@ func NewSimpleClientset(objects ...runtime.Object) *Clientset {
 	cs.discovery = &fakediscovery.FakeDiscovery{Fake: &cs.Fake}
 	cs.AddReactor("*", "*", testing.ObjectReaction(o))
 	cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) {
+		var opts metav1.ListOptions
+		if watchActcion, ok := action.(testing.WatchActionImpl); ok {
+			opts = watchActcion.ListOptions
+		}
 		gvr := action.GetResource()
 		ns := action.GetNamespace()
-		watch, err := o.Watch(gvr, ns)
+		watch, err := o.Watch(gvr, ns, opts)
 		if err != nil {
 			return false, nil, err
 		}
@@ -84,9 +89,13 @@ func NewClientset(objects ...runtime.Object) *Clientset {
 	cs.discovery = &fakediscovery.FakeDiscovery{Fake: &cs.Fake}
 	cs.AddReactor("*", "*", testing.ObjectReaction(o))
 	cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) {
+		var opts metav1.ListOptions
+		if watchActcion, ok := action.(testing.WatchActionImpl); ok {
+			opts = watchActcion.ListOptions
+		}
 		gvr := action.GetResource()
 		ns := action.GetNamespace()
-		watch, err := o.Watch(gvr, ns)
+		watch, err := o.Watch(gvr, ns, opts)
 		if err != nil {
 			return false, nil, err
 		}
diff --git a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
index 3e94e5065..5145d2df3 100644
--- a/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
+++ b/pkg/client/clientset/versioned/typed/api/v1alpha1/api_client.go
@@ -60,9 +60,7 @@ func (c *GatewayV1alpha1Client) TrafficPolicies(namespace string) TrafficPolicyI
 // where httpClient was generated with rest.HTTPClientFor(c).
 func NewForConfig(c *rest.Config) (*GatewayV1alpha1Client, error) {
 	config := *c
-	if err := setConfigDefaults(&config); err != nil {
-		return nil, err
-	}
+	setConfigDefaults(&config)
 	httpClient, err := rest.HTTPClientFor(&config)
 	if err != nil {
 		return nil, err
@@ -74,9 +72,7 @@ func NewForConfig(c *rest.Config) (*GatewayV1alpha1Client, error) {
 // Note the http client provided takes precedence over the configured transport values.
 func NewForConfigAndClient(c *rest.Config, h *http.Client) (*GatewayV1alpha1Client, error) {
 	config := *c
-	if err := setConfigDefaults(&config); err != nil {
-		return nil, err
-	}
+	setConfigDefaults(&config)
 	client, err := rest.RESTClientForConfigAndClient(&config, h)
 	if err != nil {
 		return nil, err
@@ -99,7 +95,7 @@ func New(c rest.Interface) *GatewayV1alpha1Client {
 	return &GatewayV1alpha1Client{c}
 }
 
-func setConfigDefaults(config *rest.Config) error {
+func setConfigDefaults(config *rest.Config) {
 	gv := apiv1alpha1.SchemeGroupVersion
 	config.GroupVersion = &gv
 	config.APIPath = "/apis"
@@ -108,8 +104,6 @@ func setConfigDefaults(config *rest.Config) error {
 	if config.UserAgent == "" {
 		config.UserAgent = rest.DefaultKubernetesUserAgent()
 	}
-
-	return nil
 }
 
 // RESTClient returns a RESTClient that is used to communicate
diff --git a/pkg/generated/openapi/zz_generated.openapi.go b/pkg/generated/openapi/zz_generated.openapi.go
index 2099598d2..a59386eaa 100644
--- a/pkg/generated/openapi/zz_generated.openapi.go
+++ b/pkg/generated/openapi/zz_generated.openapi.go
@@ -262,6 +262,7 @@ func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenA
 		"k8s.io/api/core/v1.NodeSelectorTerm":                                                        schema_k8sio_api_core_v1_NodeSelectorTerm(ref),
 		"k8s.io/api/core/v1.NodeSpec":                                                                schema_k8sio_api_core_v1_NodeSpec(ref),
 		"k8s.io/api/core/v1.NodeStatus":                                                              schema_k8sio_api_core_v1_NodeStatus(ref),
+		"k8s.io/api/core/v1.NodeSwapStatus":                                                          schema_k8sio_api_core_v1_NodeSwapStatus(ref),
 		"k8s.io/api/core/v1.NodeSystemInfo":                                                          schema_k8sio_api_core_v1_NodeSystemInfo(ref),
 		"k8s.io/api/core/v1.ObjectFieldSelector":                                                     schema_k8sio_api_core_v1_ObjectFieldSelector(ref),
 		"k8s.io/api/core/v1.ObjectReference":                                                         schema_k8sio_api_core_v1_ObjectReference(ref),
@@ -8135,6 +8136,14 @@ func schema_k8sio_api_core_v1_ContainerStatus(ref common.ReferenceCallback) comm
 							},
 						},
 					},
+					"stopSignal": {
+						SchemaProps: spec.SchemaProps{
+							Description: "StopSignal reports the effective stop signal for this container\n\nPossible enum values:\n - `\"SIGABRT\"`\n - `\"SIGALRM\"`\n - `\"SIGBUS\"`\n - `\"SIGCHLD\"`\n - `\"SIGCLD\"`\n - `\"SIGCONT\"`\n - `\"SIGFPE\"`\n - `\"SIGHUP\"`\n - `\"SIGILL\"`\n - `\"SIGINT\"`\n - `\"SIGIO\"`\n - `\"SIGIOT\"`\n - `\"SIGKILL\"`\n - `\"SIGPIPE\"`\n - `\"SIGPOLL\"`\n - `\"SIGPROF\"`\n - `\"SIGPWR\"`\n - `\"SIGQUIT\"`\n - `\"SIGRTMAX\"`\n - `\"SIGRTMAX-1\"`\n - `\"SIGRTMAX-10\"`\n - `\"SIGRTMAX-11\"`\n - `\"SIGRTMAX-12\"`\n - `\"SIGRTMAX-13\"`\n - `\"SIGRTMAX-14\"`\n - `\"SIGRTMAX-2\"`\n - `\"SIGRTMAX-3\"`\n - `\"SIGRTMAX-4\"`\n - `\"SIGRTMAX-5\"`\n - `\"SIGRTMAX-6\"`\n - `\"SIGRTMAX-7\"`\n - `\"SIGRTMAX-8\"`\n - `\"SIGRTMAX-9\"`\n - `\"SIGRTMIN\"`\n - `\"SIGRTMIN+1\"`\n - `\"SIGRTMIN+10\"`\n - `\"SIGRTMIN+11\"`\n - `\"SIGRTMIN+12\"`\n - `\"SIGRTMIN+13\"`\n - `\"SIGRTMIN+14\"`\n - `\"SIGRTMIN+15\"`\n - `\"SIGRTMIN+2\"`\n - `\"SIGRTMIN+3\"`\n - `\"SIGRTMIN+4\"`\n - `\"SIGRTMIN+5\"`\n - `\"SIGRTMIN+6\"`\n - `\"SIGRTMIN+7\"`\n - `\"SIGRTMIN+8\"`\n - `\"SIGRTMIN+9\"`\n - `\"SIGSEGV\"`\n - `\"SIGSTKFLT\"`\n - `\"SIGSTOP\"`\n - `\"SIGSYS\"`\n - `\"SIGTERM\"`\n - `\"SIGTRAP\"`\n - `\"SIGTSTP\"`\n - `\"SIGTTIN\"`\n - `\"SIGTTOU\"`\n - `\"SIGURG\"`\n - `\"SIGUSR1\"`\n - `\"SIGUSR2\"`\n - `\"SIGVTALRM\"`\n - `\"SIGWINCH\"`\n - `\"SIGXCPU\"`\n - `\"SIGXFSZ\"`",
+							Type:        []string{"string"},
+							Format:      "",
+							Enum:        []interface{}{"SIGABRT", "SIGALRM", "SIGBUS", "SIGCHLD", "SIGCLD", "SIGCONT", "SIGFPE", "SIGHUP", "SIGILL", "SIGINT", "SIGIO", "SIGIOT", "SIGKILL", "SIGPIPE", "SIGPOLL", "SIGPROF", "SIGPWR", "SIGQUIT", "SIGRTMAX", "SIGRTMAX-1", "SIGRTMAX-10", "SIGRTMAX-11", "SIGRTMAX-12", "SIGRTMAX-13", "SIGRTMAX-14", "SIGRTMAX-2", "SIGRTMAX-3", "SIGRTMAX-4", "SIGRTMAX-5", "SIGRTMAX-6", "SIGRTMAX-7", "SIGRTMAX-8", "SIGRTMAX-9", "SIGRTMIN", "SIGRTMIN+1", "SIGRTMIN+10", "SIGRTMIN+11", "SIGRTMIN+12", "SIGRTMIN+13", "SIGRTMIN+14", "SIGRTMIN+15", "SIGRTMIN+2", "SIGRTMIN+3", "SIGRTMIN+4", "SIGRTMIN+5", "SIGRTMIN+6", "SIGRTMIN+7", "SIGRTMIN+8", "SIGRTMIN+9", "SIGSEGV", "SIGSTKFLT", "SIGSTOP", "SIGSYS", "SIGTERM", "SIGTRAP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGURG", "SIGUSR1", "SIGUSR2", "SIGVTALRM", "SIGWINCH", "SIGXCPU", "SIGXFSZ"},
+						},
+					},
 				},
 				Required: []string{"name", "ready", "restartCount", "image", "imageID"},
 			},
@@ -8337,7 +8346,7 @@ func schema_k8sio_api_core_v1_EndpointAddress(ref common.ReferenceCallback) comm
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointAddress is a tuple that describes single IP address.",
+				Description: "EndpointAddress is a tuple that describes single IP address. Deprecated: This API is deprecated in v1.33+.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"ip": {
@@ -8386,7 +8395,7 @@ func schema_k8sio_api_core_v1_EndpointPort(ref common.ReferenceCallback) common.
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointPort is a tuple that describes a single port.",
+				Description: "EndpointPort is a tuple that describes a single port. Deprecated: This API is deprecated in v1.33+.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"name": {
@@ -8435,7 +8444,7 @@ func schema_k8sio_api_core_v1_EndpointSubset(ref common.ReferenceCallback) commo
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:\n\n\t{\n\t  Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t  Ports:     [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t}\n\nThe resulting set of endpoints can be viewed as:\n\n\ta: [ 10.10.1.1:8675, 10.10.2.2:8675 ],\n\tb: [ 10.10.1.1:309, 10.10.2.2:309 ]",
+				Description: "EndpointSubset is a group of addresses with a common set of ports. The expanded set of endpoints is the Cartesian product of Addresses x Ports. For example, given:\n\n\t{\n\t  Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t  Ports:     [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t}\n\nThe resulting set of endpoints can be viewed as:\n\n\ta: [ 10.10.1.1:8675, 10.10.2.2:8675 ],\n\tb: [ 10.10.1.1:309, 10.10.2.2:309 ]\n\nDeprecated: This API is deprecated in v1.33+.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"addresses": {
@@ -8507,7 +8516,7 @@ func schema_k8sio_api_core_v1_Endpoints(ref common.ReferenceCallback) common.Ope
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]",
+				Description: "Endpoints is a collection of endpoints that implement the actual service. Example:\n\n\t Name: \"mysvc\",\n\t Subsets: [\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.1.1\"}, {\"ip\": \"10.10.2.2\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 8675}, {\"name\": \"b\", \"port\": 309}]\n\t   },\n\t   {\n\t     Addresses: [{\"ip\": \"10.10.3.3\"}],\n\t     Ports: [{\"name\": \"a\", \"port\": 93}, {\"name\": \"b\", \"port\": 76}]\n\t   },\n\t]\n\nEndpoints is a legacy API and does not contain information about all Service features. Use discoveryv1.EndpointSlice for complete information about Service endpoints.\n\nDeprecated: This API is deprecated in v1.33+. Use discoveryv1.EndpointSlice.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"kind": {
@@ -8562,7 +8571,7 @@ func schema_k8sio_api_core_v1_EndpointsList(ref common.ReferenceCallback) common
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EndpointsList is a list of endpoints.",
+				Description: "EndpointsList is a list of endpoints. Deprecated: This API is deprecated in v1.33+.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"kind": {
@@ -8613,12 +8622,12 @@ func schema_k8sio_api_core_v1_EnvFromSource(ref common.ReferenceCallback) common
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
 			SchemaProps: spec.SchemaProps{
-				Description: "EnvFromSource represents the source of a set of ConfigMaps",
+				Description: "EnvFromSource represents the source of a set of ConfigMaps or Secrets",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
 					"prefix": {
 						SchemaProps: spec.SchemaProps{
-							Description: "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
+							Description: "Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.",
 							Type:        []string{"string"},
 							Format:      "",
 						},
@@ -10520,6 +10529,14 @@ func schema_k8sio_api_core_v1_Lifecycle(ref common.ReferenceCallback) common.Ope
 							Ref:         ref("k8s.io/api/core/v1.LifecycleHandler"),
 						},
 					},
+					"stopSignal": {
+						SchemaProps: spec.SchemaProps{
+							Description: "StopSignal defines which signal will be sent to a container when it is being stopped. If not specified, the default is defined by the container runtime in use. StopSignal can only be set for Pods with a non-empty .spec.os.name\n\nPossible enum values:\n - `\"SIGABRT\"`\n - `\"SIGALRM\"`\n - `\"SIGBUS\"`\n - `\"SIGCHLD\"`\n - `\"SIGCLD\"`\n - `\"SIGCONT\"`\n - `\"SIGFPE\"`\n - `\"SIGHUP\"`\n - `\"SIGILL\"`\n - `\"SIGINT\"`\n - `\"SIGIO\"`\n - `\"SIGIOT\"`\n - `\"SIGKILL\"`\n - `\"SIGPIPE\"`\n - `\"SIGPOLL\"`\n - `\"SIGPROF\"`\n - `\"SIGPWR\"`\n - `\"SIGQUIT\"`\n - `\"SIGRTMAX\"`\n - `\"SIGRTMAX-1\"`\n - `\"SIGRTMAX-10\"`\n - `\"SIGRTMAX-11\"`\n - `\"SIGRTMAX-12\"`\n - `\"SIGRTMAX-13\"`\n - `\"SIGRTMAX-14\"`\n - `\"SIGRTMAX-2\"`\n - `\"SIGRTMAX-3\"`\n - `\"SIGRTMAX-4\"`\n - `\"SIGRTMAX-5\"`\n - `\"SIGRTMAX-6\"`\n - `\"SIGRTMAX-7\"`\n - `\"SIGRTMAX-8\"`\n - `\"SIGRTMAX-9\"`\n - `\"SIGRTMIN\"`\n - `\"SIGRTMIN+1\"`\n - `\"SIGRTMIN+10\"`\n - `\"SIGRTMIN+11\"`\n - `\"SIGRTMIN+12\"`\n - `\"SIGRTMIN+13\"`\n - `\"SIGRTMIN+14\"`\n - `\"SIGRTMIN+15\"`\n - `\"SIGRTMIN+2\"`\n - `\"SIGRTMIN+3\"`\n - `\"SIGRTMIN+4\"`\n - `\"SIGRTMIN+5\"`\n - `\"SIGRTMIN+6\"`\n - `\"SIGRTMIN+7\"`\n - `\"SIGRTMIN+8\"`\n - `\"SIGRTMIN+9\"`\n - `\"SIGSEGV\"`\n - `\"SIGSTKFLT\"`\n - `\"SIGSTOP\"`\n - `\"SIGSYS\"`\n - `\"SIGTERM\"`\n - `\"SIGTRAP\"`\n - `\"SIGTSTP\"`\n - `\"SIGTTIN\"`\n - `\"SIGTTOU\"`\n - `\"SIGURG\"`\n - `\"SIGUSR1\"`\n - `\"SIGUSR2\"`\n - `\"SIGVTALRM\"`\n - `\"SIGWINCH\"`\n - `\"SIGXCPU\"`\n - `\"SIGXFSZ\"`",
+							Type:        []string{"string"},
+							Format:      "",
+							Enum:        []interface{}{"SIGABRT", "SIGALRM", "SIGBUS", "SIGCHLD", "SIGCLD", "SIGCONT", "SIGFPE", "SIGHUP", "SIGILL", "SIGINT", "SIGIO", "SIGIOT", "SIGKILL", "SIGPIPE", "SIGPOLL", "SIGPROF", "SIGPWR", "SIGQUIT", "SIGRTMAX", "SIGRTMAX-1", "SIGRTMAX-10", "SIGRTMAX-11", "SIGRTMAX-12", "SIGRTMAX-13", "SIGRTMAX-14", "SIGRTMAX-2", "SIGRTMAX-3", "SIGRTMAX-4", "SIGRTMAX-5", "SIGRTMAX-6", "SIGRTMAX-7", "SIGRTMAX-8", "SIGRTMAX-9", "SIGRTMIN", "SIGRTMIN+1", "SIGRTMIN+10", "SIGRTMIN+11", "SIGRTMIN+12", "SIGRTMIN+13", "SIGRTMIN+14", "SIGRTMIN+15", "SIGRTMIN+2", "SIGRTMIN+3", "SIGRTMIN+4", "SIGRTMIN+5", "SIGRTMIN+6", "SIGRTMIN+7", "SIGRTMIN+8", "SIGRTMIN+9", "SIGSEGV", "SIGSTKFLT", "SIGSTOP", "SIGSYS", "SIGTERM", "SIGTRAP", "SIGTSTP", "SIGTTIN", "SIGTTOU", "SIGURG", "SIGUSR1", "SIGUSR2", "SIGVTALRM", "SIGWINCH", "SIGXCPU", "SIGXFSZ"},
+						},
+					},
 				},
 			},
 		},
@@ -12196,6 +12213,26 @@ func schema_k8sio_api_core_v1_NodeStatus(ref common.ReferenceCallback) common.Op
 	}
 }
 
+func schema_k8sio_api_core_v1_NodeSwapStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
+	return common.OpenAPIDefinition{
+		Schema: spec.Schema{
+			SchemaProps: spec.SchemaProps{
+				Description: "NodeSwapStatus represents swap memory information.",
+				Type:        []string{"object"},
+				Properties: map[string]spec.Schema{
+					"capacity": {
+						SchemaProps: spec.SchemaProps{
+							Description: "Total amount of swap memory in bytes.",
+							Type:        []string{"integer"},
+							Format:      "int64",
+						},
+					},
+				},
+			},
+		},
+	}
+}
+
 func schema_k8sio_api_core_v1_NodeSystemInfo(ref common.ReferenceCallback) common.OpenAPIDefinition {
 	return common.OpenAPIDefinition{
 		Schema: spec.Schema{
@@ -12283,10 +12320,18 @@ func schema_k8sio_api_core_v1_NodeSystemInfo(ref common.ReferenceCallback) commo
 							Format:      "",
 						},
 					},
+					"swap": {
+						SchemaProps: spec.SchemaProps{
+							Description: "Swap Info reported by the node.",
+							Ref:         ref("k8s.io/api/core/v1.NodeSwapStatus"),
+						},
+					},
 				},
 				Required: []string{"machineID", "systemUUID", "bootID", "kernelVersion", "osImage", "containerRuntimeVersion", "kubeletVersion", "kubeProxyVersion", "operatingSystem", "architecture"},
 			},
 		},
+		Dependencies: []string{
+			"k8s.io/api/core/v1.NodeSwapStatus"},
 	}
 }
 
@@ -13556,7 +13601,7 @@ func schema_k8sio_api_core_v1_PodAffinityTerm(ref common.ReferenceCallback) comm
 							},
 						},
 						SchemaProps: spec.SchemaProps{
-							Description: "MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
+							Description: "MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set.",
 							Type:        []string{"array"},
 							Items: &spec.SchemaOrArray{
 								Schema: &spec.Schema{
@@ -13576,7 +13621,7 @@ func schema_k8sio_api_core_v1_PodAffinityTerm(ref common.ReferenceCallback) comm
 							},
 						},
 						SchemaProps: spec.SchemaProps{
-							Description: "MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
+							Description: "MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set.",
 							Type:        []string{"array"},
 							Items: &spec.SchemaOrArray{
 								Schema: &spec.Schema{
@@ -13728,6 +13773,13 @@ func schema_k8sio_api_core_v1_PodCondition(ref common.ReferenceCallback) common.
 							Format:      "",
 						},
 					},
+					"observedGeneration": {
+						SchemaProps: spec.SchemaProps{
+							Description: "If set, this represents the .metadata.generation that the pod condition was set based upon. This is an alpha field. Enable PodObservedGenerationTracking to be able to use this field.",
+							Type:        []string{"integer"},
+							Format:      "int64",
+						},
+					},
 					"status": {
 						SchemaProps: spec.SchemaProps{
 							Description: "Status is the status of the condition. Can be True, False, Unknown. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions",
@@ -14531,7 +14583,7 @@ func schema_k8sio_api_core_v1_PodSpec(ref common.ReferenceCallback) common.OpenA
 							},
 						},
 						SchemaProps: spec.SchemaProps{
-							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
+							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
 							Type:        []string{"array"},
 							Items: &spec.SchemaOrArray{
 								Schema: &spec.Schema{
@@ -14988,6 +15040,13 @@ func schema_k8sio_api_core_v1_PodStatus(ref common.ReferenceCallback) common.Ope
 				Description: "PodStatus represents information about the status of a pod. Status may trail the actual state of a system, especially if the node that hosts the pod cannot contact the control plane.",
 				Type:        []string{"object"},
 				Properties: map[string]spec.Schema{
+					"observedGeneration": {
+						SchemaProps: spec.SchemaProps{
+							Description: "If set, this represents the .metadata.generation that the pod status was set based upon. This is an alpha field. Enable PodObservedGenerationTracking to be able to use this field.",
+							Type:        []string{"integer"},
+							Format:      "int64",
+						},
+					},
 					"phase": {
 						SchemaProps: spec.SchemaProps{
 							Description: "The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle. The conditions array, the reason and message fields, and the individual container status arrays contain more detail about the pod's status. There are five possible phase values:\n\nPending: The pod has been accepted by the Kubernetes system, but one or more of the container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while. Running: The pod has been bound to a node, and all of the containers have been created. At least one container is still running, or is in the process of starting or restarting. Succeeded: All containers in the pod have terminated in success, and will not be restarted. Failed: All containers in the pod have terminated, and at least one container has terminated in failure. The container either exited with non-zero status or was terminated by the system. Unknown: For some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod.\n\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase\n\nPossible enum values:\n - `\"Failed\"` means that all containers in the pod have terminated, and at least one container has terminated in a failure (exited with a non-zero exit code or was stopped by the system).\n - `\"Pending\"` means the pod has been accepted by the system, but one or more of the containers has not been started. This includes time before being bound to a node, as well as time spent pulling images onto the host.\n - `\"Running\"` means the pod has been bound to a node and all of the containers have been started. At least one container is still running or is in the process of being restarted.\n - `\"Succeeded\"` means that all containers in the pod have voluntarily terminated with a container exit code of 0, and the system is not going to restart any of these containers.\n - `\"Unknown\"` means that for some reason the state of the pod could not be obtained, typically due to an error in communicating with the host of the pod. Deprecated: It isn't being set since 2015 (74da3b14b0c0f658b3bb8d2def5094686d0e9095)",
@@ -15173,7 +15232,7 @@ func schema_k8sio_api_core_v1_PodStatus(ref common.ReferenceCallback) common.Ope
 					},
 					"resize": {
 						SchemaProps: spec.SchemaProps{
-							Description: "Status of resources resize desired for pod's containers. It is empty if no resources resize is pending. Any changes to container resources will automatically set this to \"Proposed\"",
+							Description: "Status of resources resize desired for pod's containers. It is empty if no resources resize is pending. Any changes to container resources will automatically set this to \"Proposed\" Deprecated: Resize status is moved to two pod conditions PodResizePending and PodResizeInProgress. PodResizePending will track states where the spec has been resized, but the Kubelet has not yet allocated the resources. PodResizeInProgress will track in-progress resizes, and should be present whenever allocated resources != acknowledged resources.",
 							Type:        []string{"string"},
 							Format:      "",
 						},
@@ -16134,6 +16193,7 @@ func schema_k8sio_api_core_v1_ReplicationControllerSpec(ref common.ReferenceCall
 					"replicas": {
 						SchemaProps: spec.SchemaProps{
 							Description: "Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller",
+							Default:     1,
 							Type:        []string{"integer"},
 							Format:      "int32",
 						},
@@ -16141,6 +16201,7 @@ func schema_k8sio_api_core_v1_ReplicationControllerSpec(ref common.ReferenceCall
 					"minReadySeconds": {
 						SchemaProps: spec.SchemaProps{
 							Description: "Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
+							Default:     0,
 							Type:        []string{"integer"},
 							Format:      "int32",
 						},
@@ -16493,7 +16554,7 @@ func schema_k8sio_api_core_v1_ResourceQuotaSpec(ref common.ReferenceCallback) co
 										Default: "",
 										Type:    []string{"string"},
 										Format:  "",
-										Enum:    []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating"},
+										Enum:    []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating", "VolumeAttributesClass"},
 									},
 								},
 							},
@@ -16934,11 +16995,11 @@ func schema_k8sio_api_core_v1_ScopedResourceSelectorRequirement(ref common.Refer
 				Properties: map[string]spec.Schema{
 					"scopeName": {
 						SchemaProps: spec.SchemaProps{
-							Description: "The name of the scope that the selector applies to.\n\nPossible enum values:\n - `\"BestEffort\"` Match all pod objects that have best effort quality of service\n - `\"CrossNamespacePodAffinity\"` Match all pod objects that have cross-namespace pod (anti)affinity mentioned.\n - `\"NotBestEffort\"` Match all pod objects that do not have best effort quality of service\n - `\"NotTerminating\"` Match all pod objects where spec.activeDeadlineSeconds is nil\n - `\"PriorityClass\"` Match all pod objects that have priority class mentioned\n - `\"Terminating\"` Match all pod objects where spec.activeDeadlineSeconds >=0",
+							Description: "The name of the scope that the selector applies to.\n\nPossible enum values:\n - `\"BestEffort\"` Match all pod objects that have best effort quality of service\n - `\"CrossNamespacePodAffinity\"` Match all pod objects that have cross-namespace pod (anti)affinity mentioned.\n - `\"NotBestEffort\"` Match all pod objects that do not have best effort quality of service\n - `\"NotTerminating\"` Match all pod objects where spec.activeDeadlineSeconds is nil\n - `\"PriorityClass\"` Match all pod objects that have priority class mentioned\n - `\"Terminating\"` Match all pod objects where spec.activeDeadlineSeconds >=0\n - `\"VolumeAttributesClass\"` Match all pvc objects that have volume attributes class mentioned.",
 							Default:     "",
 							Type:        []string{"string"},
 							Format:      "",
-							Enum:        []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating"},
+							Enum:        []interface{}{"BestEffort", "CrossNamespacePodAffinity", "NotBestEffort", "NotTerminating", "PriorityClass", "Terminating", "VolumeAttributesClass"},
 						},
 					},
 					"operator": {
@@ -18087,7 +18148,7 @@ func schema_k8sio_api_core_v1_ServiceSpec(ref common.ReferenceCallback) common.O
 					},
 					"trafficDistribution": {
 						SchemaProps: spec.SchemaProps{
-							Description: "TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to \"PreferClose\", implementations should prioritize endpoints that are topologically close (e.g., same zone). This is a beta field and requires enabling ServiceTrafficDistribution feature.",
+							Description: "TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to \"PreferClose\", implementations should prioritize endpoints that are in the same zone.",
 							Type:        []string{"string"},
 							Format:      "",
 						},
@@ -18570,7 +18631,7 @@ func schema_k8sio_api_core_v1_TopologySpreadConstraint(ref common.ReferenceCallb
 					},
 					"nodeAffinityPolicy": {
 						SchemaProps: spec.SchemaProps{
-							Description: "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
+							Description: "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
 							Type:        []string{"string"},
 							Format:      "",
 							Enum:        []interface{}{"Honor", "Ignore"},
@@ -18578,7 +18639,7 @@ func schema_k8sio_api_core_v1_TopologySpreadConstraint(ref common.ReferenceCallb
 					},
 					"nodeTaintsPolicy": {
 						SchemaProps: spec.SchemaProps{
-							Description: "NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
+							Description: "NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy.\n\nPossible enum values:\n - `\"Honor\"` means use this scheduling directive when calculating pod topology spread skew.\n - `\"Ignore\"` means ignore this scheduling directive when calculating pod topology spread skew.",
 							Type:        []string{"string"},
 							Format:      "",
 							Enum:        []interface{}{"Honor", "Ignore"},
@@ -18890,7 +18951,7 @@ func schema_k8sio_api_core_v1_Volume(ref common.ReferenceCallback) common.OpenAP
 					},
 					"image": {
 						SchemaProps: spec.SchemaProps{
-							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath). The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
+							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33. The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
 							Ref:         ref("k8s.io/api/core/v1.ImageVolumeSource"),
 						},
 					},
@@ -19335,7 +19396,7 @@ func schema_k8sio_api_core_v1_VolumeSource(ref common.ReferenceCallback) common.
 					},
 					"image": {
 						SchemaProps: spec.SchemaProps{
-							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath). The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
+							Description: "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine. The volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails. - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present. - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation. A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message. The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field. The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images. The volume will be mounted read-only (ro) and non-executable files (noexec). Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33. The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
 							Ref:         ref("k8s.io/api/core/v1.ImageVolumeSource"),
 						},
 					},
@@ -22058,16 +22119,46 @@ func schema_k8sio_apimachinery_pkg_version_Info(ref common.ReferenceCallback) co
 				Properties: map[string]spec.Schema{
 					"major": {
 						SchemaProps: spec.SchemaProps{
-							Default: "",
-							Type:    []string{"string"},
-							Format:  "",
+							Description: "Major is the major version of the binary version",
+							Default:     "",
+							Type:        []string{"string"},
+							Format:      "",
 						},
 					},
 					"minor": {
 						SchemaProps: spec.SchemaProps{
-							Default: "",
-							Type:    []string{"string"},
-							Format:  "",
+							Description: "Minor is the minor version of the binary version",
+							Default:     "",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
+					"emulationMajor": {
+						SchemaProps: spec.SchemaProps{
+							Description: "EmulationMajor is the major version of the emulation version",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
+					"emulationMinor": {
+						SchemaProps: spec.SchemaProps{
+							Description: "EmulationMinor is the minor version of the emulation version",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
+					"minCompatibilityMajor": {
+						SchemaProps: spec.SchemaProps{
+							Description: "MinCompatibilityMajor is the major version of the minimum compatibility version",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
+					"minCompatibilityMinor": {
+						SchemaProps: spec.SchemaProps{
+							Description: "MinCompatibilityMinor is the minor version of the minimum compatibility version",
+							Type:        []string{"string"},
+							Format:      "",
 						},
 					},
 					"gitVersion": {
-- 
2.39.5 (Apple Git-154)


From ddcf9545e80708c112d33cf3dd96655e8a61e1fc Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Wed, 2 Jul 2025 14:40:55 -0700
Subject: [PATCH 13/17] fix workloads and service sync

---
 .../agentgatewaysyncer/gateway_collection.go  |   1 +
 internal/kgateway/agentgatewaysyncer/model.go |   3 +-
 .../kgateway/agentgatewaysyncer/service.go    |   1 +
 .../kgateway/agentgatewaysyncer/syncer.go     | 531 +++++++++++-------
 internal/kgateway/controller/start.go         |   4 +-
 5 files changed, 320 insertions(+), 220 deletions(-)

diff --git a/internal/kgateway/agentgatewaysyncer/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
index 97d7a59c8..277183b02 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
@@ -204,6 +204,7 @@ func GatewayCollection(
 		r.Gateway(obj).SetCondition(reporter.GatewayCondition{
 			Type:   gwv1.GatewayConditionAccepted,
 			Status: metav1.ConditionTrue,
+			Reason: gwv1.GatewayReasonAccepted,
 		})
 		return result
 	}, krtopts.ToOptions("KubernetesGateway")...)
diff --git a/internal/kgateway/agentgatewaysyncer/model.go b/internal/kgateway/agentgatewaysyncer/model.go
index 6fa2a474e..4f5a14104 100644
--- a/internal/kgateway/agentgatewaysyncer/model.go
+++ b/internal/kgateway/agentgatewaysyncer/model.go
@@ -94,14 +94,13 @@ func (r ADPCacheResource) Equals(in ADPCacheResource) bool {
 type ADPCacheAddress struct {
 	NamespacedName types.NamespacedName
 	Address        envoycache.Resources `json:"address"`
-	proxyKey       string
 
 	reports    reports.ReportMap
 	VersionMap map[string]map[string]string
 }
 
 func (r ADPCacheAddress) ResourceName() string {
-	return r.proxyKey
+	return r.NamespacedName.String()
 }
 
 func (r ADPCacheAddress) Equals(in ADPCacheAddress) bool {
diff --git a/internal/kgateway/agentgatewaysyncer/service.go b/internal/kgateway/agentgatewaysyncer/service.go
index efcb3a363..38a127bca 100644
--- a/internal/kgateway/agentgatewaysyncer/service.go
+++ b/internal/kgateway/agentgatewaysyncer/service.go
@@ -730,6 +730,7 @@ func (i ServiceInfo) ResourceName() string {
 }
 
 func serviceResourceName(s *api.Service) string {
+	// TODO: check prepending svc
 	return s.GetNamespace() + "/" + s.GetHostname()
 }
 
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 78234e8df..822bab24e 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -3,13 +3,17 @@ package agentgatewaysyncer
 import (
 	"context"
 	"fmt"
+	"log/slog"
 	"maps"
 	"strconv"
-	"strings"
+	"time"
 
 	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/avast/retry-go/v4"
 	envoytypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
+	"github.com/google/go-cmp/cmp"
+	"github.com/google/go-cmp/cmp/cmpopts"
 	"google.golang.org/protobuf/proto"
 	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
 	"istio.io/istio/pilot/pkg/features"
@@ -21,29 +25,30 @@ import (
 	"istio.io/istio/pkg/kube/kubetypes"
 	corev1 "k8s.io/api/core/v1"
 	discoveryv1 "k8s.io/api/discovery/v1"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/types"
 	"k8s.io/apimachinery/pkg/util/sets"
 	"k8s.io/apimachinery/pkg/watch"
 	"k8s.io/client-go/tools/cache"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/controller-runtime/pkg/manager"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	"sigs.k8s.io/gateway-api-inference-extension/client-go/clientset/versioned"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 	gwv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
+	gwxv1a1 "sigs.k8s.io/gateway-api/apisx/v1alpha1"
 
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
-
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
-	"github.com/kgateway-dev/kgateway/v2/pkg/metrics"
 )
 
 var logger = logging.New("agentgateway/syncer")
@@ -52,21 +57,17 @@ var logger = logging.New("agentgateway/syncer")
 // It watches Gateway resources with the agentgateway class and translates them to agentgateway configuration.
 type AgentGwSyncer struct {
 	commonCols            *common.CommonCollections
+	mgr                   manager.Manager
 	controllerName        string
 	agentGatewayClassName string
-
-	// TODO: do per client snpshot
-	//perclientSnapCollection krt.Collection[XdsSnapWrapper]
-	//uniqueClients           krt.Collection[ir.UniqlyConnectedClient]
-	//mostXdsSnapshots        krt.Collection[ADPCacheResource]
-
-	xDS                 krt.Collection[agentGwXdsResources]
-	xdsCache            envoycache.SnapshotCache
-	client              kube.Client
-	domainSuffix        string
-	systemNamespace     string
-	clusterID           string
-	xdsSnapshotsMetrics krtcollections.CollectionMetricsRecorder
+	xDS                   krt.Collection[agentGwXdsResources]
+	xdsCache              envoycache.SnapshotCache
+	client                kube.Client
+	domainSuffix          string
+	systemNamespace       string
+	clusterID             string
+	xdsSnapshotsMetrics   krtcollections.CollectionMetricsRecorder
+	statusReport          krt.Singleton[report]
 
 	waitForSync []cache.InformerSynced
 }
@@ -97,7 +98,7 @@ func NewAgentGwSyncer(
 	controllerName string,
 	agentGatewayClassName string,
 	client kube.Client,
-	uniqueClients krt.Collection[ir.UniqlyConnectedClient],
+	mgr manager.Manager,
 	commonCols *common.CommonCollections,
 	xdsCache envoycache.SnapshotCache,
 	domainSuffix string,
@@ -111,11 +112,11 @@ func NewAgentGwSyncer(
 		agentGatewayClassName: agentGatewayClassName,
 		xdsCache:              xdsCache,
 		client:                client,
-		//uniqueClients:         uniqueClients,
-		domainSuffix:        domainSuffix,
-		systemNamespace:     systemNamespace,
-		clusterID:           clusterID,
-		xdsSnapshotsMetrics: krtcollections.NewCollectionMetricsRecorder("AgentGatewayXDSSnapshots"),
+		mgr:                   mgr,
+		domainSuffix:          domainSuffix,
+		systemNamespace:       systemNamespace,
+		clusterID:             clusterID,
+		xdsSnapshotsMetrics:   krtcollections.NewCollectionMetricsRecorder("AgentGatewayXDSSnapshots"),
 	}
 }
 
@@ -368,6 +369,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	// these are agw api-style services combined from kube services and service entries
 	//WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, serviceEntries, namespaces, krtopts)
 	workloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, inputs.InferencePools, namespaces, krtopts)
+
+	// collection ADPCacheAddress (envoy resources)
+	// TODO: don't have this as a list
 	svcAddresses := krt.NewCollection(workloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
 		var cacheResources []envoytypes.Resource
 		addrMessage := obj.AsAddress.Address
@@ -400,7 +404,6 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		krtopts,
 	)
 
-	proxyKey := "default~agent-gateway" // TODO: don't hard code, use s.perclientSnapCollection
 	workloadAddresses := krt.NewCollection(workloads, func(ctx krt.HandlerContext, obj WorkloadInfo) *ADPCacheAddress {
 		var cacheResources []envoytypes.Resource
 		addrMessage := obj.AsAddress.Address
@@ -419,7 +422,6 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		result := &ADPCacheAddress{
 			NamespacedName: types.NamespacedName{Name: obj.Workload.GetName(), Namespace: obj.Workload.GetNamespace()},
 			Address:        envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
-			proxyKey:       proxyKey,
 		}
 		logger.Debug("created XDS resources for workload address with ID", "addr", fmt.Sprintf("%s,%s", obj.Workload.GetName(), obj.Workload.GetNamespace()), "resourceid", result.ResourceName())
 		return result
@@ -429,11 +431,11 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 	// TODO: if you make a collection from adpResources -> only last value gets added to agentGwXdsResources (same gw key)
 	adpResources := krt.JoinCollection([]krt.Collection[ADPResource]{binds, listeners, adpRoutes}, krtopts.ToOptions("ADPResources")...)
+
 	s.xDS = krt.NewCollection(adpResources, func(kctx krt.HandlerContext, obj ADPResource) *agentGwXdsResources {
-		//gwNamespacedName := types.NamespacedName{Name: obj.Name, Namespace: obj.Namespace}
 		gwNamespacedName := obj.Gateway
 
-		// TODO: sync addr separately
+		// TODO: give final array here, don't recompute (each block can be it's own collection)
 		var cacheAddresses []envoytypes.Resource
 		addrList := krt.Fetch(kctx, adpAddresses)
 		for _, addr := range addrList {
@@ -443,10 +445,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 			}
 		}
 		var cacheResources []envoytypes.Resource
-		resourceList := krt.Fetch(kctx, adpResources) // TODO: gw collection doesn't seem to work?
+		resourceList := krt.Fetch(kctx, adpResources)
 		for _, resource := range resourceList {
 			// TODO: filter at collection? (add index per gw?)
-			// TODO: empty gw??
 			if resource.Gateway.Name == gwNamespacedName.Name && resource.Gateway.Namespace == gwNamespacedName.Namespace {
 				cacheResources = append(cacheResources, &envoyResourceWithCustomName{
 					Message: resource.Resource,
@@ -478,24 +479,17 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		return result
 	})
 
-	// Create per-client addresses
-	//addrPerClient := NewPerClientAddresses(
-	//	krtopts,
-	//	s.uniqueClients,
-	//	addressxDS,
-	//)
-	//// Initialize per-client snap collection
-	//s.perclientSnapCollection = snapshotPerClient(
-	//	krtopts,
-	//	s.uniqueClients,
-	//	s.mostXdsSnapshots,
-	//	addrPerClient,
-	//	s.xdsSnapshotsMetrics,
-	//)
+	// as proxies are created, they also contain a reportMap containing status for the Gateway and associated xRoutes (really parentRefs)
+	// here we will merge reports that are per-Proxy to a singleton Report used to persist to k8s on a timer
+	s.statusReport = krt.NewSingleton(func(kctx krt.HandlerContext) *report {
+		proxies := krt.Fetch(kctx, s.xDS)
+		merged := mergeProxyReports(proxies)
+		return &report{merged}
+	})
 
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
-		gateways.HasSynced, // wait separately?
+		gateways.HasSynced,
 		// resources
 		binds.HasSynced,
 		listeners.HasSynced,
@@ -507,9 +501,6 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		endpointSlices.HasSynced,
 		workloadServices.HasSynced,
 		workloads.HasSynced,
-		////per-client syncer
-		//s.uniqueClients.HasSynced,
-		//s.perclientSnapCollection.HasSynced,
 	}
 }
 
@@ -543,26 +534,30 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		}
 	}, true)
 
-	//// Register per-client snapshot handler
-	//s.perclientSnapCollection.RegisterBatch(func(events []krt.Event[XdsSnapWrapper], _ bool) {
-	//	for _, e := range events {
-	//		snap := e.Latest()
-	//		if e.Event == controllers.EventDelete {
-	//			s.xdsCache.ClearSnapshot(snap.proxyKey)
-	//			continue
-	//		}
-	//		logger.Debug("setting per-client xds snapshot", "proxy_key", snap.proxyKey)
-	//		err := s.xdsCache.SetSnapshot(ctx, snap.proxyKey, snap.snap)
-	//
-	//		// todo: remove debug
-	//		dumpXDSCacheState(ctx, s.xdsCache)
-	//
-	//		if err != nil {
-	//			logger.Error("failed to set per-client xds snapshot", "proxy_key", snap.proxyKey, "error", err.Error())
-	//			continue
-	//		}
-	//	}
-	//}, true)
+	// latestReport will be constantly updated to contain the merged status report for Kube Gateway status
+	// when timer ticks, we will use the state of the mergedReports at that point in time to sync the status to k8s
+	latestReportQueue := utils.NewAsyncQueue[reports.ReportMap]()
+	s.statusReport.Register(func(o krt.Event[report]) {
+		if o.Event == controllers.EventDelete {
+			// TODO: handle garbage collection (see: https://github.com/solo-io/solo-projects/issues/7086)
+			return
+		}
+		latestReportQueue.Enqueue(o.Latest().reportMap)
+	})
+	routeStatusLogger := logger.With("subcomponent", "routeStatusSyncer")
+	listenerSetStatusLogger := logger.With("subcomponent", "listenerSetStatusSyncer")
+	gatewayStatusLogger := logger.With("subcomponent", "gatewayStatusSyncer")
+	go func() {
+		for {
+			latestReport, err := latestReportQueue.Dequeue(ctx)
+			if err != nil {
+				return
+			}
+			s.syncGatewayStatus(ctx, gatewayStatusLogger, latestReport)
+			s.syncListenerSetStatus(ctx, listenerSetStatusLogger, latestReport)
+			s.syncRouteStatus(ctx, routeStatusLogger, latestReport)
+		}
+	}()
 
 	return nil
 }
@@ -697,181 +692,283 @@ func (ie *PerClientAddresses) FetchEndpointsForClient(kctx krt.HandlerContext, u
 	return krt.Fetch(kctx, ie.addresses, krt.FilterIndex(ie.index, ucc.ResourceName()))
 }
 
-func NewPerClientAddresses(
-	krtopts krtutil.KrtOptions,
-	uccs krt.Collection[ir.UniqlyConnectedClient],
-	addresses krt.Collection[ADPCacheAddress],
-) PerClientAddresses {
-	perclientAddresses := krt.NewManyCollection(addresses, func(kctx krt.HandlerContext, addr ADPCacheAddress) []UccWithAddress {
-		uccs := krt.Fetch(kctx, uccs)
-		uccWithEndpointsRet := make([]UccWithAddress, 0, len(uccs))
-		for _, ucc := range uccs {
-			u := UccWithAddress{
-				Client:  ucc,
-				Address: addr,
-			}
-			uccWithEndpointsRet = append(uccWithEndpointsRet, u)
-		}
-		return uccWithEndpointsRet
-	}, krtopts.ToOptions("PerClientAddresses")...)
-	idx := krt.NewIndex(perclientAddresses, func(ucc UccWithAddress) []string {
-		return []string{ucc.Client.ResourceName()}
-	})
-
-	return PerClientAddresses{
-		addresses: perclientAddresses,
-		index:     idx,
+func (s *AgentGwSyncer) syncRouteStatus(ctx context.Context, logger *slog.Logger, rm reports.ReportMap) {
+	stopwatch := utils.NewTranslatorStopWatch("RouteStatusSyncer")
+	stopwatch.Start()
+	defer stopwatch.Stop(ctx)
+
+	// TODO: add routeStatusMetrics
+
+	// Helper function to sync route status with retry
+	syncStatusWithRetry := func(
+		routeType string,
+		routeKey client.ObjectKey,
+		getRouteFunc func() client.Object,
+		statusUpdater func(route client.Object) error,
+	) error {
+		return retry.Do(
+			func() error {
+				route := getRouteFunc()
+				err := s.mgr.GetClient().Get(ctx, routeKey, route)
+				if err != nil {
+					if apierrors.IsNotFound(err) {
+						// the route is not found, we can't report status on it
+						// if it's recreated, we'll retranslate it anyway
+						return nil
+					}
+					logger.Error("error getting route", "error", err, "resource_ref", routeKey, "route_type", routeType)
+					return err
+				}
+				if err := statusUpdater(route); err != nil {
+					logger.Debug("error updating status for route", "error", err, "resource_ref", routeKey, "route_type", routeType)
+					return err
+				}
+				return nil
+			},
+			retry.Attempts(5),
+			retry.Delay(100*time.Millisecond),
+			retry.DelayType(retry.BackOffDelay),
+		)
 	}
-}
 
-func snapshotPerClient(
-	krtopts krtutil.KrtOptions,
-	uccCol krt.Collection[ir.UniqlyConnectedClient],
-	mostXdsSnapshots krt.Collection[ADPCacheResource],
-	addresses PerClientAddresses,
-	metricsRecorder krtcollections.CollectionMetricsRecorder,
-) krt.Collection[XdsSnapWrapper] {
-	addrResources := krt.NewCollection(uccCol, func(kctx krt.HandlerContext, ucc ir.UniqlyConnectedClient) *addressesWithUccName {
-		endpointsForUcc := addresses.FetchEndpointsForClient(kctx, ucc)
-		endpointsProto := make([]envoytypes.ResourceWithTTL, 0, len(endpointsForUcc))
-		var endpointsHash uint64
-		for _, ep := range endpointsForUcc {
-			// Extract individual resources from the Address.Resources
-			for _, resourceWithTTL := range ep.Address.Address.Items {
-				endpointsProto = append(endpointsProto, resourceWithTTL)
-				// Use the resource hash for versioning
-				if resource, ok := resourceWithTTL.Resource.(*envoyResourceWithCustomName); ok {
-					endpointsHash ^= resource.version
-				}
+	// Helper function to build route status and update if needed
+	buildAndUpdateStatus := func(route client.Object, routeType string) error {
+		var status *gwv1.RouteStatus
+		switch r := route.(type) {
+		case *gwv1.HTTPRoute: // TODO: beta1?
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
+			}
+			r.Status.RouteStatus = *status
+		case *gwv1alpha2.TCPRoute:
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
 			}
+			r.Status.RouteStatus = *status
+		case *gwv1alpha2.TLSRoute:
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
+			}
+			r.Status.RouteStatus = *status
+		case *gwv1.GRPCRoute:
+			status = rm.BuildRouteStatus(ctx, r, s.controllerName)
+			if status == nil || isRouteStatusEqual(&r.Status.RouteStatus, status) {
+				return nil
+			}
+			r.Status.RouteStatus = *status
+		default:
+			logger.Warn("unsupported route type", "route_type", routeType, "resource_ref", client.ObjectKeyFromObject(route))
+			return nil
 		}
 
-		endpointResources := envoycache.NewResourcesWithTTL(fmt.Sprintf("%d", endpointsHash), endpointsProto)
-		return &addressesWithUccName{
-			addresses:    endpointResources,
-			resourceName: ucc.ResourceName(),
-		}
-	}, krtopts.ToOptions("AddressResources")...)
+		// Update the status
+		return s.mgr.GetClient().Status().Update(ctx, route)
+	}
 
-	xdsSnapshotsForUcc := krt.NewCollection(uccCol, func(kctx krt.HandlerContext, ucc ir.UniqlyConnectedClient) *XdsSnapWrapper {
-		listenerRouteSnapshot := krt.FetchOne(kctx, mostXdsSnapshots, krt.FilterKey(ucc.Role))
-		if listenerRouteSnapshot == nil {
-			logger.Debug("snapshot missing", "proxy_key", ucc.Role)
-			return nil
-		}
-		clientEndpointResources := krt.FetchOne(kctx, addrResources, krt.FilterKey(ucc.ResourceName()))
-
-		// HACK
-		// https://github.com/solo-io/gloo/pull/10611/files#diff-060acb7cdd3a287a3aef1dd864aae3e0193da17b6230c382b649ce9dc0eca80b
-		// Without this, we will send a "blip" where the DestinationRule
-		// or other per-client config is not applied to the clusters
-		// by sending the genericSnap clusters on the first pass, then
-		// the correct ones.
-		// This happens because the event for the new connected client
-		// triggers the per-client cluster transformation in parallel
-		// with this snapshotPerClient transformation. This Fetch is racing
-		// with that computation and will almost always lose.
-		// While we're looking for a way to make this ordering predictable
-		// to avoid hacks like this, it will do for now.
-		if clientEndpointResources == nil {
-			logger.Info("no perclient addresses; defer building snapshot", "client", ucc.ResourceName())
-			return nil
+	for rnn := range rm.HTTPRoutes {
+		err := syncStatusWithRetry(
+			wellknown.HTTPRouteKind,
+			rnn,
+			func() client.Object {
+				return new(gwv1.HTTPRoute)
+			},
+			func(route client.Object) error {
+				return buildAndUpdateStatus(route, wellknown.HTTPRouteKind)
+			},
+		)
+		if err != nil {
+			logger.Error("all attempts failed at updating HTTPRoute status", "error", err, "route", rnn)
 		}
+	}
+}
 
-		snap := XdsSnapWrapper{}
-		snap.proxyKey = ucc.ResourceName()
-		// Create agentGwSnapshot for XdsSnapWrapper
-		snapshot := &agentGwSnapshot{
-			Resources: listenerRouteSnapshot.Resources,
-			Addresses: clientEndpointResources.addresses,
-		}
-		snap.snap = snapshot
-		logger.Debug("snapshots", "proxy_key", snap.proxyKey,
-			"resources", resourcesStringer(listenerRouteSnapshot.Resources).String(),
-			"addresses", resourcesStringer(clientEndpointResources.addresses).String(),
-		)
+// syncGatewayStatus will build and update status for all Gateways in a reportMap
+func (s *AgentGwSyncer) syncGatewayStatus(ctx context.Context, logger *slog.Logger, rm reports.ReportMap) {
+	stopwatch := utils.NewTranslatorStopWatch("GatewayStatusSyncer")
+	stopwatch.Start()
 
-		return &snap
-	}, krtopts.ToOptions("PerClientXdsSnapshots")...)
+	// TODO: add gatewayStatusMetrics
 
-	// Register metrics for the collection
-	metrics.RegisterEvents(xdsSnapshotsForUcc, func(o krt.Event[XdsSnapWrapper]) {
-		name := o.Latest().ResourceName()
-		namespace := "unknown"
+	// TODO: retry within loop per GW rather that as a full block
+	err := retry.Do(func() error {
+		for gwnn := range rm.Gateways {
+			gw := gwv1.Gateway{}
+			err := s.mgr.GetClient().Get(ctx, gwnn, &gw)
+			if err != nil {
+				logger.Info("error getting gw", "error", err, "gateway", gwnn.String())
+				return err
+			}
 
-		pks := strings.SplitN(name, "~", 5)
-		if len(pks) > 1 {
-			namespace = pks[1]
+			gwStatusWithoutAddress := gw.Status
+			gwStatusWithoutAddress.Addresses = nil
+			if status := rm.BuildGWStatus(ctx, gw); status != nil {
+				if !isGatewayStatusEqual(&gwStatusWithoutAddress, status) {
+					gw.Status = *status
+					if err := s.mgr.GetClient().Status().Patch(ctx, &gw, client.Merge); err != nil {
+						logger.Error("error patching gateway status", "error", err, "gateway", gwnn.String())
+						return err
+					}
+					logger.Info("patched gw status", "gateway", gwnn.String())
+				} else {
+					logger.Info("skipping k8s gateway status update, status equal", "gateway", gwnn.String())
+				}
+			}
 		}
+		return nil
+	},
+		retry.Attempts(5),
+		retry.Delay(100*time.Millisecond),
+		retry.DelayType(retry.BackOffDelay),
+	)
+	if err != nil {
+		logger.Error("all attempts failed at updating gateway statuses", "error", err)
+	}
+	duration := stopwatch.Stop(ctx)
+	logger.Debug("synced gw status for gateways", "count", len(rm.Gateways), "duration", duration)
+}
 
-		if len(pks) > 2 {
-			name = pks[2]
-		}
+// syncListenerSetStatus will build and update status for all Listener Sets in a reportMap
+func (s *AgentGwSyncer) syncListenerSetStatus(ctx context.Context, logger *slog.Logger, rm reports.ReportMap) {
+	stopwatch := utils.NewTranslatorStopWatch("ListenerSetStatusSyncer")
+	stopwatch.Start()
+
+	// TODO: add listenerStatusMetrics
 
-		switch o.Event {
-		case controllers.EventDelete:
-			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
-				Namespace: namespace,
-				Name:      name,
-				Resource:  "Resource",
-			}, 0)
-
-			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
-				Namespace: namespace,
-				Name:      name,
-				Resource:  "Address",
-			}, 0)
-		case controllers.EventAdd, controllers.EventUpdate:
-			snap := o.Latest().snap
-			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
-				Namespace: namespace,
-				Name:      name,
-				Resource:  "Resource",
-			}, len(snap.Resources.Items))
-
-			metricsRecorder.SetResources(krtcollections.CollectionResourcesMetricLabels{
-				Namespace: namespace,
-				Name:      name,
-				Resource:  "Address",
-			}, len(snap.Addresses.Items))
+	// TODO: retry within loop per LS rathen that as a full block
+	err := retry.Do(func() error {
+		for lsnn := range rm.ListenerSets {
+			ls := gwxv1a1.XListenerSet{}
+			err := s.mgr.GetClient().Get(ctx, lsnn, &ls)
+			if err != nil {
+				logger.Info("error getting ls", "erro", err.Error())
+				return err
+			}
+			lsStatus := ls.Status
+			if status := rm.BuildListenerSetStatus(ctx, ls); status != nil {
+				if !isListenerSetStatusEqual(&lsStatus, status) {
+					ls.Status = *status
+					if err := s.mgr.GetClient().Status().Patch(ctx, &ls, client.Merge); err != nil {
+						logger.Error("error patching listener set status", "error", err, "gateway", lsnn.String())
+						return err
+					}
+					logger.Info("patched ls status", "listenerset", lsnn.String())
+				} else {
+					logger.Info("skipping k8s ls status update, status equal", "listenerset", lsnn.String())
+				}
+			}
 		}
-	})
+		return nil
+	},
+		retry.Attempts(5),
+		retry.Delay(100*time.Millisecond),
+		retry.DelayType(retry.BackOffDelay),
+	)
+	if err != nil {
+		logger.Error("all attempts failed at updating listener set statuses", "error", err)
+	}
+	duration := stopwatch.Stop(ctx)
+	logger.Debug("synced listener sets status for listener set", "count", len(rm.ListenerSets), "duration", duration.String())
+}
+
+// TODO: refactor proxy_syncer status syncing to use the same logic as agentgateway syncer
 
-	return xdsSnapshotsForUcc
+var opts = cmp.Options{
+	cmpopts.IgnoreFields(metav1.Condition{}, "LastTransitionTime"),
+	cmpopts.IgnoreMapEntries(func(k string, _ any) bool {
+		return k == "lastTransitionTime"
+	}),
 }
 
-type resourcesStringer envoycache.Resources
+// isRouteStatusEqual compares two RouteStatus objects directly
+func isRouteStatusEqual(objA, objB *gwv1.RouteStatus) bool {
+	return cmp.Equal(objA, objB, opts)
+}
 
-func (r resourcesStringer) String() string {
-	return fmt.Sprintf("len: %d, version %s", len(r.Items), r.Version)
+func isListenerSetStatusEqual(objA, objB *gwxv1a1.ListenerSetStatus) bool {
+	return cmp.Equal(objA, objB, opts)
 }
 
-// dumpXDSCacheState is a helper function that dump the current state of the XDS cache for the agentgateway cache
-func dumpXDSCacheState(ctx context.Context, cache envoycache.SnapshotCache) {
-	logger.Info("current XDS cache state:")
+func mergeProxyReports(
+	proxies []agentGwXdsResources,
+) reports.ReportMap {
+	merged := reports.NewReportMap()
+	for _, p := range proxies {
+		// 1. merge GW Reports for all Proxies' status reports
+		maps.Copy(merged.Gateways, p.reports.Gateways)
 
-	// Get all snapshot IDs from cache
-	for _, nodeID := range cache.GetStatusKeys() {
-		logger.Info("snapshot has node", "node_id", nodeID)
+		// 2. merge LS Reports for all Proxies' status reports
+		maps.Copy(merged.ListenerSets, p.reports.ListenerSets)
 
-		snapshot, err := cache.GetSnapshot(nodeID)
-		if err != nil {
-			logger.Info("error getting snapshot", "error", err.Error())
-			continue
+		// 3. merge httproute parentRefs into RouteReports
+		for rnn, rr := range p.reports.HTTPRoutes {
+			// if we haven't encountered this route, just copy it over completely
+			old := merged.HTTPRoutes[rnn]
+			if old == nil {
+				merged.HTTPRoutes[rnn] = rr
+				continue
+			}
+			// else, this route has already been seen for a proxy, merge this proxy's parents
+			// into the merged report
+			maps.Copy(merged.HTTPRoutes[rnn].Parents, rr.Parents)
+		}
+
+		// 4. merge tcproute parentRefs into RouteReports
+		for rnn, rr := range p.reports.TCPRoutes {
+			// if we haven't encountered this route, just copy it over completely
+			old := merged.TCPRoutes[rnn]
+			if old == nil {
+				merged.TCPRoutes[rnn] = rr
+				continue
+			}
+			// else, this route has already been seen for a proxy, merge this proxy's parents
+			// into the merged report
+			maps.Copy(merged.TCPRoutes[rnn].Parents, rr.Parents)
 		}
 
-		// Check for Resource targets
-		logger.Info("Resource targets version", "snapshot", snapshot.GetVersion(TargetTypeResourceUrl)) //nolint:sloglint // ignore msg-type
-		resources := snapshot.GetResources(TargetTypeResourceUrl)
-		for name := range resources {
-			logger.Info("snapshot has resources", "name", name)
+		for rnn, rr := range p.reports.TLSRoutes {
+			// if we haven't encountered this route, just copy it over completely
+			old := merged.TLSRoutes[rnn]
+			if old == nil {
+				merged.TLSRoutes[rnn] = rr
+				continue
+			}
+			// else, this route has already been seen for a proxy, merge this proxy's parents
+			// into the merged report
+			maps.Copy(merged.TLSRoutes[rnn].Parents, rr.Parents)
 		}
 
-		// Check addresses
-		logger.Info("Address targets version", "snapshot", snapshot.GetVersion(TargetTypeAddressUrl)) //nolint:sloglint // ignore msg-type
-		addrs := snapshot.GetResources(TargetTypeAddressUrl)
-		for name := range addrs {
-			logger.Info("snapshot has addr", "name", name)
+		for rnn, rr := range p.reports.GRPCRoutes {
+			// if we haven't encountered this route, just copy it over completely
+			old := merged.GRPCRoutes[rnn]
+			if old == nil {
+				merged.GRPCRoutes[rnn] = rr
+				continue
+			}
+			// else, this route has already been seen for a proxy, merge this proxy's parents
+			// into the merged report
+			maps.Copy(merged.GRPCRoutes[rnn].Parents, rr.Parents)
 		}
+
+		// TODO: add back when policies are back
+		//for key, report := range p.reports.Policies {
+		//	// if we haven't encountered this policy, just copy it over completely
+		//	old := merged.Policies[key]
+		//	if old == nil {
+		//		merged.Policies[key] = report
+		//		continue
+		//	}
+		//	// else, let's merge our parentRefs into the existing map
+		//	// obsGen will stay as-is...
+		//	maps.Copy(merged.Policies[key].Ancestors, report.Ancestors)
+		//}
 	}
+
+	return merged
+}
+
+func isGatewayStatusEqual(objA, objB *gwv1.GatewayStatus) bool {
+	return cmp.Equal(objA, objB, opts)
 }
diff --git a/internal/kgateway/controller/start.go b/internal/kgateway/controller/start.go
index 95cc9047b..6841b69c9 100644
--- a/internal/kgateway/controller/start.go
+++ b/internal/kgateway/controller/start.go
@@ -80,6 +80,8 @@ type StartConfig struct {
 	Client      istiokube.Client
 
 	AugmentedPods krt.Collection[krtcollections.LocalityPod]
+	// Special collection built using envoy callbacks
+	// Need this for DR (failover for eds snapshot)
 	UniqueClients krt.Collection[ir.UniqlyConnectedClient]
 
 	KrtOptions krtutil.KrtOptions
@@ -215,7 +217,7 @@ func NewControllerBuilder(ctx context.Context, cfg StartConfig) (*ControllerBuil
 			cfg.ControllerName,
 			cfg.AgentGatewayClassName,
 			cfg.Client,
-			cfg.UniqueClients,
+			mgr,
 			commoncol,
 			cfg.SetupOpts.Cache,
 			domainSuffix,
-- 
2.39.5 (Apple Git-154)


From c81276e9766584a0fd9127d1c8663ea2d899e269 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Thu, 3 Jul 2025 12:15:17 -0700
Subject: [PATCH 14/17] bump agentgateway

---
 go.mod                                                        | 2 +-
 go.sum                                                        | 4 ++--
 hack/utils/oss_compliance/osa_provided.md                     | 2 +-
 .../kgateway/templates/gateway/agent-gateway-deployment.yaml  | 1 -
 .../features/agentgateway/testdata/agentgateway-deploy.yaml   | 2 +-
 5 files changed, 5 insertions(+), 6 deletions(-)

diff --git a/go.mod b/go.mod
index ad0627a85..d48131cef 100644
--- a/go.mod
+++ b/go.mod
@@ -617,7 +617,7 @@ require (
 replace sigs.k8s.io/controller-tools => github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132
 
 replace (
-	github.com/agentgateway/agentgateway => github.com/solo-io/agentgateway-enterprise v0.0.0-20250626235044-bb6ced925fc3
+	github.com/agentgateway/agentgateway => github.com/solo-io/agentgateway-enterprise v0.0.0-20250703185034-bc92714cfedc
 	github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
 )
 
diff --git a/go.sum b/go.sum
index 6bc3d7835..d20467e31 100644
--- a/go.sum
+++ b/go.sum
@@ -1640,8 +1640,8 @@ github.com/smartystreets/goconvey v1.7.2/go.mod h1:Vw0tHAZW6lzCRk3xgdin6fKYcG+G3
 github.com/smartystreets/goconvey v1.8.1 h1:qGjIddxOk4grTu9JPOU31tVfq3cNdBlNa5sSznIX1xY=
 github.com/smartystreets/goconvey v1.8.1/go.mod h1:+/u4qLyY6x1jReYOp7GOM2FSt8aP9CzCZL03bI28W60=
 github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
-github.com/solo-io/agentgateway-enterprise v0.0.0-20250626235044-bb6ced925fc3 h1:n/r6SAYyKQ8AcH8I6mLwDSNuk9nxmgyR94GVfwSbO14=
-github.com/solo-io/agentgateway-enterprise v0.0.0-20250626235044-bb6ced925fc3/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
+github.com/solo-io/agentgateway-enterprise v0.0.0-20250703185034-bc92714cfedc h1:dLQ3+UIQBA6ar2Q5VaynoV74cyYPA+OuoV+/n7vWPw0=
+github.com/solo-io/agentgateway-enterprise v0.0.0-20250703185034-bc92714cfedc/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966 h1:MavIqMAvo9dxhcuN0/m7Ok830e7htfhR+JWRDqs3qj4=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966/go.mod h1:27GcajR+wxZ34COPvLp1+4hxGN66/GSx7SSjVn8LySY=
 github.com/solo-io/go-list-licenses v0.1.4 h1:u4xh1OUORT4iSWuAp3Q4NsfHcDaeUV8QRDH8ACQqbxw=
diff --git a/hack/utils/oss_compliance/osa_provided.md b/hack/utils/oss_compliance/osa_provided.md
index 4f0e4baee..c3bb97faf 100644
--- a/hack/utils/oss_compliance/osa_provided.md
+++ b/hack/utils/oss_compliance/osa_provided.md
@@ -1,6 +1,6 @@
 Name|Version|License
 ---|---|---
-[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.0.0-20250626235044-bb6ced925fc3|Apache License 2.0
+[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.0.0-20250703185034-bc92714cfedc|Apache License 2.0
 [avast/retry-go](https://github.com/avast/retry-go)|v2.4.3+incompatible|MIT License
 [retry-go/v4](https://github.com/avast/retry-go)|v4.3.3|MIT License
 [caarlos0/log](https://github.com/caarlos0/log)|v0.4.6|MIT License
diff --git a/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml b/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
index 63fa3d3d2..389772225 100644
--- a/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
+++ b/internal/kgateway/helm/kgateway/templates/gateway/agent-gateway-deployment.yaml
@@ -40,7 +40,6 @@ spec:
             {{- toYaml $gateway.resources | nindent 12 }}
           {{- end }} {{/* if $gateway.resources */}}
           args:
-            - gateway
             - -f
             - /config/config.json
           env:
diff --git a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
index 4cc108066..77a249b4b 100644
--- a/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
+++ b/test/kubernetes/e2e/features/agentgateway/testdata/agentgateway-deploy.yaml
@@ -8,7 +8,7 @@ spec:
       enabled: true
       logLevel: debug
       image:
-        tag: fd98c99-dirty
+        tag: bc92714
 ---
 kind: GatewayClass
 apiVersion: gateway.networking.k8s.io/v1
-- 
2.39.5 (Apple Git-154)


From 87dc35e2b8048da170df31e398c2434242ee1f50 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Mon, 7 Jul 2025 11:20:22 -0700
Subject: [PATCH 15/17] wip: cleanup

wip: cleanup

tests

Signed-off-by: npolshakova <nina.polshakova@solo.io>
---
 go.mod                                        |    2 +-
 hack/utils/oss_compliance/osa_provided.md     |    1 -
 .../kgateway/agentgatewaysyncer/conversion.go |   16 +-
 .../agentgatewaysyncer/gateway_collection.go  |    3 +-
 internal/kgateway/agentgatewaysyncer/model.go |   93 +-
 .../references_collection.go                  |    7 +-
 .../agentgatewaysyncer/route_collections.go   |   33 -
 .../route_collections_test.go                 | 1059 +++++++++++++++++
 .../kgateway/agentgatewaysyncer/syncer.go     |  479 ++++----
 .../agentgatewaysyncer/syncer_test.go         |  647 ++++++++++
 .../kgateway/agentgatewaysyncer/workloads.go  |    1 -
 .../kgateway/agentgatewaysyncer/xdswrapper.go |  192 ---
 internal/kgateway/setup/agentgateway_test.go  |  357 ++++--
 .../testdata/agentgateway/httproute-out.json  |  148 ++-
 .../agentgateway/inferencepool-out.json       |  142 +++
 15 files changed, 2566 insertions(+), 614 deletions(-)
 create mode 100644 internal/kgateway/agentgatewaysyncer/route_collections_test.go
 create mode 100644 internal/kgateway/agentgatewaysyncer/syncer_test.go
 delete mode 100644 internal/kgateway/agentgatewaysyncer/xdswrapper.go

diff --git a/go.mod b/go.mod
index d48131cef..b8edd0f14 100644
--- a/go.mod
+++ b/go.mod
@@ -294,7 +294,7 @@ require (
 	github.com/gobwas/glob v0.2.3 // indirect
 	github.com/goccy/go-json v0.10.5 // indirect
 	github.com/gofrs/flock v0.12.1 // indirect
-	github.com/gogo/protobuf v1.3.2
+	github.com/gogo/protobuf v1.3.2 // indirect
 	github.com/golang-jwt/jwt/v4 v4.5.2 // indirect
 	github.com/golang-jwt/jwt/v5 v5.2.1 // indirect
 	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
diff --git a/hack/utils/oss_compliance/osa_provided.md b/hack/utils/oss_compliance/osa_provided.md
index c3bb97faf..7ac4fbcc3 100644
--- a/hack/utils/oss_compliance/osa_provided.md
+++ b/hack/utils/oss_compliance/osa_provided.md
@@ -13,7 +13,6 @@ Name|Version|License
 [ghodss/yaml](https://github.com/ghodss/yaml)|v1.0.1-0.20190212211648-25d852aebe32|MIT License
 [go-logr/logr](https://github.com/go-logr/logr)|v1.4.2|Apache License 2.0
 [go-logr/zapr](https://github.com/go-logr/zapr)|v1.3.0|Apache License 2.0
-[gogo/protobuf](https://github.com/gogo/protobuf)|v1.3.2|BSD 3-clause "New" or "Revised" License
 [google/go-cmp](https://github.com/google/go-cmp)|v0.7.0|BSD 3-clause "New" or "Revised" License
 [grpc-ecosystem/go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)|v1.4.0|Apache License 2.0
 [kelseyhightower/envconfig](https://github.com/kelseyhightower/envconfig)|v1.4.0|MIT License
diff --git a/internal/kgateway/agentgatewaysyncer/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
index 7bfaeb27d..6b70a7db7 100644
--- a/internal/kgateway/agentgatewaysyncer/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -23,6 +23,7 @@ import (
 	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/config/schema/gvk"
 	"istio.io/istio/pkg/config/schema/kind"
 	"istio.io/istio/pkg/kube/controllers"
 	"istio.io/istio/pkg/kube/krt"
@@ -389,8 +390,17 @@ func referenceAllowed(
 		out:
 			for _, routeHostname := range hostnames {
 				for _, parentHostNamespace := range parent.Hostnames {
-					spl := strings.Split(parentHostNamespace, "/")
-					parentNamespace, parentHostname := spl[0], spl[1]
+					var parentNamespace, parentHostname string
+					// When parentHostNamespace lacks a '/', it was likely sanitized from '*/host' to 'host'
+					// by sanitizeServerHostNamespace. Set parentNamespace to '*' to reflect the wildcard namespace
+					// and parentHostname to the sanitized host to prevent an index out of range panic.
+					if strings.Contains(parentHostNamespace, "/") {
+						spl := strings.Split(parentHostNamespace, "/")
+						parentNamespace, parentHostname = spl[0], spl[1]
+					} else {
+						parentNamespace, parentHostname = "*", parentHostNamespace
+					}
+
 					hostnameMatch := host.Name(parentHostname).Matches(host.Name(routeHostname))
 					namespaceMatch := parentNamespace == "*" || parentNamespace == localNamespace
 					hostMatched = hostMatched || hostnameMatch
@@ -423,7 +433,7 @@ func referenceAllowed(
 	// Also make sure this route kind is allowed
 	matched := false
 	for _, ak := range parent.AllowedKinds {
-		if string(ak.Kind) == routeKind.Kind && ptr.OrDefault((*string)(ak.Group), wellknown.GatewayClassGVK.Group) == routeKind.Group {
+		if string(ak.Kind) == routeKind.Kind && ptr.OrDefault((*string)(ak.Group), gvk.GatewayClass.Group) == routeKind.Group {
 			matched = true
 			break
 		}
diff --git a/internal/kgateway/agentgatewaysyncer/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
index 277183b02..796be2baa 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
@@ -107,8 +107,9 @@ func (g Gateway) ResourceName() string {
 }
 
 func (g Gateway) Equals(other Gateway) bool {
+	// TODO: ok to ignore parent/parentInfo?
 	return g.Config.Equals(other.Config) &&
-		g.Valid == other.Valid // TODO: ok to ignore parent/parentInfo?
+		g.Valid == other.Valid
 }
 
 func GatewayCollection(
diff --git a/internal/kgateway/agentgatewaysyncer/model.go b/internal/kgateway/agentgatewaysyncer/model.go
index 4f5a14104..803565664 100644
--- a/internal/kgateway/agentgatewaysyncer/model.go
+++ b/internal/kgateway/agentgatewaysyncer/model.go
@@ -1,24 +1,19 @@
 package agentgatewaysyncer
 
 import (
-	"cmp"
-	"encoding/json"
 	"fmt"
 	"maps"
 	"reflect"
 	"slices"
-	"sort"
 	"time"
 
 	"github.com/agentgateway/agentgateway/go/api"
 	udpa "github.com/cncf/xds/go/udpa/type/v1"
 	envoycache "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
-	gogoproto "github.com/gogo/protobuf/proto"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/reflect/protoreflect"
 	"istio.io/istio/pkg/config/schema/kind"
 	"istio.io/istio/pkg/util/hash"
-	"istio.io/istio/pkg/util/protomarshal"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
@@ -55,23 +50,6 @@ func (key ConfigKey) String() string {
 	return key.Kind.String() + "/" + key.Namespace + "/" + key.Name
 }
 
-// sortConfigByCreationTime sorts the list of config objects in ascending order by their creation time (if available)
-func sortConfigByCreationTime(configs []Config) []Config {
-	sort.Slice(configs, func(i, j int) bool {
-		if r := configs[i].CreationTimestamp.Compare(configs[j].CreationTimestamp); r != 0 {
-			return r == -1 // -1 means i is less than j, so return true
-		}
-		// If creation time is the same, then behavior is nondeterministic. In this case, we can
-		// pick an arbitrary but consistent ordering based on name and namespace, which is unique.
-		// CreationTimestamp is stored in seconds, so this is not uncommon.
-		if r := cmp.Compare(configs[i].Name, configs[j].Name); r != 0 {
-			return r == -1
-		}
-		return cmp.Compare(configs[i].Namespace, configs[j].Namespace) == -1
-	})
-	return configs
-}
-
 type ADPCacheResource struct {
 	Gateway types.NamespacedName `json:"gateway"`
 	reports reports.ReportMap
@@ -93,7 +71,10 @@ func (r ADPCacheResource) Equals(in ADPCacheResource) bool {
 
 type ADPCacheAddress struct {
 	NamespacedName types.NamespacedName
-	Address        envoycache.Resources `json:"address"`
+
+	Address             proto.Message
+	AddressResourceName string
+	AddressVersion      uint64
 
 	reports    reports.ReportMap
 	VersionMap map[string]map[string]string
@@ -105,7 +86,9 @@ func (r ADPCacheAddress) ResourceName() string {
 
 func (r ADPCacheAddress) Equals(in ADPCacheAddress) bool {
 	return report{r.reports}.Equals(report{in.reports}) &&
-		r.Address.Version == in.Address.Version
+		proto.Equal(r.Address, in.Address) &&
+		r.AddressVersion == in.AddressVersion &&
+		r.AddressResourceName == in.AddressResourceName
 }
 
 type ADPResource struct {
@@ -314,73 +297,19 @@ func (meta *Meta) ToObjectMeta() metav1.ObjectMeta {
 	}
 }
 
-func (c Config) DeepCopy() Config {
-	var clone Config
-	clone.Meta = c.Meta
-	clone.Labels = maps.Clone(c.Labels)
-	clone.Annotations = maps.Clone(clone.Annotations)
-	clone.Spec = DeepCopy(c.Spec)
-	if c.Status != nil {
-		clone.Status = DeepCopy(c.Status)
-	}
-	return clone
-}
-
-type deepCopier interface {
-	DeepCopyInterface() any
-}
-
-func DeepCopy(s any) any {
-	if s == nil {
-		return nil
-	}
-	// If deep copy is defined, use that
-	if dc, ok := s.(deepCopier); ok {
-		return dc.DeepCopyInterface()
-	}
-
-	// golang protobuf. Use protoreflect.ProtoMessage to distinguish from gogo
-	// golang/protobuf 1.4+ will have this interface. Older golang/protobuf are gogo compatible
-	// but also not used by Istio at all.
-	if _, ok := s.(protoreflect.ProtoMessage); ok {
-		if pb, ok := s.(proto.Message); ok {
-			return protomarshal.Clone(pb)
-		}
-	}
-
-	// gogo protobuf
-	if pb, ok := s.(gogoproto.Message); ok {
-		return gogoproto.Clone(pb)
-	}
-
-	// If we don't have a deep copy method, we will have to do some reflection magic. Its not ideal,
-	// but all Istio types have an efficient deep copy.
-	js, err := json.Marshal(s)
-	if err != nil {
-		return nil
-	}
-
-	data := reflect.New(reflect.TypeOf(s)).Interface()
-	if err := json.Unmarshal(js, data); err != nil {
-		return nil
-	}
-	data = reflect.ValueOf(data).Elem().Interface()
-	return data
-}
-
-func (c Config) GetName() string {
+func (c *Config) GetName() string {
 	return c.Name
 }
 
-func (c Config) GetNamespace() string {
+func (c *Config) GetNamespace() string {
 	return c.Namespace
 }
 
-func (c Config) GetCreationTimestamp() time.Time {
+func (c *Config) GetCreationTimestamp() time.Time {
 	return c.CreationTimestamp
 }
 
-func (c Config) NamespacedName() types.NamespacedName {
+func (c *Config) NamespacedName() types.NamespacedName {
 	return types.NamespacedName{
 		Namespace: c.Namespace,
 		Name:      c.Name,
diff --git a/internal/kgateway/agentgatewaysyncer/references_collection.go b/internal/kgateway/agentgatewaysyncer/references_collection.go
index 50cf00277..2fb25189e 100644
--- a/internal/kgateway/agentgatewaysyncer/references_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/references_collection.go
@@ -3,16 +3,15 @@ package agentgatewaysyncer
 import (
 	"fmt"
 
+	creds "istio.io/istio/pilot/pkg/model/credentials"
+	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/kube/krt"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	"k8s.io/apimachinery/pkg/types"
 	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
-
-	creds "istio.io/istio/pilot/pkg/model/credentials"
-	"istio.io/istio/pkg/config"
-	"istio.io/istio/pkg/kube/krt"
 )
 
 // Reference stores a reference to a namespaced GVK, as used by ReferencePolicy
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
index 48cea3cf2..c1d959703 100644
--- a/internal/kgateway/agentgatewaysyncer/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -171,36 +171,3 @@ func (r RouteWithKey) Equals(o RouteWithKey) bool {
 func buildGatewayRoutes[T any](parentRefs []routeParentReference, convertRules func() T) T {
 	return convertRules()
 }
-
-// RouteResult holds the result of a route collection
-type RouteResult[I, IStatus any] struct {
-	// VirtualServices are the primary output that configures the internal routing logic
-	VirtualServices krt.Collection[*Config]
-	// RouteAttachments holds information about parent attachment to routes, used for computed the `attachedRoutes` count.
-	RouteAttachments krt.Collection[*RouteAttachment]
-}
-
-type GatewayAndListener struct {
-	// To is assumed to be a Gateway
-	To           types.NamespacedName
-	ListenerName string
-}
-
-func (g GatewayAndListener) String() string {
-	return g.To.String() + "/" + g.ListenerName
-}
-
-type RouteAttachment struct {
-	From TypedResource
-	// To is assumed to be a Gateway
-	To           types.NamespacedName
-	ListenerName string
-}
-
-func (r *RouteAttachment) ResourceName() string {
-	return r.From.Kind.String() + "/" + r.From.Name.String() + "/" + r.To.String() + "/" + r.ListenerName
-}
-
-func (r *RouteAttachment) Equals(other RouteAttachment) bool {
-	return r.From == other.From && r.To == other.To && r.ListenerName == other.ListenerName
-}
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections_test.go b/internal/kgateway/agentgatewaysyncer/route_collections_test.go
new file mode 100644
index 000000000..94cca5bec
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/route_collections_test.go
@@ -0,0 +1,1059 @@
+package agentgatewaysyncer
+
+import (
+	"context"
+	"testing"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	networkingclient "istio.io/client-go/pkg/apis/networking/v1"
+	"istio.io/istio/pkg/kube/krt/krttest"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/utils/ptr"
+	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
+)
+
+var (
+	groupName = gwv1.Group(gwv1.GroupName)
+)
+
+func TestADPRouteCollection(t *testing.T) {
+	testCases := []struct {
+		name           string
+		httpRoutes     []*gwv1.HTTPRoute
+		services       []*corev1.Service
+		namespaces     []*corev1.Namespace
+		gateways       []Gateway
+		refGrants      []ReferenceGrant
+		expectedCount  int
+		expectedRoutes []*api.Route
+	}{
+		{
+			name: "Simple HTTP route with single rule",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/api"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 1,
+			expectedRoutes: []*api.Route{
+				{
+					Key:       "default.test-route.0.0.http",
+					RouteName: "default/test-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/api",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "HTTP route with multiple rules",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "multi-rule-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/api"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/admin"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "admin-service",
+												Port: ptr.To(gwv1.PortNumber(8080)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "admin-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 8080,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 2,
+			expectedRoutes: []*api.Route{ // TODO: consistent ordering of routes?
+				{
+					Key:       "default.multi-rule-route.0.0.http",
+					RouteName: "default/multi-rule-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/api",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+				{
+					Key:       "default.multi-rule-route.1.0.http",
+					RouteName: "default/multi-rule-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/admin",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/admin-service.default.svc.cluster.local",
+							},
+							Port: 8080,
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "HTTP route with exact path match",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "exact-match-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"api.example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchExact),
+											Value: ptr.To("/exact"),
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 1,
+			expectedRoutes: []*api.Route{
+				{
+					Key:       "default.exact-match-route.0.0.http",
+					RouteName: "default/exact-match-route",
+					Hostnames: []string{"api.example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_Exact{
+									Exact: "/exact",
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "HTTP route with header match",
+			httpRoutes: []*gwv1.HTTPRoute{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "header-match-route",
+						Namespace: "default",
+					},
+					Spec: gwv1.HTTPRouteSpec{
+						CommonRouteSpec: gwv1.CommonRouteSpec{
+							ParentRefs: []gwv1.ParentReference{
+								{
+									Name: "test-gateway",
+								},
+							},
+						},
+						Hostnames: []gwv1.Hostname{"example.com"},
+						Rules: []gwv1.HTTPRouteRule{
+							{
+								Matches: []gwv1.HTTPRouteMatch{
+									{
+										Path: &gwv1.HTTPPathMatch{
+											Type:  ptr.To(gwv1.PathMatchPathPrefix),
+											Value: ptr.To("/api"),
+										},
+										Headers: []gwv1.HTTPHeaderMatch{
+											{
+												Type:  ptr.To(gwv1.HeaderMatchExact),
+												Name:  "X-API-Version",
+												Value: "v1",
+											},
+										},
+									},
+								},
+								BackendRefs: []gwv1.HTTPBackendRef{
+									{
+										BackendRef: gwv1.BackendRef{
+											BackendObjectReference: gwv1.BackendObjectReference{
+												Name: "test-service",
+												Port: ptr.To(gwv1.PortNumber(80)),
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			services: []*corev1.Service{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      "test-service",
+						Namespace: "default",
+					},
+					Spec: corev1.ServiceSpec{
+						Ports: []corev1.ServicePort{
+							{
+								Port: 80,
+							},
+						},
+					},
+				},
+			},
+			namespaces: []*corev1.Namespace{
+				{
+					ObjectMeta: metav1.ObjectMeta{
+						Name: "default",
+					},
+				},
+			},
+			gateways: []Gateway{
+				{
+					Config: &Config{
+						Meta: Meta{
+							Name:      "test-gateway",
+							Namespace: "default",
+						},
+					},
+					parent: parentKey{
+						Kind:      wellknown.GatewayGVK,
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+					parentInfo: parentInfo{
+						InternalName: "default/test-gateway",
+						Protocol:     gwv1.HTTPProtocolType,
+						Port:         80,
+						SectionName:  "http",
+						AllowedKinds: []gwv1.RouteGroupKind{
+							{
+								Group: &groupName,
+								Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+							},
+						},
+					},
+					Valid: true,
+				},
+			},
+			refGrants:     []ReferenceGrant{},
+			expectedCount: 1,
+			expectedRoutes: []*api.Route{
+				{
+					Key:       "default.header-match-route.0.0.http",
+					RouteName: "default/header-match-route",
+					Hostnames: []string{"example.com"},
+					Matches: []*api.RouteMatch{
+						{
+							Path: &api.PathMatch{
+								Kind: &api.PathMatch_PathPrefix{
+									PathPrefix: "/api",
+								},
+							},
+							Headers: []*api.HeaderMatch{
+								{
+									Name: "X-API-Version",
+									Value: &api.HeaderMatch_Exact{
+										Exact: "v1",
+									},
+								},
+							},
+						},
+					},
+					Backends: []*api.RouteBackend{
+						{
+							Kind: &api.RouteBackend_Service{
+								Service: "default/test-service.default.svc.cluster.local",
+							},
+							Port: 80,
+						},
+					},
+				},
+			},
+		},
+		{
+			name:           "No HTTP routes",
+			httpRoutes:     []*gwv1.HTTPRoute{},
+			services:       []*corev1.Service{},
+			namespaces:     []*corev1.Namespace{},
+			gateways:       []Gateway{},
+			refGrants:      []ReferenceGrant{},
+			expectedCount:  0,
+			expectedRoutes: []*api.Route{},
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			// Prepare inputs
+			var inputs []any
+			for _, route := range tc.httpRoutes {
+				inputs = append(inputs, route)
+			}
+			for _, svc := range tc.services {
+				inputs = append(inputs, svc)
+			}
+			for _, ns := range tc.namespaces {
+				inputs = append(inputs, ns)
+			}
+			for _, gw := range tc.gateways {
+				inputs = append(inputs, gw)
+			}
+			for _, gw := range tc.refGrants {
+				inputs = append(inputs, gw)
+			}
+
+			// Create mock collections
+			mock := krttest.NewMock(t, inputs)
+			gateways := krttest.GetMockCollection[Gateway](mock)
+			httpRoutes := krttest.GetMockCollection[*gwv1.HTTPRoute](mock)
+			refGrantsCollection := krttest.GetMockCollection[ReferenceGrant](mock)
+			services := krttest.GetMockCollection[*corev1.Service](mock)
+			namespaces := krttest.GetMockCollection[*corev1.Namespace](mock)
+			serviceEntries := krttest.GetMockCollection[*networkingclient.ServiceEntry](mock)
+			inferencePools := krttest.GetMockCollection[*inf.InferencePool](mock)
+
+			// Wait for collections to sync
+			gateways.WaitUntilSynced(context.Background().Done())
+			httpRoutes.WaitUntilSynced(context.Background().Done())
+			refGrantsCollection.WaitUntilSynced(context.Background().Done())
+			services.WaitUntilSynced(context.Background().Done())
+			namespaces.WaitUntilSynced(context.Background().Done())
+
+			routeParents := BuildRouteParents(gateways)
+			refGrants := BuildReferenceGrants(refGrantsCollection)
+			// Create route context inputs
+			routeInputs := RouteContextInputs{
+				Grants:         refGrants,
+				RouteParents:   routeParents,
+				DomainSuffix:   "cluster.local",
+				Services:       services,
+				Namespaces:     namespaces,
+				ServiceEntries: serviceEntries,
+				InferencePools: inferencePools,
+			}
+
+			// Create KRT options
+			krtopts := krtutil.KrtOptions{}
+
+			// Call ADPRouteCollection
+			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts)
+
+			// Wait for the collection to process
+			adpRoutes.WaitUntilSynced(context.Background().Done())
+
+			// Get results
+			results := adpRoutes.List()
+
+			// Verify expected count
+			assert.Equal(t, tc.expectedCount, len(results), "Expected %d routes but got %d", tc.expectedCount, len(results))
+
+			// Create a map of actual routes by key for easy lookup
+			actualRoutes := make(map[string]*api.Route)
+			for _, result := range results {
+				require.NotNil(t, result.Resource, "Resource should not be nil")
+				routeResource := result.Resource.GetRoute()
+				require.NotNil(t, routeResource, "Route resource should not be nil")
+				actualRoutes[routeResource.GetKey()] = routeResource
+			}
+
+			// Verify each expected route exists in the actual results
+			for _, expectedRoute := range tc.expectedRoutes {
+				expected := expectedRoute
+				routeResource, found := actualRoutes[expected.GetKey()]
+				require.True(t, found, "Expected route with key %s not found", expected.GetKey())
+
+				// Verify route properties using the expected api.Route
+				assert.Equal(t, expected.GetKey(), routeResource.GetKey(), "Route key mismatch")
+				assert.Equal(t, expected.GetRouteName(), routeResource.GetRouteName(), "Route name mismatch")
+				assert.Equal(t, expected.GetHostnames(), routeResource.GetHostnames(), "Hostnames mismatch")
+
+				// Verify matches
+				require.Equal(t, len(expected.GetMatches()), len(routeResource.GetMatches()), "Matches count mismatch")
+				for j, expectedMatch := range expected.GetMatches() {
+					actualMatch := routeResource.GetMatches()[j]
+
+					// Verify path match
+					if expectedMatch.GetPath() != nil {
+						require.NotNil(t, actualMatch.GetPath(), "Path match should not be nil")
+						switch expectedPath := expectedMatch.GetPath().GetKind().(type) {
+						case *api.PathMatch_PathPrefix:
+							actualPath, ok := actualMatch.GetPath().GetKind().(*api.PathMatch_PathPrefix)
+							require.True(t, ok, "Expected PathPrefix match")
+							assert.Equal(t, expectedPath.PathPrefix, actualPath.PathPrefix, "PathPrefix mismatch")
+						case *api.PathMatch_Exact:
+							actualPath, ok := actualMatch.GetPath().GetKind().(*api.PathMatch_Exact)
+							require.True(t, ok, "Expected Exact match")
+							assert.Equal(t, expectedPath.Exact, actualPath.Exact, "Exact path mismatch")
+						}
+					}
+
+					// Verify header matches
+					require.Equal(t, len(expectedMatch.GetHeaders()), len(actualMatch.GetHeaders()), "Header matches count mismatch")
+					for k, expectedHeader := range expectedMatch.GetHeaders() {
+						actualHeader := actualMatch.GetHeaders()[k]
+						assert.Equal(t, expectedHeader.GetName(), actualHeader.GetName(), "Header name mismatch")
+						switch expectedValue := expectedHeader.GetValue().(type) {
+						case *api.HeaderMatch_Exact:
+							actualValue, ok := actualHeader.GetValue().(*api.HeaderMatch_Exact)
+							require.True(t, ok, "Expected exact header match")
+							assert.Equal(t, expectedValue.Exact, actualValue.Exact, "Header exact value mismatch")
+						}
+					}
+				}
+
+				// Verify backends
+				require.Equal(t, len(expected.GetBackends()), len(routeResource.GetBackends()), "Backends count mismatch")
+				for j, expectedBackend := range expected.GetBackends() {
+					actualBackend := routeResource.GetBackends()[j]
+					assert.Equal(t, expectedBackend.GetPort(), actualBackend.GetPort(), "Backend port mismatch")
+
+					// Verify service backend
+					switch expectedKind := expectedBackend.GetKind().(type) {
+					case *api.RouteBackend_Service:
+						actualKind, ok := actualBackend.GetKind().(*api.RouteBackend_Service)
+						require.True(t, ok, "Expected service backend")
+						assert.Equal(t, expectedKind.Service, actualKind.Service, "Service mismatch")
+					}
+				}
+			}
+		})
+	}
+}
+
+func TestADPRouteCollectionWithFilters(t *testing.T) {
+	testCases := []struct {
+		name           string
+		httpRoute      *gwv1.HTTPRoute
+		expectedFilter *api.RouteFilter
+	}{
+		{
+			name: "Route with request header modifier",
+			httpRoute: &gwv1.HTTPRoute{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "header-route",
+					Namespace: "default",
+				},
+				Spec: gwv1.HTTPRouteSpec{
+					CommonRouteSpec: gwv1.CommonRouteSpec{
+						ParentRefs: []gwv1.ParentReference{
+							{
+								Name: "test-gateway",
+							},
+						},
+					},
+					Rules: []gwv1.HTTPRouteRule{
+						{
+							Filters: []gwv1.HTTPRouteFilter{
+								{
+									Type: gwv1.HTTPRouteFilterRequestHeaderModifier,
+									RequestHeaderModifier: &gwv1.HTTPHeaderFilter{
+										Set: []gwv1.HTTPHeader{
+											{
+												Name:  "X-Test-Header",
+												Value: "test-value",
+											},
+										},
+									},
+								},
+							},
+							BackendRefs: []gwv1.HTTPBackendRef{
+								{
+									BackendRef: gwv1.BackendRef{
+										BackendObjectReference: gwv1.BackendObjectReference{
+											Name: "test-service",
+											Port: ptr.To(gwv1.PortNumber(80)),
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedFilter: &api.RouteFilter{
+				Kind: &api.RouteFilter_RequestHeaderModifier{
+					RequestHeaderModifier: &api.HeaderModifier{
+						Set: []*api.Header{
+							{
+								Name:  "X-Test-Header",
+								Value: "test-value",
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Route with redirect filter",
+			httpRoute: &gwv1.HTTPRoute{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "redirect-route",
+					Namespace: "default",
+				},
+				Spec: gwv1.HTTPRouteSpec{
+					CommonRouteSpec: gwv1.CommonRouteSpec{
+						ParentRefs: []gwv1.ParentReference{
+							{
+								Name: "test-gateway",
+							},
+						},
+					},
+					Rules: []gwv1.HTTPRouteRule{
+						{
+							Filters: []gwv1.HTTPRouteFilter{
+								{
+									Type: gwv1.HTTPRouteFilterRequestRedirect,
+									RequestRedirect: &gwv1.HTTPRequestRedirectFilter{
+										Scheme:     ptr.To("https"),
+										StatusCode: ptr.To(301),
+									},
+								},
+							},
+							BackendRefs: []gwv1.HTTPBackendRef{
+								{
+									BackendRef: gwv1.BackendRef{
+										BackendObjectReference: gwv1.BackendObjectReference{
+											Name: "test-service",
+											Port: ptr.To(gwv1.PortNumber(80)),
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedFilter: &api.RouteFilter{
+				Kind: &api.RouteFilter_RequestRedirect{
+					RequestRedirect: &api.RequestRedirect{
+						Scheme: "https",
+						Status: 301,
+					},
+				},
+			},
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			// Prepare inputs
+			service := &corev1.Service{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-service",
+					Namespace: "default",
+				},
+				Spec: corev1.ServiceSpec{
+					Ports: []corev1.ServicePort{
+						{
+							Port: 80,
+						},
+					},
+				},
+			}
+
+			namespace := &corev1.Namespace{
+				ObjectMeta: metav1.ObjectMeta{
+					Name: "default",
+				},
+			}
+
+			gateway := Gateway{
+				Config: &Config{
+					Meta: Meta{
+						Name:      "test-gateway",
+						Namespace: "default",
+					},
+				},
+				parent: parentKey{
+					Kind:      wellknown.GatewayGVK,
+					Name:      "test-gateway",
+					Namespace: "default",
+				},
+				parentInfo: parentInfo{
+					InternalName: "default/test-gateway",
+					Protocol:     gwv1.HTTPProtocolType,
+					Port:         80,
+					SectionName:  "http",
+					AllowedKinds: []gwv1.RouteGroupKind{
+						{
+							Group: &groupName,
+							Kind:  gwv1.Kind(wellknown.HTTPRouteKind),
+						},
+					},
+				},
+				Valid: true,
+			}
+
+			refGrant := ReferenceGrant{}
+
+			inputs := []any{tc.httpRoute, service, namespace, gateway, refGrant}
+
+			// Create mock collections
+			mock := krttest.NewMock(t, inputs)
+			gateways := krttest.GetMockCollection[Gateway](mock)
+			httpRoutes := krttest.GetMockCollection[*gwv1.HTTPRoute](mock)
+			refGrantsCollection := krttest.GetMockCollection[ReferenceGrant](mock)
+			services := krttest.GetMockCollection[*corev1.Service](mock)
+			namespaces := krttest.GetMockCollection[*corev1.Namespace](mock)
+			serviceEntries := krttest.GetMockCollection[*networkingclient.ServiceEntry](mock)
+			inferencePools := krttest.GetMockCollection[*inf.InferencePool](mock)
+
+			// Wait for collections to sync
+			gateways.WaitUntilSynced(context.Background().Done())
+			httpRoutes.WaitUntilSynced(context.Background().Done())
+			refGrantsCollection.WaitUntilSynced(context.Background().Done())
+			services.WaitUntilSynced(context.Background().Done())
+			namespaces.WaitUntilSynced(context.Background().Done())
+
+			routeParents := BuildRouteParents(gateways)
+			refGrants := BuildReferenceGrants(refGrantsCollection)
+			// Create route context inputs
+			routeInputs := RouteContextInputs{
+				Grants:         refGrants,
+				RouteParents:   routeParents,
+				DomainSuffix:   "cluster.local",
+				Services:       services,
+				Namespaces:     namespaces,
+				ServiceEntries: serviceEntries,
+				InferencePools: inferencePools,
+			}
+
+			// Create KRT options
+			krtopts := krtutil.KrtOptions{}
+
+			// Call ADPRouteCollection
+			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts)
+
+			// Wait for the collection to process
+			adpRoutes.WaitUntilSynced(context.Background().Done())
+
+			// Get results
+			results := adpRoutes.List()
+
+			// Verify we got a result
+			require.Len(t, results, 1, "Expected exactly one route")
+
+			result := results[0]
+			require.NotNil(t, result.Resource, "Resource should not be nil")
+
+			routeResource := result.Resource.GetRoute()
+			require.NotNil(t, routeResource, "Route resource should not be nil")
+
+			// Verify filters
+			require.Len(t, routeResource.GetFilters(), 1, "Expected exactly one filter")
+			actualFilter := routeResource.GetFilters()[0]
+
+			// Verify filter type and content
+			switch expectedKind := tc.expectedFilter.GetKind().(type) {
+			case *api.RouteFilter_RequestHeaderModifier:
+				actualKind, ok := actualFilter.GetKind().(*api.RouteFilter_RequestHeaderModifier)
+				require.True(t, ok, "Expected RequestHeaderModifier filter")
+
+				expectedMod := expectedKind.RequestHeaderModifier
+				actualMod := actualKind.RequestHeaderModifier
+
+				require.Equal(t, len(expectedMod.GetSet()), len(actualMod.GetSet()), "Set headers count mismatch")
+				for i, expectedHeader := range expectedMod.GetSet() {
+					actualHeader := actualMod.GetSet()[i]
+					assert.Equal(t, expectedHeader.GetName(), actualHeader.GetName(), "Header name mismatch")
+					assert.Equal(t, expectedHeader.GetValue(), actualHeader.GetValue(), "Header value mismatch")
+				}
+
+			case *api.RouteFilter_RequestRedirect:
+				actualKind, ok := actualFilter.GetKind().(*api.RouteFilter_RequestRedirect)
+				require.True(t, ok, "Expected RequestRedirect filter")
+
+				expectedRedirect := expectedKind.RequestRedirect
+				actualRedirect := actualKind.RequestRedirect
+
+				assert.Equal(t, expectedRedirect.GetScheme(), actualRedirect.GetScheme(), "Redirect scheme mismatch")
+				assert.Equal(t, expectedRedirect.GetStatus(), actualRedirect.GetStatus(), "Redirect status mismatch")
+			}
+		})
+	}
+}
+
+func TestADPRouteCollectionResourceName(t *testing.T) {
+	// Test that ADPResource implements ResourceName correctly
+	adpResource := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: &api.Route{
+					Key: "test-key",
+				},
+			},
+		},
+		Gateway: types.NamespacedName{
+			Name:      "test-gateway",
+			Namespace: "default",
+		},
+	}
+
+	expectedName := "route/test-key"
+	actualName := adpResource.ResourceName()
+	assert.Equal(t, expectedName, actualName, "Resource name should match expected format")
+}
+
+func TestADPRouteCollectionEquals(t *testing.T) {
+	// Test that ADPResource implements Equals correctly
+	route1 := &api.Route{
+		Key:       "test-key",
+		RouteName: "test-route",
+	}
+
+	route2 := &api.Route{
+		Key:       "test-key",
+		RouteName: "test-route",
+	}
+
+	route3 := &api.Route{
+		Key:       "different-key",
+		RouteName: "test-route",
+	}
+
+	gateway := types.NamespacedName{
+		Name:      "test-gateway",
+		Namespace: "default",
+	}
+
+	adpResource1 := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: route1,
+			},
+		},
+		Gateway: gateway,
+	}
+
+	adpResource2 := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: route2,
+			},
+		},
+		Gateway: gateway,
+	}
+
+	adpResource3 := ADPResource{
+		Resource: &api.Resource{
+			Kind: &api.Resource_Route{
+				Route: route3,
+			},
+		},
+		Gateway: gateway,
+	}
+
+	assert.True(t, adpResource1.Equals(adpResource2), "Equal resources should return true")
+	assert.False(t, adpResource1.Equals(adpResource3), "Different resources should return false")
+}
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 822bab24e..ffa74a9f5 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -53,38 +53,68 @@ import (
 
 var logger = logging.New("agentgateway/syncer")
 
+const (
+	// Retry configuration constants
+	maxRetryAttempts = 5
+	retryDelay       = 100 * time.Millisecond
+
+	// Resource name format strings
+	resourceNameFormat = "%s~%s"
+	bindKeyFormat      = "%s/%s"
+	gatewayNameFormat  = "%s/%s"
+
+	// Log message keys
+	logKeyControllerName = "controllername"
+	logKeyError          = "error"
+	logKeyGateway        = "gateway"
+	logKeyResourceRef    = "resource_ref"
+	logKeyRouteType      = "route_type"
+)
+
 // AgentGwSyncer synchronizes Kubernetes Gateway API resources with xDS for agentgateway proxies.
 // It watches Gateway resources with the agentgateway class and translates them to agentgateway configuration.
 type AgentGwSyncer struct {
-	commonCols            *common.CommonCollections
-	mgr                   manager.Manager
+	// Core collections and dependencies
+	commonCols *common.CommonCollections
+	mgr        manager.Manager
+	client     kube.Client
+
+	// Configuration
 	controllerName        string
 	agentGatewayClassName string
-	xDS                   krt.Collection[agentGwXdsResources]
-	xdsCache              envoycache.SnapshotCache
-	client                kube.Client
 	domainSuffix          string
 	systemNamespace       string
 	clusterID             string
-	xdsSnapshotsMetrics   krtcollections.CollectionMetricsRecorder
-	statusReport          krt.Singleton[report]
 
+	// XDS and caching
+	xDS                 krt.Collection[agentGwXdsResources]
+	xdsCache            envoycache.SnapshotCache
+	xdsSnapshotsMetrics krtcollections.CollectionMetricsRecorder
+
+	// Status reporting
+	statusReport krt.Singleton[report]
+
+	// Synchronization
 	waitForSync []cache.InformerSynced
 }
 
+// agentGwXdsResources represents XDS resources for a single agent gateway
 type agentGwXdsResources struct {
 	types.NamespacedName
 
+	// Status reports for this gateway
 	reports reports.ReportMap
-	// Resources config for gw (Bind, Listener. Route)
+
+	// Resources config for gateway (Bind, Listener, Route)
 	ResourceConfig envoycache.Resources
+
 	// Address config (Services, Workloads)
 	AddressConfig envoycache.Resources
 }
 
-// Needs to match agentgateway role configured in client.rs (https://github.com/agentgateway/agentgateway/blob/main/crates/agentgateway/src/xds/client.rs)
+// ResourceName needs to match agentgateway role configured in client.rs (https://github.com/agentgateway/agentgateway/blob/main/crates/agentgateway/src/xds/client.rs)
 func (r agentGwXdsResources) ResourceName() string {
-	return fmt.Sprintf("%s~%s", r.Namespace, r.Name)
+	return fmt.Sprintf(resourceNameFormat, r.Namespace, r.Name)
 }
 
 func (r agentGwXdsResources) Equals(in agentGwXdsResources) bool {
@@ -168,12 +198,14 @@ func (r report) Equals(in report) bool {
 		maps.Equal(r.reportMap.TCPRoutes, in.reportMap.TCPRoutes)
 }
 
+// Inputs holds all the input collections needed for the syncer
 type Inputs struct {
+	// Core Kubernetes resources
 	Namespaces krt.Collection[*corev1.Namespace]
+	Services   krt.Collection[*corev1.Service]
+	Secrets    krt.Collection[*corev1.Secret]
 
-	Services krt.Collection[*corev1.Service]
-	Secrets  krt.Collection[*corev1.Secret]
-
+	// Gateway API resources
 	GatewayClasses  krt.Collection[*gwv1.GatewayClass]
 	Gateways        krt.Collection[*gwv1.Gateway]
 	HTTPRoutes      krt.Collection[*gwv1.HTTPRoute]
@@ -181,14 +213,22 @@ type Inputs struct {
 	TCPRoutes       krt.Collection[*gwv1alpha2.TCPRoute]
 	TLSRoutes       krt.Collection[*gwv1alpha2.TLSRoute]
 	ReferenceGrants krt.Collection[*gwv1beta1.ReferenceGrant]
-	ServiceEntries  krt.Collection[*networkingclient.ServiceEntry]
-	InferencePools  krt.Collection[*inf.InferencePool]
+
+	// Extended resources
+	ServiceEntries krt.Collection[*networkingclient.ServiceEntry]
+	InferencePools krt.Collection[*inf.InferencePool]
 }
 
 func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	logger.Debug("init agentgateway Syncer", "controllername", s.controllerName)
 
-	// TODO: move this
+	s.setupInferenceExtensionClient()
+	inputs := s.buildInputCollections(krtopts)
+	s.buildResourceCollections(inputs, krtopts)
+}
+
+func (s *AgentGwSyncer) setupInferenceExtensionClient() {
+	// TODO: share this in a common spot with the inference extension plugin
 	// Create the inference extension clientset.
 	inferencePoolGVR := wellknown.InferencePoolGVK.GroupVersion().WithResource("inferencepools")
 	infCli, err := versioned.NewForConfig(s.commonCols.Client.RESTConfig())
@@ -206,7 +246,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 			},
 		)
 	}
+}
 
+func (s *AgentGwSyncer) buildInputCollections(krtopts krtutil.KrtOptions) Inputs {
 	inputs := Inputs{
 		Namespaces: krt.NewInformer[*corev1.Namespace](s.client),
 		Secrets: krt.WrapClient[*corev1.Secret](
@@ -226,8 +268,9 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 		ReferenceGrants: krt.WrapClient(kclient.New[*gwv1beta1.ReferenceGrant](s.client), krtopts.ToOptions("informer/ReferenceGrants")...),
 		//ServiceEntries:  krt.WrapClient(kclient.New[*networkingclient.ServiceEntry](s.client), krtopts.ToOptions("informer/ServiceEntries")...),
-		InferencePools: krt.WrapClient(kclient.NewDelayedInformer[*inf.InferencePool](s.client, inferencePoolGVR, kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()}), krtopts.ToOptions("informer/InferencePools")...),
+		InferencePools: krt.WrapClient(kclient.NewDelayedInformer[*inf.InferencePool](s.client, wellknown.InferencePoolGVK.GroupVersion().WithResource("inferencepools"), kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()}), krtopts.ToOptions("informer/InferencePools")...),
 	}
+
 	if features.EnableAlphaGatewayAPI {
 		inputs.TCPRoutes = krt.WrapClient(kclient.New[*gwv1alpha2.TCPRoute](s.client), krtopts.ToOptions("informer/TCPRoutes")...)
 		inputs.TLSRoutes = krt.WrapClient(kclient.New[*gwv1alpha2.TLSRoute](s.client), krtopts.ToOptions("informer/TLSRoutes")...)
@@ -237,22 +280,46 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		inputs.TLSRoutes = krt.NewStaticCollection[*gwv1alpha2.TLSRoute](nil, krtopts.ToOptions("disable/TLSRoutes")...)
 	}
 
-	GatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, krtopts)
+	return inputs
+}
+
+func (s *AgentGwSyncer) buildResourceCollections(inputs Inputs, krtopts krtutil.KrtOptions) {
+	// Build core collections
+	gatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, krtopts)
+	refGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, krtopts))
+	gateways := s.buildGatewayCollection(inputs, gatewayClasses, refGrants, krtopts)
 
-	RefGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, krtopts))
+	// Build ADP resources
+	adpResources := s.buildADPResources(gateways, inputs, refGrants, krtopts)
 
-	// Note: not fully complete until its join with route attachments to report attachedRoutes.
-	// Do not register yet.
-	gateways := GatewayCollection(
+	// Build address collections
+	addresses := s.buildAddressCollections(inputs, krtopts)
+
+	// Build XDS collection
+	s.buildXDSCollection(adpResources, addresses, krtopts)
+
+	// Build status reporting
+	s.buildStatusReporting()
+
+	// Set up sync dependencies
+	s.setupSyncDependencies(gateways, adpResources, addresses, inputs)
+}
+
+func (s *AgentGwSyncer) buildGatewayCollection(inputs Inputs, gatewayClasses krt.Collection[GatewayClass], refGrants ReferenceGrants, krtopts krtutil.KrtOptions) krt.Collection[Gateway] {
+	return GatewayCollection(
 		s.agentGatewayClassName,
 		inputs.Gateways,
-		GatewayClasses,
+		gatewayClasses,
 		inputs.Namespaces,
-		RefGrants,
+		refGrants,
 		inputs.Secrets,
 		s.domainSuffix,
 		krtopts,
 	)
+}
+
+func (s *AgentGwSyncer) buildADPResources(gateways krt.Collection[Gateway], inputs Inputs, refGrants ReferenceGrants, krtopts krtutil.KrtOptions) krt.Collection[ADPResource] {
+	// Build ports and binds
 	ports := krt.NewCollection(gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
 		port := fmt.Sprint(obj.parentInfo.Port)
 		return &IndexObject[string, Gateway]{
@@ -283,64 +350,83 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		return binds
 	}, krtopts.ToOptions("Binds")...)
 
-	listeners := krt.NewCollection(gateways, func(ctx krt.HandlerContext, obj Gateway) *ADPResource {
-		l := &api.Listener{
-			Key:         obj.ResourceName(),
-			Name:        string(obj.parentInfo.SectionName),
-			BindKey:     fmt.Sprint(obj.parentInfo.Port) + "/" + obj.parent.Namespace + "/" + obj.parent.Name,
-			GatewayName: obj.parent.Namespace + "/" + obj.parent.Name,
-			Hostname:    obj.parentInfo.OriginalHostname,
-		}
-
-		switch obj.parentInfo.Protocol {
-		case gwv1.HTTPProtocolType:
-			l.Protocol = api.Protocol_HTTP
-		case gwv1.HTTPSProtocolType:
-			l.Protocol = api.Protocol_HTTPS
-			if obj.TLSInfo == nil {
-				return nil
-			}
-			l.Tls = &api.TLSConfig{
-				Cert:       obj.TLSInfo.Cert,
-				PrivateKey: obj.TLSInfo.Key,
-			}
-		case gwv1.TLSProtocolType:
-			l.Protocol = api.Protocol_TLS
-			if obj.TLSInfo == nil {
-				return nil
-			}
-			l.Tls = &api.TLSConfig{
-				Cert:       obj.TLSInfo.Cert,
-				PrivateKey: obj.TLSInfo.Key,
-			}
-		case gwv1.TCPProtocolType:
-			l.Protocol = api.Protocol_TCP
-		default:
-			return nil
-		}
-		return toResourcep(types.NamespacedName{
-			Namespace: obj.parent.Namespace,
-			Name:      obj.parent.Name,
-		}, ADPListener{l})
-	}, krtopts.ToOptions("Listeners")...)
+	// Build listeners
+	listeners := krt.NewCollection(gateways, s.buildListenerFromGateway, krtopts.ToOptions("Listeners")...)
 
+	// Build routes
 	routeParents := BuildRouteParents(gateways)
-
 	routeInputs := RouteContextInputs{
-		Grants:       RefGrants,
-		RouteParents: routeParents,
-		DomainSuffix: s.domainSuffix,
-		Services:     inputs.Services,
-		Namespaces:   inputs.Namespaces,
-		//ServiceEntries: inputs.ServiceEntries,
+		Grants:         refGrants,
+		RouteParents:   routeParents,
+		DomainSuffix:   s.domainSuffix,
+		Services:       inputs.Services,
+		Namespaces:     inputs.Namespaces,
 		InferencePools: inputs.InferencePools,
 	}
-	adpRoutes := ADPRouteCollection(
-		inputs.HTTPRoutes,
-		routeInputs,
-		krtopts,
-	)
+	adpRoutes := ADPRouteCollection(inputs.HTTPRoutes, routeInputs, krtopts)
+
+	return krt.JoinCollection([]krt.Collection[ADPResource]{binds, listeners, adpRoutes}, krtopts.ToOptions("ADPResources")...)
+}
+
+// buildListenerFromGateway creates a listener resource from a gateway
+func (s *AgentGwSyncer) buildListenerFromGateway(ctx krt.HandlerContext, obj Gateway) *ADPResource {
+	l := &api.Listener{
+		Key:         obj.ResourceName(),
+		Name:        string(obj.parentInfo.SectionName),
+		BindKey:     fmt.Sprint(obj.parentInfo.Port) + "/" + obj.parent.Namespace + "/" + obj.parent.Name,
+		GatewayName: obj.parent.Namespace + "/" + obj.parent.Name,
+		Hostname:    obj.parentInfo.OriginalHostname,
+	}
+
+	// Set protocol and TLS configuration
+	protocol, tlsConfig, ok := s.getProtocolAndTLSConfig(obj)
+	if !ok {
+		return nil // Unsupported protocol or missing TLS config
+	}
+
+	l.Protocol = protocol
+	l.Tls = tlsConfig
+
+	return toResourcep(types.NamespacedName{
+		Namespace: obj.parent.Namespace,
+		Name:      obj.parent.Name,
+	}, ADPListener{l})
+}
 
+// getProtocolAndTLSConfig extracts protocol and TLS configuration from a gateway
+func (s *AgentGwSyncer) getProtocolAndTLSConfig(obj Gateway) (api.Protocol, *api.TLSConfig, bool) {
+	var tlsConfig *api.TLSConfig
+
+	// Build TLS config if needed
+	if obj.TLSInfo != nil {
+		tlsConfig = &api.TLSConfig{
+			Cert:       obj.TLSInfo.Cert,
+			PrivateKey: obj.TLSInfo.Key,
+		}
+	}
+
+	switch obj.parentInfo.Protocol {
+	case gwv1.HTTPProtocolType:
+		return api.Protocol_HTTP, nil, true
+	case gwv1.HTTPSProtocolType:
+		if tlsConfig == nil {
+			return api.Protocol_HTTPS, nil, false // TLS required but not configured
+		}
+		return api.Protocol_HTTPS, tlsConfig, true
+	case gwv1.TLSProtocolType:
+		if tlsConfig == nil {
+			return api.Protocol_TLS, nil, false // TLS required but not configured
+		}
+		return api.Protocol_TLS, tlsConfig, true
+	case gwv1.TCPProtocolType:
+		return api.Protocol_TCP, nil, true
+	default:
+		return api.Protocol_HTTP, nil, false // Unsupported protocol
+	}
+}
+
+func (s *AgentGwSyncer) buildAddressCollections(inputs Inputs, krtopts krtutil.KrtOptions) krt.Collection[envoyResourceWithCustomName] {
+	// Build endpoint slices and namespaces
 	epSliceClient := kclient.NewFiltered[*discoveryv1.EndpointSlice](
 		s.commonCols.Client,
 		kclient.Filter{ObjectFilter: s.commonCols.Client.ObjectFilter()},
@@ -353,12 +439,7 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 	)
 	namespaces := krt.WrapClient(nsClient, s.commonCols.KrtOpts.ToOptions("informer/Namespaces")...)
 
-	//seInformer := kclient.NewDelayedInformer[*networkingclient.ServiceEntry](
-	//	s.client, gvr.ServiceEntry,
-	//	kubetypes.StandardInformer, kclient.Filter{ObjectFilter: s.client.ObjectFilter()},
-	//)
-	//serviceEntries := krt.WrapClient(seInformer, krtopts.ToOptions("informer/ServiceEntries")...)
-
+	// Build workload index
 	workloadIndex := index{
 		namespaces:      s.commonCols.Namespaces,
 		SystemNamespace: s.systemNamespace,
@@ -366,35 +447,8 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		DomainSuffix:    s.domainSuffix,
 	}
 
-	// these are agw api-style services combined from kube services and service entries
-	//WorkloadServices := workloadIndex.ServicesCollection(inputs.Services, serviceEntries, namespaces, krtopts)
+	// Build service and workload collections
 	workloadServices := workloadIndex.ServicesCollection(inputs.Services, nil, inputs.InferencePools, namespaces, krtopts)
-
-	// collection ADPCacheAddress (envoy resources)
-	// TODO: don't have this as a list
-	svcAddresses := krt.NewCollection(workloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
-		var cacheResources []envoytypes.Resource
-		addrMessage := obj.AsAddress.Address
-		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
-			Message: addrMessage,
-			Name:    obj.ResourceName(),
-			version: utils.HashProto(addrMessage),
-		})
-
-		// Create the resource wrappers
-		var resourceVersion uint64
-		for _, res := range cacheResources {
-			resourceVersion ^= res.(*envoyResourceWithCustomName).version
-		}
-
-		result := &ADPCacheAddress{
-			NamespacedName: types.NamespacedName{Name: obj.Service.GetName(), Namespace: obj.Service.GetNamespace()},
-			Address:        envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
-		}
-		logger.Debug("created XDS resources for svc address with ID", "addr", fmt.Sprintf("%s,%s", obj.Service.GetName(), obj.Service.GetNamespace()), "resourceid", result.ResourceName())
-		return result
-	})
-
 	workloads := workloadIndex.WorkloadsCollection(
 		s.commonCols.WrappedPods,
 		workloadServices,
@@ -404,57 +458,67 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		krtopts,
 	)
 
-	workloadAddresses := krt.NewCollection(workloads, func(ctx krt.HandlerContext, obj WorkloadInfo) *ADPCacheAddress {
-		var cacheResources []envoytypes.Resource
+	// Build address collections
+	svcAddresses := krt.NewCollection(workloadServices, func(ctx krt.HandlerContext, obj ServiceInfo) *ADPCacheAddress {
 		addrMessage := obj.AsAddress.Address
-		cacheResources = append(cacheResources, &envoyResourceWithCustomName{
-			Message: addrMessage,
-			Name:    obj.ResourceName(),
-			version: utils.HashProto(addrMessage),
-		})
-
-		// Create the resource wrappers
-		var resourceVersion uint64
-		for _, res := range cacheResources {
-			resourceVersion ^= res.(*envoyResourceWithCustomName).version
+		resourceVersion := utils.HashProto(addrMessage)
+		result := &ADPCacheAddress{
+			NamespacedName:      types.NamespacedName{Name: obj.Service.GetName(), Namespace: obj.Service.GetNamespace()},
+			Address:             addrMessage,
+			AddressResourceName: obj.ResourceName(),
+			AddressVersion:      resourceVersion,
 		}
+		logger.Debug("created XDS resources for svc address with ID", "addr", fmt.Sprintf("%s,%s", obj.Service.GetName(), obj.Service.GetNamespace()), "resourceid", result.ResourceName())
+		return result
+	})
 
+	workloadAddresses := krt.NewCollection(workloads, func(ctx krt.HandlerContext, obj WorkloadInfo) *ADPCacheAddress {
+		addrMessage := obj.AsAddress.Address
+		resourceVersion := utils.HashProto(addrMessage)
 		result := &ADPCacheAddress{
-			NamespacedName: types.NamespacedName{Name: obj.Workload.GetName(), Namespace: obj.Workload.GetNamespace()},
-			Address:        envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
+			NamespacedName:      types.NamespacedName{Name: obj.Workload.GetName(), Namespace: obj.Workload.GetNamespace()},
+			Address:             addrMessage,
+			AddressVersion:      resourceVersion,
+			AddressResourceName: obj.ResourceName(),
 		}
 		logger.Debug("created XDS resources for workload address with ID", "addr", fmt.Sprintf("%s,%s", obj.Workload.GetName(), obj.Workload.GetNamespace()), "resourceid", result.ResourceName())
 		return result
 	})
 
 	adpAddresses := krt.JoinCollection([]krt.Collection[ADPCacheAddress]{svcAddresses, workloadAddresses}, krtopts.ToOptions("ADPAddresses")...)
+	return krt.NewCollection(adpAddresses, func(kctx krt.HandlerContext, obj ADPCacheAddress) *envoyResourceWithCustomName {
+		return &envoyResourceWithCustomName{
+			Message: obj.Address,
+			Name:    obj.AddressResourceName,
+			version: obj.AddressVersion,
+		}
+	}, krtopts.ToOptions("XDSAddresses")...)
+}
 
-	// TODO: if you make a collection from adpResources -> only last value gets added to agentGwXdsResources (same gw key)
-	adpResources := krt.JoinCollection([]krt.Collection[ADPResource]{binds, listeners, adpRoutes}, krtopts.ToOptions("ADPResources")...)
+func (s *AgentGwSyncer) buildXDSCollection(adpResources krt.Collection[ADPResource], xdsAddresses krt.Collection[envoyResourceWithCustomName], krtopts krtutil.KrtOptions) {
+	// Create an index on adpResources by Gateway to avoid fetching all resources
+	adpResourcesByGateway := krt.NewIndex(adpResources, func(resource ADPResource) []types.NamespacedName {
+		return []types.NamespacedName{resource.Gateway}
+	})
 
 	s.xDS = krt.NewCollection(adpResources, func(kctx krt.HandlerContext, obj ADPResource) *agentGwXdsResources {
 		gwNamespacedName := obj.Gateway
 
-		// TODO: give final array here, don't recompute (each block can be it's own collection)
-		var cacheAddresses []envoytypes.Resource
-		addrList := krt.Fetch(kctx, adpAddresses)
-		for _, addr := range addrList {
-			// Extract resources from the Address.Resources
-			for _, resourceWithTTL := range addr.Address.Items {
-				cacheAddresses = append(cacheAddresses, resourceWithTTL.Resource)
-			}
+		cacheAddresses := krt.Fetch(kctx, xdsAddresses)
+		envoytypesAddresses := make([]envoytypes.Resource, 0, len(cacheAddresses))
+		for _, addr := range cacheAddresses {
+			envoytypesAddresses = append(envoytypesAddresses, addr)
 		}
+
 		var cacheResources []envoytypes.Resource
-		resourceList := krt.Fetch(kctx, adpResources)
+		// Use index to fetch only resources for this gateway instead of all resources
+		resourceList := krt.Fetch(kctx, adpResources, krt.FilterIndex(adpResourcesByGateway, gwNamespacedName))
 		for _, resource := range resourceList {
-			// TODO: filter at collection? (add index per gw?)
-			if resource.Gateway.Name == gwNamespacedName.Name && resource.Gateway.Namespace == gwNamespacedName.Namespace {
-				cacheResources = append(cacheResources, &envoyResourceWithCustomName{
-					Message: resource.Resource,
-					Name:    resource.ResourceName(),
-					version: utils.HashProto(resource.Resource),
-				})
-			}
+			cacheResources = append(cacheResources, &envoyResourceWithCustomName{
+				Message: resource.Resource,
+				Name:    resource.ResourceName(),
+				version: utils.HashProto(resource.Resource),
+			})
 		}
 
 		// Create the resource wrappers
@@ -465,20 +529,20 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		// Calculate address version
 		var addrVersion uint64
 		for _, res := range cacheAddresses {
-			if resource, ok := res.(*envoyResourceWithCustomName); ok {
-				addrVersion ^= resource.version
-			}
+			addrVersion ^= res.version
 		}
 
 		result := &agentGwXdsResources{
 			NamespacedName: gwNamespacedName,
 			ResourceConfig: envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
-			AddressConfig:  envoycache.NewResources(fmt.Sprintf("%d", addrVersion), cacheAddresses),
+			AddressConfig:  envoycache.NewResources(fmt.Sprintf("%d", addrVersion), envoytypesAddresses),
 		}
 		logger.Debug("created XDS resources for gateway with ID", "gwname", fmt.Sprintf("%s,%s", gwNamespacedName.Name, gwNamespacedName.Namespace), "resourceid", result.ResourceName())
 		return result
 	})
+}
 
+func (s *AgentGwSyncer) buildStatusReporting() {
 	// as proxies are created, they also contain a reportMap containing status for the Gateway and associated xRoutes (really parentRefs)
 	// here we will merge reports that are per-Proxy to a singleton Report used to persist to k8s on a timer
 	s.statusReport = krt.NewSingleton(func(kctx krt.HandlerContext) *report {
@@ -486,21 +550,18 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 		merged := mergeProxyReports(proxies)
 		return &report{merged}
 	})
+}
 
+func (s *AgentGwSyncer) setupSyncDependencies(gateways krt.Collection[Gateway], adpResources krt.Collection[ADPResource], addresses krt.Collection[envoyResourceWithCustomName], inputs Inputs) {
 	s.waitForSync = []cache.InformerSynced{
 		s.commonCols.HasSynced,
 		gateways.HasSynced,
 		// resources
-		binds.HasSynced,
-		listeners.HasSynced,
-		adpRoutes.HasSynced,
+		adpResources.HasSynced,
 		s.xDS.HasSynced,
 		// addresses
-		//serviceEntries.HasSynced,
-		namespaces.HasSynced,
-		endpointSlices.HasSynced,
-		workloadServices.HasSynced,
-		workloads.HasSynced,
+		addresses.HasSynced,
+		inputs.Namespaces.HasSynced,
 	}
 }
 
@@ -716,17 +777,17 @@ func (s *AgentGwSyncer) syncRouteStatus(ctx context.Context, logger *slog.Logger
 						// if it's recreated, we'll retranslate it anyway
 						return nil
 					}
-					logger.Error("error getting route", "error", err, "resource_ref", routeKey, "route_type", routeType)
+					logger.Error("error getting route", logKeyError, err, logKeyResourceRef, routeKey, logKeyRouteType, routeType)
 					return err
 				}
 				if err := statusUpdater(route); err != nil {
-					logger.Debug("error updating status for route", "error", err, "resource_ref", routeKey, "route_type", routeType)
+					logger.Debug("error updating status for route", logKeyError, err, logKeyResourceRef, routeKey, logKeyRouteType, routeType)
 					return err
 				}
 				return nil
 			},
-			retry.Attempts(5),
-			retry.Delay(100*time.Millisecond),
+			retry.Attempts(maxRetryAttempts),
+			retry.Delay(retryDelay),
 			retry.DelayType(retry.BackOffDelay),
 		)
 	}
@@ -760,7 +821,7 @@ func (s *AgentGwSyncer) syncRouteStatus(ctx context.Context, logger *slog.Logger
 			}
 			r.Status.RouteStatus = *status
 		default:
-			logger.Warn("unsupported route type", "route_type", routeType, "resource_ref", client.ObjectKeyFromObject(route))
+			logger.Warn("unsupported route type", logKeyRouteType, routeType, logKeyResourceRef, client.ObjectKeyFromObject(route))
 			return nil
 		}
 
@@ -780,7 +841,7 @@ func (s *AgentGwSyncer) syncRouteStatus(ctx context.Context, logger *slog.Logger
 			},
 		)
 		if err != nil {
-			logger.Error("all attempts failed at updating HTTPRoute status", "error", err, "route", rnn)
+			logger.Error("all attempts failed at updating HTTPRoute status", logKeyError, err, "route", rnn)
 		}
 	}
 }
@@ -798,7 +859,7 @@ func (s *AgentGwSyncer) syncGatewayStatus(ctx context.Context, logger *slog.Logg
 			gw := gwv1.Gateway{}
 			err := s.mgr.GetClient().Get(ctx, gwnn, &gw)
 			if err != nil {
-				logger.Info("error getting gw", "error", err, "gateway", gwnn.String())
+				logger.Info("error getting gw", logKeyError, err, logKeyGateway, gwnn.String())
 				return err
 			}
 
@@ -808,23 +869,23 @@ func (s *AgentGwSyncer) syncGatewayStatus(ctx context.Context, logger *slog.Logg
 				if !isGatewayStatusEqual(&gwStatusWithoutAddress, status) {
 					gw.Status = *status
 					if err := s.mgr.GetClient().Status().Patch(ctx, &gw, client.Merge); err != nil {
-						logger.Error("error patching gateway status", "error", err, "gateway", gwnn.String())
+						logger.Error("error patching gateway status", logKeyError, err, logKeyGateway, gwnn.String())
 						return err
 					}
-					logger.Info("patched gw status", "gateway", gwnn.String())
+					logger.Info("patched gw status", logKeyGateway, gwnn.String())
 				} else {
-					logger.Info("skipping k8s gateway status update, status equal", "gateway", gwnn.String())
+					logger.Info("skipping k8s gateway status update, status equal", logKeyGateway, gwnn.String())
 				}
 			}
 		}
 		return nil
 	},
-		retry.Attempts(5),
-		retry.Delay(100*time.Millisecond),
+		retry.Attempts(maxRetryAttempts),
+		retry.Delay(retryDelay),
 		retry.DelayType(retry.BackOffDelay),
 	)
 	if err != nil {
-		logger.Error("all attempts failed at updating gateway statuses", "error", err)
+		logger.Error("all attempts failed at updating gateway statuses", logKeyError, err)
 	}
 	duration := stopwatch.Stop(ctx)
 	logger.Debug("synced gw status for gateways", "count", len(rm.Gateways), "duration", duration)
@@ -851,7 +912,7 @@ func (s *AgentGwSyncer) syncListenerSetStatus(ctx context.Context, logger *slog.
 				if !isListenerSetStatusEqual(&lsStatus, status) {
 					ls.Status = *status
 					if err := s.mgr.GetClient().Status().Patch(ctx, &ls, client.Merge); err != nil {
-						logger.Error("error patching listener set status", "error", err, "gateway", lsnn.String())
+						logger.Error("error patching listener set status", logKeyError, err, logKeyGateway, lsnn.String())
 						return err
 					}
 					logger.Info("patched ls status", "listenerset", lsnn.String())
@@ -862,12 +923,12 @@ func (s *AgentGwSyncer) syncListenerSetStatus(ctx context.Context, logger *slog.
 		}
 		return nil
 	},
-		retry.Attempts(5),
-		retry.Delay(100*time.Millisecond),
+		retry.Attempts(maxRetryAttempts),
+		retry.Delay(retryDelay),
 		retry.DelayType(retry.BackOffDelay),
 	)
 	if err != nil {
-		logger.Error("all attempts failed at updating listener set statuses", "error", err)
+		logger.Error("all attempts failed at updating listener set statuses", logKeyError, err)
 	}
 	duration := stopwatch.Stop(ctx)
 	logger.Debug("synced listener sets status for listener set", "count", len(rm.ListenerSets), "duration", duration.String())
@@ -891,10 +952,9 @@ func isListenerSetStatusEqual(objA, objB *gwxv1a1.ListenerSetStatus) bool {
 	return cmp.Equal(objA, objB, opts)
 }
 
-func mergeProxyReports(
-	proxies []agentGwXdsResources,
-) reports.ReportMap {
+func mergeProxyReports(proxies []agentGwXdsResources) reports.ReportMap {
 	merged := reports.NewReportMap()
+
 	for _, p := range proxies {
 		// 1. merge GW Reports for all Proxies' status reports
 		maps.Copy(merged.Gateways, p.reports.Gateways)
@@ -902,55 +962,11 @@ func mergeProxyReports(
 		// 2. merge LS Reports for all Proxies' status reports
 		maps.Copy(merged.ListenerSets, p.reports.ListenerSets)
 
-		// 3. merge httproute parentRefs into RouteReports
-		for rnn, rr := range p.reports.HTTPRoutes {
-			// if we haven't encountered this route, just copy it over completely
-			old := merged.HTTPRoutes[rnn]
-			if old == nil {
-				merged.HTTPRoutes[rnn] = rr
-				continue
-			}
-			// else, this route has already been seen for a proxy, merge this proxy's parents
-			// into the merged report
-			maps.Copy(merged.HTTPRoutes[rnn].Parents, rr.Parents)
-		}
-
-		// 4. merge tcproute parentRefs into RouteReports
-		for rnn, rr := range p.reports.TCPRoutes {
-			// if we haven't encountered this route, just copy it over completely
-			old := merged.TCPRoutes[rnn]
-			if old == nil {
-				merged.TCPRoutes[rnn] = rr
-				continue
-			}
-			// else, this route has already been seen for a proxy, merge this proxy's parents
-			// into the merged report
-			maps.Copy(merged.TCPRoutes[rnn].Parents, rr.Parents)
-		}
-
-		for rnn, rr := range p.reports.TLSRoutes {
-			// if we haven't encountered this route, just copy it over completely
-			old := merged.TLSRoutes[rnn]
-			if old == nil {
-				merged.TLSRoutes[rnn] = rr
-				continue
-			}
-			// else, this route has already been seen for a proxy, merge this proxy's parents
-			// into the merged report
-			maps.Copy(merged.TLSRoutes[rnn].Parents, rr.Parents)
-		}
-
-		for rnn, rr := range p.reports.GRPCRoutes {
-			// if we haven't encountered this route, just copy it over completely
-			old := merged.GRPCRoutes[rnn]
-			if old == nil {
-				merged.GRPCRoutes[rnn] = rr
-				continue
-			}
-			// else, this route has already been seen for a proxy, merge this proxy's parents
-			// into the merged report
-			maps.Copy(merged.GRPCRoutes[rnn].Parents, rr.Parents)
-		}
+		// 3. merge route parentRefs into RouteReports for all route types
+		mergeRouteReports(merged.HTTPRoutes, p.reports.HTTPRoutes)
+		mergeRouteReports(merged.TCPRoutes, p.reports.TCPRoutes)
+		mergeRouteReports(merged.TLSRoutes, p.reports.TLSRoutes)
+		mergeRouteReports(merged.GRPCRoutes, p.reports.GRPCRoutes)
 
 		// TODO: add back when policies are back
 		//for key, report := range p.reports.Policies {
@@ -969,6 +985,21 @@ func mergeProxyReports(
 	return merged
 }
 
+// mergeRouteReports is a helper function to merge route reports
+func mergeRouteReports(merged map[types.NamespacedName]*reports.RouteReport, source map[types.NamespacedName]*reports.RouteReport) {
+	for rnn, rr := range source {
+		// if we haven't encountered this route, just copy it over completely
+		old := merged[rnn]
+		if old == nil {
+			merged[rnn] = rr
+			continue
+		}
+		// else, this route has already been seen for a proxy, merge this proxy's parents
+		// into the merged report
+		maps.Copy(merged[rnn].Parents, rr.Parents)
+	}
+}
+
 func isGatewayStatusEqual(objA, objB *gwv1.GatewayStatus) bool {
 	return cmp.Equal(objA, objB, opts)
 }
diff --git a/internal/kgateway/agentgatewaysyncer/syncer_test.go b/internal/kgateway/agentgatewaysyncer/syncer_test.go
new file mode 100644
index 000000000..a41f4c864
--- /dev/null
+++ b/internal/kgateway/agentgatewaysyncer/syncer_test.go
@@ -0,0 +1,647 @@
+package agentgatewaysyncer
+
+import (
+	"testing"
+
+	"github.com/agentgateway/agentgateway/go/api"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/utils/ptr"
+	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+)
+
+func TestBuildADPFilters(t *testing.T) {
+	testCases := []struct {
+		name            string
+		inputFilters    []gwv1.HTTPRouteFilter
+		expectedFilters []*api.RouteFilter
+		expectedError   bool
+	}{
+		{
+			name: "Request header modifier filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterRequestHeaderModifier,
+					RequestHeaderModifier: &gwv1.HTTPHeaderFilter{
+						Set: []gwv1.HTTPHeader{
+							{Name: "X-Custom-Header", Value: "custom-value"},
+						},
+						Add: []gwv1.HTTPHeader{
+							{Name: "X-Added-Header", Value: "added-value"},
+						},
+						Remove: []string{"X-Remove-Header"},
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_RequestHeaderModifier{
+						RequestHeaderModifier: &api.HeaderModifier{
+							Set: []*api.Header{
+								{Name: "X-Custom-Header", Value: "custom-value"},
+							},
+							Add: []*api.Header{
+								{Name: "X-Added-Header", Value: "added-value"},
+							},
+							Remove: []string{"X-Remove-Header"},
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
+		{
+			name: "Response header modifier filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterResponseHeaderModifier,
+					ResponseHeaderModifier: &gwv1.HTTPHeaderFilter{
+						Set: []gwv1.HTTPHeader{
+							{Name: "X-Response-Header", Value: "response-value"},
+						},
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_ResponseHeaderModifier{
+						ResponseHeaderModifier: &api.HeaderModifier{
+							Set: []*api.Header{
+								{Name: "X-Response-Header", Value: "response-value"},
+							},
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
+		{
+			name: "Request redirect filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterRequestRedirect,
+					RequestRedirect: &gwv1.HTTPRequestRedirectFilter{
+						Scheme:     ptr.To("https"),
+						Hostname:   ptr.To(gwv1.PreciseHostname("secure.example.com")),
+						StatusCode: ptr.To(301),
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_RequestRedirect{
+						RequestRedirect: &api.RequestRedirect{
+							Scheme: "https",
+							Host:   "secure.example.com",
+							Status: 301,
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
+		{
+			name: "URL rewrite filter",
+			inputFilters: []gwv1.HTTPRouteFilter{
+				{
+					Type: gwv1.HTTPRouteFilterURLRewrite,
+					URLRewrite: &gwv1.HTTPURLRewriteFilter{
+						Path: &gwv1.HTTPPathModifier{
+							Type:               gwv1.PrefixMatchHTTPPathModifier,
+							ReplacePrefixMatch: ptr.To("/new-prefix"),
+						},
+					},
+				},
+			},
+			expectedFilters: []*api.RouteFilter{
+				{
+					Kind: &api.RouteFilter_UrlRewrite{
+						UrlRewrite: &api.UrlRewrite{
+							Path: &api.UrlRewrite_Prefix{
+								Prefix: "/new-prefix",
+							},
+						},
+					},
+				},
+			},
+			expectedError: false,
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			ctx := RouteContext{
+				RouteContextInputs: RouteContextInputs{
+					Grants:       ReferenceGrants{},
+					RouteParents: RouteParents{},
+				},
+			}
+
+			result, err := buildADPFilters(ctx, "default", tc.inputFilters)
+
+			if tc.expectedError {
+				assert.NotNil(t, err)
+				return
+			}
+
+			assert.Nil(t, err)
+			require.Equal(t, len(tc.expectedFilters), len(result))
+
+			for i, expectedFilter := range tc.expectedFilters {
+				actualFilter := result[i]
+
+				// Compare filter types
+				switch expectedFilter.Kind.(type) {
+				case *api.RouteFilter_RequestHeaderModifier:
+					assert.IsType(t, &api.RouteFilter_RequestHeaderModifier{}, actualFilter.Kind)
+				case *api.RouteFilter_ResponseHeaderModifier:
+					assert.IsType(t, &api.RouteFilter_ResponseHeaderModifier{}, actualFilter.Kind)
+				case *api.RouteFilter_RequestRedirect:
+					assert.IsType(t, &api.RouteFilter_RequestRedirect{}, actualFilter.Kind)
+				case *api.RouteFilter_UrlRewrite:
+					assert.IsType(t, &api.RouteFilter_UrlRewrite{}, actualFilter.Kind)
+				}
+			}
+		})
+	}
+}
+
+func TestGetProtocolAndTLSConfig(t *testing.T) {
+	testCases := []struct {
+		name          string
+		gateway       Gateway
+		expectedProto api.Protocol
+		expectedTLS   *api.TLSConfig
+		expectedOk    bool
+	}{
+		{
+			name: "HTTP protocol",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.HTTPProtocolType,
+				},
+				TLSInfo: nil,
+			},
+			expectedProto: api.Protocol_HTTP,
+			expectedTLS:   nil,
+			expectedOk:    true,
+		},
+		{
+			name: "HTTPS protocol with TLS",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.HTTPSProtocolType,
+				},
+				TLSInfo: &TLSInfo{
+					Cert: []byte("cert-data"),
+					Key:  []byte("key-data"),
+				},
+			},
+			expectedProto: api.Protocol_HTTPS,
+			expectedTLS: &api.TLSConfig{
+				Cert:       []byte("cert-data"),
+				PrivateKey: []byte("key-data"),
+			},
+			expectedOk: true,
+		},
+		{
+			name: "HTTPS protocol without TLS (should fail)",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.HTTPSProtocolType,
+				},
+				TLSInfo: nil,
+			},
+			expectedProto: api.Protocol_HTTPS,
+			expectedTLS:   nil,
+			expectedOk:    false,
+		},
+		{
+			name: "TCP protocol",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.TCPProtocolType,
+				},
+				TLSInfo: nil,
+			},
+			expectedProto: api.Protocol_TCP,
+			expectedTLS:   nil,
+			expectedOk:    true,
+		},
+		{
+			name: "TLS protocol with TLS",
+			gateway: Gateway{
+				parentInfo: parentInfo{
+					Protocol: gwv1.TLSProtocolType,
+				},
+				TLSInfo: &TLSInfo{
+					Cert: []byte("tls-cert"),
+					Key:  []byte("tls-key"),
+				},
+			},
+			expectedProto: api.Protocol_TLS,
+			expectedTLS: &api.TLSConfig{
+				Cert:       []byte("tls-cert"),
+				PrivateKey: []byte("tls-key"),
+			},
+			expectedOk: true,
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			syncer := &AgentGwSyncer{}
+
+			proto, tlsConfig, ok := syncer.getProtocolAndTLSConfig(tc.gateway)
+
+			assert.Equal(t, tc.expectedOk, ok)
+			if tc.expectedOk {
+				assert.Equal(t, tc.expectedProto, proto)
+				if tc.expectedTLS != nil {
+					require.NotNil(t, tlsConfig)
+					assert.Equal(t, tc.expectedTLS.Cert, tlsConfig.Cert)
+					assert.Equal(t, tc.expectedTLS.PrivateKey, tlsConfig.PrivateKey)
+				} else {
+					assert.Nil(t, tlsConfig)
+				}
+			}
+		})
+	}
+}
+
+func TestADPResourceCreation(t *testing.T) {
+	testCases := []struct {
+		name                 string
+		expectedResource     *api.Resource
+		expectedResourceName string
+	}{
+		{
+			name: "Create Bind resource",
+			expectedResource: &api.Resource{
+				Kind: &api.Resource_Bind{
+					Bind: &api.Bind{
+						Key:  "8080/default/test-gateway",
+						Port: 8080,
+					},
+				},
+			},
+			expectedResourceName: "bind/8080/default/test-gateway",
+		},
+		{
+			name: "Create Listener resource",
+			expectedResource: &api.Resource{
+				Kind: &api.Resource_Listener{
+					Listener: &api.Listener{
+						Key:         "default/test-gateway",
+						Name:        "http",
+						BindKey:     "8080/default/test-gateway",
+						GatewayName: "default/test-gateway",
+						Protocol:    api.Protocol_HTTP,
+						Hostname:    "example.com",
+					},
+				},
+			},
+			expectedResourceName: "listener/default/test-gateway",
+		},
+		{
+			name: "Create Route resource",
+			expectedResource: &api.Resource{
+				Kind: &api.Resource_Route{
+					Route: &api.Route{
+						Key:         "default.test-route.0.0",
+						RouteName:   "default/test-route",
+						ListenerKey: "http",
+						Hostnames:   []string{"example.com"},
+						Matches: []*api.RouteMatch{
+							{
+								Path: &api.PathMatch{
+									Kind: &api.PathMatch_PathPrefix{
+										PathPrefix: "/api",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expectedResourceName: "route/default.test-route.0.0",
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			gateway := types.NamespacedName{
+				Name:      "test-gateway",
+				Namespace: "default",
+			}
+
+			adpResource := ADPResource{
+				Resource: tc.expectedResource,
+				Gateway:  gateway,
+			}
+
+			assert.Equal(t, tc.expectedResourceName, adpResource.ResourceName())
+
+			// Test that two identical resources are equal
+			adpResource2 := ADPResource{
+				Resource: tc.expectedResource,
+				Gateway:  gateway,
+			}
+			assert.True(t, adpResource.Equals(adpResource2))
+		})
+	}
+}
+
+func TestMergeProxyReports(t *testing.T) {
+	tests := []struct {
+		name     string
+		proxies  []agentGwXdsResources
+		expected reports.ReportMap
+	}{
+		{
+			name: "Merge HTTPRoute reports for different parents",
+			proxies: []agentGwXdsResources{
+				{
+					reports: reports.ReportMap{
+						HTTPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					reports: reports.ReportMap{
+						HTTPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expected: reports.ReportMap{
+				HTTPRoutes: map[types.NamespacedName]*reports.RouteReport{
+					{Name: "route1", Namespace: "default"}: {
+						Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+							{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+							{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Merge TCPRoute reports for different parents",
+			proxies: []agentGwXdsResources{
+				{
+					reports: reports.ReportMap{
+						TCPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+				{
+					reports: reports.ReportMap{
+						TCPRoutes: map[types.NamespacedName]*reports.RouteReport{
+							{Name: "route1", Namespace: "default"}: {
+								Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+									{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+										Conditions: []metav1.Condition{
+											{
+												Type:   "Accepted",
+												Status: metav1.ConditionTrue,
+												Reason: "Accepted",
+											},
+										},
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+			expected: reports.ReportMap{
+				TCPRoutes: map[types.NamespacedName]*reports.RouteReport{
+					{Name: "route1", Namespace: "default"}: {
+						Parents: map[reports.ParentRefKey]*reports.ParentRefReport{
+							{NamespacedName: types.NamespacedName{Name: "gw-1", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+							{NamespacedName: types.NamespacedName{Name: "gw-2", Namespace: "default"}}: {
+								Conditions: []metav1.Condition{
+									{
+										Type:   "Accepted",
+										Status: metav1.ConditionTrue,
+										Reason: "Accepted",
+									},
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		{
+			name: "Merge Gateway reports from multiple proxies",
+			proxies: []agentGwXdsResources{
+				{
+					reports: reports.ReportMap{
+						Gateways: map[types.NamespacedName]*reports.GatewayReport{
+							{Name: "gw1", Namespace: "default"}: {},
+						},
+					},
+				},
+				{
+					reports: reports.ReportMap{
+						Gateways: map[types.NamespacedName]*reports.GatewayReport{
+							{Name: "gw2", Namespace: "default"}: {},
+						},
+					},
+				},
+			},
+			expected: reports.ReportMap{
+				Gateways: map[types.NamespacedName]*reports.GatewayReport{
+					{Name: "gw1", Namespace: "default"}: {},
+					{Name: "gw2", Namespace: "default"}: {},
+				},
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			a := assert.New(t)
+
+			actual := mergeProxyReports(tt.proxies)
+			if tt.expected.HTTPRoutes != nil {
+				a.Equal(tt.expected.HTTPRoutes, actual.HTTPRoutes)
+			}
+			if tt.expected.TCPRoutes != nil {
+				a.Equal(tt.expected.TCPRoutes, actual.TCPRoutes)
+			}
+			if tt.expected.TLSRoutes != nil {
+				a.Equal(tt.expected.TLSRoutes, actual.TLSRoutes)
+			}
+			if tt.expected.GRPCRoutes != nil {
+				a.Equal(tt.expected.GRPCRoutes, actual.GRPCRoutes)
+			}
+			if tt.expected.Gateways != nil {
+				a.Equal(tt.expected.Gateways, actual.Gateways)
+			}
+		})
+	}
+}
+
+func TestADPResourceEquals(t *testing.T) {
+	testCases := []struct {
+		name      string
+		resource1 ADPResource
+		resource2 ADPResource
+		expected  bool
+	}{
+		{
+			name: "Equal bind resources",
+			resource1: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			resource2: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			expected: true,
+		},
+		{
+			name: "Different gateway",
+			resource1: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			resource2: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "other", Namespace: "default"},
+			},
+			expected: false,
+		},
+		{
+			name: "Different resource port",
+			resource1: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 8080,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			resource2: ADPResource{
+				Resource: &api.Resource{
+					Kind: &api.Resource_Bind{
+						Bind: &api.Bind{
+							Key:  "test-key",
+							Port: 9090,
+						},
+					},
+				},
+				Gateway: types.NamespacedName{Name: "test", Namespace: "default"},
+			},
+			expected: false,
+		},
+	}
+
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			result := tc.resource1.Equals(tc.resource2)
+			assert.Equal(t, tc.expected, result)
+		})
+	}
+}
diff --git a/internal/kgateway/agentgatewaysyncer/workloads.go b/internal/kgateway/agentgatewaysyncer/workloads.go
index 0ddbbd16b..654a4c142 100644
--- a/internal/kgateway/agentgatewaysyncer/workloads.go
+++ b/internal/kgateway/agentgatewaysyncer/workloads.go
@@ -35,7 +35,6 @@ import (
 	"k8s.io/apimachinery/pkg/types"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
-
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 )
 
diff --git a/internal/kgateway/agentgatewaysyncer/xdswrapper.go b/internal/kgateway/agentgatewaysyncer/xdswrapper.go
deleted file mode 100644
index bd5c61cda..000000000
--- a/internal/kgateway/agentgatewaysyncer/xdswrapper.go
+++ /dev/null
@@ -1,192 +0,0 @@
-package agentgatewaysyncer
-
-import (
-	"encoding/json"
-	"fmt"
-
-	udpaannontations "github.com/cncf/xds/go/udpa/annotations"
-	envoycachetypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
-	"google.golang.org/protobuf/encoding/protojson"
-	"google.golang.org/protobuf/proto"
-	"google.golang.org/protobuf/reflect/protoreflect"
-	"google.golang.org/protobuf/types/descriptorpb"
-	"google.golang.org/protobuf/types/known/anypb"
-	"istio.io/istio/pkg/kube/krt"
-
-	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils"
-	"github.com/kgateway-dev/kgateway/v2/pkg/utils/envutils"
-)
-
-var (
-	UseDetailedUnmarshalling = !envutils.IsEnvTruthy("DISABLE_DETAILED_SNAP_UNMARSHALLING")
-)
-
-type XdsSnapWrapper struct {
-	snap     *agentGwSnapshot
-	proxyKey string
-}
-
-func (p XdsSnapWrapper) WithSnapshot(snap *agentGwSnapshot) XdsSnapWrapper {
-	p.snap = snap
-	return p
-}
-
-var _ krt.ResourceNamer = XdsSnapWrapper{}
-
-func (p XdsSnapWrapper) Equals(in XdsSnapWrapper) bool {
-	// check that all the versions are the equal
-	if p.snap.Addresses.Version != in.snap.Addresses.Version {
-		return false
-	}
-	if p.snap.Resources.Version != in.snap.Resources.Version {
-		return false
-	}
-	return true
-}
-
-func (p XdsSnapWrapper) ResourceName() string {
-	return p.proxyKey
-}
-
-// note: this is feature gated, as i'm not confident the new logic can't panic, in all envoy configs
-// once 1.18 is out, we can remove the feature gate.
-func (p XdsSnapWrapper) MarshalJSON() (out []byte, err error) {
-	if !UseDetailedUnmarshalling {
-		// use a new struct to prevent infinite recursion
-		return json.Marshal(struct {
-			snap     *agentGwSnapshot
-			proxyKey string
-		}{
-			snap:     p.snap,
-			proxyKey: p.proxyKey,
-		})
-	}
-
-	snap := p.snap
-
-	defer func() {
-		if r := recover(); r != nil {
-			err = fmt.Errorf("panic handling snapshot: %v", r)
-		}
-	}()
-
-	// redact things
-	redact(snap)
-	snapJson := map[string]map[string]any{}
-	addToSnap(snapJson, "Address", snap.Addresses.Items)
-	addToSnap(snapJson, "Resources", snap.Resources.Items)
-
-	return json.Marshal(struct {
-		Snap     any
-		ProxyKey string
-	}{
-		Snap:     snapJson,
-		ProxyKey: p.proxyKey,
-	})
-}
-
-func addToSnap(snapJson map[string]map[string]any, k string, resources map[string]envoycachetypes.ResourceWithTTL) {
-	for rname, r := range resources {
-		rJson, _ := protojson.Marshal(r.Resource)
-		var rAny any
-		json.Unmarshal(rJson, &rAny)
-		if snapJson[k] == nil {
-			snapJson[k] = map[string]any{}
-		}
-		snapJson[k][rname] = rAny
-	}
-}
-
-func redact(snap *agentGwSnapshot) {
-	// clusters and listener might have secrets
-	for _, l := range snap.Resources.Items {
-		redactProto(l.Resource)
-	}
-	for _, l := range snap.Addresses.Items {
-		redactProto(l.Resource)
-	}
-}
-
-func redactProto(m proto.Message) {
-	var msg proto.Message = m.(proto.Message)
-	visitFields(msg.ProtoReflect(), false)
-}
-
-func isSensitive(fd protoreflect.FieldDescriptor) bool {
-	opts := fd.Options().(*descriptorpb.FieldOptions)
-	if !proto.HasExtension(opts, udpaannontations.E_Sensitive) {
-		return false
-	}
-
-	maybeExt := proto.GetExtension(opts, udpaannontations.E_Sensitive)
-	return maybeExt.(bool)
-}
-
-func visitFields(msg protoreflect.Message, ancestor_sensitive bool) {
-	msg.Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
-		sensitive := ancestor_sensitive || isSensitive(fd)
-
-		if fd.IsList() {
-			list := v.List()
-			for i := 0; i < list.Len(); i++ {
-				elem := list.Get(i)
-				if fd.Message() != nil {
-					visitMessage(msg, fd, elem, sensitive)
-				} else {
-					// Redact scalar fields if needed
-					if sensitive {
-						list.Set(i, redactValue(fd, elem))
-					}
-				}
-			}
-		} else if fd.IsMap() {
-			m := v.Map()
-			m.Range(func(k protoreflect.MapKey, v protoreflect.Value) bool {
-				if fd.MapValue().Message() != nil {
-					visitMessage(msg, fd.MapValue(), v, sensitive)
-				} else {
-					// Redact scalar fields if needed
-					if sensitive {
-						m.Set(k, redactValue(fd.MapValue(), v))
-					}
-				}
-				return true
-			})
-		} else {
-			if fd.Message() != nil {
-				visitMessage(msg, fd, v, sensitive)
-			} else {
-				// Redact scalar fields if needed
-				if sensitive {
-					msg.Set(fd, redactValue(fd, v))
-				}
-			}
-		}
-		return true
-	})
-}
-
-func visitMessage(msg protoreflect.Message, fd protoreflect.FieldDescriptor, v protoreflect.Value, sensitive bool) {
-	visitMsg := v.Message()
-	var anyMsg proto.Message
-	m := visitMsg.Interface()
-	if anymsg, ok := m.(*anypb.Any); ok {
-		anyMsg, _ = anypb.UnmarshalNew(anymsg, proto.UnmarshalOptions{})
-		visitMsg = anyMsg.ProtoReflect()
-	}
-	visitFields(visitMsg, sensitive)
-	if anyMsg != nil {
-		anymsg, _ := utils.MessageToAny(anyMsg)
-		msg.Set(fd, protoreflect.ValueOf(anymsg.ProtoReflect()))
-	}
-}
-
-func redactValue(fd protoreflect.FieldDescriptor, v protoreflect.Value) protoreflect.Value {
-	switch fd.Kind() {
-	case protoreflect.StringKind:
-		return protoreflect.ValueOfString("[REDACTED]")
-	case protoreflect.BytesKind:
-		return protoreflect.ValueOfBytes([]byte("[REDACTED]"))
-	}
-	return v
-}
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index d8d61644c..7985cb779 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -6,6 +6,7 @@ import (
 	"fmt"
 	"os"
 	"path/filepath"
+	"sort"
 	"strings"
 	"testing"
 	"time"
@@ -15,6 +16,7 @@ import (
 	discovery_v3 "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/credentials/insecure"
+	"google.golang.org/protobuf/encoding/protojson"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/structpb"
 	istiokube "istio.io/istio/pkg/kube"
@@ -46,9 +48,9 @@ func runAgentGatewayScenario(t *testing.T, scenarioDir string, globalSettings *s
 			t.Fatalf("failed to read dir: %v", err)
 		}
 		for _, f := range files {
-			// run tests with the yaml files (but not -out.yaml files)
+			// run tests with the yaml files (agentgateway dumps json output)
 			parentT := t
-			if strings.HasSuffix(f.Name(), ".yaml") && !strings.HasSuffix(f.Name(), "-out.yaml") {
+			if strings.HasSuffix(f.Name(), ".yaml") {
 				if os.Getenv("TEST_PREFIX") != "" && !strings.HasPrefix(f.Name(), os.Getenv("TEST_PREFIX")) {
 					continue
 				}
@@ -78,7 +80,7 @@ func testAgentGatewayScenario(
 	t.Logf("running agent gateway scenario for test file: %s", f)
 
 	// read the out file
-	fout := fpre + "-out" + fext
+	fout := fpre + "-out.json"
 	write := false
 	_, err := os.ReadFile(fout)
 	// if not exist
@@ -172,7 +174,7 @@ func testAgentGatewayScenario(
 		t.Logf("Resource counts - Binds: %d, Listeners: %d, Routes: %d", bindCount, listenerCount, routeCount)
 
 		for _, resource := range dump.Addresses {
-			switch resource.Type.(type) {
+			switch resource.GetType().(type) {
 			case *api.Address_Workload:
 				worklodCount++
 				t.Logf("workload resource: %+v", resource.GetWorkload())
@@ -183,74 +185,19 @@ func testAgentGatewayScenario(
 		}
 		t.Logf("Address counts - Workload: %d, Service: %d", worklodCount, serviceCount)
 
-		// --- BEGIN: Assert expected resources and addresses are present ---
-		// Expected resource keys (from example output)
-		expectedBinds := map[string]bool{"8080/gwtest/http-httproute": false}
-		expectedListeners := map[string]bool{"http-httproute-agentgateway-autogenerated-k8s-gateway-http": false}
-		expectedRoutes := map[string]bool{"gwtest.my-route.0.0.http": false, "gwtest.my-route2.0.0.http": false}
-
-		// Check resources
-		for _, r := range dump.Resources {
-			switch x := r.GetKind().(type) {
-			case *api.Resource_Bind:
-				if _, ok := expectedBinds[x.Bind.GetKey()]; ok {
-					expectedBinds[x.Bind.GetKey()] = true
-				}
-			case *api.Resource_Listener:
-				if _, ok := expectedListeners[x.Listener.GetKey()]; ok {
-					expectedListeners[x.Listener.GetKey()] = true
-				}
-			case *api.Resource_Route:
-				if _, ok := expectedRoutes[x.Route.GetKey()]; ok {
-					expectedRoutes[x.Route.GetKey()] = true
-				}
-			}
-		}
-		for k, v := range expectedBinds {
-			if !v {
-				t.Errorf("expected Bind resource with key %q not found", k)
-			}
-		}
-		for k, v := range expectedListeners {
-			if !v {
-				t.Errorf("expected Listener resource with key %q not found", k)
-			}
-		}
-		for k, v := range expectedRoutes {
-			if !v {
-				t.Errorf("expected Route resource with key %q not found", k)
+		if !write {
+			// Read expected values from out.json file and compare
+			expectedDump, err := readExpectedDump(t, fout)
+			t.Logf("expected dump: %+v", expectedDump)
+			if err != nil {
+				return fmt.Errorf("failed to read expected dump from %s: %v", fout, err)
 			}
-		}
 
-		// Expected address keys (from example output)
-		expectedWorkloads := map[string]bool{"reviews-1": false, "reviews-2": false, "reviews-3": false, "reviews-4": false}
-		expectedServices := map[string]bool{"http-httproute.gwtest.svc.": false, "reviews.gwtest.svc.": false, "kubernetes.default.svc.": false}
-
-		for _, addr := range dump.Addresses {
-			switch x := addr.GetType().(type) {
-			case *api.Address_Workload:
-				name := x.Workload.GetName()
-				if _, ok := expectedWorkloads[name]; ok {
-					expectedWorkloads[name] = true
-				}
-			case *api.Address_Service:
-				host := x.Service.GetHostname()
-				if _, ok := expectedServices[host]; ok {
-					expectedServices[host] = true
-				}
+			// Compare actual vs expected dump
+			if err := compareDumps(dump, expectedDump); err != nil {
+				return fmt.Errorf("dump comparison failed: %v", err)
 			}
 		}
-		for k, v := range expectedWorkloads {
-			if !v {
-				t.Errorf("expected Workload address for %q not found", k)
-			}
-		}
-		for k, v := range expectedServices {
-			if !v {
-				t.Errorf("expected Service address for %q not found", k)
-			}
-		}
-		// --- END: Assert expected resources and addresses are present ---
 
 		return nil
 	}, retry.Converge(2), retry.BackoffDelay(2*time.Second), retry.Timeout(10*time.Second))
@@ -262,13 +209,22 @@ func testAgentGatewayScenario(
 func dumpProtoToJSON(t *testing.T, dump agentGwDump, fpre string) {
 	jsonFile := fpre + "-out.json"
 
+	// Sort resources and addresses for consistent ordering
+	sortedResources := make([]*api.Resource, len(dump.Resources))
+	copy(sortedResources, dump.Resources)
+	sortResources(sortedResources)
+
+	sortedAddresses := make([]*api.Address, len(dump.Addresses))
+	copy(sortedAddresses, dump.Addresses)
+	sortAddresses(sortedAddresses)
+
 	// Create a structured dump map
 	dumpMap := map[string]interface{}{
-		"resources": dump.Resources,
-		"addresses": dump.Addresses,
+		"resources": sortedResources,
+		"addresses": sortedAddresses,
 	}
 
-	// Marshal to JSON using regular JSON marshaling
+	// Marshal to JSON using standard JSON marshaling to maintain consistency
 	jsonData, err := json.MarshalIndent(dumpMap, "", "  ")
 	if err != nil {
 		t.Logf("failed to marshal to JSON: %v", err)
@@ -284,6 +240,265 @@ func dumpProtoToJSON(t *testing.T, dump agentGwDump, fpre string) {
 	t.Logf("wrote JSON dump to: %s", jsonFile)
 }
 
+// sortResources sorts resources by type and key for consistent ordering
+func sortResources(resources []*api.Resource) {
+	sort.Slice(resources, func(i, j int) bool {
+		// First sort by resource type
+		typeI := getResourceType(resources[i])
+		typeJ := getResourceType(resources[j])
+		if typeI != typeJ {
+			return typeI < typeJ
+		}
+
+		// Then sort by key within the same type
+		keyI := getResourceKey(resources[i])
+		keyJ := getResourceKey(resources[j])
+		return keyI < keyJ
+	})
+}
+
+// sortAddresses sorts addresses by type and identifier for consistent ordering
+func sortAddresses(addresses []*api.Address) {
+	sort.Slice(addresses, func(i, j int) bool {
+		// First sort by address type
+		typeI := getAddressType(addresses[i])
+		typeJ := getAddressType(addresses[j])
+		if typeI != typeJ {
+			return typeI < typeJ
+		}
+
+		// Then sort by identifier within the same type
+		idI := getAddressIdentifier(addresses[i])
+		idJ := getAddressIdentifier(addresses[j])
+		return idI < idJ
+	})
+}
+
+// getResourceType returns a string representation of the resource type for sorting
+func getResourceType(resource *api.Resource) string {
+	switch resource.GetKind().(type) {
+	case *api.Resource_Bind:
+		return "bind"
+	case *api.Resource_Listener:
+		return "listener"
+	case *api.Resource_Route:
+		return "route"
+	default:
+		return "unknown"
+	}
+}
+
+// getResourceKey returns the key for a resource for sorting
+func getResourceKey(resource *api.Resource) string {
+	switch x := resource.GetKind().(type) {
+	case *api.Resource_Bind:
+		return x.Bind.GetKey()
+	case *api.Resource_Listener:
+		return x.Listener.GetKey()
+	case *api.Resource_Route:
+		return x.Route.GetKey()
+	default:
+		return ""
+	}
+}
+
+// getAddressType returns a string representation of the address type for sorting
+func getAddressType(address *api.Address) string {
+	switch address.GetType().(type) {
+	case *api.Address_Workload:
+		return "workload"
+	case *api.Address_Service:
+		return "service"
+	default:
+		return "unknown"
+	}
+}
+
+// getAddressIdentifier returns an identifier for an address for sorting
+func getAddressIdentifier(address *api.Address) string {
+	switch x := address.GetType().(type) {
+	case *api.Address_Workload:
+		return x.Workload.GetName()
+	case *api.Address_Service:
+		return x.Service.GetHostname()
+	default:
+		return ""
+	}
+}
+
+// readExpectedDump reads and parses the expected dump from a JSON file
+func readExpectedDump(t *testing.T, filename string) (agentGwDump, error) {
+	var dump agentGwDump
+
+	data, err := os.ReadFile(filename)
+	if err != nil {
+		return dump, fmt.Errorf("failed to read file: %v", err)
+	}
+
+	// Parse the JSON structure using a custom approach that matches the actual JSON format
+	var jsonData map[string]interface{}
+	if err := json.Unmarshal(data, &jsonData); err != nil {
+		return dump, fmt.Errorf("failed to unmarshal JSON: %v", err)
+	}
+
+	// Create unmarshaler for protobuf types
+	unmarshaler := protojson.UnmarshalOptions{
+		DiscardUnknown: true,
+	}
+
+	// Parse resources
+	if resourcesData, ok := jsonData["resources"].([]interface{}); ok {
+		for _, r := range resourcesData {
+			if resourceMap, ok := r.(map[string]interface{}); ok {
+				resource := &api.Resource{}
+
+				// Parse Kind field
+				if kindData, ok := resourceMap["Kind"].(map[string]interface{}); ok {
+					if bindData, ok := kindData["Bind"].(map[string]interface{}); ok {
+						bindJSON, err := json.Marshal(bindData)
+						if err != nil {
+							t.Logf("failed to marshal bind data: %v", err)
+							continue
+						}
+						bind := &api.Bind{}
+						if err := unmarshaler.Unmarshal(bindJSON, bind); err != nil {
+							t.Logf("failed to unmarshal bind: %v", err)
+							continue
+						}
+						resource.Kind = &api.Resource_Bind{Bind: bind}
+					} else if listenerData, ok := kindData["Listener"].(map[string]interface{}); ok {
+						listenerJSON, err := json.Marshal(listenerData)
+						if err != nil {
+							t.Logf("failed to marshal listener data: %v", err)
+							continue
+						}
+						listener := &api.Listener{}
+						if err := unmarshaler.Unmarshal(listenerJSON, listener); err != nil {
+							t.Logf("failed to unmarshal listener: %v", err)
+							continue
+						}
+						resource.Kind = &api.Resource_Listener{Listener: listener}
+					} else if routeData, ok := kindData["Route"].(map[string]interface{}); ok {
+						routeJSON, err := json.Marshal(routeData)
+						if err != nil {
+							t.Logf("failed to marshal route data: %v", err)
+							continue
+						}
+						route := &api.Route{}
+						if err := unmarshaler.Unmarshal(routeJSON, route); err != nil {
+							t.Logf("failed to unmarshal route: %v", err)
+							continue
+						}
+						resource.Kind = &api.Resource_Route{Route: route}
+					}
+				}
+
+				if resource.Kind != nil {
+					dump.Resources = append(dump.Resources, resource)
+				}
+			}
+		}
+	}
+
+	// Parse addresses
+	if addressesData, ok := jsonData["addresses"].([]interface{}); ok {
+		for _, a := range addressesData {
+			if addressMap, ok := a.(map[string]interface{}); ok {
+				address := &api.Address{}
+
+				// Parse Type field
+				if typeData, ok := addressMap["Type"].(map[string]interface{}); ok {
+					if serviceData, ok := typeData["Service"].(map[string]interface{}); ok {
+						serviceJSON, err := json.Marshal(serviceData)
+						if err != nil {
+							t.Logf("failed to marshal service data: %v", err)
+							continue
+						}
+						service := &api.Service{}
+						if err := unmarshaler.Unmarshal(serviceJSON, service); err != nil {
+							t.Logf("failed to unmarshal service: %v", err)
+							continue
+						}
+						address.Type = &api.Address_Service{Service: service}
+					} else if workloadData, ok := typeData["Workload"].(map[string]interface{}); ok {
+						workloadJSON, err := json.Marshal(workloadData)
+						if err != nil {
+							t.Logf("failed to marshal workload data: %v", err)
+							continue
+						}
+						workload := &api.Workload{}
+						if err := unmarshaler.Unmarshal(workloadJSON, workload); err != nil {
+							t.Logf("failed to unmarshal workload: %v", err)
+							continue
+						}
+						address.Type = &api.Address_Workload{Workload: workload}
+					}
+				}
+
+				if address.Type != nil {
+					dump.Addresses = append(dump.Addresses, address)
+				}
+			}
+		}
+	}
+
+	return dump, nil
+}
+
+// compareDumps compares two dumps and returns an error if they differ
+func compareDumps(actual, expected agentGwDump) error {
+	// Sort both dumps for comparison
+	sortedActual := agentGwDump{
+		Resources: make([]*api.Resource, len(actual.Resources)),
+		Addresses: make([]*api.Address, len(actual.Addresses)),
+	}
+	copy(sortedActual.Resources, actual.Resources)
+	copy(sortedActual.Addresses, actual.Addresses)
+	sortResources(sortedActual.Resources)
+	sortAddresses(sortedActual.Addresses)
+
+	sortedExpected := agentGwDump{
+		Resources: make([]*api.Resource, len(expected.Resources)),
+		Addresses: make([]*api.Address, len(expected.Addresses)),
+	}
+	copy(sortedExpected.Resources, expected.Resources)
+	copy(sortedExpected.Addresses, expected.Addresses)
+	sortResources(sortedExpected.Resources)
+	sortAddresses(sortedExpected.Addresses)
+
+	// Compare resources
+	if len(sortedActual.Resources) != len(sortedExpected.Resources) {
+		return fmt.Errorf("resource count mismatch: actual=%d, expected=%d", len(sortedActual.Resources), len(sortedExpected.Resources))
+	}
+
+	for i, actualRes := range sortedActual.Resources {
+		expectedRes := sortedExpected.Resources[i]
+		if getResourceType(actualRes) != getResourceType(expectedRes) {
+			return fmt.Errorf("resource type mismatch at index %d: actual=%s, expected=%s", i, getResourceType(actualRes), getResourceType(expectedRes))
+		}
+		if getResourceKey(actualRes) != getResourceKey(expectedRes) {
+			return fmt.Errorf("resource key mismatch at index %d: actual=%s, expected=%s", i, getResourceKey(actualRes), getResourceKey(expectedRes))
+		}
+	}
+
+	// Compare addresses
+	if len(sortedActual.Addresses) != len(sortedExpected.Addresses) {
+		return fmt.Errorf("address count mismatch: actual=%d, expected=%d", len(sortedActual.Addresses), len(sortedExpected.Addresses))
+	}
+
+	for i, actualAddr := range sortedActual.Addresses {
+		expectedAddr := sortedExpected.Addresses[i]
+		if getAddressType(actualAddr) != getAddressType(expectedAddr) {
+			return fmt.Errorf("address type mismatch at index %d: actual=%s, expected=%s", i, getAddressType(actualAddr), getAddressType(expectedAddr))
+		}
+		if getAddressIdentifier(actualAddr) != getAddressIdentifier(expectedAddr) {
+			return fmt.Errorf("address identifier mismatch at index %d: actual=%s, expected=%s", i, getAddressIdentifier(actualAddr), getAddressIdentifier(expectedAddr))
+		}
+	}
+
+	return nil
+}
+
 func newAgentGatewayXdsDumper(t *testing.T, ctx context.Context, xdsPort int, gwname, gwnamespace string) xdsDumper {
 	conn, err := grpc.NewClient(fmt.Sprintf("localhost:%d", xdsPort),
 		grpc.WithTransportCredentials(insecure.NewCredentials()),
diff --git a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
index 42c0ab793..be8929cec 100644
--- a/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
+++ b/internal/kgateway/setup/testdata/agentgateway/httproute-out.json
@@ -8,7 +8,7 @@
           "hostname": "http-httproute.gwtest.svc.cluster.local",
           "addresses": [
             {
-              "address": "CgAApw=="
+              "address": "CgAAbg=="
             }
           ],
           "ports": [
@@ -21,6 +21,53 @@
         }
       }
     },
+    {
+      "Type": {
+        "Service": {
+          "name": "kubernetes",
+          "namespace": "default",
+          "hostname": "kubernetes.default.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAAQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 443,
+              "target_port": 59848
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "reviews",
+          "namespace": "gwtest",
+          "hostname": "reviews.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAA/g=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8000,
+              "target_port": 8080,
+              "app_protocol": 1
+            },
+            {
+              "service_port": 9090,
+              "target_port": 9090
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
     {
       "Type": {
         "Workload": {
@@ -53,6 +100,105 @@
           "status": 1
         }
       }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-2",
+          "name": "reviews-2",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQCDg=="
+          ],
+          "service_account": "default",
+          "node": "worker2",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-2",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-3",
+          "name": "reviews-3",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQDAw=="
+          ],
+          "service_account": "default",
+          "node": "worker3",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-3",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-4",
+          "name": "reviews-4",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQEBA=="
+          ],
+          "service_account": "default",
+          "node": "worker4",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-4",
+          "services": {
+            "gwtest/reviews.gwtest.svc.cluster.local": {
+              "ports": [
+                {
+                  "service_port": 8000,
+                  "target_port": 8080
+                },
+                {
+                  "service_port": 9090,
+                  "target_port": 9090
+                }
+              ]
+            }
+          },
+          "status": 1
+        }
+      }
     }
   ],
   "resources": [
diff --git a/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
index 717094c9e..ab31fcdfd 100644
--- a/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
+++ b/internal/kgateway/setup/testdata/agentgateway/inferencepool-out.json
@@ -1,5 +1,27 @@
 {
   "addresses": [
+    {
+      "Type": {
+        "Service": {
+          "name": "gateway-pool-endpoint-picker",
+          "namespace": "gwtest",
+          "hostname": "gateway-pool-endpoint-picker.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAATQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 9002,
+              "target_port": 9002,
+              "app_protocol": 3
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
     {
       "Type": {
         "Service": {
@@ -16,6 +38,107 @@
         }
       }
     },
+    {
+      "Type": {
+        "Service": {
+          "name": "http-httproute",
+          "namespace": "gwtest",
+          "hostname": "http-httproute.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAbg=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "http-inferencepool",
+          "namespace": "gwtest",
+          "hostname": "http-inferencepool.gwtest.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAIQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 8080,
+              "target_port": 8080
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Service": {
+          "name": "kubernetes",
+          "namespace": "default",
+          "hostname": "kubernetes.default.svc.cluster.local",
+          "addresses": [
+            {
+              "address": "CgAAAQ=="
+            }
+          ],
+          "ports": [
+            {
+              "service_port": 443,
+              "target_port": 59848
+            }
+          ],
+          "ip_families": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-1",
+          "name": "reviews-1",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQBCw=="
+          ],
+          "service_account": "default",
+          "node": "worker",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-1",
+          "status": 1
+        }
+      }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-2",
+          "name": "reviews-2",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQCDg=="
+          ],
+          "service_account": "default",
+          "node": "worker2",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-2",
+          "status": 1
+        }
+      }
+    },
     {
       "Type": {
         "Workload": {
@@ -34,6 +157,25 @@
           "status": 1
         }
       }
+    },
+    {
+      "Type": {
+        "Workload": {
+          "uid": "//Pod/gwtest/reviews-4",
+          "name": "reviews-4",
+          "namespace": "gwtest",
+          "addresses": [
+            "CvQEBA=="
+          ],
+          "service_account": "default",
+          "node": "worker4",
+          "canonical_name": "reviews",
+          "canonical_revision": "latest",
+          "workload_type": 2,
+          "workload_name": "reviews-4",
+          "status": 1
+        }
+      }
     }
   ],
   "resources": [
-- 
2.39.5 (Apple Git-154)


From 700991bf282e2061e35bc9715289d747bc48ceb9 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Tue, 8 Jul 2025 13:50:00 -0700
Subject: [PATCH 16/17] wip: statuses

---
 .../agentgatewaysyncer/gateway_collection.go  | 42 +++++++---
 .../agentgatewaysyncer/route_collections.go   | 16 ++--
 .../route_collections_test.go                 | 10 ++-
 .../kgateway/agentgatewaysyncer/syncer.go     | 79 +++++++++++++++----
 .../kgateway/proxy_syncer/proxy_syncer.go     |  2 +-
 internal/kgateway/reports/reporter.go         | 11 +++
 internal/kgateway/reports/status.go           |  2 +
 internal/kgateway/setup/agentgateway_test.go  |  3 +-
 8 files changed, 133 insertions(+), 32 deletions(-)

diff --git a/internal/kgateway/agentgatewaysyncer/gateway_collection.go b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
index 796be2baa..311f813c1 100644
--- a/internal/kgateway/agentgatewaysyncer/gateway_collection.go
+++ b/internal/kgateway/agentgatewaysyncer/gateway_collection.go
@@ -26,14 +26,23 @@ func toResourcep(gw types.NamespacedName, t any) *ADPResource {
 	return &res
 }
 
+func toResourcepWithReports(gw types.NamespacedName, t any, reportMap reports.ReportMap) *ADPResource {
+	res := toResourceWithReports(gw, t, reportMap)
+	return &res
+}
+
 func toResource(gw types.NamespacedName, t any) ADPResource {
+	return toResourceWithReports(gw, t, reports.NewReportMap())
+}
+
+func toResourceWithReports(gw types.NamespacedName, t any, reportMap reports.ReportMap) ADPResource {
 	switch tt := t.(type) {
 	case Bind:
-		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Bind{tt.Bind}}, Gateway: gw}
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Bind{tt.Bind}}, Gateway: gw, reports: reportMap}
 	case ADPListener:
-		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Listener{tt.Listener}}, Gateway: gw}
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Listener{tt.Listener}}, Gateway: gw, reports: reportMap}
 	case ADPRoute:
-		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Route{tt.Route}}, Gateway: gw}
+		return ADPResource{Resource: &api.Resource{Kind: &api.Resource_Route{tt.Route}}, Gateway: gw, reports: reportMap}
 	}
 	panic("unknown resource kind")
 }
@@ -121,10 +130,10 @@ func GatewayCollection(
 	secrets krt.Collection[*corev1.Secret],
 	domainSuffix string,
 	krtopts krtutil.KrtOptions,
+	statusReporter reporter.Reporter,
 ) krt.Collection[Gateway] {
 	gw := krt.NewManyCollection(gateways, func(ctx krt.HandlerContext, obj *gwv1.Gateway) []Gateway {
-		rm := reports.NewReportMap()
-		r := reports.NewReporter(&rm)
+		gwReporter := statusReporter.Gateway(obj)
 		logger.Debug("translating Gateway", "gw_name", obj.GetName(), "resource_version", obj.GetResourceVersion())
 
 		if string(obj.Spec.GatewayClassName) != agentGatewayClassName {
@@ -146,7 +155,7 @@ func GatewayCollection(
 		if len(gatewayServices) == 0 && err != nil {
 			// Short circuit if its a hard failure
 			logger.Error("failed to translate gwv1", "name", obj.GetName(), "namespace", obj.GetNamespace(), "err", err.Message)
-			r.Gateway(obj).SetCondition(reporter.GatewayCondition{
+			gwReporter.SetCondition(reporter.GatewayCondition{
 				Type:    gwv1.GatewayConditionAccepted,
 				Status:  metav1.ConditionFalse,
 				Reason:  gwv1.GatewayReasonInvalid, // TODO: check reason
@@ -157,6 +166,23 @@ func GatewayCollection(
 
 		for i, l := range kgw.Listeners {
 			server, tlsInfo, programmed := buildListener(ctx, secrets, grants, namespaces, obj, status, l, i, controllerName)
+			lstatus := status.Listeners[i]
+
+			// Generate supported kinds for the listener
+			allowed, _ := generateSupportedKinds(l)
+
+			// Set all listener conditions from the actual status
+			for _, condition := range lstatus.Conditions {
+				gwReporter.Listener(&l).SetCondition(reporter.ListenerCondition{
+					Type:    gwv1.ListenerConditionType(condition.Type),
+					Status:  condition.Status,
+					Reason:  gwv1.ListenerConditionReason(condition.Reason),
+					Message: condition.Message,
+				})
+			}
+
+			// Set supported kinds for the listener
+			gwReporter.Listener(&l).SetSupportedKinds(allowed)
 
 			servers = append(servers, server)
 			meta := parentMeta(obj, &l.Name)
@@ -175,8 +201,6 @@ func GatewayCollection(
 					Servers: []*istio.Server{server},
 				},
 			}
-
-			allowed, _ := generateSupportedKinds(l)
 			ref := parentKey{
 				Kind:      wellknown.GatewayGVK,
 				Name:      obj.Name,
@@ -202,7 +226,7 @@ func GatewayCollection(
 			result = append(result, res)
 		}
 
-		r.Gateway(obj).SetCondition(reporter.GatewayCondition{
+		gwReporter.SetCondition(reporter.GatewayCondition{
 			Type:   gwv1.GatewayConditionAccepted,
 			Status: metav1.ConditionTrue,
 			Reason: gwv1.GatewayReasonAccepted,
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
index c1d959703..4a3fd37bb 100644
--- a/internal/kgateway/agentgatewaysyncer/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -18,6 +18,7 @@ import (
 	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 )
@@ -27,13 +28,14 @@ func ADPRouteCollection(
 	httpRoutes krt.Collection[*gwv1.HTTPRoute],
 	inputs RouteContextInputs,
 	krtopts krtutil.KrtOptions,
+	rm reports.ReportMap,
+	rep reporter.Reporter,
 ) krt.Collection[ADPResource] {
 	routes := krt.NewManyCollection(httpRoutes, func(krtctx krt.HandlerContext, obj *gwv1.HTTPRoute) []ADPResource {
-		rm := reports.NewReportMap()
-		rep := reports.NewReporter(&rm)
 		logger.Debug("translating HTTPRoute", "route_name", obj.GetName(), "resource_version", obj.GetResourceVersion())
 
 		ctx := inputs.WithCtx(krtctx)
+		routeReporter := rep.Route(obj)
 		route := obj.Spec
 		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gwv1.HTTPRoute) iter.Seq2[ADPRoute, *ConfigError] {
 			return func(yield func(ADPRoute, *ConfigError) bool) {
@@ -58,14 +60,18 @@ func ADPRouteCollection(
 
 		var res []ADPResource
 		for _, parent := range filteredReferences(parentRefs) {
+			// Always create a route reporter entry for the parent ref
+			parentRefReporter := routeReporter.ParentRef(&parent.OriginalReference)
+
 			// for gwv1beta1 routes, build one VS per gwv1beta1+host
 			routes := gwResult.routes
 			if len(routes) == 0 {
+				logger.Debug("no routes for parent", "route_name", obj.GetName(), "parent", parent.ParentKey)
 				continue
 			}
 			if gwResult.error != nil {
-				rep.Route(obj).ParentRef(&parent.OriginalReference).SetCondition(reporter.RouteCondition{
-					Type:    gwv1beta1.RouteConditionResolvedRefs, // TODO: check type
+				parentRefReporter.SetCondition(reporter.RouteCondition{
+					Type:    gwv1beta1.RouteConditionResolvedRefs, // TODO: fix
 					Status:  metav1.ConditionFalse,
 					Reason:  gwv1beta1.RouteConditionReason(gwResult.error.Reason),
 					Message: gwResult.error.Message,
@@ -81,7 +87,7 @@ func ADPRouteCollection(
 				_, name, _ := strings.Cut(parent.InternalName, "/")
 				inner.ListenerKey = name
 				inner.Key = inner.GetKey() + "." + string(parent.ParentSection)
-				return toResource(gw, ADPRoute{Route: inner})
+				return toResourceWithReports(gw, ADPRoute{Route: inner}, rm)
 			})...)
 		}
 		return res
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections_test.go b/internal/kgateway/agentgatewaysyncer/route_collections_test.go
index 94cca5bec..ca96d031b 100644
--- a/internal/kgateway/agentgatewaysyncer/route_collections_test.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections_test.go
@@ -16,6 +16,8 @@ import (
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
 
+	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 )
@@ -647,7 +649,9 @@ func TestADPRouteCollection(t *testing.T) {
 			krtopts := krtutil.KrtOptions{}
 
 			// Call ADPRouteCollection
-			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts)
+			rm := reports.NewReportMap()
+			rep := reports.NewReporter(&rm)
+			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts, rm, rep)
 
 			// Wait for the collection to process
 			adpRoutes.WaitUntilSynced(context.Background().Done())
@@ -933,7 +937,9 @@ func TestADPRouteCollectionWithFilters(t *testing.T) {
 			krtopts := krtutil.KrtOptions{}
 
 			// Call ADPRouteCollection
-			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts)
+			rm := reports.NewReportMap()
+			rep := reports.NewReporter(&rm)
+			adpRoutes := ADPRouteCollection(httpRoutes, routeInputs, krtopts, rm, rep)
 
 			// Wait for the collection to process
 			adpRoutes.WaitUntilSynced(context.Background().Done())
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index ffa74a9f5..0e0f1f77c 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -41,6 +41,8 @@ import (
 	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 	gwxv1a1 "sigs.k8s.io/gateway-api/apisx/v1alpha1"
 
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
@@ -93,6 +95,7 @@ type AgentGwSyncer struct {
 
 	// Status reporting
 	statusReport krt.Singleton[report]
+	reportMap    *reports.ReportMap
 
 	// Synchronization
 	waitForSync []cache.InformerSynced
@@ -193,9 +196,13 @@ func (r report) ResourceName() string {
 }
 
 func (r report) Equals(in report) bool {
-	return maps.Equal(r.reportMap.Gateways, in.reportMap.Gateways) &&
-		maps.Equal(r.reportMap.HTTPRoutes, in.reportMap.HTTPRoutes) &&
-		maps.Equal(r.reportMap.TCPRoutes, in.reportMap.TCPRoutes)
+	if !maps.Equal(r.reportMap.Gateways, in.reportMap.Gateways) {
+		return false
+	}
+	if !maps.Equal(r.reportMap.HTTPRoutes, in.reportMap.HTTPRoutes) {
+		return false
+	}
+	return true
 }
 
 // Inputs holds all the input collections needed for the syncer
@@ -224,7 +231,10 @@ func (s *AgentGwSyncer) Init(krtopts krtutil.KrtOptions) {
 
 	s.setupInferenceExtensionClient()
 	inputs := s.buildInputCollections(krtopts)
-	s.buildResourceCollections(inputs, krtopts)
+	rm := reports.NewReportMap()
+	r := reports.NewReporter(&rm)
+	s.reportMap = &rm // Store the report map in the struct
+	s.buildResourceCollections(inputs, krtopts, r)
 }
 
 func (s *AgentGwSyncer) setupInferenceExtensionClient() {
@@ -283,14 +293,14 @@ func (s *AgentGwSyncer) buildInputCollections(krtopts krtutil.KrtOptions) Inputs
 	return inputs
 }
 
-func (s *AgentGwSyncer) buildResourceCollections(inputs Inputs, krtopts krtutil.KrtOptions) {
+func (s *AgentGwSyncer) buildResourceCollections(inputs Inputs, krtopts krtutil.KrtOptions, reporter reporter.Reporter) {
 	// Build core collections
 	gatewayClasses := GatewayClassesCollection(inputs.GatewayClasses, krtopts)
 	refGrants := BuildReferenceGrants(ReferenceGrantsCollection(inputs.ReferenceGrants, krtopts))
-	gateways := s.buildGatewayCollection(inputs, gatewayClasses, refGrants, krtopts)
+	gateways := s.buildGatewayCollection(inputs, gatewayClasses, refGrants, krtopts, reporter)
 
 	// Build ADP resources
-	adpResources := s.buildADPResources(gateways, inputs, refGrants, krtopts)
+	adpResources := s.buildADPResources(gateways, inputs, refGrants, krtopts, reporter)
 
 	// Build address collections
 	addresses := s.buildAddressCollections(inputs, krtopts)
@@ -305,7 +315,13 @@ func (s *AgentGwSyncer) buildResourceCollections(inputs Inputs, krtopts krtutil.
 	s.setupSyncDependencies(gateways, adpResources, addresses, inputs)
 }
 
-func (s *AgentGwSyncer) buildGatewayCollection(inputs Inputs, gatewayClasses krt.Collection[GatewayClass], refGrants ReferenceGrants, krtopts krtutil.KrtOptions) krt.Collection[Gateway] {
+func (s *AgentGwSyncer) buildGatewayCollection(
+	inputs Inputs,
+	gatewayClasses krt.Collection[GatewayClass],
+	refGrants ReferenceGrants,
+	krtopts krtutil.KrtOptions,
+	reporter reporter.Reporter,
+) krt.Collection[Gateway] {
 	return GatewayCollection(
 		s.agentGatewayClassName,
 		inputs.Gateways,
@@ -315,10 +331,24 @@ func (s *AgentGwSyncer) buildGatewayCollection(inputs Inputs, gatewayClasses krt
 		inputs.Secrets,
 		s.domainSuffix,
 		krtopts,
+		reporter,
 	)
 }
 
-func (s *AgentGwSyncer) buildADPResources(gateways krt.Collection[Gateway], inputs Inputs, refGrants ReferenceGrants, krtopts krtutil.KrtOptions) krt.Collection[ADPResource] {
+func (s *AgentGwSyncer) buildADPResources(
+	gateways krt.Collection[Gateway],
+	inputs Inputs,
+	refGrants ReferenceGrants,
+	krtopts krtutil.KrtOptions,
+	rep reporter.Reporter,
+) krt.Collection[ADPResource] {
+	// Use the report map from the syncer - pass the original map, not a copy
+	reportMap := s.reportMap
+	if reportMap == nil {
+		newMap := reports.NewReportMap()
+		reportMap = &newMap
+	}
+
 	// Build ports and binds
 	ports := krt.NewCollection(gateways, func(ctx krt.HandlerContext, obj Gateway) *IndexObject[string, Gateway] {
 		port := fmt.Sprint(obj.parentInfo.Port)
@@ -338,6 +368,7 @@ func (s *AgentGwSyncer) buildADPResources(gateways krt.Collection[Gateway], inpu
 			})
 		}
 		var binds []ADPResource
+
 		for _, obj := range uniq.UnsortedList() {
 			bind := Bind{
 				Bind: &api.Bind{
@@ -345,7 +376,7 @@ func (s *AgentGwSyncer) buildADPResources(gateways krt.Collection[Gateway], inpu
 					Port: uint32(port),
 				},
 			}
-			binds = append(binds, toResource(obj, bind))
+			binds = append(binds, toResourceWithReports(obj, bind, *reportMap))
 		}
 		return binds
 	}, krtopts.ToOptions("Binds")...)
@@ -363,7 +394,7 @@ func (s *AgentGwSyncer) buildADPResources(gateways krt.Collection[Gateway], inpu
 		Namespaces:     inputs.Namespaces,
 		InferencePools: inputs.InferencePools,
 	}
-	adpRoutes := ADPRouteCollection(inputs.HTTPRoutes, routeInputs, krtopts)
+	adpRoutes := ADPRouteCollection(inputs.HTTPRoutes, routeInputs, krtopts, *reportMap, rep)
 
 	return krt.JoinCollection([]krt.Collection[ADPResource]{binds, listeners, adpRoutes}, krtopts.ToOptions("ADPResources")...)
 }
@@ -387,10 +418,17 @@ func (s *AgentGwSyncer) buildListenerFromGateway(ctx krt.HandlerContext, obj Gat
 	l.Protocol = protocol
 	l.Tls = tlsConfig
 
-	return toResourcep(types.NamespacedName{
+	// Use the report map from the syncer
+	reportMap := s.reportMap
+	if reportMap == nil {
+		newMap := reports.NewReportMap()
+		reportMap = &newMap
+	}
+
+	return toResourcepWithReports(types.NamespacedName{
 		Namespace: obj.parent.Namespace,
 		Name:      obj.parent.Name,
-	}, ADPListener{l})
+	}, ADPListener{l}, *reportMap)
 }
 
 // getProtocolAndTLSConfig extracts protocol and TLS configuration from a gateway
@@ -513,12 +551,23 @@ func (s *AgentGwSyncer) buildXDSCollection(adpResources krt.Collection[ADPResour
 		var cacheResources []envoytypes.Resource
 		// Use index to fetch only resources for this gateway instead of all resources
 		resourceList := krt.Fetch(kctx, adpResources, krt.FilterIndex(adpResourcesByGateway, gwNamespacedName))
+
+		// Collect and merge reports from all resources for this gateway
+		mergedReports := reports.NewReportMap()
 		for _, resource := range resourceList {
 			cacheResources = append(cacheResources, &envoyResourceWithCustomName{
 				Message: resource.Resource,
 				Name:    resource.ResourceName(),
 				version: utils.HashProto(resource.Resource),
 			})
+
+			// Merge reports from this resource into the merged reports
+			maps.Copy(mergedReports.Gateways, resource.reports.Gateways)
+			maps.Copy(mergedReports.ListenerSets, resource.reports.ListenerSets)
+			mergeRouteReports(mergedReports.HTTPRoutes, resource.reports.HTTPRoutes)
+			mergeRouteReports(mergedReports.TCPRoutes, resource.reports.TCPRoutes)
+			mergeRouteReports(mergedReports.TLSRoutes, resource.reports.TLSRoutes)
+			mergeRouteReports(mergedReports.GRPCRoutes, resource.reports.GRPCRoutes)
 		}
 
 		// Create the resource wrappers
@@ -534,6 +583,7 @@ func (s *AgentGwSyncer) buildXDSCollection(adpResources krt.Collection[ADPResour
 
 		result := &agentGwXdsResources{
 			NamespacedName: gwNamespacedName,
+			reports:        mergedReports,
 			ResourceConfig: envoycache.NewResources(fmt.Sprintf("%d", resourceVersion), cacheResources),
 			AddressConfig:  envoycache.NewResources(fmt.Sprintf("%d", addrVersion), envoytypesAddresses),
 		}
@@ -600,7 +650,7 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 	latestReportQueue := utils.NewAsyncQueue[reports.ReportMap]()
 	s.statusReport.Register(func(o krt.Event[report]) {
 		if o.Event == controllers.EventDelete {
-			// TODO: handle garbage collection (see: https://github.com/solo-io/solo-projects/issues/7086)
+			// TODO: handle garbage collection
 			return
 		}
 		latestReportQueue.Enqueue(o.Latest().reportMap)
@@ -612,6 +662,7 @@ func (s *AgentGwSyncer) Start(ctx context.Context) error {
 		for {
 			latestReport, err := latestReportQueue.Dequeue(ctx)
 			if err != nil {
+				logger.Error("failed to dequeue latest report", "error", err)
 				return
 			}
 			s.syncGatewayStatus(ctx, gatewayStatusLogger, latestReport)
diff --git a/internal/kgateway/proxy_syncer/proxy_syncer.go b/internal/kgateway/proxy_syncer/proxy_syncer.go
index dc4680d9a..4a82b177e 100644
--- a/internal/kgateway/proxy_syncer/proxy_syncer.go
+++ b/internal/kgateway/proxy_syncer/proxy_syncer.go
@@ -381,7 +381,7 @@ func (s *ProxySyncer) Start(ctx context.Context) error {
 	latestReportQueue := utils.NewAsyncQueue[reports.ReportMap]()
 	s.statusReport.Register(func(o krt.Event[report]) {
 		if o.Event == controllers.EventDelete {
-			// TODO: handle garbage collection (see: https://github.com/solo-io/solo-projects/issues/7086)
+			// TODO: handle garbage collection
 			return
 		}
 		latestReportQueue.Enqueue(o.Latest().reportMap)
diff --git a/internal/kgateway/reports/reporter.go b/internal/kgateway/reports/reporter.go
index 794b9c22e..dc58225b3 100644
--- a/internal/kgateway/reports/reporter.go
+++ b/internal/kgateway/reports/reporter.go
@@ -81,15 +81,24 @@ func key(obj metav1.Object) types.NamespacedName {
 //
 // NOTE: Exported for unit testing, validation_test.go should be refactored to reduce this visibility
 func (r *ReportMap) Gateway(gateway *gwv1.Gateway) *GatewayReport {
+	fmt.Printf("debug(npolshak) Gateway() %s\n", gateway.Name)
 	key := key(gateway)
+	if r.Gateways[key] == nil {
+		fmt.Printf("debug(npolshak) nil gateway report %v\n", r.Gateways[key])
+	} else {
+		fmt.Printf("debug(npolshak) val gateway report not nil %v\n", r.Gateways[key].conditions)
+	}
 	return r.Gateways[key]
 }
 
 func (r *ReportMap) newGatewayReport(gateway *gwv1.Gateway) *GatewayReport {
+	fmt.Printf("debug(npolshak) creating new gateway report %s\n", gateway.Name)
+
 	gr := &GatewayReport{}
 	gr.observedGeneration = gateway.Generation
 	key := key(gateway)
 	r.Gateways[key] = gr
+	fmt.Printf("debug(npolshak) newGatewayReport val gateway report %v\n", gr.conditions)
 	return gr
 }
 
@@ -199,6 +208,7 @@ func (g *GatewayReport) SetCondition(gc pluginsdkreporter.GatewayCondition) {
 		Reason:  string(gc.Reason),
 		Message: gc.Message,
 	}
+	fmt.Printf("debug(npolshak) SetCondition %v for %v\n", condition, g)
 	meta.SetStatusCondition(&g.conditions, condition)
 }
 
@@ -272,6 +282,7 @@ type reporter struct {
 }
 
 func (r *reporter) Gateway(gateway *gwv1.Gateway) pluginsdkreporter.GatewayReporter {
+	fmt.Printf("debug(npolshak) reporter Gateway(gateway) %s\n", gateway.Name)
 	gr := r.report.Gateway(gateway)
 	if gr == nil {
 		gr = r.report.newGatewayReport(gateway)
diff --git a/internal/kgateway/reports/status.go b/internal/kgateway/reports/status.go
index d67126a8d..ef28eac2f 100644
--- a/internal/kgateway/reports/status.go
+++ b/internal/kgateway/reports/status.go
@@ -23,6 +23,7 @@ import (
 // TODO: refactor this struct + methods to better reflect the usage now in proxy_syncer
 
 func (r *ReportMap) BuildGWStatus(ctx context.Context, gw gwv1.Gateway) *gwv1.GatewayStatus {
+	fmt.Printf("debug(npolshak) BuildGWStatus %v\n", gw.Name)
 	gwReport := r.Gateway(&gw)
 	if gwReport == nil {
 		return nil
@@ -52,6 +53,7 @@ func (r *ReportMap) BuildGWStatus(ctx context.Context, gw gwv1.Gateway) *gwv1.Ga
 		finalListeners = append(finalListeners, lisReport.Status)
 	}
 
+	fmt.Printf("debug(npolshak) adding missing gateway conditions %v\n", gw.Name)
 	addMissingGatewayConditions(r.Gateway(&gw))
 
 	finalConditions := make([]metav1.Condition, 0)
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index 7985cb779..b9ebc494c 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -16,13 +16,14 @@ import (
 	discovery_v3 "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
 	"google.golang.org/grpc"
 	"google.golang.org/grpc/credentials/insecure"
-	"google.golang.org/protobuf/encoding/protojson"
 	"google.golang.org/protobuf/proto"
 	"google.golang.org/protobuf/types/known/structpb"
 	istiokube "istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/krt"
 	"istio.io/istio/pkg/test/util/retry"
 
+	"google.golang.org/protobuf/encoding/protojson"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/agentgatewaysyncer"
 	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 )
-- 
2.39.5 (Apple Git-154)


From 905cb20800817a270c69a00cb8bccaa766ce9465 Mon Sep 17 00:00:00 2001
From: npolshakova <nina.polshakova@solo.io>
Date: Wed, 9 Jul 2025 08:48:03 -0700
Subject: [PATCH 17/17] cleanup

---
 examples/httpbin.yaml                         |   8 +
 go.mod                                        |   3 +-
 go.sum                                        |   4 +-
 hack/utils/oss_compliance/osa_provided.md     |   2 +-
 install/test/helm_test.go                     |   4 +-
 .../kgateway/agentgatewaysyncer/README.md     |  48 ++++
 internal/kgateway/agentgatewaysyncer/adp.go   |  31 ++-
 .../kgateway/agentgatewaysyncer/conversion.go | 242 ++++++++++++------
 internal/kgateway/agentgatewaysyncer/model.go |   4 +-
 .../agentgatewaysyncer/route_collections.go   |  17 +-
 .../kgateway/agentgatewaysyncer/syncer.go     |   3 +-
 .../inferenceextension/endpointpicker/ir.go   |   4 +-
 .../plugins/serviceentry/collections.go       |   8 +-
 internal/kgateway/krtcollections/pods.go      |   2 +-
 internal/kgateway/setup/agentgateway_test.go  |   2 +-
 test/envtestutil/util.go                      |   2 +-
 test/helpers/kube_dump.go                     |   2 +-
 .../kubernetes/e2e/features/waypoint/suite.go |   4 +-
 .../testutils/assertions/deployments.go       |   2 +-
 19 files changed, 277 insertions(+), 115 deletions(-)

diff --git a/examples/httpbin.yaml b/examples/httpbin.yaml
index 8a4451b1d..a10d508ba 100644
--- a/examples/httpbin.yaml
+++ b/examples/httpbin.yaml
@@ -1,3 +1,8 @@
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: httpbin
+---
 ##################################################################################################
 # httpbin service
 ##################################################################################################
@@ -5,11 +10,13 @@ apiVersion: v1
 kind: ServiceAccount
 metadata:
   name: httpbin
+  namespace: httpbin
 ---
 apiVersion: v1
 kind: Service
 metadata:
   name: httpbin
+  namespace: httpbin
   labels:
     app: httpbin
     service: httpbin
@@ -27,6 +34,7 @@ apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: httpbin
+  namespace: httpbin
 spec:
   replicas: 1
   selector:
diff --git a/go.mod b/go.mod
index b8edd0f14..a2db01d95 100644
--- a/go.mod
+++ b/go.mod
@@ -617,7 +617,8 @@ require (
 replace sigs.k8s.io/controller-tools => github.com/shashankram/controller-tools v0.0.0-20250626172831-f7be064a9132
 
 replace (
-	github.com/agentgateway/agentgateway => github.com/solo-io/agentgateway-enterprise v0.0.0-20250703185034-bc92714cfedc
+	// TODO: replace once https://github.com/agentgateway/agentgateway/pull/157/ merges
+	github.com/agentgateway/agentgateway => github.com/howardjohn/agentgateway v0.0.0-20250709153329-b02466b38629
 	github.com/imdario/mergo => github.com/imdario/mergo v0.3.16
 )
 
diff --git a/go.sum b/go.sum
index d20467e31..d3cf80593 100644
--- a/go.sum
+++ b/go.sum
@@ -1061,6 +1061,8 @@ github.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUq
 github.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=
 github.com/hinshun/vt10x v0.0.0-20180616224451-1954e6464174/go.mod h1:DqJ97dSdRW1W22yXSB90986pcOyQ7r45iio1KN2ez1A=
 github.com/hinshun/vt10x v0.0.0-20180809195222-d55458df857c/go.mod h1:DqJ97dSdRW1W22yXSB90986pcOyQ7r45iio1KN2ez1A=
+github.com/howardjohn/agentgateway v0.0.0-20250709153329-b02466b38629 h1:48Q9oTh15xO862CTafbgz6osutPS0ZWIhJ1fOIhqgM8=
+github.com/howardjohn/agentgateway v0.0.0-20250709153329-b02466b38629/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
 github.com/huandu/xstrings v1.5.0 h1:2ag3IFq9ZDANvthTwTiqSSZLjDc+BedvHPAp5tJy2TI=
 github.com/huandu/xstrings v1.5.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
@@ -1640,8 +1642,6 @@ github.com/smartystreets/goconvey v1.7.2/go.mod h1:Vw0tHAZW6lzCRk3xgdin6fKYcG+G3
 github.com/smartystreets/goconvey v1.8.1 h1:qGjIddxOk4grTu9JPOU31tVfq3cNdBlNa5sSznIX1xY=
 github.com/smartystreets/goconvey v1.8.1/go.mod h1:+/u4qLyY6x1jReYOp7GOM2FSt8aP9CzCZL03bI28W60=
 github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
-github.com/solo-io/agentgateway-enterprise v0.0.0-20250703185034-bc92714cfedc h1:dLQ3+UIQBA6ar2Q5VaynoV74cyYPA+OuoV+/n7vWPw0=
-github.com/solo-io/agentgateway-enterprise v0.0.0-20250703185034-bc92714cfedc/go.mod h1:geHd31xH5d8OrCRuRyvnDxBeqSZ9+O9VhL8VJAfcA+E=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966 h1:MavIqMAvo9dxhcuN0/m7Ok830e7htfhR+JWRDqs3qj4=
 github.com/solo-io/envoy-gloo/go v0.0.0-20250102165327-33a74fcf9966/go.mod h1:27GcajR+wxZ34COPvLp1+4hxGN66/GSx7SSjVn8LySY=
 github.com/solo-io/go-list-licenses v0.1.4 h1:u4xh1OUORT4iSWuAp3Q4NsfHcDaeUV8QRDH8ACQqbxw=
diff --git a/hack/utils/oss_compliance/osa_provided.md b/hack/utils/oss_compliance/osa_provided.md
index 7ac4fbcc3..74a2b7316 100644
--- a/hack/utils/oss_compliance/osa_provided.md
+++ b/hack/utils/oss_compliance/osa_provided.md
@@ -1,6 +1,6 @@
 Name|Version|License
 ---|---|---
-[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.0.0-20250703185034-bc92714cfedc|Apache License 2.0
+[agentgateway/agentgateway](https://github.com/agentgateway/agentgateway)|v0.0.0-20250709153329-b02466b38629|Apache License 2.0
 [avast/retry-go](https://github.com/avast/retry-go)|v2.4.3+incompatible|MIT License
 [retry-go/v4](https://github.com/avast/retry-go)|v4.3.3|MIT License
 [caarlos0/log](https://github.com/caarlos0/log)|v0.4.6|MIT License
diff --git a/install/test/helm_test.go b/install/test/helm_test.go
index 5618746ce..0ce18bce5 100644
--- a/install/test/helm_test.go
+++ b/install/test/helm_test.go
@@ -2102,7 +2102,7 @@ spec:
   behavior:
     scaleDown:
       policies:
-      - type: LocalityPods
+      - type: Pods
         value: 4
         periodSeconds: 60
       - type: Percent
@@ -2148,7 +2148,7 @@ spec:
       - type: Percent
         value: 100
         periodSeconds: 15
-      - type: LocalityPods
+      - type: Pods
         value: 4
         periodSeconds: 15
       selectPolicy: Max
diff --git a/internal/kgateway/agentgatewaysyncer/README.md b/internal/kgateway/agentgatewaysyncer/README.md
index 97441e8bb..d7d0d77ba 100644
--- a/internal/kgateway/agentgatewaysyncer/README.md
+++ b/internal/kgateway/agentgatewaysyncer/README.md
@@ -2,6 +2,54 @@
 
 This syncer configures xds updates for the [agentgateway](https://agentgateway.dev/) data plane. 
 
+To use the agentgateway control plane with kgateway, you need to enable the integration in the helm chart:
+```yaml
+agentGateway:
+  enabled: true # set this to true
+```
+
+You can configure the agentgateway Gateway class to use a specific image by setting the image field on the 
+GatewayClass:
+```yaml
+kind: GatewayParameters
+apiVersion: gateway.kgateway.dev/v1alpha1
+metadata:
+  name: kgateway
+spec:
+  kube:
+    agentGateway:
+      enabled: true
+      logLevel: debug
+      image:
+        tag: bc92714
+---
+kind: GatewayClass
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: agentgateway
+spec:
+  controllerName: kgateway.dev/kgateway
+  parametersRef:
+    group: gateway.kgateway.dev
+    kind: GatewayParameters
+    name: kgateway
+    namespace: default
+---
+kind: Gateway
+apiVersion: gateway.networking.k8s.io/v1
+metadata:
+  name: agent-gateway
+spec:
+  gatewayClassName: agentgateway
+  listeners:
+    - protocol: HTTP
+      port: 8080
+      name: http
+      allowedRoutes:
+        namespaces:
+          from: All
+```
+
 ### APIs
 
 The syncer uses the following APIs:
diff --git a/internal/kgateway/agentgatewaysyncer/adp.go b/internal/kgateway/agentgatewaysyncer/adp.go
index b8e15d390..e5eca1a0d 100644
--- a/internal/kgateway/agentgatewaysyncer/adp.go
+++ b/internal/kgateway/agentgatewaysyncer/adp.go
@@ -6,11 +6,14 @@ import (
 
 	"github.com/agentgateway/agentgateway/go/api"
 	"istio.io/istio/pkg/slices"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime/schema"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 )
 
-func createADPMethodMatch(match gwv1.HTTPRouteMatch) (*api.MethodMatch, *ConfigError) {
+func createADPMethodMatch(match gwv1.HTTPRouteMatch) (*api.MethodMatch, *reporter.RouteCondition) {
 	if match.Method == nil {
 		return nil, nil
 	}
@@ -19,7 +22,7 @@ func createADPMethodMatch(match gwv1.HTTPRouteMatch) (*api.MethodMatch, *ConfigE
 	}, nil
 }
 
-func createADPQueryMatch(match gwv1.HTTPRouteMatch) ([]*api.QueryMatch, *ConfigError) {
+func createADPQueryMatch(match gwv1.HTTPRouteMatch) ([]*api.QueryMatch, *reporter.RouteCondition) {
 	res := []*api.QueryMatch{}
 	for _, header := range match.QueryParams {
 		tp := gwv1.QueryParamMatchExact
@@ -39,7 +42,11 @@ func createADPQueryMatch(match gwv1.HTTPRouteMatch) ([]*api.QueryMatch, *ConfigE
 			})
 		default:
 			// Should never happen, unless a new field is added
-			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported QueryMatch type", tp)}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported QueryMatch type", tp)}
 		}
 	}
 	if len(res) == 0 {
@@ -48,7 +55,7 @@ func createADPQueryMatch(match gwv1.HTTPRouteMatch) ([]*api.QueryMatch, *ConfigE
 	return res, nil
 }
 
-func createADPPathMatch(match gwv1.HTTPRouteMatch) (*api.PathMatch, *ConfigError) {
+func createADPPathMatch(match gwv1.HTTPRouteMatch) (*api.PathMatch, *reporter.RouteCondition) {
 	tp := gwv1.PathMatchPathPrefix
 	if match.Path.Type != nil {
 		tp = *match.Path.Type
@@ -76,11 +83,15 @@ func createADPPathMatch(match gwv1.HTTPRouteMatch) (*api.PathMatch, *ConfigError
 		}}, nil
 	default:
 		// Should never happen, unless a new field is added
-		return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
 	}
 }
 
-func createADPHeadersMatch(match gwv1.HTTPRouteMatch) ([]*api.HeaderMatch, *ConfigError) {
+func createADPHeadersMatch(match gwv1.HTTPRouteMatch) ([]*api.HeaderMatch, *reporter.RouteCondition) {
 	res := []*api.HeaderMatch{}
 	for _, header := range match.Headers {
 		tp := gwv1.HeaderMatchExact
@@ -100,7 +111,11 @@ func createADPHeadersMatch(match gwv1.HTTPRouteMatch) ([]*api.HeaderMatch, *Conf
 			})
 		default:
 			// Should never happen, unless a new field is added
-			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
 		}
 	}
 
@@ -172,7 +187,7 @@ func createADPMirrorFilter(
 	filter *gwv1.HTTPRequestMirrorFilter,
 	ns string,
 	k schema.GroupVersionKind,
-) (*api.RouteFilter, *ConfigError) {
+) (*api.RouteFilter, *reporter.RouteCondition) {
 	if filter == nil {
 		return nil, nil
 	}
diff --git a/internal/kgateway/agentgatewaysyncer/conversion.go b/internal/kgateway/agentgatewaysyncer/conversion.go
index 6b70a7db7..8951b21eb 100644
--- a/internal/kgateway/agentgatewaysyncer/conversion.go
+++ b/internal/kgateway/agentgatewaysyncer/conversion.go
@@ -38,6 +38,8 @@ import (
 	gwv1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
 	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
+
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 )
 
@@ -47,7 +49,7 @@ const (
 
 func convertHTTPRouteToADP(ctx RouteContext, r gwv1.HTTPRouteRule,
 	obj *gwv1.HTTPRoute, pos int, matchPos int,
-) (*api.Route, *ConfigError) {
+) (*api.Route, *reporter.RouteCondition) {
 	res := &api.Route{
 		Key:         obj.Namespace + "." + obj.Name + "." + strconv.Itoa(pos) + "." + strconv.Itoa(matchPos),
 		RouteName:   obj.Namespace + "/" + obj.Name,
@@ -117,9 +119,9 @@ func buildADPFilters(
 	ctx RouteContext,
 	ns string,
 	inputFilters []gwv1.HTTPRouteFilter,
-) ([]*api.RouteFilter, *ConfigError) {
+) ([]*api.RouteFilter, *reporter.RouteCondition) {
 	var filters []*api.RouteFilter
-	var mirrorBackendErr *ConfigError
+	var mirrorBackendErr *reporter.RouteCondition
 	for _, filter := range inputFilters {
 		switch filter.Type {
 		case gwv1.HTTPRouteFilterRequestHeaderModifier:
@@ -154,13 +156,15 @@ func buildADPFilters(
 			}
 			filters = append(filters, h)
 		case gwv1.HTTPRouteFilterCORS:
-			//return nil, &ConfigError{
+			//return nil, &reporter.RouteCondition{
 			//	Reason:  InvalidFilter,
 			//	Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
 			//}
 		default:
-			return nil, &ConfigError{
-				Reason:  InvalidFilter,
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonIncompatibleFilters,
 				Message: fmt.Sprintf("unsupported filter type %q", filter.Type),
 			}
 		}
@@ -172,12 +176,12 @@ func buildADPHTTPDestination(
 	ctx RouteContext,
 	forwardTo []gwv1.HTTPBackendRef,
 	ns string,
-) ([]*api.RouteBackend, *ConfigError, *ConfigError) {
+) ([]*api.RouteBackend, *reporter.RouteCondition, *reporter.RouteCondition) {
 	if forwardTo == nil {
 		return nil, nil, nil
 	}
 
-	var invalidBackendErr *ConfigError
+	var invalidBackendErr *reporter.RouteCondition
 	var res []*api.RouteBackend
 	for _, fwd := range forwardTo {
 		dst, err := buildADPDestination(ctx, fwd, ns, wellknown.HTTPRouteGVK)
@@ -207,12 +211,14 @@ func buildADPDestination(
 	to gwv1.HTTPBackendRef,
 	ns string,
 	k schema.GroupVersionKind,
-) (*api.RouteBackend, *ConfigError) {
+) (*api.RouteBackend, *reporter.RouteCondition) {
 	// check if the reference is allowed
 	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
 		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
-			return nil, &ConfigError{
-				Reason:  InvalidDestinationPermit,
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonRefNotPermitted,
 				Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
 			}
 		}
@@ -222,7 +228,7 @@ func buildADPDestination(
 	if to.Namespace != nil {
 		namespace = string(*to.Namespace)
 	}
-	var invalidBackendErr *ConfigError
+	var invalidBackendErr *reporter.RouteCondition
 	var hostname string
 	weight := int32(1) // default
 	if to.Weight != nil {
@@ -236,14 +242,22 @@ func buildADPDestination(
 	switch ref.GroupKind() {
 	case wellknown.InferencePoolGVK.GroupKind():
 		if strings.Contains(string(to.Name), ".") {
-			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
 		}
 		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
 		key := namespace + "/" + string(to.Name)
 		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
 		logger.Debug("Found pull pool for service", "svc", svc, "key", key)
 		if svc == nil {
-			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
 		} else {
 			port = ptr.Of(gwv1.PortNumber(svc.Spec.TargetPortNumber))
 		}
@@ -251,19 +265,29 @@ func buildADPDestination(
 	case wellknown.ServiceGVK.GroupKind():
 		port = to.Port
 		if strings.Contains(string(to.Name), ".") {
-			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
 		}
 		hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
 		key := namespace + "/" + string(to.Name)
 		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
 		if svc == nil {
-			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
 		}
 		rb.Kind = &api.RouteBackend_Service{Service: namespace + "/" + hostname}
 	default:
 		port = to.Port
-		return nil, &ConfigError{
-			Reason:  InvalidDestinationKind,
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionResolvedRefs,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonInvalidKind,
 			Message: fmt.Sprintf("referencing unsupported backendRef: group %q kind %q", ptr.OrEmpty(to.Group), ptr.OrEmpty(to.Kind)),
 		}
 	}
@@ -271,7 +295,11 @@ func buildADPDestination(
 	// that do not require port.
 	if port == nil {
 		// "Port is required when the referent is a Kubernetes Service."
-		return nil, &ConfigError{Reason: InvalidDestination, Message: "port is required in backendRef"}
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: "port is required in backendRef"}
 	}
 	rb.Port = int32(*port)
 	return rb, invalidBackendErr
@@ -505,7 +533,7 @@ func extractParentReferenceInfo(ctx RouteContext, parents RouteParents, obj cont
 	return parentRefs
 }
 
-func convertTCPRoute(ctx RouteContext, r gwv1alpha2.TCPRouteRule, obj *gwv1alpha2.TCPRoute) (*istio.TCPRoute, *ConfigError) {
+func convertTCPRoute(ctx RouteContext, r gwv1alpha2.TCPRouteRule, obj *gwv1alpha2.TCPRoute) (*istio.TCPRoute, *reporter.RouteCondition) {
 	if tcpWeightSum(r.BackendRefs) == 0 {
 		// The spec requires us to reject connections when there are no >0 weight backends
 		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
@@ -529,7 +557,7 @@ func convertTCPRoute(ctx RouteContext, r gwv1alpha2.TCPRouteRule, obj *gwv1alpha
 	}, backendErr
 }
 
-func convertTLSRoute(ctx RouteContext, r gwv1alpha2.TLSRouteRule, obj *gwv1alpha2.TLSRoute) (*istio.TLSRoute, *ConfigError) {
+func convertTLSRoute(ctx RouteContext, r gwv1alpha2.TLSRouteRule, obj *gwv1alpha2.TLSRoute) (*istio.TLSRoute, *reporter.RouteCondition) {
 	if tcpWeightSum(r.BackendRefs) == 0 {
 		// The spec requires us to reject connections when there are no >0 weight backends
 		// We don't have a great way to do it. TODO: add a fault injection API for TCP?
@@ -559,7 +587,7 @@ func buildTCPDestination(
 	forwardTo []gwv1.BackendRef,
 	ns string,
 	k schema.GroupVersionKind,
-) ([]*istio.RouteDestination, *ConfigError, *ConfigError) {
+) ([]*istio.RouteDestination, *reporter.RouteCondition, *reporter.RouteCondition) {
 	if forwardTo == nil {
 		return nil, nil, nil
 	}
@@ -578,7 +606,7 @@ func buildTCPDestination(
 		weights = []int{0}
 	}
 
-	var invalidBackendErr *ConfigError
+	var invalidBackendErr *reporter.RouteCondition
 	var res []*istio.RouteDestination
 	for i, fwd := range action {
 		dst, err := buildDestination(ctx, fwd, ns, k)
@@ -644,7 +672,7 @@ func buildHTTPDestination(
 	ctx RouteContext,
 	forwardTo []gwv1.HTTPBackendRef,
 	ns string,
-) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
+) ([]*istio.HTTPRouteDestination, *reporter.RouteCondition, *reporter.RouteCondition) {
 	if forwardTo == nil {
 		return nil, nil, nil
 	}
@@ -662,7 +690,7 @@ func buildHTTPDestination(
 		weights = []int{0}
 	}
 
-	var invalidBackendErr *ConfigError
+	var invalidBackendErr *reporter.RouteCondition
 	res := []*istio.HTTPRouteDestination{}
 	for i, fwd := range action {
 		dst, err := buildDestination(ctx, fwd.BackendRef, ns, wellknown.HTTPRouteGVK)
@@ -699,7 +727,11 @@ func buildHTTPDestination(
 				}
 				rd.GetHeaders().Response = h
 			default:
-				return nil, nil, &ConfigError{Reason: InvalidFilter, Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
+				return nil, nil, &reporter.RouteCondition{
+					Type:    gwv1.RouteConditionAccepted,
+					Status:  metav1.ConditionFalse,
+					Reason:  gwv1.RouteReasonIncompatibleFilters,
+					Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
 			}
 		}
 		res = append(res, rd)
@@ -711,7 +743,7 @@ func buildGRPCDestination(
 	ctx RouteContext,
 	forwardTo []gwv1.GRPCBackendRef,
 	ns string,
-) ([]*istio.HTTPRouteDestination, *ConfigError, *ConfigError) {
+) ([]*istio.HTTPRouteDestination, *reporter.RouteCondition, *reporter.RouteCondition) {
 	if forwardTo == nil {
 		return nil, nil, nil
 	}
@@ -729,8 +761,8 @@ func buildGRPCDestination(
 		weights = []int{0}
 	}
 
-	var invalidBackendErr *ConfigError
-	res := []*istio.HTTPRouteDestination{}
+	var invalidBackendErr *reporter.RouteCondition
+	var res []*istio.HTTPRouteDestination
 	for i, fwd := range action {
 		dst, err := buildDestination(ctx, fwd.BackendRef, ns, wellknown.GRPCRouteGVK)
 		if err != nil {
@@ -766,7 +798,11 @@ func buildGRPCDestination(
 				}
 				rd.GetHeaders().Response = h
 			default:
-				return nil, nil, &ConfigError{Reason: InvalidFilter, Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
+				return nil, nil, &reporter.RouteCondition{
+					Type:    gwv1.RouteConditionAccepted,
+					Status:  metav1.ConditionFalse,
+					Reason:  gwv1.RouteReasonIncompatibleFilters,
+					Message: fmt.Sprintf("unsupported filter type %q", filter.Type)}
 			}
 		}
 		res = append(res, rd)
@@ -774,45 +810,67 @@ func buildGRPCDestination(
 	return res, invalidBackendErr, nil
 }
 
-func buildDestination(ctx RouteContext, to gwv1.BackendRef, ns string, k schema.GroupVersionKind) (*istio.Destination, *ConfigError) {
+func buildDestination(ctx RouteContext, to gwv1.BackendRef, ns string, k schema.GroupVersionKind) (*istio.Destination, *reporter.RouteCondition) {
 	// check if the reference is allowed
 	if toNs := to.Namespace; toNs != nil && string(*toNs) != ns {
 		if !ctx.Grants.BackendAllowed(ctx.Krt, k, to.Name, *toNs, ns) {
-			return &istio.Destination{}, &ConfigError{
-				Reason:  InvalidDestinationPermit,
+			return &istio.Destination{}, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonRefNotPermitted,
 				Message: fmt.Sprintf("backendRef %v/%v not accessible to a %s in namespace %q (missing a ReferenceGrant?)", to.Name, *toNs, k.Kind, ns),
 			}
 		}
 	}
 
 	namespace := ptr.OrDefault((*string)(to.Namespace), ns)
-	var invalidBackendErr *ConfigError
+	var invalidBackendErr *reporter.RouteCondition
 	var hostname string
 	ref := normalizeReference(to.Group, to.Kind, wellknown.ServiceGVK)
 	switch ref {
-	//case wellknown.InferencePoolGVK: // TODO: add validation
-	//	if strings.Contains(string(to.Name), ".") {
-	//		return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
-	//	}
-	//	hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
-	//	key := namespace + "/" + string(to.Name)
-	//	svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
-	//	if svc == nil {
-	//		invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
-	//	}
+	case wellknown.InferencePoolGVK: // TODO: add validation
+		if strings.Contains(string(to.Name), ".") {
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
+		}
+		hostname = fmt.Sprintf("%s.%s.inference.%s", to.Name, namespace, ctx.DomainSuffix)
+		key := namespace + "/" + string(to.Name)
+		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.InferencePools, krt.FilterKey(key)))
+		if svc == nil {
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
+		}
 	case wellknown.ServiceGVK:
 		if strings.Contains(string(to.Name), ".") {
-			return nil, &ConfigError{Reason: InvalidDestination, Message: "service name invalid; the name of the Service must be used, not the hostname."}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "service name invalid; the name of the Service must be used, not the hostname."}
 		}
 		hostname = fmt.Sprintf("%s.%s.svc.%s", to.Name, namespace, ctx.DomainSuffix)
 		key := namespace + "/" + string(to.Name)
 		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
 		if svc == nil {
-			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
 		}
 	case schema.GroupVersionKind{Group: wellknown.ServiceEntryGVK.Group, Kind: "Hostname"}:
 		if to.Namespace != nil {
-			return nil, &ConfigError{Reason: InvalidDestination, Message: "namespace may not be set with Hostname type"}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: "namespace may not be set with Hostname type"}
 		}
 		hostname = string(to.Name)
 		// TODO: check hostname is valid
@@ -827,11 +885,17 @@ func buildDestination(ctx RouteContext, to gwv1.BackendRef, ns string, k schema.
 		key := namespace + "/" + string(to.Name)
 		svc := ptr.Flatten(krt.FetchOne(ctx.Krt, ctx.Services, krt.FilterKey(key)))
 		if svc == nil {
-			invalidBackendErr = &ConfigError{Reason: InvalidDestinationNotFound, Message: fmt.Sprintf("backend(%s) not found", hostname)}
+			invalidBackendErr = &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionResolvedRefs,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonBackendNotFound,
+				Message: fmt.Sprintf("backend(%s) not found", hostname)}
 		}
 	default:
-		return &istio.Destination{}, &ConfigError{
-			Reason:  InvalidDestinationKind,
+		return &istio.Destination{}, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionResolvedRefs,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonInvalidKind,
 			Message: fmt.Sprintf("referencing unsupported backendRef: group %q kind %q", ptr.OrEmpty(to.Group), ptr.OrEmpty(to.Kind)),
 		}
 	}
@@ -839,7 +903,11 @@ func buildDestination(ctx RouteContext, to gwv1.BackendRef, ns string, k schema.
 	// that do not require port.
 	if to.Port == nil {
 		// "Port is required when the referent is a Kubernetes Service."
-		return nil, &ConfigError{Reason: InvalidDestination, Message: "port is required in backendRef"}
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: "port is required in backendRef"}
 	}
 	return &istio.Destination{
 		Host: hostname,
@@ -848,10 +916,10 @@ func buildDestination(ctx RouteContext, to gwv1.BackendRef, ns string, k schema.
 }
 
 // https://github.com/kubernetes-sigs/gateway-api/blob/cea484e38e078a2c1997d8c7a62f410a1540f519/apis/v1beta1/httproute_types.go#L207-L212
-func isInvalidBackend(err *ConfigError) bool {
-	return err.Reason == InvalidDestinationPermit ||
-		err.Reason == InvalidDestinationNotFound ||
-		err.Reason == InvalidDestinationKind
+func isInvalidBackend(err *reporter.RouteCondition) bool {
+	return err.Reason == gwv1.RouteReasonRefNotPermitted ||
+		err.Reason == gwv1.RouteReasonBackendNotFound ||
+		err.Reason == gwv1.RouteReasonInvalidKind
 }
 
 func headerListToMap(hl []gwv1.HTTPHeader) map[string]string {
@@ -872,7 +940,7 @@ func headerListToMap(hl []gwv1.HTTPHeader) map[string]string {
 
 func createMirrorFilter(ctx RouteContext, filter *gwv1.HTTPRequestMirrorFilter, ns string,
 	k schema.GroupVersionKind,
-) (*istio.HTTPMirrorPolicy, *ConfigError) {
+) (*istio.HTTPMirrorPolicy, *reporter.RouteCondition) {
 	if filter == nil {
 		return nil, nil
 	}
@@ -1009,7 +1077,7 @@ func createHeadersFilter(filter *gwv1.HTTPHeaderFilter) *istio.Headers_HeaderOpe
 }
 
 // nolint: unparam
-func createMethodMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
+func createMethodMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *reporter.RouteCondition) {
 	if match.Method == nil {
 		return nil, nil
 	}
@@ -1018,7 +1086,7 @@ func createMethodMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *ConfigEr
 	}, nil
 }
 
-func createQueryParamsMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+func createQueryParamsMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *reporter.RouteCondition) {
 	res := map[string]*istio.StringMatch{}
 	for _, qp := range match.QueryParams {
 		tp := gwv1.QueryParamMatchExact
@@ -1036,7 +1104,11 @@ func createQueryParamsMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.String
 			}
 		default:
 			// Should never happen, unless a new field is added
-			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported QueryParams type", tp)}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported QueryParams type", tp)}
 		}
 	}
 
@@ -1046,7 +1118,7 @@ func createQueryParamsMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.String
 	return res, nil
 }
 
-func createHeadersMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+func createHeadersMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatch, *reporter.RouteCondition) {
 	res := map[string]*istio.StringMatch{}
 	for _, header := range match.Headers {
 		tp := gwv1.HeaderMatchExact
@@ -1064,7 +1136,11 @@ func createHeadersMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatc
 			}
 		default:
 			// Should never happen, unless a new field is added
-			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
 		}
 	}
 
@@ -1074,7 +1150,7 @@ func createHeadersMatch(match gwv1.HTTPRouteMatch) (map[string]*istio.StringMatc
 	return res, nil
 }
 
-func createGRPCHeadersMatch(match gwv1.GRPCRouteMatch) (map[string]*istio.StringMatch, *ConfigError) {
+func createGRPCHeadersMatch(match gwv1.GRPCRouteMatch) (map[string]*istio.StringMatch, *reporter.RouteCondition) {
 	res := map[string]*istio.StringMatch{}
 	for _, header := range match.Headers {
 		tp := gwv1.GRPCHeaderMatchExact
@@ -1092,7 +1168,11 @@ func createGRPCHeadersMatch(match gwv1.GRPCRouteMatch) (map[string]*istio.String
 			}
 		default:
 			// Should never happen, unless a new field is added
-			return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
+			return nil, &reporter.RouteCondition{
+				Type:    gwv1.RouteConditionAccepted,
+				Status:  metav1.ConditionFalse,
+				Reason:  gwv1.RouteReasonUnsupportedValue,
+				Message: fmt.Sprintf("unknown type: %q is not supported HeaderMatch type", tp)}
 		}
 	}
 
@@ -1102,7 +1182,7 @@ func createGRPCHeadersMatch(match gwv1.GRPCRouteMatch) (map[string]*istio.String
 	return res, nil
 }
 
-func createURIMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *ConfigError) {
+func createURIMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *reporter.RouteCondition) {
 	tp := gwv1.PathMatchPathPrefix
 	if match.Path.Type != nil {
 		tp = *match.Path.Type
@@ -1130,11 +1210,15 @@ func createURIMatch(match gwv1.HTTPRouteMatch) (*istio.StringMatch, *ConfigError
 		}, nil
 	default:
 		// Should never happen, unless a new field is added
-		return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
 	}
 }
 
-func createGRPCURIMatch(match gwv1.GRPCRouteMatch) (*istio.StringMatch, *ConfigError) {
+func createGRPCURIMatch(match gwv1.GRPCRouteMatch) (*istio.StringMatch, *reporter.RouteCondition) {
 	m := match.Method
 	if m == nil {
 		return nil, nil
@@ -1145,7 +1229,11 @@ func createGRPCURIMatch(match gwv1.GRPCRouteMatch) (*istio.StringMatch, *ConfigE
 	}
 	if m.Method == nil && m.Service == nil {
 		// Should never happen, invalid per spec
-		return nil, &ConfigError{Reason: InvalidConfiguration, Message: "gRPC match must have method or service defined"}
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: "gRPC match must have method or service defined"}
 	}
 	// gRPC format is /<Service>/<Method>. Since we don't natively understand this, convert to various string matches
 	switch tp {
@@ -1179,7 +1267,11 @@ func createGRPCURIMatch(match gwv1.GRPCRouteMatch) (*istio.StringMatch, *ConfigE
 		}, nil
 	default:
 		// Should never happen, unless a new field is added
-		return nil, &ConfigError{Reason: InvalidConfiguration, Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
+		return nil, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
+			Message: fmt.Sprintf("unknown type: %q is not supported Path match type", tp)}
 	}
 }
 
@@ -1330,7 +1422,7 @@ func IsManaged(gw *gwv1.GatewaySpec) bool {
 	return false
 }
 
-func extractGatewayServices(domainSuffix string, kgw *gwv1.Gateway) ([]string, *ConfigError) {
+func extractGatewayServices(domainSuffix string, kgw *gwv1.Gateway) ([]string, *reporter.RouteCondition) {
 	if IsManaged(&kgw.Spec) {
 		name := model.GetOrDefault(kgw.Annotations[annotation.GatewayNameOverride.Name], getDefaultName(kgw.Name, &kgw.Spec))
 		return []string{fmt.Sprintf("%s.%s.svc.%v", name, kgw.Namespace, domainSuffix)}, nil
@@ -1355,16 +1447,20 @@ func extractGatewayServices(domainSuffix string, kgw *gwv1.Gateway) ([]string, *
 	}
 	if len(skippedAddresses) > 0 {
 		// Give error but return services, this is a soft failure
-		return gatewayServices, &ConfigError{
-			Reason:  InvalidAddress,
+		return gatewayServices, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
 			Message: fmt.Sprintf("only Hostname is supported, ignoring %v", skippedAddresses),
 		}
 	}
 	if _, f := kgw.Annotations[annotation.NetworkingServiceType.Name]; f {
 		// Give error but return services, this is a soft failure
 		// Remove entirely in 1.20
-		return gatewayServices, &ConfigError{
-			Reason:  DeprecateFieldUsage,
+		return gatewayServices, &reporter.RouteCondition{
+			Type:    gwv1.RouteConditionAccepted,
+			Status:  metav1.ConditionFalse,
+			Reason:  gwv1.RouteReasonUnsupportedValue,
 			Message: fmt.Sprintf("annotation %v is deprecated, use Spec.Infrastructure.Routeability", annotation.NetworkingServiceType.Name),
 		}
 	}
diff --git a/internal/kgateway/agentgatewaysyncer/model.go b/internal/kgateway/agentgatewaysyncer/model.go
index 803565664..852354393 100644
--- a/internal/kgateway/agentgatewaysyncer/model.go
+++ b/internal/kgateway/agentgatewaysyncer/model.go
@@ -86,6 +86,7 @@ func (r ADPCacheAddress) ResourceName() string {
 
 func (r ADPCacheAddress) Equals(in ADPCacheAddress) bool {
 	return report{r.reports}.Equals(report{in.reports}) &&
+		r.NamespacedName.Name == in.NamespacedName.Name && r.NamespacedName.Namespace == in.NamespacedName.Namespace &&
 		proto.Equal(r.Address, in.Address) &&
 		r.AddressVersion == in.AddressVersion &&
 		r.AddressResourceName == in.AddressResourceName
@@ -111,7 +112,8 @@ func (g ADPResource) ResourceName() string {
 }
 
 func (g ADPResource) Equals(other ADPResource) bool {
-	return proto.Equal(g.Resource, other.Resource) && g.Gateway == other.Gateway
+	return proto.Equal(g.Resource, other.Resource) && g.Gateway == other.Gateway &&
+		report{g.reports}.Equals(report{other.reports})
 }
 
 // Meta is metadata attached to each configuration unit.
diff --git a/internal/kgateway/agentgatewaysyncer/route_collections.go b/internal/kgateway/agentgatewaysyncer/route_collections.go
index 4a3fd37bb..edab6364e 100644
--- a/internal/kgateway/agentgatewaysyncer/route_collections.go
+++ b/internal/kgateway/agentgatewaysyncer/route_collections.go
@@ -11,11 +11,9 @@ import (
 	"istio.io/istio/pkg/slices"
 	"istio.io/istio/pkg/util/protomarshal"
 	corev1 "k8s.io/api/core/v1"
-	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/types"
 	inf "sigs.k8s.io/gateway-api-inference-extension/api/v1alpha2"
 	gwv1 "sigs.k8s.io/gateway-api/apis/v1"
-	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/reports"
 
@@ -37,8 +35,8 @@ func ADPRouteCollection(
 		ctx := inputs.WithCtx(krtctx)
 		routeReporter := rep.Route(obj)
 		route := obj.Spec
-		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gwv1.HTTPRoute) iter.Seq2[ADPRoute, *ConfigError] {
-			return func(yield func(ADPRoute, *ConfigError) bool) {
+		parentRefs, gwResult := computeRoute(ctx, obj, func(obj *gwv1.HTTPRoute) iter.Seq2[ADPRoute, *reporter.RouteCondition] {
+			return func(yield func(ADPRoute, *reporter.RouteCondition) bool) {
 				for n, r := range route.Rules {
 					// split the rule to make sure each rule has up to one match
 					matches := slices.Reference(r.Matches)
@@ -70,12 +68,7 @@ func ADPRouteCollection(
 				continue
 			}
 			if gwResult.error != nil {
-				parentRefReporter.SetCondition(reporter.RouteCondition{
-					Type:    gwv1beta1.RouteConditionResolvedRefs, // TODO: fix
-					Status:  metav1.ConditionFalse,
-					Reason:  gwv1beta1.RouteConditionReason(gwResult.error.Reason),
-					Message: gwResult.error.Message,
-				})
+				parentRefReporter.SetCondition(*gwResult.error)
 			}
 
 			gw := types.NamespacedName{
@@ -97,7 +90,7 @@ func ADPRouteCollection(
 }
 
 type conversionResult[O any] struct {
-	error  *ConfigError
+	error  *reporter.RouteCondition
 	routes []O
 }
 
@@ -110,7 +103,7 @@ func IsNil[O comparable](o O) bool {
 // computeRoute holds the common route building logic shared amongst all types
 func computeRoute[T controllers.Object, O comparable](ctx RouteContext, obj T, translator func(
 	obj T,
-) iter.Seq2[O, *ConfigError],
+) iter.Seq2[O, *reporter.RouteCondition],
 ) ([]routeParentReference, conversionResult[O]) {
 	parentRefs := extractParentReferenceInfo(ctx, ctx.RouteParents, obj)
 
diff --git a/internal/kgateway/agentgatewaysyncer/syncer.go b/internal/kgateway/agentgatewaysyncer/syncer.go
index 0e0f1f77c..57f0dfa09 100644
--- a/internal/kgateway/agentgatewaysyncer/syncer.go
+++ b/internal/kgateway/agentgatewaysyncer/syncer.go
@@ -41,8 +41,6 @@ import (
 	gwv1beta1 "sigs.k8s.io/gateway-api/apis/v1beta1"
 	gwxv1a1 "sigs.k8s.io/gateway-api/apisx/v1alpha1"
 
-	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
-
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/extensions2/common"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/krtcollections"
@@ -51,6 +49,7 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/utils/krtutil"
 	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/wellknown"
 	"github.com/kgateway-dev/kgateway/v2/pkg/logging"
+	"github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
 )
 
 var logger = logging.New("agentgateway/syncer")
diff --git a/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go b/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go
index 5e8a7b7c0..36b3f6ade 100644
--- a/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go
+++ b/internal/kgateway/extensions2/plugins/inferenceextension/endpointpicker/ir.go
@@ -21,9 +21,9 @@ const (
 // inferencePool defines the internal representation of an inferencePool resource.
 type inferencePool struct {
 	objMeta metav1.ObjectMeta
-	// podSelector is a label selector to select LocalityPods that are members of the InferencePool.
+	// podSelector is a label selector to select Pods that are members of the InferencePool.
 	podSelector map[string]string
-	// targetPort is the port number that should be targeted for LocalityPods selected by Selector.
+	// targetPort is the port number that should be targeted for Pods selected by Selector.
 	targetPort int32
 	// configRef is a reference to the extension configuration. A configRef is typically implemented
 	// as a Kubernetes Service resource.
diff --git a/internal/kgateway/extensions2/plugins/serviceentry/collections.go b/internal/kgateway/extensions2/plugins/serviceentry/collections.go
index 43dc1f1df..b620950c7 100644
--- a/internal/kgateway/extensions2/plugins/serviceentry/collections.go
+++ b/internal/kgateway/extensions2/plugins/serviceentry/collections.go
@@ -65,7 +65,7 @@ func (s seSelector) Equals(in seSelector) bool {
 	return metaEqual && proto.Equal(&s.ServiceEntry.Spec, &in.ServiceEntry.Spec)
 }
 
-// selectedWorkload adds the following to LocalityPod:
+// selectedWorkload adds the following to Pods:
 // * fields specific to workload entry (portMapping, network, weight)
 // * selectedBy pointers to the selecting ServiceEntries
 // Usable with FilterSelect
@@ -197,7 +197,7 @@ func selectedWorkloads(
 		return namespaces.UnsortedList()
 	})
 
-	// WorkloadEntries: selection logic and conver to LocalityPod
+	// WorkloadEntries: selection logic and convert to Pod
 	selectedWorkloadEntries := krt.NewCollection(WorkloadEntries, func(ctx krt.HandlerContext, we *networkingclient.WorkloadEntry) *selectedWorkload {
 		// find all the SEs that select this we
 		// if there are none, we can stop early
@@ -221,7 +221,7 @@ func selectedWorkloads(
 		return &workload
 	}, krt.WithName("ServiceEntrySelectWorkloadEntry"))
 
-	// LocalityPods: selection logic
+	// Pods: selection logic
 	selectedPods := krt.NewCollection(Pods, func(ctx krt.HandlerContext, workload krtcollections.LocalityPod) *selectedWorkload {
 		serviceEntries := krt.Fetch(
 			ctx,
@@ -241,7 +241,7 @@ func selectedWorkloads(
 		}
 	}, krt.WithName("ServiceEntrySelectPod"))
 
-	// consolidate LocalityPods and WorkloadEntries
+	// consolidate Pods and WorkloadEntries
 	allWorkloads := krt.JoinCollection([]krt.Collection[selectedWorkload]{selectedPods, selectedWorkloadEntries}, krt.WithName("ServiceEntrySelectWorkloads"))
 	workloadsByServiceEntry := krt.NewIndex(allWorkloads, func(o selectedWorkload) []string {
 		return slices.Map(o.selectedBy, func(n krt.Named) string {
diff --git a/internal/kgateway/krtcollections/pods.go b/internal/kgateway/krtcollections/pods.go
index 01fcfaf26..4d1143de3 100644
--- a/internal/kgateway/krtcollections/pods.go
+++ b/internal/kgateway/krtcollections/pods.go
@@ -316,7 +316,7 @@ func AugmentLabels(locality ir.PodLocality, labels map[string]string) {
 
 // technically the plural PodIPs isn't a required field.
 // we don't use it yet, but it will be useful to support ipv6
-// "LocalityPods may be allocated at most 1 value for each of IPv4 and IPv6."
+// "Pods may be allocated at most 1 value for each of IPv4 and IPv6."
 //   - k8s docs
 func extractPodIPs(pod *corev1.Pod) []string {
 	if len(pod.Status.PodIPs) > 0 {
diff --git a/internal/kgateway/setup/agentgateway_test.go b/internal/kgateway/setup/agentgateway_test.go
index b9ebc494c..5f9eb5cb1 100644
--- a/internal/kgateway/setup/agentgateway_test.go
+++ b/internal/kgateway/setup/agentgateway_test.go
@@ -28,7 +28,7 @@ import (
 	"github.com/kgateway-dev/kgateway/v2/pkg/settings"
 )
 
-func TestAgentGatewayScenarioDump(t *testing.T) {
+func TestAgentgateway(t *testing.T) {
 	st, err := settings.BuildSettings()
 	st.EnableAgentGateway = true
 
diff --git a/test/envtestutil/util.go b/test/envtestutil/util.go
index 1b883c783..e203bcf9f 100644
--- a/test/envtestutil/util.go
+++ b/test/envtestutil/util.go
@@ -190,7 +190,7 @@ func addApiServerLogs(t *testing.T, testEnv *envtest.Environment) {
 }
 
 // applyPodStatusFromFile reads a YAML file, looks for Pod resources with a Status set,
-// and patches their status into the cluster. Skips any LocalityPods not found or lacking a status.
+// and patches their status into the cluster. Skips any Pods not found or lacking a status.
 // This is needed because the other places that apply yaml will only apply spec.
 // We now have tests (ServiceEntry) that rely on IPs from Pod status instead of EndpointSlice.
 func applyPodStatusFromFile(ctx context.Context, c istiokube.CLIClient, defaultNs, filePath string) error {
diff --git a/test/helpers/kube_dump.go b/test/helpers/kube_dump.go
index 739502431..16b12159c 100644
--- a/test/helpers/kube_dump.go
+++ b/test/helpers/kube_dump.go
@@ -144,7 +144,7 @@ func recordKubeState(ctx context.Context, kubectlCli *kubectl.Cli, f *os.File) {
 		return
 	}
 
-	// Describe everything to identify the reason for issues such as LocalityPods, LoadBalancers stuck in pending state
+	// Describe everything to identify the reason for issues such as Pods, LoadBalancers stuck in pending state
 	// (insufficient resources, unable to acquire an IP), etc.
 	// Ie: More context around the output of the previous command `kubectl get all -A`
 	kubeDescribe, err := kubectlCli.RunCommandWithOutput(ctx, "describe", "all", "-A")
diff --git a/test/kubernetes/e2e/features/waypoint/suite.go b/test/kubernetes/e2e/features/waypoint/suite.go
index 801408bdb..6635fe880 100644
--- a/test/kubernetes/e2e/features/waypoint/suite.go
+++ b/test/kubernetes/e2e/features/waypoint/suite.go
@@ -60,8 +60,8 @@ func NewIngressTestingSuite(ctx context.Context, testInst *e2e.TestInstallation)
 // SetupSuite provides common objects used by all tests:
 // * Create an ambient captured Namespace - `testNamespace`
 // * Deploy a kgateway-waypoint using a Gateway resource - `gwName`
-// * Deploy server (Services, LocalityPods) - `svc-a`, `svc-b`
-// * Deploy client (LocalityPods) - `client-a`
+// * Deploy server (Services, Pods) - `svc-a`, `svc-b`
+// * Deploy client (Pods) - `client-a`
 func (s *testingSuite) SetupSuite() {
 	// must apply the ns first
 	err := s.testInstallation.ClusterContext.Cli.ApplyFilePath(s.ctx, nsYAML)
diff --git a/test/kubernetes/testutils/assertions/deployments.go b/test/kubernetes/testutils/assertions/deployments.go
index 36de52d2c..c6b4a88dc 100644
--- a/test/kubernetes/testutils/assertions/deployments.go
+++ b/test/kubernetes/testutils/assertions/deployments.go
@@ -15,7 +15,7 @@ import (
 // are in the ready state and able to receive traffic.
 func (p *Provider) EventuallyReadyReplicas(ctx context.Context, deploymentMeta metav1.ObjectMeta, replicaMatcher types.GomegaMatcher) {
 	p.Gomega.Eventually(func(innerG Gomega) {
-		// We intentionally rely only on LocalityPods that have marked themselves as ready as a way of defining more explicit assertions
+		// We intentionally rely only on Pods that have marked themselves as ready as a way of defining more explicit assertions
 		pods, err := kubeutils.GetReadyPodsForDeployment(ctx, p.clusterContext.Clientset, deploymentMeta)
 		innerG.Expect(err).NotTo(HaveOccurred(), "can get pods for deployment")
 		innerG.Expect(len(pods)).To(replicaMatcher, "running pods matches expected count")
-- 
2.39.5 (Apple Git-154)

